// ignore_for_file: type=lint

import 'package:json_annotation/json_annotation.dart';
import 'package:collection/collection.dart';
import 'dart:convert';

import 'package:chopper/chopper.dart';

import 'client_mapping.dart';
import 'dart:async';
import 'package:chopper/chopper.dart' as chopper;
import 'plaid_service.enums.swagger.dart' as enums;
export 'plaid_service.enums.swagger.dart';

part 'plaid_service.swagger.chopper.dart';
part 'plaid_service.swagger.g.dart';

// **************************************************************************
// SwaggerChopperGenerator
// **************************************************************************

@ChopperApi()
abstract class PlaidService extends ChopperService {
  static PlaidService create({
    ChopperClient? client,
    Authenticator? authenticator,
    Uri? baseUrl,
    Iterable<dynamic>? interceptors,
  }) {
    if (client != null) {
      return _$PlaidService(client);
    }

    final newClient = ChopperClient(
        services: [_$PlaidService()],
        converter: $JsonSerializableConverter(),
        interceptors: interceptors ?? [],
        authenticator: authenticator,
        baseUrl: baseUrl ?? Uri.parse('http://'));
    return _$PlaidService(newClient);
  }

  ///Create an Asset Report
  Future<chopper.Response<AssetReportCreateResponse>> assetReportCreatePost(
      {required AssetReportCreateRequest? body}) {
    generatedMapping.putIfAbsent(AssetReportCreateResponse,
        () => AssetReportCreateResponse.fromJsonFactory);

    return _assetReportCreatePost(body: body);
  }

  ///Create an Asset Report
  @Post(
    path: '/asset_report/create',
    optionalBody: true,
  )
  Future<chopper.Response<AssetReportCreateResponse>> _assetReportCreatePost(
      {@Body() required AssetReportCreateRequest? body});

  ///Retrieve an Asset Report
  Future<chopper.Response<AssetReportGetResponse>> assetReportGetPost(
      {required AssetReportGetRequest? body}) {
    generatedMapping.putIfAbsent(
        AssetReportGetResponse, () => AssetReportGetResponse.fromJsonFactory);

    return _assetReportGetPost(body: body);
  }

  ///Retrieve an Asset Report
  @Post(
    path: '/asset_report/get',
    optionalBody: true,
  )
  Future<chopper.Response<AssetReportGetResponse>> _assetReportGetPost(
      {@Body() required AssetReportGetRequest? body});

  ///Retrieve a PDF Asset Report
  Future<chopper.Response<Object>> assetReportPdfGetPost(
      {required AssetReportPDFGetRequest? body}) {
    return _assetReportPdfGetPost(body: body);
  }

  ///Retrieve a PDF Asset Report
  @Post(
    path: '/asset_report/pdf/get',
    optionalBody: true,
  )
  Future<chopper.Response<Object>> _assetReportPdfGetPost(
      {@Body() required AssetReportPDFGetRequest? body});

  ///Refresh an Asset Report
  Future<chopper.Response<AssetReportRefreshResponse>> assetReportRefreshPost(
      {required AssetReportRefreshRequest? body}) {
    generatedMapping.putIfAbsent(AssetReportRefreshResponse,
        () => AssetReportRefreshResponse.fromJsonFactory);

    return _assetReportRefreshPost(body: body);
  }

  ///Refresh an Asset Report
  @Post(
    path: '/asset_report/refresh',
    optionalBody: true,
  )
  Future<chopper.Response<AssetReportRefreshResponse>> _assetReportRefreshPost(
      {@Body() required AssetReportRefreshRequest? body});

  ///Filter Asset Report
  Future<chopper.Response<AssetReportFilterResponse>> assetReportFilterPost(
      {required AssetReportFilterRequest? body}) {
    generatedMapping.putIfAbsent(AssetReportFilterResponse,
        () => AssetReportFilterResponse.fromJsonFactory);

    return _assetReportFilterPost(body: body);
  }

  ///Filter Asset Report
  @Post(
    path: '/asset_report/filter',
    optionalBody: true,
  )
  Future<chopper.Response<AssetReportFilterResponse>> _assetReportFilterPost(
      {@Body() required AssetReportFilterRequest? body});

  ///Delete an Asset Report
  Future<chopper.Response<AssetReportRemoveResponse>> assetReportRemovePost(
      {required AssetReportRemoveRequest? body}) {
    generatedMapping.putIfAbsent(AssetReportRemoveResponse,
        () => AssetReportRemoveResponse.fromJsonFactory);

    return _assetReportRemovePost(body: body);
  }

  ///Delete an Asset Report
  @Post(
    path: '/asset_report/remove',
    optionalBody: true,
  )
  Future<chopper.Response<AssetReportRemoveResponse>> _assetReportRemovePost(
      {@Body() required AssetReportRemoveRequest? body});

  ///Create Asset Report Audit Copy
  Future<chopper.Response<AssetReportAuditCopyCreateResponse>>
      assetReportAuditCopyCreatePost(
          {required AssetReportAuditCopyCreateRequest? body}) {
    generatedMapping.putIfAbsent(AssetReportAuditCopyCreateResponse,
        () => AssetReportAuditCopyCreateResponse.fromJsonFactory);

    return _assetReportAuditCopyCreatePost(body: body);
  }

  ///Create Asset Report Audit Copy
  @Post(
    path: '/asset_report/audit_copy/create',
    optionalBody: true,
  )
  Future<chopper.Response<AssetReportAuditCopyCreateResponse>>
      _assetReportAuditCopyCreatePost(
          {@Body() required AssetReportAuditCopyCreateRequest? body});

  ///Retrieve an Asset Report Audit Copy
  Future<chopper.Response<AssetReportGetResponse>> assetReportAuditCopyGetPost(
      {required AssetReportAuditCopyGetRequest? body}) {
    generatedMapping.putIfAbsent(
        AssetReportGetResponse, () => AssetReportGetResponse.fromJsonFactory);

    return _assetReportAuditCopyGetPost(body: body);
  }

  ///Retrieve an Asset Report Audit Copy
  @Post(
    path: '/asset_report/audit_copy/get',
    optionalBody: true,
  )
  Future<chopper.Response<AssetReportGetResponse>> _assetReportAuditCopyGetPost(
      {@Body() required AssetReportAuditCopyGetRequest? body});

  ///Remove Asset Report Audit Copy
  Future<chopper.Response<AssetReportAuditCopyRemoveResponse>>
      assetReportAuditCopyRemovePost(
          {required AssetReportAuditCopyRemoveRequest? body}) {
    generatedMapping.putIfAbsent(AssetReportAuditCopyRemoveResponse,
        () => AssetReportAuditCopyRemoveResponse.fromJsonFactory);

    return _assetReportAuditCopyRemovePost(body: body);
  }

  ///Remove Asset Report Audit Copy
  @Post(
    path: '/asset_report/audit_copy/remove',
    optionalBody: true,
  )
  Future<chopper.Response<AssetReportAuditCopyRemoveResponse>>
      _assetReportAuditCopyRemovePost(
          {@Body() required AssetReportAuditCopyRemoveRequest? body});

  ///List a user’s connected applications
  Future<chopper.Response<ItemApplicationListResponse>> itemApplicationListPost(
      {required ItemApplicationListRequest? body}) {
    generatedMapping.putIfAbsent(ItemApplicationListResponse,
        () => ItemApplicationListResponse.fromJsonFactory);

    return _itemApplicationListPost(body: body);
  }

  ///List a user’s connected applications
  @Post(
    path: '/item/application/list',
    optionalBody: true,
  )
  Future<chopper.Response<ItemApplicationListResponse>>
      _itemApplicationListPost(
          {@Body() required ItemApplicationListRequest? body});

  ///Update the scopes of access for a particular application
  Future<chopper.Response<ItemApplicationScopesUpdateResponse>>
      itemApplicationScopesUpdatePost(
          {required ItemApplicationScopesUpdateRequest? body}) {
    generatedMapping.putIfAbsent(ItemApplicationScopesUpdateResponse,
        () => ItemApplicationScopesUpdateResponse.fromJsonFactory);

    return _itemApplicationScopesUpdatePost(body: body);
  }

  ///Update the scopes of access for a particular application
  @Post(
    path: '/item/application/scopes/update',
    optionalBody: true,
  )
  Future<chopper.Response<ItemApplicationScopesUpdateResponse>>
      _itemApplicationScopesUpdatePost(
          {@Body() required ItemApplicationScopesUpdateRequest? body});

  ///Retrieve information about a Plaid application
  Future<chopper.Response<ApplicationGetResponse>> applicationGetPost(
      {required ApplicationGetRequest? body}) {
    generatedMapping.putIfAbsent(
        ApplicationGetResponse, () => ApplicationGetResponse.fromJsonFactory);

    return _applicationGetPost(body: body);
  }

  ///Retrieve information about a Plaid application
  @Post(
    path: '/application/get',
    optionalBody: true,
  )
  Future<chopper.Response<ApplicationGetResponse>> _applicationGetPost(
      {@Body() required ApplicationGetRequest? body});

  ///Retrieve an Item
  Future<chopper.Response<ItemGetResponse>> itemGetPost(
      {required ItemGetRequest? body}) {
    generatedMapping.putIfAbsent(
        ItemGetResponse, () => ItemGetResponse.fromJsonFactory);

    return _itemGetPost(body: body);
  }

  ///Retrieve an Item
  @Post(
    path: '/item/get',
    optionalBody: true,
  )
  Future<chopper.Response<ItemGetResponse>> _itemGetPost(
      {@Body() required ItemGetRequest? body});

  ///Retrieve auth data
  Future<chopper.Response<AuthGetResponse>> authGetPost(
      {required AuthGetRequest? body}) {
    generatedMapping.putIfAbsent(
        AuthGetResponse, () => AuthGetResponse.fromJsonFactory);

    return _authGetPost(body: body);
  }

  ///Retrieve auth data
  @Post(
    path: '/auth/get',
    optionalBody: true,
  )
  Future<chopper.Response<AuthGetResponse>> _authGetPost(
      {@Body() required AuthGetRequest? body});

  ///Get transaction data
  Future<chopper.Response<TransactionsGetResponse>> transactionsGetPost(
      {required TransactionsGetRequest? body}) {
    generatedMapping.putIfAbsent(
        TransactionsGetResponse, () => TransactionsGetResponse.fromJsonFactory);

    return _transactionsGetPost(body: body);
  }

  ///Get transaction data
  @Post(
    path: '/transactions/get',
    optionalBody: true,
  )
  Future<chopper.Response<TransactionsGetResponse>> _transactionsGetPost(
      {@Body() required TransactionsGetRequest? body});

  ///Refresh transaction data
  Future<chopper.Response<TransactionsRefreshResponse>> transactionsRefreshPost(
      {required TransactionsRefreshRequest? body}) {
    generatedMapping.putIfAbsent(TransactionsRefreshResponse,
        () => TransactionsRefreshResponse.fromJsonFactory);

    return _transactionsRefreshPost(body: body);
  }

  ///Refresh transaction data
  @Post(
    path: '/transactions/refresh',
    optionalBody: true,
  )
  Future<chopper.Response<TransactionsRefreshResponse>>
      _transactionsRefreshPost(
          {@Body() required TransactionsRefreshRequest? body});

  ///Fetch recurring transaction streams
  Future<chopper.Response<TransactionsRecurringGetResponse>>
      transactionsRecurringGetPost(
          {required TransactionsRecurringGetRequest? body}) {
    generatedMapping.putIfAbsent(TransactionsRecurringGetResponse,
        () => TransactionsRecurringGetResponse.fromJsonFactory);

    return _transactionsRecurringGetPost(body: body);
  }

  ///Fetch recurring transaction streams
  @Post(
    path: '/transactions/recurring/get',
    optionalBody: true,
  )
  Future<chopper.Response<TransactionsRecurringGetResponse>>
      _transactionsRecurringGetPost(
          {@Body() required TransactionsRecurringGetRequest? body});

  ///Get incremental transaction updates on an Item
  Future<chopper.Response<TransactionsSyncResponse>> transactionsSyncPost(
      {required TransactionsSyncRequest? body}) {
    generatedMapping.putIfAbsent(TransactionsSyncResponse,
        () => TransactionsSyncResponse.fromJsonFactory);

    return _transactionsSyncPost(body: body);
  }

  ///Get incremental transaction updates on an Item
  @Post(
    path: '/transactions/sync',
    optionalBody: true,
  )
  Future<chopper.Response<TransactionsSyncResponse>> _transactionsSyncPost(
      {@Body() required TransactionsSyncRequest? body});

  ///Enrich locally-held transaction data
  Future<chopper.Response<TransactionsEnrichGetResponse>>
      transactionsEnrichPost({required TransactionsEnrichGetRequest? body}) {
    generatedMapping.putIfAbsent(TransactionsEnrichGetResponse,
        () => TransactionsEnrichGetResponse.fromJsonFactory);

    return _transactionsEnrichPost(body: body);
  }

  ///Enrich locally-held transaction data
  @Post(
    path: '/transactions/enrich',
    optionalBody: true,
  )
  Future<chopper.Response<TransactionsEnrichGetResponse>>
      _transactionsEnrichPost(
          {@Body() required TransactionsEnrichGetRequest? body});

  ///Get details of all supported institutions
  Future<chopper.Response<InstitutionsGetResponse>> institutionsGetPost(
      {required InstitutionsGetRequest? body}) {
    generatedMapping.putIfAbsent(
        InstitutionsGetResponse, () => InstitutionsGetResponse.fromJsonFactory);

    return _institutionsGetPost(body: body);
  }

  ///Get details of all supported institutions
  @Post(
    path: '/institutions/get',
    optionalBody: true,
  )
  Future<chopper.Response<InstitutionsGetResponse>> _institutionsGetPost(
      {@Body() required InstitutionsGetRequest? body});

  ///Search institutions
  Future<chopper.Response<InstitutionsSearchResponse>> institutionsSearchPost(
      {required InstitutionsSearchRequest? body}) {
    generatedMapping.putIfAbsent(InstitutionsSearchResponse,
        () => InstitutionsSearchResponse.fromJsonFactory);

    return _institutionsSearchPost(body: body);
  }

  ///Search institutions
  @Post(
    path: '/institutions/search',
    optionalBody: true,
  )
  Future<chopper.Response<InstitutionsSearchResponse>> _institutionsSearchPost(
      {@Body() required InstitutionsSearchRequest? body});

  ///Get details of an institution
  Future<chopper.Response<InstitutionsGetByIdResponse>> institutionsGetByIdPost(
      {required InstitutionsGetByIdRequest? body}) {
    generatedMapping.putIfAbsent(InstitutionsGetByIdResponse,
        () => InstitutionsGetByIdResponse.fromJsonFactory);

    return _institutionsGetByIdPost(body: body);
  }

  ///Get details of an institution
  @Post(
    path: '/institutions/get_by_id',
    optionalBody: true,
  )
  Future<chopper.Response<InstitutionsGetByIdResponse>>
      _institutionsGetByIdPost(
          {@Body() required InstitutionsGetByIdRequest? body});

  ///Remove an Item
  Future<chopper.Response<ItemRemoveResponse>> itemRemovePost(
      {required ItemRemoveRequest? body}) {
    generatedMapping.putIfAbsent(
        ItemRemoveResponse, () => ItemRemoveResponse.fromJsonFactory);

    return _itemRemovePost(body: body);
  }

  ///Remove an Item
  @Post(
    path: '/item/remove',
    optionalBody: true,
  )
  Future<chopper.Response<ItemRemoveResponse>> _itemRemovePost(
      {@Body() required ItemRemoveRequest? body});

  ///Retrieve accounts
  Future<chopper.Response<AccountsGetResponse>> accountsGetPost(
      {required AccountsGetRequest? body}) {
    generatedMapping.putIfAbsent(
        AccountsGetResponse, () => AccountsGetResponse.fromJsonFactory);

    return _accountsGetPost(body: body);
  }

  ///Retrieve accounts
  @Post(
    path: '/accounts/get',
    optionalBody: true,
  )
  Future<chopper.Response<AccountsGetResponse>> _accountsGetPost(
      {@Body() required AccountsGetRequest? body});

  ///Get Categories
  Future<chopper.Response<CategoriesGetResponse>> categoriesGetPost(
      {required CategoriesGetRequest? body}) {
    generatedMapping.putIfAbsent(
        CategoriesGetResponse, () => CategoriesGetResponse.fromJsonFactory);

    return _categoriesGetPost(body: body);
  }

  ///Get Categories
  @Post(
    path: '/categories/get',
    optionalBody: true,
  )
  Future<chopper.Response<CategoriesGetResponse>> _categoriesGetPost(
      {@Body() required CategoriesGetRequest? body});

  ///Create a test Item and processor token
  Future<chopper.Response<SandboxProcessorTokenCreateResponse>>
      sandboxProcessorTokenCreatePost(
          {required SandboxProcessorTokenCreateRequest? body}) {
    generatedMapping.putIfAbsent(SandboxProcessorTokenCreateResponse,
        () => SandboxProcessorTokenCreateResponse.fromJsonFactory);

    return _sandboxProcessorTokenCreatePost(body: body);
  }

  ///Create a test Item and processor token
  @Post(
    path: '/sandbox/processor_token/create',
    optionalBody: true,
  )
  Future<chopper.Response<SandboxProcessorTokenCreateResponse>>
      _sandboxProcessorTokenCreatePost(
          {@Body() required SandboxProcessorTokenCreateRequest? body});

  ///Create a test Item
  Future<chopper.Response<SandboxPublicTokenCreateResponse>>
      sandboxPublicTokenCreatePost(
          {required SandboxPublicTokenCreateRequest? body}) {
    generatedMapping.putIfAbsent(SandboxPublicTokenCreateResponse,
        () => SandboxPublicTokenCreateResponse.fromJsonFactory);

    return _sandboxPublicTokenCreatePost(body: body);
  }

  ///Create a test Item
  @Post(
    path: '/sandbox/public_token/create',
    optionalBody: true,
  )
  Future<chopper.Response<SandboxPublicTokenCreateResponse>>
      _sandboxPublicTokenCreatePost(
          {@Body() required SandboxPublicTokenCreateRequest? body});

  ///Fire a test webhook
  Future<chopper.Response<SandboxItemFireWebhookResponse>>
      sandboxItemFireWebhookPost(
          {required SandboxItemFireWebhookRequest? body}) {
    generatedMapping.putIfAbsent(SandboxItemFireWebhookResponse,
        () => SandboxItemFireWebhookResponse.fromJsonFactory);

    return _sandboxItemFireWebhookPost(body: body);
  }

  ///Fire a test webhook
  @Post(
    path: '/sandbox/item/fire_webhook',
    optionalBody: true,
  )
  Future<chopper.Response<SandboxItemFireWebhookResponse>>
      _sandboxItemFireWebhookPost(
          {@Body() required SandboxItemFireWebhookRequest? body});

  ///Retrieve real-time balance data
  Future<chopper.Response<AccountsGetResponse>> accountsBalanceGetPost(
      {required AccountsBalanceGetRequest? body}) {
    generatedMapping.putIfAbsent(
        AccountsGetResponse, () => AccountsGetResponse.fromJsonFactory);

    return _accountsBalanceGetPost(body: body);
  }

  ///Retrieve real-time balance data
  @Post(
    path: '/accounts/balance/get',
    optionalBody: true,
  )
  Future<chopper.Response<AccountsGetResponse>> _accountsBalanceGetPost(
      {@Body() required AccountsBalanceGetRequest? body});

  ///Retrieve identity data
  Future<chopper.Response<IdentityGetResponse>> identityGetPost(
      {required IdentityGetRequest? body}) {
    generatedMapping.putIfAbsent(
        IdentityGetResponse, () => IdentityGetResponse.fromJsonFactory);

    return _identityGetPost(body: body);
  }

  ///Retrieve identity data
  @Post(
    path: '/identity/get',
    optionalBody: true,
  )
  Future<chopper.Response<IdentityGetResponse>> _identityGetPost(
      {@Body() required IdentityGetRequest? body});

  ///Retrieve identity match score
  Future<chopper.Response<IdentityMatchResponse>> identityMatchPost(
      {required IdentityMatchRequest? body}) {
    generatedMapping.putIfAbsent(
        IdentityMatchResponse, () => IdentityMatchResponse.fromJsonFactory);

    return _identityMatchPost(body: body);
  }

  ///Retrieve identity match score
  @Post(
    path: '/identity/match',
    optionalBody: true,
  )
  Future<chopper.Response<IdentityMatchResponse>> _identityMatchPost(
      {@Body() required IdentityMatchRequest? body});

  ///Retrieve a dashboard user
  Future<chopper.Response<DashboardUserGetResponse>> dashboardUserGetPost(
      {required DashboardUserGetRequest? body}) {
    generatedMapping.putIfAbsent(DashboardUserGetResponse,
        () => DashboardUserGetResponse.fromJsonFactory);

    return _dashboardUserGetPost(body: body);
  }

  ///Retrieve a dashboard user
  @Post(
    path: '/dashboard_user/get',
    optionalBody: true,
  )
  Future<chopper.Response<DashboardUserGetResponse>> _dashboardUserGetPost(
      {@Body() required DashboardUserGetRequest? body});

  ///List dashboard users
  Future<chopper.Response<DashboardUserListResponse>> dashboardUserListPost(
      {required DashboardUserListRequest? body}) {
    generatedMapping.putIfAbsent(DashboardUserListResponse,
        () => DashboardUserListResponse.fromJsonFactory);

    return _dashboardUserListPost(body: body);
  }

  ///List dashboard users
  @Post(
    path: '/dashboard_user/list',
    optionalBody: true,
  )
  Future<chopper.Response<DashboardUserListResponse>> _dashboardUserListPost(
      {@Body() required DashboardUserListRequest? body});

  ///Create a new identity verification
  Future<chopper.Response<IdentityVerificationCreateResponse>>
      identityVerificationCreatePost(
          {required IdentityVerificationCreateRequest? body}) {
    generatedMapping.putIfAbsent(IdentityVerificationCreateResponse,
        () => IdentityVerificationCreateResponse.fromJsonFactory);

    return _identityVerificationCreatePost(body: body);
  }

  ///Create a new identity verification
  @Post(
    path: '/identity_verification/create',
    optionalBody: true,
  )
  Future<chopper.Response<IdentityVerificationCreateResponse>>
      _identityVerificationCreatePost(
          {@Body() required IdentityVerificationCreateRequest? body});

  ///Retrieve Identity Verification
  Future<chopper.Response<IdentityVerificationGetResponse>>
      identityVerificationGetPost(
          {required IdentityVerificationGetRequest? body}) {
    generatedMapping.putIfAbsent(IdentityVerificationGetResponse,
        () => IdentityVerificationGetResponse.fromJsonFactory);

    return _identityVerificationGetPost(body: body);
  }

  ///Retrieve Identity Verification
  @Post(
    path: '/identity_verification/get',
    optionalBody: true,
  )
  Future<chopper.Response<IdentityVerificationGetResponse>>
      _identityVerificationGetPost(
          {@Body() required IdentityVerificationGetRequest? body});

  ///List Identity Verifications
  Future<chopper.Response<IdentityVerificationListResponse>>
      identityVerificationListPost(
          {required IdentityVerificationListRequest? body}) {
    generatedMapping.putIfAbsent(IdentityVerificationListResponse,
        () => IdentityVerificationListResponse.fromJsonFactory);

    return _identityVerificationListPost(body: body);
  }

  ///List Identity Verifications
  @Post(
    path: '/identity_verification/list',
    optionalBody: true,
  )
  Future<chopper.Response<IdentityVerificationListResponse>>
      _identityVerificationListPost(
          {@Body() required IdentityVerificationListRequest? body});

  ///Retry an Identity Verification
  Future<chopper.Response<IdentityVerificationRetryResponse>>
      identityVerificationRetryPost(
          {required IdentityVerificationRetryRequest? body}) {
    generatedMapping.putIfAbsent(IdentityVerificationRetryResponse,
        () => IdentityVerificationRetryResponse.fromJsonFactory);

    return _identityVerificationRetryPost(body: body);
  }

  ///Retry an Identity Verification
  @Post(
    path: '/identity_verification/retry',
    optionalBody: true,
  )
  Future<chopper.Response<IdentityVerificationRetryResponse>>
      _identityVerificationRetryPost(
          {@Body() required IdentityVerificationRetryRequest? body});

  ///Create a watchlist screening for an entity
  Future<chopper.Response<WatchlistScreeningEntityCreateResponse>>
      watchlistScreeningEntityCreatePost(
          {required WatchlistScreeningEntityCreateRequest? body}) {
    generatedMapping.putIfAbsent(WatchlistScreeningEntityCreateResponse,
        () => WatchlistScreeningEntityCreateResponse.fromJsonFactory);

    return _watchlistScreeningEntityCreatePost(body: body);
  }

  ///Create a watchlist screening for an entity
  @Post(
    path: '/watchlist_screening/entity/create',
    optionalBody: true,
  )
  Future<chopper.Response<WatchlistScreeningEntityCreateResponse>>
      _watchlistScreeningEntityCreatePost(
          {@Body() required WatchlistScreeningEntityCreateRequest? body});

  ///Get an entity screening
  Future<chopper.Response<WatchlistScreeningEntityGetResponse>>
      watchlistScreeningEntityGetPost(
          {required WatchlistScreeningEntityGetRequest? body}) {
    generatedMapping.putIfAbsent(WatchlistScreeningEntityGetResponse,
        () => WatchlistScreeningEntityGetResponse.fromJsonFactory);

    return _watchlistScreeningEntityGetPost(body: body);
  }

  ///Get an entity screening
  @Post(
    path: '/watchlist_screening/entity/get',
    optionalBody: true,
  )
  Future<chopper.Response<WatchlistScreeningEntityGetResponse>>
      _watchlistScreeningEntityGetPost(
          {@Body() required WatchlistScreeningEntityGetRequest? body});

  ///List history for entity watchlist screenings
  Future<chopper.Response<WatchlistScreeningEntityHistoryListResponse>>
      watchlistScreeningEntityHistoryListPost(
          {required WatchlistScreeningEntityHistoryListRequest? body}) {
    generatedMapping.putIfAbsent(WatchlistScreeningEntityHistoryListResponse,
        () => WatchlistScreeningEntityHistoryListResponse.fromJsonFactory);

    return _watchlistScreeningEntityHistoryListPost(body: body);
  }

  ///List history for entity watchlist screenings
  @Post(
    path: '/watchlist_screening/entity/history/list',
    optionalBody: true,
  )
  Future<chopper.Response<WatchlistScreeningEntityHistoryListResponse>>
      _watchlistScreeningEntityHistoryListPost(
          {@Body() required WatchlistScreeningEntityHistoryListRequest? body});

  ///List hits for entity watchlist screenings
  Future<chopper.Response<WatchlistScreeningEntityHitListResponse>>
      watchlistScreeningEntityHitListPost(
          {required WatchlistScreeningEntityHitListRequest? body}) {
    generatedMapping.putIfAbsent(WatchlistScreeningEntityHitListResponse,
        () => WatchlistScreeningEntityHitListResponse.fromJsonFactory);

    return _watchlistScreeningEntityHitListPost(body: body);
  }

  ///List hits for entity watchlist screenings
  @Post(
    path: '/watchlist_screening/entity/hit/list',
    optionalBody: true,
  )
  Future<chopper.Response<WatchlistScreeningEntityHitListResponse>>
      _watchlistScreeningEntityHitListPost(
          {@Body() required WatchlistScreeningEntityHitListRequest? body});

  ///List entity watchlist screenings
  Future<chopper.Response<WatchlistScreeningEntityListResponse>>
      watchlistScreeningEntityListPost(
          {required WatchlistScreeningEntityListRequest? body}) {
    generatedMapping.putIfAbsent(WatchlistScreeningEntityListResponse,
        () => WatchlistScreeningEntityListResponse.fromJsonFactory);

    return _watchlistScreeningEntityListPost(body: body);
  }

  ///List entity watchlist screenings
  @Post(
    path: '/watchlist_screening/entity/list',
    optionalBody: true,
  )
  Future<chopper.Response<WatchlistScreeningEntityListResponse>>
      _watchlistScreeningEntityListPost(
          {@Body() required WatchlistScreeningEntityListRequest? body});

  ///Get entity watchlist screening program
  Future<chopper.Response<WatchlistScreeningEntityProgramGetResponse>>
      watchlistScreeningEntityProgramGetPost(
          {required WatchlistScreeningEntityProgramGetRequest? body}) {
    generatedMapping.putIfAbsent(WatchlistScreeningEntityProgramGetResponse,
        () => WatchlistScreeningEntityProgramGetResponse.fromJsonFactory);

    return _watchlistScreeningEntityProgramGetPost(body: body);
  }

  ///Get entity watchlist screening program
  @Post(
    path: '/watchlist_screening/entity/program/get',
    optionalBody: true,
  )
  Future<chopper.Response<WatchlistScreeningEntityProgramGetResponse>>
      _watchlistScreeningEntityProgramGetPost(
          {@Body() required WatchlistScreeningEntityProgramGetRequest? body});

  ///List entity watchlist screening programs
  Future<chopper.Response<WatchlistScreeningEntityProgramListResponse>>
      watchlistScreeningEntityProgramListPost(
          {required WatchlistScreeningEntityProgramListRequest? body}) {
    generatedMapping.putIfAbsent(WatchlistScreeningEntityProgramListResponse,
        () => WatchlistScreeningEntityProgramListResponse.fromJsonFactory);

    return _watchlistScreeningEntityProgramListPost(body: body);
  }

  ///List entity watchlist screening programs
  @Post(
    path: '/watchlist_screening/entity/program/list',
    optionalBody: true,
  )
  Future<chopper.Response<WatchlistScreeningEntityProgramListResponse>>
      _watchlistScreeningEntityProgramListPost(
          {@Body() required WatchlistScreeningEntityProgramListRequest? body});

  ///Create a review for an entity watchlist screening
  Future<chopper.Response<WatchlistScreeningEntityReviewCreateResponse>>
      watchlistScreeningEntityReviewCreatePost(
          {required WatchlistScreeningEntityReviewCreateRequest? body}) {
    generatedMapping.putIfAbsent(WatchlistScreeningEntityReviewCreateResponse,
        () => WatchlistScreeningEntityReviewCreateResponse.fromJsonFactory);

    return _watchlistScreeningEntityReviewCreatePost(body: body);
  }

  ///Create a review for an entity watchlist screening
  @Post(
    path: '/watchlist_screening/entity/review/create',
    optionalBody: true,
  )
  Future<chopper.Response<WatchlistScreeningEntityReviewCreateResponse>>
      _watchlistScreeningEntityReviewCreatePost(
          {@Body() required WatchlistScreeningEntityReviewCreateRequest? body});

  ///List reviews for entity watchlist screenings
  Future<chopper.Response<WatchlistScreeningEntityReviewListResponse>>
      watchlistScreeningEntityReviewListPost(
          {required WatchlistScreeningEntityReviewListRequest? body}) {
    generatedMapping.putIfAbsent(WatchlistScreeningEntityReviewListResponse,
        () => WatchlistScreeningEntityReviewListResponse.fromJsonFactory);

    return _watchlistScreeningEntityReviewListPost(body: body);
  }

  ///List reviews for entity watchlist screenings
  @Post(
    path: '/watchlist_screening/entity/review/list',
    optionalBody: true,
  )
  Future<chopper.Response<WatchlistScreeningEntityReviewListResponse>>
      _watchlistScreeningEntityReviewListPost(
          {@Body() required WatchlistScreeningEntityReviewListRequest? body});

  ///Update an entity screening
  Future<chopper.Response<WatchlistScreeningEntityUpdateResponse>>
      watchlistScreeningEntityUpdatePost(
          {required WatchlistScreeningEntityUpdateRequest? body}) {
    generatedMapping.putIfAbsent(WatchlistScreeningEntityUpdateResponse,
        () => WatchlistScreeningEntityUpdateResponse.fromJsonFactory);

    return _watchlistScreeningEntityUpdatePost(body: body);
  }

  ///Update an entity screening
  @Post(
    path: '/watchlist_screening/entity/update',
    optionalBody: true,
  )
  Future<chopper.Response<WatchlistScreeningEntityUpdateResponse>>
      _watchlistScreeningEntityUpdatePost(
          {@Body() required WatchlistScreeningEntityUpdateRequest? body});

  ///Create a watchlist screening for a person
  Future<chopper.Response<WatchlistScreeningIndividualCreateResponse>>
      watchlistScreeningIndividualCreatePost(
          {required WatchlistScreeningIndividualCreateRequest? body}) {
    generatedMapping.putIfAbsent(WatchlistScreeningIndividualCreateResponse,
        () => WatchlistScreeningIndividualCreateResponse.fromJsonFactory);

    return _watchlistScreeningIndividualCreatePost(body: body);
  }

  ///Create a watchlist screening for a person
  @Post(
    path: '/watchlist_screening/individual/create',
    optionalBody: true,
  )
  Future<chopper.Response<WatchlistScreeningIndividualCreateResponse>>
      _watchlistScreeningIndividualCreatePost(
          {@Body() required WatchlistScreeningIndividualCreateRequest? body});

  ///Retrieve an individual watchlist screening
  Future<chopper.Response<WatchlistScreeningIndividualGetResponse>>
      watchlistScreeningIndividualGetPost(
          {required WatchlistScreeningIndividualGetRequest? body}) {
    generatedMapping.putIfAbsent(WatchlistScreeningIndividualGetResponse,
        () => WatchlistScreeningIndividualGetResponse.fromJsonFactory);

    return _watchlistScreeningIndividualGetPost(body: body);
  }

  ///Retrieve an individual watchlist screening
  @Post(
    path: '/watchlist_screening/individual/get',
    optionalBody: true,
  )
  Future<chopper.Response<WatchlistScreeningIndividualGetResponse>>
      _watchlistScreeningIndividualGetPost(
          {@Body() required WatchlistScreeningIndividualGetRequest? body});

  ///List history for individual watchlist screenings
  Future<chopper.Response<WatchlistScreeningIndividualHistoryListResponse>>
      watchlistScreeningIndividualHistoryListPost(
          {required WatchlistScreeningIndividualHistoryListRequest? body}) {
    generatedMapping.putIfAbsent(
        WatchlistScreeningIndividualHistoryListResponse,
        () => WatchlistScreeningIndividualHistoryListResponse.fromJsonFactory);

    return _watchlistScreeningIndividualHistoryListPost(body: body);
  }

  ///List history for individual watchlist screenings
  @Post(
    path: '/watchlist_screening/individual/history/list',
    optionalBody: true,
  )
  Future<chopper.Response<WatchlistScreeningIndividualHistoryListResponse>>
      _watchlistScreeningIndividualHistoryListPost(
          {@Body()
              required WatchlistScreeningIndividualHistoryListRequest? body});

  ///List hits for individual watchlist screening
  Future<chopper.Response<WatchlistScreeningIndividualHitListResponse>>
      watchlistScreeningIndividualHitListPost(
          {required WatchlistScreeningIndividualHitListRequest? body}) {
    generatedMapping.putIfAbsent(WatchlistScreeningIndividualHitListResponse,
        () => WatchlistScreeningIndividualHitListResponse.fromJsonFactory);

    return _watchlistScreeningIndividualHitListPost(body: body);
  }

  ///List hits for individual watchlist screening
  @Post(
    path: '/watchlist_screening/individual/hit/list',
    optionalBody: true,
  )
  Future<chopper.Response<WatchlistScreeningIndividualHitListResponse>>
      _watchlistScreeningIndividualHitListPost(
          {@Body() required WatchlistScreeningIndividualHitListRequest? body});

  ///List Individual Watchlist Screenings
  Future<chopper.Response<WatchlistScreeningIndividualListResponse>>
      watchlistScreeningIndividualListPost(
          {required WatchlistScreeningIndividualListRequest? body}) {
    generatedMapping.putIfAbsent(WatchlistScreeningIndividualListResponse,
        () => WatchlistScreeningIndividualListResponse.fromJsonFactory);

    return _watchlistScreeningIndividualListPost(body: body);
  }

  ///List Individual Watchlist Screenings
  @Post(
    path: '/watchlist_screening/individual/list',
    optionalBody: true,
  )
  Future<chopper.Response<WatchlistScreeningIndividualListResponse>>
      _watchlistScreeningIndividualListPost(
          {@Body() required WatchlistScreeningIndividualListRequest? body});

  ///Get individual watchlist screening program
  Future<chopper.Response<WatchlistScreeningIndividualProgramGetResponse>>
      watchlistScreeningIndividualProgramGetPost(
          {required WatchlistScreeningIndividualProgramGetRequest? body}) {
    generatedMapping.putIfAbsent(WatchlistScreeningIndividualProgramGetResponse,
        () => WatchlistScreeningIndividualProgramGetResponse.fromJsonFactory);

    return _watchlistScreeningIndividualProgramGetPost(body: body);
  }

  ///Get individual watchlist screening program
  @Post(
    path: '/watchlist_screening/individual/program/get',
    optionalBody: true,
  )
  Future<chopper.Response<WatchlistScreeningIndividualProgramGetResponse>>
      _watchlistScreeningIndividualProgramGetPost(
          {@Body()
              required WatchlistScreeningIndividualProgramGetRequest? body});

  ///List individual watchlist screening programs
  Future<chopper.Response<WatchlistScreeningIndividualProgramListResponse>>
      watchlistScreeningIndividualProgramListPost(
          {required WatchlistScreeningIndividualProgramListRequest? body}) {
    generatedMapping.putIfAbsent(
        WatchlistScreeningIndividualProgramListResponse,
        () => WatchlistScreeningIndividualProgramListResponse.fromJsonFactory);

    return _watchlistScreeningIndividualProgramListPost(body: body);
  }

  ///List individual watchlist screening programs
  @Post(
    path: '/watchlist_screening/individual/program/list',
    optionalBody: true,
  )
  Future<chopper.Response<WatchlistScreeningIndividualProgramListResponse>>
      _watchlistScreeningIndividualProgramListPost(
          {@Body()
              required WatchlistScreeningIndividualProgramListRequest? body});

  ///Create a review for an individual watchlist screening
  Future<chopper.Response<WatchlistScreeningIndividualReviewCreateResponse>>
      watchlistScreeningIndividualReviewCreatePost(
          {required WatchlistScreeningIndividualReviewCreateRequest? body}) {
    generatedMapping.putIfAbsent(
        WatchlistScreeningIndividualReviewCreateResponse,
        () => WatchlistScreeningIndividualReviewCreateResponse.fromJsonFactory);

    return _watchlistScreeningIndividualReviewCreatePost(body: body);
  }

  ///Create a review for an individual watchlist screening
  @Post(
    path: '/watchlist_screening/individual/review/create',
    optionalBody: true,
  )
  Future<chopper.Response<WatchlistScreeningIndividualReviewCreateResponse>>
      _watchlistScreeningIndividualReviewCreatePost(
          {@Body()
              required WatchlistScreeningIndividualReviewCreateRequest? body});

  ///List reviews for individual watchlist screenings
  Future<chopper.Response<WatchlistScreeningIndividualReviewListResponse>>
      watchlistScreeningIndividualReviewListPost(
          {required WatchlistScreeningIndividualReviewListRequest? body}) {
    generatedMapping.putIfAbsent(WatchlistScreeningIndividualReviewListResponse,
        () => WatchlistScreeningIndividualReviewListResponse.fromJsonFactory);

    return _watchlistScreeningIndividualReviewListPost(body: body);
  }

  ///List reviews for individual watchlist screenings
  @Post(
    path: '/watchlist_screening/individual/review/list',
    optionalBody: true,
  )
  Future<chopper.Response<WatchlistScreeningIndividualReviewListResponse>>
      _watchlistScreeningIndividualReviewListPost(
          {@Body()
              required WatchlistScreeningIndividualReviewListRequest? body});

  ///Update individual watchlist screening
  Future<chopper.Response<WatchlistScreeningIndividualUpdateResponse>>
      watchlistScreeningIndividualUpdatePost(
          {required WatchlistScreeningIndividualUpdateRequest? body}) {
    generatedMapping.putIfAbsent(WatchlistScreeningIndividualUpdateResponse,
        () => WatchlistScreeningIndividualUpdateResponse.fromJsonFactory);

    return _watchlistScreeningIndividualUpdatePost(body: body);
  }

  ///Update individual watchlist screening
  @Post(
    path: '/watchlist_screening/individual/update',
    optionalBody: true,
  )
  Future<chopper.Response<WatchlistScreeningIndividualUpdateResponse>>
      _watchlistScreeningIndividualUpdatePost(
          {@Body() required WatchlistScreeningIndividualUpdateRequest? body});

  ///Retrieve Auth data
  Future<chopper.Response<ProcessorAuthGetResponse>> processorAuthGetPost(
      {required ProcessorAuthGetRequest? body}) {
    generatedMapping.putIfAbsent(ProcessorAuthGetResponse,
        () => ProcessorAuthGetResponse.fromJsonFactory);

    return _processorAuthGetPost(body: body);
  }

  ///Retrieve Auth data
  @Post(
    path: '/processor/auth/get',
    optionalBody: true,
  )
  Future<chopper.Response<ProcessorAuthGetResponse>> _processorAuthGetPost(
      {@Body() required ProcessorAuthGetRequest? body});

  ///Create a bank transfer as a processor
  Future<chopper.Response<ProcessorBankTransferCreateResponse>>
      processorBankTransferCreatePost(
          {required ProcessorBankTransferCreateRequest? body}) {
    generatedMapping.putIfAbsent(ProcessorBankTransferCreateResponse,
        () => ProcessorBankTransferCreateResponse.fromJsonFactory);

    return _processorBankTransferCreatePost(body: body);
  }

  ///Create a bank transfer as a processor
  @Post(
    path: '/processor/bank_transfer/create',
    optionalBody: true,
  )
  Future<chopper.Response<ProcessorBankTransferCreateResponse>>
      _processorBankTransferCreatePost(
          {@Body() required ProcessorBankTransferCreateRequest? body});

  ///Retrieve Identity data
  Future<chopper.Response<ProcessorIdentityGetResponse>>
      processorIdentityGetPost({required ProcessorIdentityGetRequest? body}) {
    generatedMapping.putIfAbsent(ProcessorIdentityGetResponse,
        () => ProcessorIdentityGetResponse.fromJsonFactory);

    return _processorIdentityGetPost(body: body);
  }

  ///Retrieve Identity data
  @Post(
    path: '/processor/identity/get',
    optionalBody: true,
  )
  Future<chopper.Response<ProcessorIdentityGetResponse>>
      _processorIdentityGetPost(
          {@Body() required ProcessorIdentityGetRequest? body});

  ///Retrieve Balance data
  Future<chopper.Response<ProcessorBalanceGetResponse>> processorBalanceGetPost(
      {required ProcessorBalanceGetRequest? body}) {
    generatedMapping.putIfAbsent(ProcessorBalanceGetResponse,
        () => ProcessorBalanceGetResponse.fromJsonFactory);

    return _processorBalanceGetPost(body: body);
  }

  ///Retrieve Balance data
  @Post(
    path: '/processor/balance/get',
    optionalBody: true,
  )
  Future<chopper.Response<ProcessorBalanceGetResponse>>
      _processorBalanceGetPost(
          {@Body() required ProcessorBalanceGetRequest? body});

  ///Update Webhook URL
  Future<chopper.Response<ItemWebhookUpdateResponse>> itemWebhookUpdatePost(
      {required ItemWebhookUpdateRequest? body}) {
    generatedMapping.putIfAbsent(ItemWebhookUpdateResponse,
        () => ItemWebhookUpdateResponse.fromJsonFactory);

    return _itemWebhookUpdatePost(body: body);
  }

  ///Update Webhook URL
  @Post(
    path: '/item/webhook/update',
    optionalBody: true,
  )
  Future<chopper.Response<ItemWebhookUpdateResponse>> _itemWebhookUpdatePost(
      {@Body() required ItemWebhookUpdateRequest? body});

  ///Invalidate access_token
  Future<chopper.Response<ItemAccessTokenInvalidateResponse>>
      itemAccessTokenInvalidatePost(
          {required ItemAccessTokenInvalidateRequest? body}) {
    generatedMapping.putIfAbsent(ItemAccessTokenInvalidateResponse,
        () => ItemAccessTokenInvalidateResponse.fromJsonFactory);

    return _itemAccessTokenInvalidatePost(body: body);
  }

  ///Invalidate access_token
  @Post(
    path: '/item/access_token/invalidate',
    optionalBody: true,
  )
  Future<chopper.Response<ItemAccessTokenInvalidateResponse>>
      _itemAccessTokenInvalidatePost(
          {@Body() required ItemAccessTokenInvalidateRequest? body});

  ///Get webhook verification key
  Future<chopper.Response<WebhookVerificationKeyGetResponse>>
      webhookVerificationKeyGetPost(
          {required WebhookVerificationKeyGetRequest? body}) {
    generatedMapping.putIfAbsent(WebhookVerificationKeyGetResponse,
        () => WebhookVerificationKeyGetResponse.fromJsonFactory);

    return _webhookVerificationKeyGetPost(body: body);
  }

  ///Get webhook verification key
  @Post(
    path: '/webhook_verification_key/get',
    optionalBody: true,
  )
  Future<chopper.Response<WebhookVerificationKeyGetResponse>>
      _webhookVerificationKeyGetPost(
          {@Body() required WebhookVerificationKeyGetRequest? body});

  ///Retrieve Liabilities data
  Future<chopper.Response<LiabilitiesGetResponse>> liabilitiesGetPost(
      {required LiabilitiesGetRequest? body}) {
    generatedMapping.putIfAbsent(
        LiabilitiesGetResponse, () => LiabilitiesGetResponse.fromJsonFactory);

    return _liabilitiesGetPost(body: body);
  }

  ///Retrieve Liabilities data
  @Post(
    path: '/liabilities/get',
    optionalBody: true,
  )
  Future<chopper.Response<LiabilitiesGetResponse>> _liabilitiesGetPost(
      {@Body() required LiabilitiesGetRequest? body});

  ///Create payment recipient
  Future<chopper.Response<PaymentInitiationRecipientCreateResponse>>
      paymentInitiationRecipientCreatePost(
          {required PaymentInitiationRecipientCreateRequest? body}) {
    generatedMapping.putIfAbsent(PaymentInitiationRecipientCreateResponse,
        () => PaymentInitiationRecipientCreateResponse.fromJsonFactory);

    return _paymentInitiationRecipientCreatePost(body: body);
  }

  ///Create payment recipient
  @Post(
    path: '/payment_initiation/recipient/create',
    optionalBody: true,
  )
  Future<chopper.Response<PaymentInitiationRecipientCreateResponse>>
      _paymentInitiationRecipientCreatePost(
          {@Body() required PaymentInitiationRecipientCreateRequest? body});

  ///Reverse an existing payment
  Future<chopper.Response<PaymentInitiationPaymentReverseResponse>>
      paymentInitiationPaymentReversePost(
          {required PaymentInitiationPaymentReverseRequest? body}) {
    generatedMapping.putIfAbsent(PaymentInitiationPaymentReverseResponse,
        () => PaymentInitiationPaymentReverseResponse.fromJsonFactory);

    return _paymentInitiationPaymentReversePost(body: body);
  }

  ///Reverse an existing payment
  @Post(
    path: '/payment_initiation/payment/reverse',
    optionalBody: true,
  )
  Future<chopper.Response<PaymentInitiationPaymentReverseResponse>>
      _paymentInitiationPaymentReversePost(
          {@Body() required PaymentInitiationPaymentReverseRequest? body});

  ///Get payment recipient
  Future<chopper.Response<PaymentInitiationRecipientGetResponse>>
      paymentInitiationRecipientGetPost(
          {required PaymentInitiationRecipientGetRequest? body}) {
    generatedMapping.putIfAbsent(PaymentInitiationRecipientGetResponse,
        () => PaymentInitiationRecipientGetResponse.fromJsonFactory);

    return _paymentInitiationRecipientGetPost(body: body);
  }

  ///Get payment recipient
  @Post(
    path: '/payment_initiation/recipient/get',
    optionalBody: true,
  )
  Future<chopper.Response<PaymentInitiationRecipientGetResponse>>
      _paymentInitiationRecipientGetPost(
          {@Body() required PaymentInitiationRecipientGetRequest? body});

  ///List payment recipients
  Future<chopper.Response<PaymentInitiationRecipientListResponse>>
      paymentInitiationRecipientListPost(
          {required PaymentInitiationRecipientListRequest? body}) {
    generatedMapping.putIfAbsent(PaymentInitiationRecipientListResponse,
        () => PaymentInitiationRecipientListResponse.fromJsonFactory);

    return _paymentInitiationRecipientListPost(body: body);
  }

  ///List payment recipients
  @Post(
    path: '/payment_initiation/recipient/list',
    optionalBody: true,
  )
  Future<chopper.Response<PaymentInitiationRecipientListResponse>>
      _paymentInitiationRecipientListPost(
          {@Body() required PaymentInitiationRecipientListRequest? body});

  ///Create a payment
  Future<chopper.Response<PaymentInitiationPaymentCreateResponse>>
      paymentInitiationPaymentCreatePost(
          {required PaymentInitiationPaymentCreateRequest? body}) {
    generatedMapping.putIfAbsent(PaymentInitiationPaymentCreateResponse,
        () => PaymentInitiationPaymentCreateResponse.fromJsonFactory);

    return _paymentInitiationPaymentCreatePost(body: body);
  }

  ///Create a payment
  @Post(
    path: '/payment_initiation/payment/create',
    optionalBody: true,
  )
  Future<chopper.Response<PaymentInitiationPaymentCreateResponse>>
      _paymentInitiationPaymentCreatePost(
          {@Body() required PaymentInitiationPaymentCreateRequest? body});

  ///Create payment token
  Future<chopper.Response<PaymentInitiationPaymentTokenCreateResponse>>
      paymentInitiationPaymentTokenCreatePost(
          {required PaymentInitiationPaymentTokenCreateRequest? body}) {
    generatedMapping.putIfAbsent(PaymentInitiationPaymentTokenCreateResponse,
        () => PaymentInitiationPaymentTokenCreateResponse.fromJsonFactory);

    return _paymentInitiationPaymentTokenCreatePost(body: body);
  }

  ///Create payment token
  @Post(
    path: '/payment_initiation/payment/token/create',
    optionalBody: true,
  )
  Future<chopper.Response<PaymentInitiationPaymentTokenCreateResponse>>
      _paymentInitiationPaymentTokenCreatePost(
          {@Body() required PaymentInitiationPaymentTokenCreateRequest? body});

  ///Create payment consent
  Future<chopper.Response<PaymentInitiationConsentCreateResponse>>
      paymentInitiationConsentCreatePost(
          {required PaymentInitiationConsentCreateRequest? body}) {
    generatedMapping.putIfAbsent(PaymentInitiationConsentCreateResponse,
        () => PaymentInitiationConsentCreateResponse.fromJsonFactory);

    return _paymentInitiationConsentCreatePost(body: body);
  }

  ///Create payment consent
  @Post(
    path: '/payment_initiation/consent/create',
    optionalBody: true,
  )
  Future<chopper.Response<PaymentInitiationConsentCreateResponse>>
      _paymentInitiationConsentCreatePost(
          {@Body() required PaymentInitiationConsentCreateRequest? body});

  ///Get payment consent
  Future<chopper.Response<PaymentInitiationConsentGetResponse>>
      paymentInitiationConsentGetPost(
          {required PaymentInitiationConsentGetRequest? body}) {
    generatedMapping.putIfAbsent(PaymentInitiationConsentGetResponse,
        () => PaymentInitiationConsentGetResponse.fromJsonFactory);

    return _paymentInitiationConsentGetPost(body: body);
  }

  ///Get payment consent
  @Post(
    path: '/payment_initiation/consent/get',
    optionalBody: true,
  )
  Future<chopper.Response<PaymentInitiationConsentGetResponse>>
      _paymentInitiationConsentGetPost(
          {@Body() required PaymentInitiationConsentGetRequest? body});

  ///Revoke payment consent
  Future<chopper.Response<PaymentInitiationConsentRevokeResponse>>
      paymentInitiationConsentRevokePost(
          {required PaymentInitiationConsentRevokeRequest? body}) {
    generatedMapping.putIfAbsent(PaymentInitiationConsentRevokeResponse,
        () => PaymentInitiationConsentRevokeResponse.fromJsonFactory);

    return _paymentInitiationConsentRevokePost(body: body);
  }

  ///Revoke payment consent
  @Post(
    path: '/payment_initiation/consent/revoke',
    optionalBody: true,
  )
  Future<chopper.Response<PaymentInitiationConsentRevokeResponse>>
      _paymentInitiationConsentRevokePost(
          {@Body() required PaymentInitiationConsentRevokeRequest? body});

  ///Execute a single payment using consent
  Future<chopper.Response<PaymentInitiationConsentPaymentExecuteResponse>>
      paymentInitiationConsentPaymentExecutePost(
          {required PaymentInitiationConsentPaymentExecuteRequest? body}) {
    generatedMapping.putIfAbsent(PaymentInitiationConsentPaymentExecuteResponse,
        () => PaymentInitiationConsentPaymentExecuteResponse.fromJsonFactory);

    return _paymentInitiationConsentPaymentExecutePost(body: body);
  }

  ///Execute a single payment using consent
  @Post(
    path: '/payment_initiation/consent/payment/execute',
    optionalBody: true,
  )
  Future<chopper.Response<PaymentInitiationConsentPaymentExecuteResponse>>
      _paymentInitiationConsentPaymentExecutePost(
          {@Body()
              required PaymentInitiationConsentPaymentExecuteRequest? body});

  ///Force a Sandbox Item into an error state
  Future<chopper.Response<SandboxItemResetLoginResponse>>
      sandboxItemResetLoginPost({required SandboxItemResetLoginRequest? body}) {
    generatedMapping.putIfAbsent(SandboxItemResetLoginResponse,
        () => SandboxItemResetLoginResponse.fromJsonFactory);

    return _sandboxItemResetLoginPost(body: body);
  }

  ///Force a Sandbox Item into an error state
  @Post(
    path: '/sandbox/item/reset_login',
    optionalBody: true,
  )
  Future<chopper.Response<SandboxItemResetLoginResponse>>
      _sandboxItemResetLoginPost(
          {@Body() required SandboxItemResetLoginRequest? body});

  ///Set verification status for Sandbox account
  Future<chopper.Response<SandboxItemSetVerificationStatusResponse>>
      sandboxItemSetVerificationStatusPost(
          {required SandboxItemSetVerificationStatusRequest? body}) {
    generatedMapping.putIfAbsent(SandboxItemSetVerificationStatusResponse,
        () => SandboxItemSetVerificationStatusResponse.fromJsonFactory);

    return _sandboxItemSetVerificationStatusPost(body: body);
  }

  ///Set verification status for Sandbox account
  @Post(
    path: '/sandbox/item/set_verification_status',
    optionalBody: true,
  )
  Future<chopper.Response<SandboxItemSetVerificationStatusResponse>>
      _sandboxItemSetVerificationStatusPost(
          {@Body() required SandboxItemSetVerificationStatusRequest? body});

  ///Exchange public token for an access token
  Future<chopper.Response<ItemPublicTokenExchangeResponse>>
      itemPublicTokenExchangePost(
          {required ItemPublicTokenExchangeRequest? body}) {
    generatedMapping.putIfAbsent(ItemPublicTokenExchangeResponse,
        () => ItemPublicTokenExchangeResponse.fromJsonFactory);

    return _itemPublicTokenExchangePost(body: body);
  }

  ///Exchange public token for an access token
  @Post(
    path: '/item/public_token/exchange',
    optionalBody: true,
  )
  Future<chopper.Response<ItemPublicTokenExchangeResponse>>
      _itemPublicTokenExchangePost(
          {@Body() required ItemPublicTokenExchangeRequest? body});

  ///Create public token
  Future<chopper.Response<ItemPublicTokenCreateResponse>>
      itemPublicTokenCreatePost({required ItemPublicTokenCreateRequest? body}) {
    generatedMapping.putIfAbsent(ItemPublicTokenCreateResponse,
        () => ItemPublicTokenCreateResponse.fromJsonFactory);

    return _itemPublicTokenCreatePost(body: body);
  }

  ///Create public token
  @Post(
    path: '/item/public_token/create',
    optionalBody: true,
  )
  Future<chopper.Response<ItemPublicTokenCreateResponse>>
      _itemPublicTokenCreatePost(
          {@Body() required ItemPublicTokenCreateRequest? body});

  ///Create user
  Future<chopper.Response<UserCreateResponse>> userCreatePost(
      {required UserCreateRequest? body}) {
    generatedMapping.putIfAbsent(
        UserCreateResponse, () => UserCreateResponse.fromJsonFactory);

    return _userCreatePost(body: body);
  }

  ///Create user
  @Post(
    path: '/user/create',
    optionalBody: true,
  )
  Future<chopper.Response<UserCreateResponse>> _userCreatePost(
      {@Body() required UserCreateRequest? body});

  ///Retrieve Link sessions for your user
  Future<chopper.Response<CreditSessionsGetResponse>> creditSessionsGetPost(
      {required CreditSessionsGetRequest? body}) {
    generatedMapping.putIfAbsent(CreditSessionsGetResponse,
        () => CreditSessionsGetResponse.fromJsonFactory);

    return _creditSessionsGetPost(body: body);
  }

  ///Retrieve Link sessions for your user
  @Post(
    path: '/credit/sessions/get',
    optionalBody: true,
  )
  Future<chopper.Response<CreditSessionsGetResponse>> _creditSessionsGetPost(
      {@Body() required CreditSessionsGetRequest? body});

  ///Get payment details
  Future<chopper.Response<PaymentInitiationPaymentGetResponse>>
      paymentInitiationPaymentGetPost(
          {required PaymentInitiationPaymentGetRequest? body}) {
    generatedMapping.putIfAbsent(PaymentInitiationPaymentGetResponse,
        () => PaymentInitiationPaymentGetResponse.fromJsonFactory);

    return _paymentInitiationPaymentGetPost(body: body);
  }

  ///Get payment details
  @Post(
    path: '/payment_initiation/payment/get',
    optionalBody: true,
  )
  Future<chopper.Response<PaymentInitiationPaymentGetResponse>>
      _paymentInitiationPaymentGetPost(
          {@Body() required PaymentInitiationPaymentGetRequest? body});

  ///List payments
  Future<chopper.Response<PaymentInitiationPaymentListResponse>>
      paymentInitiationPaymentListPost(
          {required PaymentInitiationPaymentListRequest? body}) {
    generatedMapping.putIfAbsent(PaymentInitiationPaymentListResponse,
        () => PaymentInitiationPaymentListResponse.fromJsonFactory);

    return _paymentInitiationPaymentListPost(body: body);
  }

  ///List payments
  @Post(
    path: '/payment_initiation/payment/list',
    optionalBody: true,
  )
  Future<chopper.Response<PaymentInitiationPaymentListResponse>>
      _paymentInitiationPaymentListPost(
          {@Body() required PaymentInitiationPaymentListRequest? body});

  ///Get Investment holdings
  Future<chopper.Response<InvestmentsHoldingsGetResponse>>
      investmentsHoldingsGetPost(
          {required InvestmentsHoldingsGetRequest? body}) {
    generatedMapping.putIfAbsent(InvestmentsHoldingsGetResponse,
        () => InvestmentsHoldingsGetResponse.fromJsonFactory);

    return _investmentsHoldingsGetPost(body: body);
  }

  ///Get Investment holdings
  @Post(
    path: '/investments/holdings/get',
    optionalBody: true,
  )
  Future<chopper.Response<InvestmentsHoldingsGetResponse>>
      _investmentsHoldingsGetPost(
          {@Body() required InvestmentsHoldingsGetRequest? body});

  ///Get investment transactions
  Future<chopper.Response<InvestmentsTransactionsGetResponse>>
      investmentsTransactionsGetPost(
          {required InvestmentsTransactionsGetRequest? body}) {
    generatedMapping.putIfAbsent(InvestmentsTransactionsGetResponse,
        () => InvestmentsTransactionsGetResponse.fromJsonFactory);

    return _investmentsTransactionsGetPost(body: body);
  }

  ///Get investment transactions
  @Post(
    path: '/investments/transactions/get',
    optionalBody: true,
  )
  Future<chopper.Response<InvestmentsTransactionsGetResponse>>
      _investmentsTransactionsGetPost(
          {@Body() required InvestmentsTransactionsGetRequest? body});

  ///Create processor token
  Future<chopper.Response<ProcessorTokenCreateResponse>>
      processorTokenCreatePost({required ProcessorTokenCreateRequest? body}) {
    generatedMapping.putIfAbsent(ProcessorTokenCreateResponse,
        () => ProcessorTokenCreateResponse.fromJsonFactory);

    return _processorTokenCreatePost(body: body);
  }

  ///Create processor token
  @Post(
    path: '/processor/token/create',
    optionalBody: true,
  )
  Future<chopper.Response<ProcessorTokenCreateResponse>>
      _processorTokenCreatePost(
          {@Body() required ProcessorTokenCreateRequest? body});

  ///Create Stripe bank account token
  Future<chopper.Response<ProcessorStripeBankAccountTokenCreateResponse>>
      processorStripeBankAccountTokenCreatePost(
          {required ProcessorStripeBankAccountTokenCreateRequest? body}) {
    generatedMapping.putIfAbsent(ProcessorStripeBankAccountTokenCreateResponse,
        () => ProcessorStripeBankAccountTokenCreateResponse.fromJsonFactory);

    return _processorStripeBankAccountTokenCreatePost(body: body);
  }

  ///Create Stripe bank account token
  @Post(
    path: '/processor/stripe/bank_account_token/create',
    optionalBody: true,
  )
  Future<chopper.Response<ProcessorStripeBankAccountTokenCreateResponse>>
      _processorStripeBankAccountTokenCreatePost(
          {@Body()
              required ProcessorStripeBankAccountTokenCreateRequest? body});

  ///Create Apex bank account token
  Future<chopper.Response<ProcessorTokenCreateResponse>>
      processorApexProcessorTokenCreatePost(
          {required ProcessorApexProcessorTokenCreateRequest? body}) {
    generatedMapping.putIfAbsent(ProcessorTokenCreateResponse,
        () => ProcessorTokenCreateResponse.fromJsonFactory);

    return _processorApexProcessorTokenCreatePost(body: body);
  }

  ///Create Apex bank account token
  @Post(
    path: '/processor/apex/processor_token/create',
    optionalBody: true,
  )
  Future<chopper.Response<ProcessorTokenCreateResponse>>
      _processorApexProcessorTokenCreatePost(
          {@Body() required ProcessorApexProcessorTokenCreateRequest? body});

  ///Create a deposit switch
  Future<chopper.Response<DepositSwitchCreateResponse>> depositSwitchCreatePost(
      {required DepositSwitchCreateRequest? body}) {
    generatedMapping.putIfAbsent(DepositSwitchCreateResponse,
        () => DepositSwitchCreateResponse.fromJsonFactory);

    return _depositSwitchCreatePost(body: body);
  }

  ///Create a deposit switch
  @Post(
    path: '/deposit_switch/create',
    optionalBody: true,
  )
  Future<chopper.Response<DepositSwitchCreateResponse>>
      _depositSwitchCreatePost(
          {@Body() required DepositSwitchCreateRequest? body});

  ///Import Item
  Future<chopper.Response<ItemImportResponse>> itemImportPost(
      {required ItemImportRequest? body}) {
    generatedMapping.putIfAbsent(
        ItemImportResponse, () => ItemImportResponse.fromJsonFactory);

    return _itemImportPost(body: body);
  }

  ///Import Item
  @Post(
    path: '/item/import',
    optionalBody: true,
  )
  Future<chopper.Response<ItemImportResponse>> _itemImportPost(
      {@Body() required ItemImportRequest? body});

  ///Create a deposit switch token
  Future<chopper.Response<DepositSwitchTokenCreateResponse>>
      depositSwitchTokenCreatePost(
          {required DepositSwitchTokenCreateRequest? body}) {
    generatedMapping.putIfAbsent(DepositSwitchTokenCreateResponse,
        () => DepositSwitchTokenCreateResponse.fromJsonFactory);

    return _depositSwitchTokenCreatePost(body: body);
  }

  ///Create a deposit switch token
  @Post(
    path: '/deposit_switch/token/create',
    optionalBody: true,
  )
  Future<chopper.Response<DepositSwitchTokenCreateResponse>>
      _depositSwitchTokenCreatePost(
          {@Body() required DepositSwitchTokenCreateRequest? body});

  ///Create Link Token
  Future<chopper.Response<LinkTokenCreateResponse>> linkTokenCreatePost(
      {required LinkTokenCreateRequest? body}) {
    generatedMapping.putIfAbsent(
        LinkTokenCreateResponse, () => LinkTokenCreateResponse.fromJsonFactory);

    return _linkTokenCreatePost(body: body);
  }

  ///Create Link Token
  @Post(
    path: '/link/token/create',
    optionalBody: true,
  )
  Future<chopper.Response<LinkTokenCreateResponse>> _linkTokenCreatePost(
      {@Body() required LinkTokenCreateRequest? body});

  ///Get Link Token
  Future<chopper.Response<LinkTokenGetResponse>> linkTokenGetPost(
      {required LinkTokenGetRequest? body}) {
    generatedMapping.putIfAbsent(
        LinkTokenGetResponse, () => LinkTokenGetResponse.fromJsonFactory);

    return _linkTokenGetPost(body: body);
  }

  ///Get Link Token
  @Post(
    path: '/link/token/get',
    optionalBody: true,
  )
  Future<chopper.Response<LinkTokenGetResponse>> _linkTokenGetPost(
      {@Body() required LinkTokenGetRequest? body});

  ///Exchange the Link Correlation Id for a Link Token
  Future<chopper.Response<LinkOAuthCorrelationIdExchangeResponse>>
      linkOauthCorrelationIdExchangePost(
          {required LinkOAuthCorrelationIdExchangeRequest? body}) {
    generatedMapping.putIfAbsent(LinkOAuthCorrelationIdExchangeResponse,
        () => LinkOAuthCorrelationIdExchangeResponse.fromJsonFactory);

    return _linkOauthCorrelationIdExchangePost(body: body);
  }

  ///Exchange the Link Correlation Id for a Link Token
  @Post(
    path: '/link/oauth/correlation_id/exchange',
    optionalBody: true,
  )
  Future<chopper.Response<LinkOAuthCorrelationIdExchangeResponse>>
      _linkOauthCorrelationIdExchangePost(
          {@Body() required LinkOAuthCorrelationIdExchangeRequest? body});

  ///Retrieve a deposit switch
  Future<chopper.Response<DepositSwitchGetResponse>> depositSwitchGetPost(
      {required DepositSwitchGetRequest? body}) {
    generatedMapping.putIfAbsent(DepositSwitchGetResponse,
        () => DepositSwitchGetResponse.fromJsonFactory);

    return _depositSwitchGetPost(body: body);
  }

  ///Retrieve a deposit switch
  @Post(
    path: '/deposit_switch/get',
    optionalBody: true,
  )
  Future<chopper.Response<DepositSwitchGetResponse>> _depositSwitchGetPost(
      {@Body() required DepositSwitchGetRequest? body});

  ///Retrieve a transfer
  Future<chopper.Response<TransferGetResponse>> transferGetPost(
      {required TransferGetRequest? body}) {
    generatedMapping.putIfAbsent(
        TransferGetResponse, () => TransferGetResponse.fromJsonFactory);

    return _transferGetPost(body: body);
  }

  ///Retrieve a transfer
  @Post(
    path: '/transfer/get',
    optionalBody: true,
  )
  Future<chopper.Response<TransferGetResponse>> _transferGetPost(
      {@Body() required TransferGetRequest? body});

  ///Retrieve a recurring transfer
  Future<chopper.Response<TransferRecurringGetResponse>>
      transferRecurringGetPost({required TransferRecurringGetRequest? body}) {
    generatedMapping.putIfAbsent(TransferRecurringGetResponse,
        () => TransferRecurringGetResponse.fromJsonFactory);

    return _transferRecurringGetPost(body: body);
  }

  ///Retrieve a recurring transfer
  @Post(
    path: '/transfer/recurring/get',
    optionalBody: true,
  )
  Future<chopper.Response<TransferRecurringGetResponse>>
      _transferRecurringGetPost(
          {@Body() required TransferRecurringGetRequest? body});

  ///Retrieve a bank transfer
  Future<chopper.Response<BankTransferGetResponse>> bankTransferGetPost(
      {required BankTransferGetRequest? body}) {
    generatedMapping.putIfAbsent(
        BankTransferGetResponse, () => BankTransferGetResponse.fromJsonFactory);

    return _bankTransferGetPost(body: body);
  }

  ///Retrieve a bank transfer
  @Post(
    path: '/bank_transfer/get',
    optionalBody: true,
  )
  Future<chopper.Response<BankTransferGetResponse>> _bankTransferGetPost(
      {@Body() required BankTransferGetRequest? body});

  ///Create a transfer authorization
  Future<chopper.Response<TransferAuthorizationCreateResponse>>
      transferAuthorizationCreatePost(
          {required TransferAuthorizationCreateRequest? body}) {
    generatedMapping.putIfAbsent(TransferAuthorizationCreateResponse,
        () => TransferAuthorizationCreateResponse.fromJsonFactory);

    return _transferAuthorizationCreatePost(body: body);
  }

  ///Create a transfer authorization
  @Post(
    path: '/transfer/authorization/create',
    optionalBody: true,
  )
  Future<chopper.Response<TransferAuthorizationCreateResponse>>
      _transferAuthorizationCreatePost(
          {@Body() required TransferAuthorizationCreateRequest? body});

  ///Create a transfer
  Future<chopper.Response<TransferCreateResponse>> transferCreatePost(
      {required TransferCreateRequest? body}) {
    generatedMapping.putIfAbsent(
        TransferCreateResponse, () => TransferCreateResponse.fromJsonFactory);

    return _transferCreatePost(body: body);
  }

  ///Create a transfer
  @Post(
    path: '/transfer/create',
    optionalBody: true,
  )
  Future<chopper.Response<TransferCreateResponse>> _transferCreatePost(
      {@Body() required TransferCreateRequest? body});

  ///Create a recurring transfer
  Future<chopper.Response<TransferRecurringCreateResponse>>
      transferRecurringCreatePost(
          {required TransferRecurringCreateRequest? body}) {
    generatedMapping.putIfAbsent(TransferRecurringCreateResponse,
        () => TransferRecurringCreateResponse.fromJsonFactory);

    return _transferRecurringCreatePost(body: body);
  }

  ///Create a recurring transfer
  @Post(
    path: '/transfer/recurring/create',
    optionalBody: true,
  )
  Future<chopper.Response<TransferRecurringCreateResponse>>
      _transferRecurringCreatePost(
          {@Body() required TransferRecurringCreateRequest? body});

  ///Create a bank transfer
  Future<chopper.Response<BankTransferCreateResponse>> bankTransferCreatePost(
      {required BankTransferCreateRequest? body}) {
    generatedMapping.putIfAbsent(BankTransferCreateResponse,
        () => BankTransferCreateResponse.fromJsonFactory);

    return _bankTransferCreatePost(body: body);
  }

  ///Create a bank transfer
  @Post(
    path: '/bank_transfer/create',
    optionalBody: true,
  )
  Future<chopper.Response<BankTransferCreateResponse>> _bankTransferCreatePost(
      {@Body() required BankTransferCreateRequest? body});

  ///List transfers
  Future<chopper.Response<TransferListResponse>> transferListPost(
      {required TransferListRequest? body}) {
    generatedMapping.putIfAbsent(
        TransferListResponse, () => TransferListResponse.fromJsonFactory);

    return _transferListPost(body: body);
  }

  ///List transfers
  @Post(
    path: '/transfer/list',
    optionalBody: true,
  )
  Future<chopper.Response<TransferListResponse>> _transferListPost(
      {@Body() required TransferListRequest? body});

  ///List recurring transfers
  Future<chopper.Response<TransferRecurringListResponse>>
      transferRecurringListPost({required TransferRecurringListRequest? body}) {
    generatedMapping.putIfAbsent(TransferRecurringListResponse,
        () => TransferRecurringListResponse.fromJsonFactory);

    return _transferRecurringListPost(body: body);
  }

  ///List recurring transfers
  @Post(
    path: '/transfer/recurring/list',
    optionalBody: true,
  )
  Future<chopper.Response<TransferRecurringListResponse>>
      _transferRecurringListPost(
          {@Body() required TransferRecurringListRequest? body});

  ///List bank transfers
  Future<chopper.Response<BankTransferListResponse>> bankTransferListPost(
      {required BankTransferListRequest? body}) {
    generatedMapping.putIfAbsent(BankTransferListResponse,
        () => BankTransferListResponse.fromJsonFactory);

    return _bankTransferListPost(body: body);
  }

  ///List bank transfers
  @Post(
    path: '/bank_transfer/list',
    optionalBody: true,
  )
  Future<chopper.Response<BankTransferListResponse>> _bankTransferListPost(
      {@Body() required BankTransferListRequest? body});

  ///Cancel a transfer
  Future<chopper.Response<TransferCancelResponse>> transferCancelPost(
      {required TransferCancelRequest? body}) {
    generatedMapping.putIfAbsent(
        TransferCancelResponse, () => TransferCancelResponse.fromJsonFactory);

    return _transferCancelPost(body: body);
  }

  ///Cancel a transfer
  @Post(
    path: '/transfer/cancel',
    optionalBody: true,
  )
  Future<chopper.Response<TransferCancelResponse>> _transferCancelPost(
      {@Body() required TransferCancelRequest? body});

  ///Cancel a recurring transfer.
  Future<chopper.Response<TransferRecurringCancelResponse>>
      transferRecurringCancelPost(
          {required TransferRecurringCancelRequest? body}) {
    generatedMapping.putIfAbsent(TransferRecurringCancelResponse,
        () => TransferRecurringCancelResponse.fromJsonFactory);

    return _transferRecurringCancelPost(body: body);
  }

  ///Cancel a recurring transfer.
  @Post(
    path: '/transfer/recurring/cancel',
    optionalBody: true,
  )
  Future<chopper.Response<TransferRecurringCancelResponse>>
      _transferRecurringCancelPost(
          {@Body() required TransferRecurringCancelRequest? body});

  ///Cancel a bank transfer
  Future<chopper.Response<BankTransferCancelResponse>> bankTransferCancelPost(
      {required BankTransferCancelRequest? body}) {
    generatedMapping.putIfAbsent(BankTransferCancelResponse,
        () => BankTransferCancelResponse.fromJsonFactory);

    return _bankTransferCancelPost(body: body);
  }

  ///Cancel a bank transfer
  @Post(
    path: '/bank_transfer/cancel',
    optionalBody: true,
  )
  Future<chopper.Response<BankTransferCancelResponse>> _bankTransferCancelPost(
      {@Body() required BankTransferCancelRequest? body});

  ///List transfer events
  Future<chopper.Response<TransferEventListResponse>> transferEventListPost(
      {required TransferEventListRequest? body}) {
    generatedMapping.putIfAbsent(TransferEventListResponse,
        () => TransferEventListResponse.fromJsonFactory);

    return _transferEventListPost(body: body);
  }

  ///List transfer events
  @Post(
    path: '/transfer/event/list',
    optionalBody: true,
  )
  Future<chopper.Response<TransferEventListResponse>> _transferEventListPost(
      {@Body() required TransferEventListRequest? body});

  ///List bank transfer events
  Future<chopper.Response<BankTransferEventListResponse>>
      bankTransferEventListPost({required BankTransferEventListRequest? body}) {
    generatedMapping.putIfAbsent(BankTransferEventListResponse,
        () => BankTransferEventListResponse.fromJsonFactory);

    return _bankTransferEventListPost(body: body);
  }

  ///List bank transfer events
  @Post(
    path: '/bank_transfer/event/list',
    optionalBody: true,
  )
  Future<chopper.Response<BankTransferEventListResponse>>
      _bankTransferEventListPost(
          {@Body() required BankTransferEventListRequest? body});

  ///Sync transfer events
  Future<chopper.Response<TransferEventSyncResponse>> transferEventSyncPost(
      {required TransferEventSyncRequest? body}) {
    generatedMapping.putIfAbsent(TransferEventSyncResponse,
        () => TransferEventSyncResponse.fromJsonFactory);

    return _transferEventSyncPost(body: body);
  }

  ///Sync transfer events
  @Post(
    path: '/transfer/event/sync',
    optionalBody: true,
  )
  Future<chopper.Response<TransferEventSyncResponse>> _transferEventSyncPost(
      {@Body() required TransferEventSyncRequest? body});

  ///Sync bank transfer events
  Future<chopper.Response<BankTransferEventSyncResponse>>
      bankTransferEventSyncPost({required BankTransferEventSyncRequest? body}) {
    generatedMapping.putIfAbsent(BankTransferEventSyncResponse,
        () => BankTransferEventSyncResponse.fromJsonFactory);

    return _bankTransferEventSyncPost(body: body);
  }

  ///Sync bank transfer events
  @Post(
    path: '/bank_transfer/event/sync',
    optionalBody: true,
  )
  Future<chopper.Response<BankTransferEventSyncResponse>>
      _bankTransferEventSyncPost(
          {@Body() required BankTransferEventSyncRequest? body});

  ///Retrieve a sweep
  Future<chopper.Response<TransferSweepGetResponse>> transferSweepGetPost(
      {required TransferSweepGetRequest? body}) {
    generatedMapping.putIfAbsent(TransferSweepGetResponse,
        () => TransferSweepGetResponse.fromJsonFactory);

    return _transferSweepGetPost(body: body);
  }

  ///Retrieve a sweep
  @Post(
    path: '/transfer/sweep/get',
    optionalBody: true,
  )
  Future<chopper.Response<TransferSweepGetResponse>> _transferSweepGetPost(
      {@Body() required TransferSweepGetRequest? body});

  ///Retrieve a sweep
  Future<chopper.Response<BankTransferSweepGetResponse>>
      bankTransferSweepGetPost({required BankTransferSweepGetRequest? body}) {
    generatedMapping.putIfAbsent(BankTransferSweepGetResponse,
        () => BankTransferSweepGetResponse.fromJsonFactory);

    return _bankTransferSweepGetPost(body: body);
  }

  ///Retrieve a sweep
  @Post(
    path: '/bank_transfer/sweep/get',
    optionalBody: true,
  )
  Future<chopper.Response<BankTransferSweepGetResponse>>
      _bankTransferSweepGetPost(
          {@Body() required BankTransferSweepGetRequest? body});

  ///List sweeps
  Future<chopper.Response<TransferSweepListResponse>> transferSweepListPost(
      {required TransferSweepListRequest? body}) {
    generatedMapping.putIfAbsent(TransferSweepListResponse,
        () => TransferSweepListResponse.fromJsonFactory);

    return _transferSweepListPost(body: body);
  }

  ///List sweeps
  @Post(
    path: '/transfer/sweep/list',
    optionalBody: true,
  )
  Future<chopper.Response<TransferSweepListResponse>> _transferSweepListPost(
      {@Body() required TransferSweepListRequest? body});

  ///List sweeps
  Future<chopper.Response<BankTransferSweepListResponse>>
      bankTransferSweepListPost({required BankTransferSweepListRequest? body}) {
    generatedMapping.putIfAbsent(BankTransferSweepListResponse,
        () => BankTransferSweepListResponse.fromJsonFactory);

    return _bankTransferSweepListPost(body: body);
  }

  ///List sweeps
  @Post(
    path: '/bank_transfer/sweep/list',
    optionalBody: true,
  )
  Future<chopper.Response<BankTransferSweepListResponse>>
      _bankTransferSweepListPost(
          {@Body() required BankTransferSweepListRequest? body});

  ///Get balance of your Bank Transfer account
  Future<chopper.Response<BankTransferBalanceGetResponse>>
      bankTransferBalanceGetPost(
          {required BankTransferBalanceGetRequest? body}) {
    generatedMapping.putIfAbsent(BankTransferBalanceGetResponse,
        () => BankTransferBalanceGetResponse.fromJsonFactory);

    return _bankTransferBalanceGetPost(body: body);
  }

  ///Get balance of your Bank Transfer account
  @Post(
    path: '/bank_transfer/balance/get',
    optionalBody: true,
  )
  Future<chopper.Response<BankTransferBalanceGetResponse>>
      _bankTransferBalanceGetPost(
          {@Body() required BankTransferBalanceGetRequest? body});

  ///Migrate account into Bank Transfers
  Future<chopper.Response<BankTransferMigrateAccountResponse>>
      bankTransferMigrateAccountPost(
          {required BankTransferMigrateAccountRequest? body}) {
    generatedMapping.putIfAbsent(BankTransferMigrateAccountResponse,
        () => BankTransferMigrateAccountResponse.fromJsonFactory);

    return _bankTransferMigrateAccountPost(body: body);
  }

  ///Migrate account into Bank Transfers
  @Post(
    path: '/bank_transfer/migrate_account',
    optionalBody: true,
  )
  Future<chopper.Response<BankTransferMigrateAccountResponse>>
      _bankTransferMigrateAccountPost(
          {@Body() required BankTransferMigrateAccountRequest? body});

  ///Migrate account into Transfers
  Future<chopper.Response<TransferMigrateAccountResponse>>
      transferMigrateAccountPost(
          {required TransferMigrateAccountRequest? body}) {
    generatedMapping.putIfAbsent(TransferMigrateAccountResponse,
        () => TransferMigrateAccountResponse.fromJsonFactory);

    return _transferMigrateAccountPost(body: body);
  }

  ///Migrate account into Transfers
  @Post(
    path: '/transfer/migrate_account',
    optionalBody: true,
  )
  Future<chopper.Response<TransferMigrateAccountResponse>>
      _transferMigrateAccountPost(
          {@Body() required TransferMigrateAccountRequest? body});

  ///Create a transfer intent object to invoke the Transfer UI
  Future<chopper.Response<TransferIntentCreateResponse>>
      transferIntentCreatePost({required TransferIntentCreateRequest? body}) {
    generatedMapping.putIfAbsent(TransferIntentCreateResponse,
        () => TransferIntentCreateResponse.fromJsonFactory);

    return _transferIntentCreatePost(body: body);
  }

  ///Create a transfer intent object to invoke the Transfer UI
  @Post(
    path: '/transfer/intent/create',
    optionalBody: true,
  )
  Future<chopper.Response<TransferIntentCreateResponse>>
      _transferIntentCreatePost(
          {@Body() required TransferIntentCreateRequest? body});

  ///Retrieve more information about a transfer intent
  Future<chopper.Response<TransferIntentGetResponse>> transferIntentGetPost(
      {required TransferIntentGetRequest? body}) {
    generatedMapping.putIfAbsent(TransferIntentGetResponse,
        () => TransferIntentGetResponse.fromJsonFactory);

    return _transferIntentGetPost(body: body);
  }

  ///Retrieve more information about a transfer intent
  @Post(
    path: '/transfer/intent/get',
    optionalBody: true,
  )
  Future<chopper.Response<TransferIntentGetResponse>> _transferIntentGetPost(
      {@Body() required TransferIntentGetRequest? body});

  ///Lists historical repayments
  Future<chopper.Response<TransferRepaymentListResponse>>
      transferRepaymentListPost({required TransferRepaymentListRequest? body}) {
    generatedMapping.putIfAbsent(TransferRepaymentListResponse,
        () => TransferRepaymentListResponse.fromJsonFactory);

    return _transferRepaymentListPost(body: body);
  }

  ///Lists historical repayments
  @Post(
    path: '/transfer/repayment/list',
    optionalBody: true,
  )
  Future<chopper.Response<TransferRepaymentListResponse>>
      _transferRepaymentListPost(
          {@Body() required TransferRepaymentListRequest? body});

  ///List the returns included in a repayment
  Future<chopper.Response<TransferRepaymentReturnListResponse>>
      transferRepaymentReturnListPost(
          {required TransferRepaymentReturnListRequest? body}) {
    generatedMapping.putIfAbsent(TransferRepaymentReturnListResponse,
        () => TransferRepaymentReturnListResponse.fromJsonFactory);

    return _transferRepaymentReturnListPost(body: body);
  }

  ///List the returns included in a repayment
  @Post(
    path: '/transfer/repayment/return/list',
    optionalBody: true,
  )
  Future<chopper.Response<TransferRepaymentReturnListResponse>>
      _transferRepaymentReturnListPost(
          {@Body() required TransferRepaymentReturnListRequest? body});

  ///Create a new originator
  Future<chopper.Response<TransferOriginatorCreateResponse>>
      transferOriginatorCreatePost(
          {required TransferOriginatorCreateRequest? body}) {
    generatedMapping.putIfAbsent(TransferOriginatorCreateResponse,
        () => TransferOriginatorCreateResponse.fromJsonFactory);

    return _transferOriginatorCreatePost(body: body);
  }

  ///Create a new originator
  @Post(
    path: '/transfer/originator/create',
    optionalBody: true,
  )
  Future<chopper.Response<TransferOriginatorCreateResponse>>
      _transferOriginatorCreatePost(
          {@Body() required TransferOriginatorCreateRequest? body});

  ///Generate a Plaid-hosted onboarding UI URL.
  Future<chopper.Response<TransferQuestionnaireCreateResponse>>
      transferQuestionnaireCreatePost(
          {required TransferQuestionnaireCreateRequest? body}) {
    generatedMapping.putIfAbsent(TransferQuestionnaireCreateResponse,
        () => TransferQuestionnaireCreateResponse.fromJsonFactory);

    return _transferQuestionnaireCreatePost(body: body);
  }

  ///Generate a Plaid-hosted onboarding UI URL.
  @Post(
    path: '/transfer/questionnaire/create',
    optionalBody: true,
  )
  Future<chopper.Response<TransferQuestionnaireCreateResponse>>
      _transferQuestionnaireCreatePost(
          {@Body() required TransferQuestionnaireCreateRequest? body});

  ///Get status of an originator's onboarding
  Future<chopper.Response<TransferOriginatorGetResponse>>
      transferOriginatorGetPost({required TransferOriginatorGetRequest? body}) {
    generatedMapping.putIfAbsent(TransferOriginatorGetResponse,
        () => TransferOriginatorGetResponse.fromJsonFactory);

    return _transferOriginatorGetPost(body: body);
  }

  ///Get status of an originator's onboarding
  @Post(
    path: '/transfer/originator/get',
    optionalBody: true,
  )
  Future<chopper.Response<TransferOriginatorGetResponse>>
      _transferOriginatorGetPost(
          {@Body() required TransferOriginatorGetRequest? body});

  ///Get status of all originators' onboarding
  Future<chopper.Response<TransferOriginatorListResponse>>
      transferOriginatorListPost(
          {required TransferOriginatorListRequest? body}) {
    generatedMapping.putIfAbsent(TransferOriginatorListResponse,
        () => TransferOriginatorListResponse.fromJsonFactory);

    return _transferOriginatorListPost(body: body);
  }

  ///Get status of all originators' onboarding
  @Post(
    path: '/transfer/originator/list',
    optionalBody: true,
  )
  Future<chopper.Response<TransferOriginatorListResponse>>
      _transferOriginatorListPost(
          {@Body() required TransferOriginatorListRequest? body});

  ///Create a refund
  Future<chopper.Response<TransferRefundCreateResponse>>
      transferRefundCreatePost({required TransferRefundCreateRequest? body}) {
    generatedMapping.putIfAbsent(TransferRefundCreateResponse,
        () => TransferRefundCreateResponse.fromJsonFactory);

    return _transferRefundCreatePost(body: body);
  }

  ///Create a refund
  @Post(
    path: '/transfer/refund/create',
    optionalBody: true,
  )
  Future<chopper.Response<TransferRefundCreateResponse>>
      _transferRefundCreatePost(
          {@Body() required TransferRefundCreateRequest? body});

  ///Retrieve a refund
  Future<chopper.Response<TransferRefundGetResponse>> transferRefundGetPost(
      {required TransferRefundGetRequest? body}) {
    generatedMapping.putIfAbsent(TransferRefundGetResponse,
        () => TransferRefundGetResponse.fromJsonFactory);

    return _transferRefundGetPost(body: body);
  }

  ///Retrieve a refund
  @Post(
    path: '/transfer/refund/get',
    optionalBody: true,
  )
  Future<chopper.Response<TransferRefundGetResponse>> _transferRefundGetPost(
      {@Body() required TransferRefundGetRequest? body});

  ///Cancel a refund
  Future<chopper.Response<TransferRefundCancelResponse>>
      transferRefundCancelPost({required TransferRefundCancelRequest? body}) {
    generatedMapping.putIfAbsent(TransferRefundCancelResponse,
        () => TransferRefundCancelResponse.fromJsonFactory);

    return _transferRefundCancelPost(body: body);
  }

  ///Cancel a refund
  @Post(
    path: '/transfer/refund/cancel',
    optionalBody: true,
  )
  Future<chopper.Response<TransferRefundCancelResponse>>
      _transferRefundCancelPost(
          {@Body() required TransferRefundCancelRequest? body});

  ///Simulate a bank transfer event in Sandbox
  Future<chopper.Response<SandboxBankTransferSimulateResponse>>
      sandboxBankTransferSimulatePost(
          {required SandboxBankTransferSimulateRequest? body}) {
    generatedMapping.putIfAbsent(SandboxBankTransferSimulateResponse,
        () => SandboxBankTransferSimulateResponse.fromJsonFactory);

    return _sandboxBankTransferSimulatePost(body: body);
  }

  ///Simulate a bank transfer event in Sandbox
  @Post(
    path: '/sandbox/bank_transfer/simulate',
    optionalBody: true,
  )
  Future<chopper.Response<SandboxBankTransferSimulateResponse>>
      _sandboxBankTransferSimulatePost(
          {@Body() required SandboxBankTransferSimulateRequest? body});

  ///Simulate creating a sweep
  Future<chopper.Response<SandboxTransferSweepSimulateResponse>>
      sandboxTransferSweepSimulatePost(
          {required SandboxTransferSweepSimulateRequest? body}) {
    generatedMapping.putIfAbsent(SandboxTransferSweepSimulateResponse,
        () => SandboxTransferSweepSimulateResponse.fromJsonFactory);

    return _sandboxTransferSweepSimulatePost(body: body);
  }

  ///Simulate creating a sweep
  @Post(
    path: '/sandbox/transfer/sweep/simulate',
    optionalBody: true,
  )
  Future<chopper.Response<SandboxTransferSweepSimulateResponse>>
      _sandboxTransferSweepSimulatePost(
          {@Body() required SandboxTransferSweepSimulateRequest? body});

  ///Simulate a transfer event in Sandbox
  Future<chopper.Response<SandboxTransferSimulateResponse>>
      sandboxTransferSimulatePost(
          {required SandboxTransferSimulateRequest? body}) {
    generatedMapping.putIfAbsent(SandboxTransferSimulateResponse,
        () => SandboxTransferSimulateResponse.fromJsonFactory);

    return _sandboxTransferSimulatePost(body: body);
  }

  ///Simulate a transfer event in Sandbox
  @Post(
    path: '/sandbox/transfer/simulate',
    optionalBody: true,
  )
  Future<chopper.Response<SandboxTransferSimulateResponse>>
      _sandboxTransferSimulatePost(
          {@Body() required SandboxTransferSimulateRequest? body});

  ///Trigger the creation of a repayment
  Future<chopper.Response<SandboxTransferRepaymentSimulateResponse>>
      sandboxTransferRepaymentSimulatePost(
          {required SandboxTransferRepaymentSimulateRequest? body}) {
    generatedMapping.putIfAbsent(SandboxTransferRepaymentSimulateResponse,
        () => SandboxTransferRepaymentSimulateResponse.fromJsonFactory);

    return _sandboxTransferRepaymentSimulatePost(body: body);
  }

  ///Trigger the creation of a repayment
  @Post(
    path: '/sandbox/transfer/repayment/simulate',
    optionalBody: true,
  )
  Future<chopper.Response<SandboxTransferRepaymentSimulateResponse>>
      _sandboxTransferRepaymentSimulatePost(
          {@Body() required SandboxTransferRepaymentSimulateRequest? body});

  ///Manually fire a Transfer webhook
  Future<chopper.Response<SandboxTransferFireWebhookResponse>>
      sandboxTransferFireWebhookPost(
          {required SandboxTransferFireWebhookRequest? body}) {
    generatedMapping.putIfAbsent(SandboxTransferFireWebhookResponse,
        () => SandboxTransferFireWebhookResponse.fromJsonFactory);

    return _sandboxTransferFireWebhookPost(body: body);
  }

  ///Manually fire a Transfer webhook
  @Post(
    path: '/sandbox/transfer/fire_webhook',
    optionalBody: true,
  )
  Future<chopper.Response<SandboxTransferFireWebhookResponse>>
      _sandboxTransferFireWebhookPost(
          {@Body() required SandboxTransferFireWebhookRequest? body});

  ///Create a test clock
  Future<chopper.Response<SandboxTransferTestClockCreateResponse>>
      sandboxTransferTestClockCreatePost(
          {required SandboxTransferTestClockCreateRequest? body}) {
    generatedMapping.putIfAbsent(SandboxTransferTestClockCreateResponse,
        () => SandboxTransferTestClockCreateResponse.fromJsonFactory);

    return _sandboxTransferTestClockCreatePost(body: body);
  }

  ///Create a test clock
  @Post(
    path: '/sandbox/transfer/test_clock/create',
    optionalBody: true,
  )
  Future<chopper.Response<SandboxTransferTestClockCreateResponse>>
      _sandboxTransferTestClockCreatePost(
          {@Body() required SandboxTransferTestClockCreateRequest? body});

  ///Advance a test clock
  Future<chopper.Response<SandboxTransferTestClockAdvanceResponse>>
      sandboxTransferTestClockAdvancePost(
          {required SandboxTransferTestClockAdvanceRequest? body}) {
    generatedMapping.putIfAbsent(SandboxTransferTestClockAdvanceResponse,
        () => SandboxTransferTestClockAdvanceResponse.fromJsonFactory);

    return _sandboxTransferTestClockAdvancePost(body: body);
  }

  ///Advance a test clock
  @Post(
    path: '/sandbox/transfer/test_clock/advance',
    optionalBody: true,
  )
  Future<chopper.Response<SandboxTransferTestClockAdvanceResponse>>
      _sandboxTransferTestClockAdvancePost(
          {@Body() required SandboxTransferTestClockAdvanceRequest? body});

  ///Get a test clock
  Future<chopper.Response<SandboxTransferTestClockGetResponse>>
      sandboxTransferTestClockGetPost(
          {required SandboxTransferTestClockGetRequest? body}) {
    generatedMapping.putIfAbsent(SandboxTransferTestClockGetResponse,
        () => SandboxTransferTestClockGetResponse.fromJsonFactory);

    return _sandboxTransferTestClockGetPost(body: body);
  }

  ///Get a test clock
  @Post(
    path: '/sandbox/transfer/test_clock/get',
    optionalBody: true,
  )
  Future<chopper.Response<SandboxTransferTestClockGetResponse>>
      _sandboxTransferTestClockGetPost(
          {@Body() required SandboxTransferTestClockGetRequest? body});

  ///Reset the login of a Payment Profile
  Future<chopper.Response<SandboxPaymentProfileResetLoginResponse>>
      sandboxPaymentProfileResetLoginPost(
          {required SandboxPaymentProfileResetLoginRequest? body}) {
    generatedMapping.putIfAbsent(SandboxPaymentProfileResetLoginResponse,
        () => SandboxPaymentProfileResetLoginResponse.fromJsonFactory);

    return _sandboxPaymentProfileResetLoginPost(body: body);
  }

  ///Reset the login of a Payment Profile
  @Post(
    path: '/sandbox/payment_profile/reset_login',
    optionalBody: true,
  )
  Future<chopper.Response<SandboxPaymentProfileResetLoginResponse>>
      _sandboxPaymentProfileResetLoginPost(
          {@Body() required SandboxPaymentProfileResetLoginRequest? body});

  ///Search employer database
  Future<chopper.Response<EmployersSearchResponse>> employersSearchPost(
      {required EmployersSearchRequest? body}) {
    generatedMapping.putIfAbsent(
        EmployersSearchResponse, () => EmployersSearchResponse.fromJsonFactory);

    return _employersSearchPost(body: body);
  }

  ///Search employer database
  @Post(
    path: '/employers/search',
    optionalBody: true,
  )
  Future<chopper.Response<EmployersSearchResponse>> _employersSearchPost(
      {@Body() required EmployersSearchRequest? body});

  ///(Deprecated) Create an income verification instance
  Future<chopper.Response<IncomeVerificationCreateResponse>>
      incomeVerificationCreatePost(
          {required IncomeVerificationCreateRequest? body}) {
    generatedMapping.putIfAbsent(IncomeVerificationCreateResponse,
        () => IncomeVerificationCreateResponse.fromJsonFactory);

    return _incomeVerificationCreatePost(body: body);
  }

  ///(Deprecated) Create an income verification instance
  @Post(
    path: '/income/verification/create',
    optionalBody: true,
  )
  Future<chopper.Response<IncomeVerificationCreateResponse>>
      _incomeVerificationCreatePost(
          {@Body() required IncomeVerificationCreateRequest? body});

  ///(Deprecated) Retrieve information from the paystubs used for income verification
  Future<chopper.Response<IncomeVerificationPaystubsGetResponse>>
      incomeVerificationPaystubsGetPost(
          {required IncomeVerificationPaystubsGetRequest? body}) {
    generatedMapping.putIfAbsent(IncomeVerificationPaystubsGetResponse,
        () => IncomeVerificationPaystubsGetResponse.fromJsonFactory);

    return _incomeVerificationPaystubsGetPost(body: body);
  }

  ///(Deprecated) Retrieve information from the paystubs used for income verification
  @Post(
    path: '/income/verification/paystubs/get',
    optionalBody: true,
  )
  Future<chopper.Response<IncomeVerificationPaystubsGetResponse>>
      _incomeVerificationPaystubsGetPost(
          {@Body() required IncomeVerificationPaystubsGetRequest? body});

  ///(Deprecated) Download the original documents used for income verification
  Future<chopper.Response<String>> incomeVerificationDocumentsDownloadPost(
      {required IncomeVerificationDocumentsDownloadRequest? body}) {
    return _incomeVerificationDocumentsDownloadPost(body: body);
  }

  ///(Deprecated) Download the original documents used for income verification
  @Post(
    path: '/income/verification/documents/download',
    optionalBody: true,
  )
  Future<chopper.Response<String>> _incomeVerificationDocumentsDownloadPost(
      {@Body() required IncomeVerificationDocumentsDownloadRequest? body});

  ///(Deprecated) Retrieve information from the tax documents used for income verification
  Future<chopper.Response<IncomeVerificationTaxformsGetResponse>>
      incomeVerificationTaxformsGetPost(
          {required IncomeVerificationTaxformsGetRequest? body}) {
    generatedMapping.putIfAbsent(IncomeVerificationTaxformsGetResponse,
        () => IncomeVerificationTaxformsGetResponse.fromJsonFactory);

    return _incomeVerificationTaxformsGetPost(body: body);
  }

  ///(Deprecated) Retrieve information from the tax documents used for income verification
  @Post(
    path: '/income/verification/taxforms/get',
    optionalBody: true,
  )
  Future<chopper.Response<IncomeVerificationTaxformsGetResponse>>
      _incomeVerificationTaxformsGetPost(
          {@Body() required IncomeVerificationTaxformsGetRequest? body});

  ///(Deprecated) Check digital income verification eligibility and optimize conversion
  Future<chopper.Response<IncomeVerificationPrecheckResponse>>
      incomeVerificationPrecheckPost(
          {required IncomeVerificationPrecheckRequest? body}) {
    generatedMapping.putIfAbsent(IncomeVerificationPrecheckResponse,
        () => IncomeVerificationPrecheckResponse.fromJsonFactory);

    return _incomeVerificationPrecheckPost(body: body);
  }

  ///(Deprecated) Check digital income verification eligibility and optimize conversion
  @Post(
    path: '/income/verification/precheck',
    optionalBody: true,
  )
  Future<chopper.Response<IncomeVerificationPrecheckResponse>>
      _incomeVerificationPrecheckPost(
          {@Body() required IncomeVerificationPrecheckRequest? body});

  ///(Deprecated) Retrieve a summary of an individual's employment information
  Future<chopper.Response<EmploymentVerificationGetResponse>>
      employmentVerificationGetPost(
          {required EmploymentVerificationGetRequest? body}) {
    generatedMapping.putIfAbsent(EmploymentVerificationGetResponse,
        () => EmploymentVerificationGetResponse.fromJsonFactory);

    return _employmentVerificationGetPost(body: body);
  }

  ///(Deprecated) Retrieve a summary of an individual's employment information
  @Post(
    path: '/employment/verification/get',
    optionalBody: true,
  )
  Future<chopper.Response<EmploymentVerificationGetResponse>>
      _employmentVerificationGetPost(
          {@Body() required EmploymentVerificationGetRequest? body});

  ///Create a deposit switch without using Plaid Exchange
  Future<chopper.Response<DepositSwitchAltCreateResponse>>
      depositSwitchAltCreatePost(
          {required DepositSwitchAltCreateRequest? body}) {
    generatedMapping.putIfAbsent(DepositSwitchAltCreateResponse,
        () => DepositSwitchAltCreateResponse.fromJsonFactory);

    return _depositSwitchAltCreatePost(body: body);
  }

  ///Create a deposit switch without using Plaid Exchange
  @Post(
    path: '/deposit_switch/alt/create',
    optionalBody: true,
  )
  Future<chopper.Response<DepositSwitchAltCreateResponse>>
      _depositSwitchAltCreatePost(
          {@Body() required DepositSwitchAltCreateRequest? body});

  ///Create Asset or Income Report Audit Copy Token
  Future<chopper.Response<CreditAuditCopyTokenCreateResponse>>
      creditAuditCopyTokenCreatePost(
          {required CreditAuditCopyTokenCreateRequest? body}) {
    generatedMapping.putIfAbsent(CreditAuditCopyTokenCreateResponse,
        () => CreditAuditCopyTokenCreateResponse.fromJsonFactory);

    return _creditAuditCopyTokenCreatePost(body: body);
  }

  ///Create Asset or Income Report Audit Copy Token
  @Post(
    path: '/credit/audit_copy_token/create',
    optionalBody: true,
  )
  Future<chopper.Response<CreditAuditCopyTokenCreateResponse>>
      _creditAuditCopyTokenCreatePost(
          {@Body() required CreditAuditCopyTokenCreateRequest? body});

  ///Remove an Audit Copy token
  Future<chopper.Response<CreditAuditCopyTokenRemoveResponse>>
      creditAuditCopyTokenRemovePost(
          {required CreditAuditCopyTokenRemoveRequest? body}) {
    generatedMapping.putIfAbsent(CreditAuditCopyTokenRemoveResponse,
        () => CreditAuditCopyTokenRemoveResponse.fromJsonFactory);

    return _creditAuditCopyTokenRemovePost(body: body);
  }

  ///Remove an Audit Copy token
  @Post(
    path: '/credit/audit_copy_token/remove',
    optionalBody: true,
  )
  Future<chopper.Response<CreditAuditCopyTokenRemoveResponse>>
      _creditAuditCopyTokenRemovePost(
          {@Body() required CreditAuditCopyTokenRemoveRequest? body});

  ///Retrieve an Asset Report with Freddie Mac format. Only Freddie Mac can use this endpoint.
  Future<chopper.Response<AssetReportFreddieGetResponse>>
      creditAssetReportFreddieMacGetPost(
          {required AssetReportFreddieGetRequest? body}) {
    generatedMapping.putIfAbsent(AssetReportFreddieGetResponse,
        () => AssetReportFreddieGetResponse.fromJsonFactory);

    return _creditAssetReportFreddieMacGetPost(body: body);
  }

  ///Retrieve an Asset Report with Freddie Mac format. Only Freddie Mac can use this endpoint.
  @Post(
    path: '/credit/asset_report/freddie_mac/get',
    optionalBody: true,
  )
  Future<chopper.Response<AssetReportFreddieGetResponse>>
      _creditAssetReportFreddieMacGetPost(
          {@Body() required AssetReportFreddieGetRequest? body});

  ///Retrieve information from the bank accounts used for income verification
  Future<chopper.Response<CreditBankIncomeGetResponse>> creditBankIncomeGetPost(
      {required CreditBankIncomeGetRequest? body}) {
    generatedMapping.putIfAbsent(CreditBankIncomeGetResponse,
        () => CreditBankIncomeGetResponse.fromJsonFactory);

    return _creditBankIncomeGetPost(body: body);
  }

  ///Retrieve information from the bank accounts used for income verification
  @Post(
    path: '/credit/bank_income/get',
    optionalBody: true,
  )
  Future<chopper.Response<CreditBankIncomeGetResponse>>
      _creditBankIncomeGetPost(
          {@Body() required CreditBankIncomeGetRequest? body});

  ///Retrieve information from the bank accounts used for income verification in PDF format
  Future<chopper.Response<Object>> creditBankIncomePdfGetPost(
      {required CreditBankIncomePDFGetRequest? body}) {
    return _creditBankIncomePdfGetPost(body: body);
  }

  ///Retrieve information from the bank accounts used for income verification in PDF format
  @Post(
    path: '/credit/bank_income/pdf/get',
    optionalBody: true,
  )
  Future<chopper.Response<Object>> _creditBankIncomePdfGetPost(
      {@Body() required CreditBankIncomePDFGetRequest? body});

  ///Refresh a user's bank income information
  Future<chopper.Response<CreditBankIncomeRefreshResponse>>
      creditBankIncomeRefreshPost(
          {required CreditBankIncomeRefreshRequest? body}) {
    generatedMapping.putIfAbsent(CreditBankIncomeRefreshResponse,
        () => CreditBankIncomeRefreshResponse.fromJsonFactory);

    return _creditBankIncomeRefreshPost(body: body);
  }

  ///Refresh a user's bank income information
  @Post(
    path: '/credit/bank_income/refresh',
    optionalBody: true,
  )
  Future<chopper.Response<CreditBankIncomeRefreshResponse>>
      _creditBankIncomeRefreshPost(
          {@Body() required CreditBankIncomeRefreshRequest? body});

  ///Retrieve a user's payroll information
  Future<chopper.Response<CreditPayrollIncomeGetResponse>>
      creditPayrollIncomeGetPost(
          {required CreditPayrollIncomeGetRequest? body}) {
    generatedMapping.putIfAbsent(CreditPayrollIncomeGetResponse,
        () => CreditPayrollIncomeGetResponse.fromJsonFactory);

    return _creditPayrollIncomeGetPost(body: body);
  }

  ///Retrieve a user's payroll information
  @Post(
    path: '/credit/payroll_income/get',
    optionalBody: true,
  )
  Future<chopper.Response<CreditPayrollIncomeGetResponse>>
      _creditPayrollIncomeGetPost(
          {@Body() required CreditPayrollIncomeGetRequest? body});

  ///Check income verification eligibility and optimize conversion
  Future<chopper.Response<CreditPayrollIncomePrecheckResponse>>
      creditPayrollIncomePrecheckPost(
          {required CreditPayrollIncomePrecheckRequest? body}) {
    generatedMapping.putIfAbsent(CreditPayrollIncomePrecheckResponse,
        () => CreditPayrollIncomePrecheckResponse.fromJsonFactory);

    return _creditPayrollIncomePrecheckPost(body: body);
  }

  ///Check income verification eligibility and optimize conversion
  @Post(
    path: '/credit/payroll_income/precheck',
    optionalBody: true,
  )
  Future<chopper.Response<CreditPayrollIncomePrecheckResponse>>
      _creditPayrollIncomePrecheckPost(
          {@Body() required CreditPayrollIncomePrecheckRequest? body});

  ///Retrieve a summary of an individual's employment information
  Future<chopper.Response<CreditEmploymentGetResponse>> creditEmploymentGetPost(
      {required CreditEmploymentGetRequest? body}) {
    generatedMapping.putIfAbsent(CreditEmploymentGetResponse,
        () => CreditEmploymentGetResponse.fromJsonFactory);

    return _creditEmploymentGetPost(body: body);
  }

  ///Retrieve a summary of an individual's employment information
  @Post(
    path: '/credit/employment/get',
    optionalBody: true,
  )
  Future<chopper.Response<CreditEmploymentGetResponse>>
      _creditEmploymentGetPost(
          {@Body() required CreditEmploymentGetRequest? body});

  ///Refresh a digital payroll income verification
  Future<chopper.Response<CreditPayrollIncomeRefreshResponse>>
      creditPayrollIncomeRefreshPost(
          {required CreditPayrollIncomeRefreshRequest? body}) {
    generatedMapping.putIfAbsent(CreditPayrollIncomeRefreshResponse,
        () => CreditPayrollIncomeRefreshResponse.fromJsonFactory);

    return _creditPayrollIncomeRefreshPost(body: body);
  }

  ///Refresh a digital payroll income verification
  @Post(
    path: '/credit/payroll_income/refresh',
    optionalBody: true,
  )
  Future<chopper.Response<CreditPayrollIncomeRefreshResponse>>
      _creditPayrollIncomeRefreshPost(
          {@Body() required CreditPayrollIncomeRefreshRequest? body});

  ///Create a `relay_token` to share an Asset Report with a partner client
  Future<chopper.Response<CreditRelayCreateResponse>> creditRelayCreatePost(
      {required CreditRelayCreateRequest? body}) {
    generatedMapping.putIfAbsent(CreditRelayCreateResponse,
        () => CreditRelayCreateResponse.fromJsonFactory);

    return _creditRelayCreatePost(body: body);
  }

  ///Create a `relay_token` to share an Asset Report with a partner client
  @Post(
    path: '/credit/relay/create',
    optionalBody: true,
  )
  Future<chopper.Response<CreditRelayCreateResponse>> _creditRelayCreatePost(
      {@Body() required CreditRelayCreateRequest? body});

  ///Retrieve the reports associated with a Relay token that was shared with you
  Future<chopper.Response<AssetReportGetResponse>> creditRelayGetPost(
      {required CreditRelayGetRequest? body}) {
    generatedMapping.putIfAbsent(
        AssetReportGetResponse, () => AssetReportGetResponse.fromJsonFactory);

    return _creditRelayGetPost(body: body);
  }

  ///Retrieve the reports associated with a Relay token that was shared with you
  @Post(
    path: '/credit/relay/get',
    optionalBody: true,
  )
  Future<chopper.Response<AssetReportGetResponse>> _creditRelayGetPost(
      {@Body() required CreditRelayGetRequest? body});

  ///Refresh a report of a Relay Token
  Future<chopper.Response<CreditRelayRefreshResponse>> creditRelayRefreshPost(
      {required CreditRelayRefreshRequest? body}) {
    generatedMapping.putIfAbsent(CreditRelayRefreshResponse,
        () => CreditRelayRefreshResponse.fromJsonFactory);

    return _creditRelayRefreshPost(body: body);
  }

  ///Refresh a report of a Relay Token
  @Post(
    path: '/credit/relay/refresh',
    optionalBody: true,
  )
  Future<chopper.Response<CreditRelayRefreshResponse>> _creditRelayRefreshPost(
      {@Body() required CreditRelayRefreshRequest? body});

  ///Remove Credit Relay Token
  Future<chopper.Response<CreditRelayRemoveResponse>> creditRelayRemovePost(
      {required CreditRelayRemoveRequest? body}) {
    generatedMapping.putIfAbsent(CreditRelayRemoveResponse,
        () => CreditRelayRemoveResponse.fromJsonFactory);

    return _creditRelayRemovePost(body: body);
  }

  ///Remove Credit Relay Token
  @Post(
    path: '/credit/relay/remove',
    optionalBody: true,
  )
  Future<chopper.Response<CreditRelayRemoveResponse>> _creditRelayRemovePost(
      {@Body() required CreditRelayRemoveRequest? body});

  ///Manually fire a Bank Transfer webhook
  Future<chopper.Response<SandboxBankTransferFireWebhookResponse>>
      sandboxBankTransferFireWebhookPost(
          {required SandboxBankTransferFireWebhookRequest? body}) {
    generatedMapping.putIfAbsent(SandboxBankTransferFireWebhookResponse,
        () => SandboxBankTransferFireWebhookResponse.fromJsonFactory);

    return _sandboxBankTransferFireWebhookPost(body: body);
  }

  ///Manually fire a Bank Transfer webhook
  @Post(
    path: '/sandbox/bank_transfer/fire_webhook',
    optionalBody: true,
  )
  Future<chopper.Response<SandboxBankTransferFireWebhookResponse>>
      _sandboxBankTransferFireWebhookPost(
          {@Body() required SandboxBankTransferFireWebhookRequest? body});

  ///Manually fire an Income webhook
  Future<chopper.Response<SandboxIncomeFireWebhookResponse>>
      sandboxIncomeFireWebhookPost(
          {required SandboxIncomeFireWebhookRequest? body}) {
    generatedMapping.putIfAbsent(SandboxIncomeFireWebhookResponse,
        () => SandboxIncomeFireWebhookResponse.fromJsonFactory);

    return _sandboxIncomeFireWebhookPost(body: body);
  }

  ///Manually fire an Income webhook
  @Post(
    path: '/sandbox/income/fire_webhook',
    optionalBody: true,
  )
  Future<chopper.Response<SandboxIncomeFireWebhookResponse>>
      _sandboxIncomeFireWebhookPost(
          {@Body() required SandboxIncomeFireWebhookRequest? body});

  ///Save the selected accounts when connecting to the Platypus Oauth institution
  Future<chopper.Response<SandboxOauthSelectAccountsResponse>>
      sandboxOauthSelectAccountsPost(
          {required SandboxOauthSelectAccountsRequest? body}) {
    generatedMapping.putIfAbsent(SandboxOauthSelectAccountsResponse,
        () => SandboxOauthSelectAccountsResponse.fromJsonFactory);

    return _sandboxOauthSelectAccountsPost(body: body);
  }

  ///Save the selected accounts when connecting to the Platypus Oauth institution
  @Post(
    path: '/sandbox/oauth/select_accounts',
    optionalBody: true,
  )
  Future<chopper.Response<SandboxOauthSelectAccountsResponse>>
      _sandboxOauthSelectAccountsPost(
          {@Body() required SandboxOauthSelectAccountsRequest? body});

  ///Evaluate a planned ACH transaction
  Future<chopper.Response<SignalEvaluateResponse>> signalEvaluatePost(
      {required SignalEvaluateRequest? body}) {
    generatedMapping.putIfAbsent(
        SignalEvaluateResponse, () => SignalEvaluateResponse.fromJsonFactory);

    return _signalEvaluatePost(body: body);
  }

  ///Evaluate a planned ACH transaction
  @Post(
    path: '/signal/evaluate',
    optionalBody: true,
  )
  Future<chopper.Response<SignalEvaluateResponse>> _signalEvaluatePost(
      {@Body() required SignalEvaluateRequest? body});

  ///Report whether you initiated an ACH transaction
  Future<chopper.Response<SignalDecisionReportResponse>>
      signalDecisionReportPost({required SignalDecisionReportRequest? body}) {
    generatedMapping.putIfAbsent(SignalDecisionReportResponse,
        () => SignalDecisionReportResponse.fromJsonFactory);

    return _signalDecisionReportPost(body: body);
  }

  ///Report whether you initiated an ACH transaction
  @Post(
    path: '/signal/decision/report',
    optionalBody: true,
  )
  Future<chopper.Response<SignalDecisionReportResponse>>
      _signalDecisionReportPost(
          {@Body() required SignalDecisionReportRequest? body});

  ///Report a return for an ACH transaction
  Future<chopper.Response<SignalReturnReportResponse>> signalReturnReportPost(
      {required SignalReturnReportRequest? body}) {
    generatedMapping.putIfAbsent(SignalReturnReportResponse,
        () => SignalReturnReportResponse.fromJsonFactory);

    return _signalReturnReportPost(body: body);
  }

  ///Report a return for an ACH transaction
  @Post(
    path: '/signal/return/report',
    optionalBody: true,
  )
  Future<chopper.Response<SignalReturnReportResponse>> _signalReturnReportPost(
      {@Body() required SignalReturnReportRequest? body});

  ///Opt-in an Item to Signal
  Future<chopper.Response<SignalPrepareResponse>> signalPreparePost(
      {required SignalPrepareRequest? body}) {
    generatedMapping.putIfAbsent(
        SignalPrepareResponse, () => SignalPrepareResponse.fromJsonFactory);

    return _signalPreparePost(body: body);
  }

  ///Opt-in an Item to Signal
  @Post(
    path: '/signal/prepare',
    optionalBody: true,
  )
  Future<chopper.Response<SignalPrepareResponse>> _signalPreparePost(
      {@Body() required SignalPrepareRequest? body});

  ///Create an e-wallet
  Future<chopper.Response<WalletCreateResponse>> walletCreatePost(
      {required WalletCreateRequest? body}) {
    generatedMapping.putIfAbsent(
        WalletCreateResponse, () => WalletCreateResponse.fromJsonFactory);

    return _walletCreatePost(body: body);
  }

  ///Create an e-wallet
  @Post(
    path: '/wallet/create',
    optionalBody: true,
  )
  Future<chopper.Response<WalletCreateResponse>> _walletCreatePost(
      {@Body() required WalletCreateRequest? body});

  ///Fetch an e-wallet
  Future<chopper.Response<WalletGetResponse>> walletGetPost(
      {required WalletGetRequest? body}) {
    generatedMapping.putIfAbsent(
        WalletGetResponse, () => WalletGetResponse.fromJsonFactory);

    return _walletGetPost(body: body);
  }

  ///Fetch an e-wallet
  @Post(
    path: '/wallet/get',
    optionalBody: true,
  )
  Future<chopper.Response<WalletGetResponse>> _walletGetPost(
      {@Body() required WalletGetRequest? body});

  ///Fetch a list of e-wallets
  Future<chopper.Response<WalletListResponse>> walletListPost(
      {required WalletListRequest? body}) {
    generatedMapping.putIfAbsent(
        WalletListResponse, () => WalletListResponse.fromJsonFactory);

    return _walletListPost(body: body);
  }

  ///Fetch a list of e-wallets
  @Post(
    path: '/wallet/list',
    optionalBody: true,
  )
  Future<chopper.Response<WalletListResponse>> _walletListPost(
      {@Body() required WalletListRequest? body});

  ///Execute a transaction using an e-wallet
  Future<chopper.Response<WalletTransactionExecuteResponse>>
      walletTransactionExecutePost(
          {required WalletTransactionExecuteRequest? body}) {
    generatedMapping.putIfAbsent(WalletTransactionExecuteResponse,
        () => WalletTransactionExecuteResponse.fromJsonFactory);

    return _walletTransactionExecutePost(body: body);
  }

  ///Execute a transaction using an e-wallet
  @Post(
    path: '/wallet/transaction/execute',
    optionalBody: true,
  )
  Future<chopper.Response<WalletTransactionExecuteResponse>>
      _walletTransactionExecutePost(
          {@Body() required WalletTransactionExecuteRequest? body});

  ///Fetch an e-wallet transaction
  Future<chopper.Response<WalletTransactionGetResponse>>
      walletTransactionGetPost({required WalletTransactionGetRequest? body}) {
    generatedMapping.putIfAbsent(WalletTransactionGetResponse,
        () => WalletTransactionGetResponse.fromJsonFactory);

    return _walletTransactionGetPost(body: body);
  }

  ///Fetch an e-wallet transaction
  @Post(
    path: '/wallet/transaction/get',
    optionalBody: true,
  )
  Future<chopper.Response<WalletTransactionGetResponse>>
      _walletTransactionGetPost(
          {@Body() required WalletTransactionGetRequest? body});

  ///List e-wallet transactions
  Future<chopper.Response<WalletTransactionListResponse>>
      walletTransactionListPost({required WalletTransactionListRequest? body}) {
    generatedMapping.putIfAbsent(WalletTransactionListResponse,
        () => WalletTransactionListResponse.fromJsonFactory);

    return _walletTransactionListPost(body: body);
  }

  ///List e-wallet transactions
  @Post(
    path: '/wallet/transaction/list',
    optionalBody: true,
  )
  Future<chopper.Response<WalletTransactionListResponse>>
      _walletTransactionListPost(
          {@Body() required WalletTransactionListRequest? body});

  ///List e-wallet transactions
  Future<chopper.Response<WalletTransactionListResponse>>
      walletTransactionsListPost(
          {required WalletTransactionsListRequest? body}) {
    generatedMapping.putIfAbsent(WalletTransactionListResponse,
        () => WalletTransactionListResponse.fromJsonFactory);

    return _walletTransactionsListPost(body: body);
  }

  ///List e-wallet transactions
  @Post(
    path: '/wallet/transactions/list',
    optionalBody: true,
  )
  Future<chopper.Response<WalletTransactionListResponse>>
      _walletTransactionsListPost(
          {@Body() required WalletTransactionsListRequest? body});

  ///enhance locally-held transaction data
  Future<chopper.Response<TransactionsEnhanceGetResponse>>
      betaTransactionsV1EnhancePost(
          {required TransactionsEnhanceGetRequest? body}) {
    generatedMapping.putIfAbsent(TransactionsEnhanceGetResponse,
        () => TransactionsEnhanceGetResponse.fromJsonFactory);

    return _betaTransactionsV1EnhancePost(body: body);
  }

  ///enhance locally-held transaction data
  @Post(
    path: '/beta/transactions/v1/enhance',
    optionalBody: true,
  )
  Future<chopper.Response<TransactionsEnhanceGetResponse>>
      _betaTransactionsV1EnhancePost(
          {@Body() required TransactionsEnhanceGetRequest? body});

  ///Create transaction category rule
  Future<chopper.Response<TransactionsRulesCreateResponse>>
      betaTransactionsRulesV1CreatePost(
          {required TransactionsRulesCreateRequest? body}) {
    generatedMapping.putIfAbsent(TransactionsRulesCreateResponse,
        () => TransactionsRulesCreateResponse.fromJsonFactory);

    return _betaTransactionsRulesV1CreatePost(body: body);
  }

  ///Create transaction category rule
  @Post(
    path: '/beta/transactions/rules/v1/create',
    optionalBody: true,
  )
  Future<chopper.Response<TransactionsRulesCreateResponse>>
      _betaTransactionsRulesV1CreatePost(
          {@Body() required TransactionsRulesCreateRequest? body});

  ///Return a list of rules created for the Item associated with the access token.
  Future<chopper.Response<TransactionsRulesListResponse>>
      betaTransactionsRulesV1ListPost(
          {required TransactionsRulesListRequest? body}) {
    generatedMapping.putIfAbsent(TransactionsRulesListResponse,
        () => TransactionsRulesListResponse.fromJsonFactory);

    return _betaTransactionsRulesV1ListPost(body: body);
  }

  ///Return a list of rules created for the Item associated with the access token.
  @Post(
    path: '/beta/transactions/rules/v1/list',
    optionalBody: true,
  )
  Future<chopper.Response<TransactionsRulesListResponse>>
      _betaTransactionsRulesV1ListPost(
          {@Body() required TransactionsRulesListRequest? body});

  ///Remove transaction rule
  Future<chopper.Response<TransactionsRulesRemoveResponse>>
      betaTransactionsRulesV1RemovePost(
          {required TransactionsRulesRemoveRequest? body}) {
    generatedMapping.putIfAbsent(TransactionsRulesRemoveResponse,
        () => TransactionsRulesRemoveResponse.fromJsonFactory);

    return _betaTransactionsRulesV1RemovePost(body: body);
  }

  ///Remove transaction rule
  @Post(
    path: '/beta/transactions/rules/v1/remove',
    optionalBody: true,
  )
  Future<chopper.Response<TransactionsRulesRemoveResponse>>
      _betaTransactionsRulesV1RemovePost(
          {@Body() required TransactionsRulesRemoveRequest? body});

  ///Create payment profile
  Future<chopper.Response<PaymentProfileCreateResponse>>
      paymentProfileCreatePost({required PaymentProfileCreateRequest? body}) {
    generatedMapping.putIfAbsent(PaymentProfileCreateResponse,
        () => PaymentProfileCreateResponse.fromJsonFactory);

    return _paymentProfileCreatePost(body: body);
  }

  ///Create payment profile
  @Post(
    path: '/payment_profile/create',
    optionalBody: true,
  )
  Future<chopper.Response<PaymentProfileCreateResponse>>
      _paymentProfileCreatePost(
          {@Body() required PaymentProfileCreateRequest? body});

  ///Get payment profile
  Future<chopper.Response<PaymentProfileGetResponse>> paymentProfileGetPost(
      {required PaymentProfileGetRequest? body}) {
    generatedMapping.putIfAbsent(PaymentProfileGetResponse,
        () => PaymentProfileGetResponse.fromJsonFactory);

    return _paymentProfileGetPost(body: body);
  }

  ///Get payment profile
  @Post(
    path: '/payment_profile/get',
    optionalBody: true,
  )
  Future<chopper.Response<PaymentProfileGetResponse>> _paymentProfileGetPost(
      {@Body() required PaymentProfileGetRequest? body});

  ///Remove payment profile
  Future<chopper.Response<PaymentProfileRemoveResponse>>
      paymentProfileRemovePost({required PaymentProfileRemoveRequest? body}) {
    generatedMapping.putIfAbsent(PaymentProfileRemoveResponse,
        () => PaymentProfileRemoveResponse.fromJsonFactory);

    return _paymentProfileRemovePost(body: body);
  }

  ///Remove payment profile
  @Post(
    path: '/payment_profile/remove',
    optionalBody: true,
  )
  Future<chopper.Response<PaymentProfileRemoveResponse>>
      _paymentProfileRemovePost(
          {@Body() required PaymentProfileRemoveRequest? body});

  ///Creates a new end customer for a Plaid reseller.
  Future<chopper.Response<PartnerCustomerCreateResponse>>
      partnerCustomerCreatePost({required PartnerCustomerCreateRequest? body}) {
    generatedMapping.putIfAbsent(PartnerCustomerCreateResponse,
        () => PartnerCustomerCreateResponse.fromJsonFactory);

    return _partnerCustomerCreatePost(body: body);
  }

  ///Creates a new end customer for a Plaid reseller.
  @Post(
    path: '/partner/customer/create',
    optionalBody: true,
  )
  Future<chopper.Response<PartnerCustomerCreateResponse>>
      _partnerCustomerCreatePost(
          {@Body() required PartnerCustomerCreateRequest? body});

  ///Returns a Plaid reseller's end customer.
  Future<chopper.Response<PartnerCustomerGetResponse>> partnerCustomerGetPost(
      {required PartnerCustomerGetRequest? body}) {
    generatedMapping.putIfAbsent(PartnerCustomerGetResponse,
        () => PartnerCustomerGetResponse.fromJsonFactory);

    return _partnerCustomerGetPost(body: body);
  }

  ///Returns a Plaid reseller's end customer.
  @Post(
    path: '/partner/customer/get',
    optionalBody: true,
  )
  Future<chopper.Response<PartnerCustomerGetResponse>> _partnerCustomerGetPost(
      {@Body() required PartnerCustomerGetRequest? body});

  ///Enables a Plaid reseller's end customer in the Production environment.
  Future<chopper.Response<PartnerCustomerEnableResponse>>
      partnerCustomerEnablePost({required PartnerCustomerEnableRequest? body}) {
    generatedMapping.putIfAbsent(PartnerCustomerEnableResponse,
        () => PartnerCustomerEnableResponse.fromJsonFactory);

    return _partnerCustomerEnablePost(body: body);
  }

  ///Enables a Plaid reseller's end customer in the Production environment.
  @Post(
    path: '/partner/customer/enable',
    optionalBody: true,
  )
  Future<chopper.Response<PartnerCustomerEnableResponse>>
      _partnerCustomerEnablePost(
          {@Body() required PartnerCustomerEnableRequest? body});

  ///Removes a Plaid reseller's end customer.
  Future<chopper.Response<PartnerCustomerRemoveResponse>>
      partnerCustomerRemovePost({required PartnerCustomerRemoveRequest? body}) {
    generatedMapping.putIfAbsent(PartnerCustomerRemoveResponse,
        () => PartnerCustomerRemoveResponse.fromJsonFactory);

    return _partnerCustomerRemovePost(body: body);
  }

  ///Removes a Plaid reseller's end customer.
  @Post(
    path: '/partner/customer/remove',
    optionalBody: true,
  )
  Future<chopper.Response<PartnerCustomerRemoveResponse>>
      _partnerCustomerRemovePost(
          {@Body() required PartnerCustomerRemoveRequest? body});

  ///Create link delivery session
  Future<chopper.Response<LinkDeliveryCreateResponse>> linkDeliveryCreatePost(
      {required LinkDeliveryCreateRequest? body}) {
    generatedMapping.putIfAbsent(LinkDeliveryCreateResponse,
        () => LinkDeliveryCreateResponse.fromJsonFactory);

    return _linkDeliveryCreatePost(body: body);
  }

  ///Create link delivery session
  @Post(
    path: '/link_delivery/create',
    optionalBody: true,
  )
  Future<chopper.Response<LinkDeliveryCreateResponse>> _linkDeliveryCreatePost(
      {@Body() required LinkDeliveryCreateRequest? body});

  ///Get link delivery session
  Future<chopper.Response<LinkDeliveryGetResponse>> linkDeliveryGetPost(
      {required LinkDeliveryGetRequest? body}) {
    generatedMapping.putIfAbsent(
        LinkDeliveryGetResponse, () => LinkDeliveryGetResponse.fromJsonFactory);

    return _linkDeliveryGetPost(body: body);
  }

  ///Get link delivery session
  @Post(
    path: '/link_delivery/get',
    optionalBody: true,
  )
  Future<chopper.Response<LinkDeliveryGetResponse>> _linkDeliveryGetPost(
      {@Body() required LinkDeliveryGetRequest? body});

  ///Webhook receiver for fdx notifications
  Future<chopper.Response> fdxNotificationsPost(
      {required FDXNotification? body}) {
    return _fdxNotificationsPost(body: body);
  }

  ///Webhook receiver for fdx notifications
  @Post(
    path: '/fdx/notifications',
    optionalBody: true,
  )
  Future<chopper.Response> _fdxNotificationsPost(
      {@Body() required FDXNotification? body});
}

@JsonSerializable(explicitToJson: true)
class AuthGetRequest {
  AuthGetRequest({
    this.clientId,
    this.secret,
    required this.accessToken,
    this.options,
  });

  factory AuthGetRequest.fromJson(Map<String, dynamic> json) =>
      _$AuthGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'access_token')
  final String accessToken;
  @JsonKey(name: 'options')
  final AuthGetRequestOptions? options;
  static const fromJsonFactory = _$AuthGetRequestFromJson;
  static const toJsonFactory = _$AuthGetRequestToJson;
  Map<String, dynamic> toJson() => _$AuthGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AuthGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)) &&
            (identical(other.options, options) ||
                const DeepCollectionEquality().equals(other.options, options)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(accessToken) ^
      const DeepCollectionEquality().hash(options) ^
      runtimeType.hashCode;
}

extension $AuthGetRequestExtension on AuthGetRequest {
  AuthGetRequest copyWith(
      {String? clientId,
      String? secret,
      String? accessToken,
      AuthGetRequestOptions? options}) {
    return AuthGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        accessToken: accessToken ?? this.accessToken,
        options: options ?? this.options);
  }

  AuthGetRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? accessToken,
      Wrapped<AuthGetRequestOptions?>? options}) {
    return AuthGetRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        accessToken:
            (accessToken != null ? accessToken.value : this.accessToken),
        options: (options != null ? options.value : this.options));
  }
}

@JsonSerializable(explicitToJson: true)
class AuthGetRequestOptions {
  AuthGetRequestOptions({
    this.accountIds,
  });

  factory AuthGetRequestOptions.fromJson(Map<String, dynamic> json) =>
      _$AuthGetRequestOptionsFromJson(json);

  @JsonKey(name: 'account_ids', defaultValue: <String>[])
  final List<String>? accountIds;
  static const fromJsonFactory = _$AuthGetRequestOptionsFromJson;
  static const toJsonFactory = _$AuthGetRequestOptionsToJson;
  Map<String, dynamic> toJson() => _$AuthGetRequestOptionsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AuthGetRequestOptions &&
            (identical(other.accountIds, accountIds) ||
                const DeepCollectionEquality()
                    .equals(other.accountIds, accountIds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountIds) ^ runtimeType.hashCode;
}

extension $AuthGetRequestOptionsExtension on AuthGetRequestOptions {
  AuthGetRequestOptions copyWith({List<String>? accountIds}) {
    return AuthGetRequestOptions(accountIds: accountIds ?? this.accountIds);
  }

  AuthGetRequestOptions copyWithWrapped({Wrapped<List<String>?>? accountIds}) {
    return AuthGetRequestOptions(
        accountIds: (accountIds != null ? accountIds.value : this.accountIds));
  }
}

@JsonSerializable(explicitToJson: true)
class AuthGetResponse {
  AuthGetResponse({
    required this.accounts,
    required this.numbers,
    required this.item,
    required this.requestId,
  });

  factory AuthGetResponse.fromJson(Map<String, dynamic> json) =>
      _$AuthGetResponseFromJson(json);

  @JsonKey(name: 'accounts', defaultValue: <AccountBase>[])
  final List<AccountBase> accounts;
  @JsonKey(name: 'numbers')
  final AuthGetNumbers numbers;
  @JsonKey(name: 'item')
  final Item item;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$AuthGetResponseFromJson;
  static const toJsonFactory = _$AuthGetResponseToJson;
  Map<String, dynamic> toJson() => _$AuthGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AuthGetResponse &&
            (identical(other.accounts, accounts) ||
                const DeepCollectionEquality()
                    .equals(other.accounts, accounts)) &&
            (identical(other.numbers, numbers) ||
                const DeepCollectionEquality()
                    .equals(other.numbers, numbers)) &&
            (identical(other.item, item) ||
                const DeepCollectionEquality().equals(other.item, item)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accounts) ^
      const DeepCollectionEquality().hash(numbers) ^
      const DeepCollectionEquality().hash(item) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $AuthGetResponseExtension on AuthGetResponse {
  AuthGetResponse copyWith(
      {List<AccountBase>? accounts,
      AuthGetNumbers? numbers,
      Item? item,
      String? requestId}) {
    return AuthGetResponse(
        accounts: accounts ?? this.accounts,
        numbers: numbers ?? this.numbers,
        item: item ?? this.item,
        requestId: requestId ?? this.requestId);
  }

  AuthGetResponse copyWithWrapped(
      {Wrapped<List<AccountBase>>? accounts,
      Wrapped<AuthGetNumbers>? numbers,
      Wrapped<Item>? item,
      Wrapped<String>? requestId}) {
    return AuthGetResponse(
        accounts: (accounts != null ? accounts.value : this.accounts),
        numbers: (numbers != null ? numbers.value : this.numbers),
        item: (item != null ? item.value : this.item),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class AuthGetNumbers {
  AuthGetNumbers({
    required this.ach,
    required this.eft,
    required this.international,
    required this.bacs,
  });

  factory AuthGetNumbers.fromJson(Map<String, dynamic> json) =>
      _$AuthGetNumbersFromJson(json);

  @JsonKey(name: 'ach', defaultValue: <NumbersACH>[])
  final List<NumbersACH> ach;
  @JsonKey(name: 'eft', defaultValue: <NumbersEFT>[])
  final List<NumbersEFT> eft;
  @JsonKey(name: 'international', defaultValue: <NumbersInternational>[])
  final List<NumbersInternational> international;
  @JsonKey(name: 'bacs', defaultValue: <NumbersBACS>[])
  final List<NumbersBACS> bacs;
  static const fromJsonFactory = _$AuthGetNumbersFromJson;
  static const toJsonFactory = _$AuthGetNumbersToJson;
  Map<String, dynamic> toJson() => _$AuthGetNumbersToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AuthGetNumbers &&
            (identical(other.ach, ach) ||
                const DeepCollectionEquality().equals(other.ach, ach)) &&
            (identical(other.eft, eft) ||
                const DeepCollectionEquality().equals(other.eft, eft)) &&
            (identical(other.international, international) ||
                const DeepCollectionEquality()
                    .equals(other.international, international)) &&
            (identical(other.bacs, bacs) ||
                const DeepCollectionEquality().equals(other.bacs, bacs)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ach) ^
      const DeepCollectionEquality().hash(eft) ^
      const DeepCollectionEquality().hash(international) ^
      const DeepCollectionEquality().hash(bacs) ^
      runtimeType.hashCode;
}

extension $AuthGetNumbersExtension on AuthGetNumbers {
  AuthGetNumbers copyWith(
      {List<NumbersACH>? ach,
      List<NumbersEFT>? eft,
      List<NumbersInternational>? international,
      List<NumbersBACS>? bacs}) {
    return AuthGetNumbers(
        ach: ach ?? this.ach,
        eft: eft ?? this.eft,
        international: international ?? this.international,
        bacs: bacs ?? this.bacs);
  }

  AuthGetNumbers copyWithWrapped(
      {Wrapped<List<NumbersACH>>? ach,
      Wrapped<List<NumbersEFT>>? eft,
      Wrapped<List<NumbersInternational>>? international,
      Wrapped<List<NumbersBACS>>? bacs}) {
    return AuthGetNumbers(
        ach: (ach != null ? ach.value : this.ach),
        eft: (eft != null ? eft.value : this.eft),
        international:
            (international != null ? international.value : this.international),
        bacs: (bacs != null ? bacs.value : this.bacs));
  }
}

@JsonSerializable(explicitToJson: true)
class TransactionsGetRequest {
  TransactionsGetRequest({
    this.clientId,
    this.options,
    required this.accessToken,
    this.secret,
    required this.startDate,
    required this.endDate,
  });

  factory TransactionsGetRequest.fromJson(Map<String, dynamic> json) =>
      _$TransactionsGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'options')
  final TransactionsGetRequestOptions? options;
  @JsonKey(name: 'access_token')
  final String accessToken;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'start_date', toJson: _dateToJson)
  final DateTime startDate;
  @JsonKey(name: 'end_date', toJson: _dateToJson)
  final DateTime endDate;
  static const fromJsonFactory = _$TransactionsGetRequestFromJson;
  static const toJsonFactory = _$TransactionsGetRequestToJson;
  Map<String, dynamic> toJson() => _$TransactionsGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransactionsGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.options, options) ||
                const DeepCollectionEquality()
                    .equals(other.options, options)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.startDate, startDate) ||
                const DeepCollectionEquality()
                    .equals(other.startDate, startDate)) &&
            (identical(other.endDate, endDate) ||
                const DeepCollectionEquality().equals(other.endDate, endDate)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(options) ^
      const DeepCollectionEquality().hash(accessToken) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(startDate) ^
      const DeepCollectionEquality().hash(endDate) ^
      runtimeType.hashCode;
}

extension $TransactionsGetRequestExtension on TransactionsGetRequest {
  TransactionsGetRequest copyWith(
      {String? clientId,
      TransactionsGetRequestOptions? options,
      String? accessToken,
      String? secret,
      DateTime? startDate,
      DateTime? endDate}) {
    return TransactionsGetRequest(
        clientId: clientId ?? this.clientId,
        options: options ?? this.options,
        accessToken: accessToken ?? this.accessToken,
        secret: secret ?? this.secret,
        startDate: startDate ?? this.startDate,
        endDate: endDate ?? this.endDate);
  }

  TransactionsGetRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<TransactionsGetRequestOptions?>? options,
      Wrapped<String>? accessToken,
      Wrapped<String?>? secret,
      Wrapped<DateTime>? startDate,
      Wrapped<DateTime>? endDate}) {
    return TransactionsGetRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        options: (options != null ? options.value : this.options),
        accessToken:
            (accessToken != null ? accessToken.value : this.accessToken),
        secret: (secret != null ? secret.value : this.secret),
        startDate: (startDate != null ? startDate.value : this.startDate),
        endDate: (endDate != null ? endDate.value : this.endDate));
  }
}

@JsonSerializable(explicitToJson: true)
class TransactionsGetRequestOptions {
  TransactionsGetRequestOptions({
    this.accountIds,
    this.count,
    this.offset,
    this.includeOriginalDescription,
    this.includePersonalFinanceCategoryBeta,
    this.includePersonalFinanceCategory,
  });

  factory TransactionsGetRequestOptions.fromJson(Map<String, dynamic> json) =>
      _$TransactionsGetRequestOptionsFromJson(json);

  @JsonKey(name: 'account_ids', defaultValue: <String>[])
  final List<String>? accountIds;
  @JsonKey(name: 'count')
  final int? count;
  @JsonKey(name: 'offset')
  final int? offset;
  @JsonKey(name: 'include_original_description', defaultValue: false)
  final bool? includeOriginalDescription;
  @JsonKey(name: 'include_personal_finance_category_beta', defaultValue: false)
  final bool? includePersonalFinanceCategoryBeta;
  @JsonKey(name: 'include_personal_finance_category', defaultValue: false)
  final bool? includePersonalFinanceCategory;
  static const fromJsonFactory = _$TransactionsGetRequestOptionsFromJson;
  static const toJsonFactory = _$TransactionsGetRequestOptionsToJson;
  Map<String, dynamic> toJson() => _$TransactionsGetRequestOptionsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransactionsGetRequestOptions &&
            (identical(other.accountIds, accountIds) ||
                const DeepCollectionEquality()
                    .equals(other.accountIds, accountIds)) &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)) &&
            (identical(other.offset, offset) ||
                const DeepCollectionEquality().equals(other.offset, offset)) &&
            (identical(other.includeOriginalDescription,
                    includeOriginalDescription) ||
                const DeepCollectionEquality().equals(
                    other.includeOriginalDescription,
                    includeOriginalDescription)) &&
            (identical(other.includePersonalFinanceCategoryBeta,
                    includePersonalFinanceCategoryBeta) ||
                const DeepCollectionEquality().equals(
                    other.includePersonalFinanceCategoryBeta,
                    includePersonalFinanceCategoryBeta)) &&
            (identical(other.includePersonalFinanceCategory,
                    includePersonalFinanceCategory) ||
                const DeepCollectionEquality().equals(
                    other.includePersonalFinanceCategory,
                    includePersonalFinanceCategory)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountIds) ^
      const DeepCollectionEquality().hash(count) ^
      const DeepCollectionEquality().hash(offset) ^
      const DeepCollectionEquality().hash(includeOriginalDescription) ^
      const DeepCollectionEquality().hash(includePersonalFinanceCategoryBeta) ^
      const DeepCollectionEquality().hash(includePersonalFinanceCategory) ^
      runtimeType.hashCode;
}

extension $TransactionsGetRequestOptionsExtension
    on TransactionsGetRequestOptions {
  TransactionsGetRequestOptions copyWith(
      {List<String>? accountIds,
      int? count,
      int? offset,
      bool? includeOriginalDescription,
      bool? includePersonalFinanceCategoryBeta,
      bool? includePersonalFinanceCategory}) {
    return TransactionsGetRequestOptions(
        accountIds: accountIds ?? this.accountIds,
        count: count ?? this.count,
        offset: offset ?? this.offset,
        includeOriginalDescription:
            includeOriginalDescription ?? this.includeOriginalDescription,
        includePersonalFinanceCategoryBeta:
            includePersonalFinanceCategoryBeta ??
                this.includePersonalFinanceCategoryBeta,
        includePersonalFinanceCategory: includePersonalFinanceCategory ??
            this.includePersonalFinanceCategory);
  }

  TransactionsGetRequestOptions copyWithWrapped(
      {Wrapped<List<String>?>? accountIds,
      Wrapped<int?>? count,
      Wrapped<int?>? offset,
      Wrapped<bool?>? includeOriginalDescription,
      Wrapped<bool?>? includePersonalFinanceCategoryBeta,
      Wrapped<bool?>? includePersonalFinanceCategory}) {
    return TransactionsGetRequestOptions(
        accountIds: (accountIds != null ? accountIds.value : this.accountIds),
        count: (count != null ? count.value : this.count),
        offset: (offset != null ? offset.value : this.offset),
        includeOriginalDescription: (includeOriginalDescription != null
            ? includeOriginalDescription.value
            : this.includeOriginalDescription),
        includePersonalFinanceCategoryBeta:
            (includePersonalFinanceCategoryBeta != null
                ? includePersonalFinanceCategoryBeta.value
                : this.includePersonalFinanceCategoryBeta),
        includePersonalFinanceCategory: (includePersonalFinanceCategory != null
            ? includePersonalFinanceCategory.value
            : this.includePersonalFinanceCategory));
  }
}

@JsonSerializable(explicitToJson: true)
class TransactionsGetResponse {
  TransactionsGetResponse({
    required this.accounts,
    required this.transactions,
    required this.totalTransactions,
    required this.item,
    required this.requestId,
  });

  factory TransactionsGetResponse.fromJson(Map<String, dynamic> json) =>
      _$TransactionsGetResponseFromJson(json);

  @JsonKey(name: 'accounts', defaultValue: <AccountBase>[])
  final List<AccountBase> accounts;
  @JsonKey(name: 'transactions', defaultValue: <Transaction>[])
  final List<Transaction> transactions;
  @JsonKey(name: 'total_transactions')
  final int totalTransactions;
  @JsonKey(name: 'item')
  final Item item;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$TransactionsGetResponseFromJson;
  static const toJsonFactory = _$TransactionsGetResponseToJson;
  Map<String, dynamic> toJson() => _$TransactionsGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransactionsGetResponse &&
            (identical(other.accounts, accounts) ||
                const DeepCollectionEquality()
                    .equals(other.accounts, accounts)) &&
            (identical(other.transactions, transactions) ||
                const DeepCollectionEquality()
                    .equals(other.transactions, transactions)) &&
            (identical(other.totalTransactions, totalTransactions) ||
                const DeepCollectionEquality()
                    .equals(other.totalTransactions, totalTransactions)) &&
            (identical(other.item, item) ||
                const DeepCollectionEquality().equals(other.item, item)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accounts) ^
      const DeepCollectionEquality().hash(transactions) ^
      const DeepCollectionEquality().hash(totalTransactions) ^
      const DeepCollectionEquality().hash(item) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $TransactionsGetResponseExtension on TransactionsGetResponse {
  TransactionsGetResponse copyWith(
      {List<AccountBase>? accounts,
      List<Transaction>? transactions,
      int? totalTransactions,
      Item? item,
      String? requestId}) {
    return TransactionsGetResponse(
        accounts: accounts ?? this.accounts,
        transactions: transactions ?? this.transactions,
        totalTransactions: totalTransactions ?? this.totalTransactions,
        item: item ?? this.item,
        requestId: requestId ?? this.requestId);
  }

  TransactionsGetResponse copyWithWrapped(
      {Wrapped<List<AccountBase>>? accounts,
      Wrapped<List<Transaction>>? transactions,
      Wrapped<int>? totalTransactions,
      Wrapped<Item>? item,
      Wrapped<String>? requestId}) {
    return TransactionsGetResponse(
        accounts: (accounts != null ? accounts.value : this.accounts),
        transactions:
            (transactions != null ? transactions.value : this.transactions),
        totalTransactions: (totalTransactions != null
            ? totalTransactions.value
            : this.totalTransactions),
        item: (item != null ? item.value : this.item),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class TransactionsRefreshRequest {
  TransactionsRefreshRequest({
    this.clientId,
    required this.accessToken,
    this.secret,
  });

  factory TransactionsRefreshRequest.fromJson(Map<String, dynamic> json) =>
      _$TransactionsRefreshRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'access_token')
  final String accessToken;
  @JsonKey(name: 'secret')
  final String? secret;
  static const fromJsonFactory = _$TransactionsRefreshRequestFromJson;
  static const toJsonFactory = _$TransactionsRefreshRequestToJson;
  Map<String, dynamic> toJson() => _$TransactionsRefreshRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransactionsRefreshRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(accessToken) ^
      const DeepCollectionEquality().hash(secret) ^
      runtimeType.hashCode;
}

extension $TransactionsRefreshRequestExtension on TransactionsRefreshRequest {
  TransactionsRefreshRequest copyWith(
      {String? clientId, String? accessToken, String? secret}) {
    return TransactionsRefreshRequest(
        clientId: clientId ?? this.clientId,
        accessToken: accessToken ?? this.accessToken,
        secret: secret ?? this.secret);
  }

  TransactionsRefreshRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String>? accessToken,
      Wrapped<String?>? secret}) {
    return TransactionsRefreshRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        accessToken:
            (accessToken != null ? accessToken.value : this.accessToken),
        secret: (secret != null ? secret.value : this.secret));
  }
}

@JsonSerializable(explicitToJson: true)
class TransactionsRefreshResponse {
  TransactionsRefreshResponse({
    required this.requestId,
  });

  factory TransactionsRefreshResponse.fromJson(Map<String, dynamic> json) =>
      _$TransactionsRefreshResponseFromJson(json);

  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$TransactionsRefreshResponseFromJson;
  static const toJsonFactory = _$TransactionsRefreshResponseToJson;
  Map<String, dynamic> toJson() => _$TransactionsRefreshResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransactionsRefreshResponse &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(requestId) ^ runtimeType.hashCode;
}

extension $TransactionsRefreshResponseExtension on TransactionsRefreshResponse {
  TransactionsRefreshResponse copyWith({String? requestId}) {
    return TransactionsRefreshResponse(requestId: requestId ?? this.requestId);
  }

  TransactionsRefreshResponse copyWithWrapped({Wrapped<String>? requestId}) {
    return TransactionsRefreshResponse(
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class TransactionsRecurringGetRequest {
  TransactionsRecurringGetRequest({
    this.clientId,
    required this.accessToken,
    this.secret,
    this.options,
    required this.accountIds,
  });

  factory TransactionsRecurringGetRequest.fromJson(Map<String, dynamic> json) =>
      _$TransactionsRecurringGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'access_token')
  final String accessToken;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'options')
  final TransactionsRecurringGetRequestOptions? options;
  @JsonKey(name: 'account_ids', defaultValue: <String>[])
  final List<String> accountIds;
  static const fromJsonFactory = _$TransactionsRecurringGetRequestFromJson;
  static const toJsonFactory = _$TransactionsRecurringGetRequestToJson;
  Map<String, dynamic> toJson() =>
      _$TransactionsRecurringGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransactionsRecurringGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.options, options) ||
                const DeepCollectionEquality()
                    .equals(other.options, options)) &&
            (identical(other.accountIds, accountIds) ||
                const DeepCollectionEquality()
                    .equals(other.accountIds, accountIds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(accessToken) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(options) ^
      const DeepCollectionEquality().hash(accountIds) ^
      runtimeType.hashCode;
}

extension $TransactionsRecurringGetRequestExtension
    on TransactionsRecurringGetRequest {
  TransactionsRecurringGetRequest copyWith(
      {String? clientId,
      String? accessToken,
      String? secret,
      TransactionsRecurringGetRequestOptions? options,
      List<String>? accountIds}) {
    return TransactionsRecurringGetRequest(
        clientId: clientId ?? this.clientId,
        accessToken: accessToken ?? this.accessToken,
        secret: secret ?? this.secret,
        options: options ?? this.options,
        accountIds: accountIds ?? this.accountIds);
  }

  TransactionsRecurringGetRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String>? accessToken,
      Wrapped<String?>? secret,
      Wrapped<TransactionsRecurringGetRequestOptions?>? options,
      Wrapped<List<String>>? accountIds}) {
    return TransactionsRecurringGetRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        accessToken:
            (accessToken != null ? accessToken.value : this.accessToken),
        secret: (secret != null ? secret.value : this.secret),
        options: (options != null ? options.value : this.options),
        accountIds: (accountIds != null ? accountIds.value : this.accountIds));
  }
}

@JsonSerializable(explicitToJson: true)
class TransactionsRecurringGetRequestOptions {
  TransactionsRecurringGetRequestOptions({
    this.includePersonalFinanceCategory,
  });

  factory TransactionsRecurringGetRequestOptions.fromJson(
          Map<String, dynamic> json) =>
      _$TransactionsRecurringGetRequestOptionsFromJson(json);

  @JsonKey(name: 'include_personal_finance_category', defaultValue: false)
  final bool? includePersonalFinanceCategory;
  static const fromJsonFactory =
      _$TransactionsRecurringGetRequestOptionsFromJson;
  static const toJsonFactory = _$TransactionsRecurringGetRequestOptionsToJson;
  Map<String, dynamic> toJson() =>
      _$TransactionsRecurringGetRequestOptionsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransactionsRecurringGetRequestOptions &&
            (identical(other.includePersonalFinanceCategory,
                    includePersonalFinanceCategory) ||
                const DeepCollectionEquality().equals(
                    other.includePersonalFinanceCategory,
                    includePersonalFinanceCategory)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(includePersonalFinanceCategory) ^
      runtimeType.hashCode;
}

extension $TransactionsRecurringGetRequestOptionsExtension
    on TransactionsRecurringGetRequestOptions {
  TransactionsRecurringGetRequestOptions copyWith(
      {bool? includePersonalFinanceCategory}) {
    return TransactionsRecurringGetRequestOptions(
        includePersonalFinanceCategory: includePersonalFinanceCategory ??
            this.includePersonalFinanceCategory);
  }

  TransactionsRecurringGetRequestOptions copyWithWrapped(
      {Wrapped<bool?>? includePersonalFinanceCategory}) {
    return TransactionsRecurringGetRequestOptions(
        includePersonalFinanceCategory: (includePersonalFinanceCategory != null
            ? includePersonalFinanceCategory.value
            : this.includePersonalFinanceCategory));
  }
}

@JsonSerializable(explicitToJson: true)
class TransactionsRecurringGetResponse {
  TransactionsRecurringGetResponse({
    required this.inflowStreams,
    required this.outflowStreams,
    required this.updatedDatetime,
    required this.requestId,
  });

  factory TransactionsRecurringGetResponse.fromJson(
          Map<String, dynamic> json) =>
      _$TransactionsRecurringGetResponseFromJson(json);

  @JsonKey(name: 'inflow_streams', defaultValue: <TransactionStream>[])
  final List<TransactionStream> inflowStreams;
  @JsonKey(name: 'outflow_streams', defaultValue: <TransactionStream>[])
  final List<TransactionStream> outflowStreams;
  @JsonKey(name: 'updated_datetime')
  final DateTime updatedDatetime;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$TransactionsRecurringGetResponseFromJson;
  static const toJsonFactory = _$TransactionsRecurringGetResponseToJson;
  Map<String, dynamic> toJson() =>
      _$TransactionsRecurringGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransactionsRecurringGetResponse &&
            (identical(other.inflowStreams, inflowStreams) ||
                const DeepCollectionEquality()
                    .equals(other.inflowStreams, inflowStreams)) &&
            (identical(other.outflowStreams, outflowStreams) ||
                const DeepCollectionEquality()
                    .equals(other.outflowStreams, outflowStreams)) &&
            (identical(other.updatedDatetime, updatedDatetime) ||
                const DeepCollectionEquality()
                    .equals(other.updatedDatetime, updatedDatetime)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(inflowStreams) ^
      const DeepCollectionEquality().hash(outflowStreams) ^
      const DeepCollectionEquality().hash(updatedDatetime) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $TransactionsRecurringGetResponseExtension
    on TransactionsRecurringGetResponse {
  TransactionsRecurringGetResponse copyWith(
      {List<TransactionStream>? inflowStreams,
      List<TransactionStream>? outflowStreams,
      DateTime? updatedDatetime,
      String? requestId}) {
    return TransactionsRecurringGetResponse(
        inflowStreams: inflowStreams ?? this.inflowStreams,
        outflowStreams: outflowStreams ?? this.outflowStreams,
        updatedDatetime: updatedDatetime ?? this.updatedDatetime,
        requestId: requestId ?? this.requestId);
  }

  TransactionsRecurringGetResponse copyWithWrapped(
      {Wrapped<List<TransactionStream>>? inflowStreams,
      Wrapped<List<TransactionStream>>? outflowStreams,
      Wrapped<DateTime>? updatedDatetime,
      Wrapped<String>? requestId}) {
    return TransactionsRecurringGetResponse(
        inflowStreams:
            (inflowStreams != null ? inflowStreams.value : this.inflowStreams),
        outflowStreams: (outflowStreams != null
            ? outflowStreams.value
            : this.outflowStreams),
        updatedDatetime: (updatedDatetime != null
            ? updatedDatetime.value
            : this.updatedDatetime),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class TransactionsRulesCreateRequest {
  TransactionsRulesCreateRequest({
    this.clientId,
    required this.accessToken,
    this.secret,
    required this.personalFinanceCategory,
    required this.ruleDetails,
  });

  factory TransactionsRulesCreateRequest.fromJson(Map<String, dynamic> json) =>
      _$TransactionsRulesCreateRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'access_token')
  final String accessToken;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'personal_finance_category')
  final String personalFinanceCategory;
  @JsonKey(name: 'rule_details')
  final TransactionsRuleDetails ruleDetails;
  static const fromJsonFactory = _$TransactionsRulesCreateRequestFromJson;
  static const toJsonFactory = _$TransactionsRulesCreateRequestToJson;
  Map<String, dynamic> toJson() => _$TransactionsRulesCreateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransactionsRulesCreateRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(
                    other.personalFinanceCategory, personalFinanceCategory) ||
                const DeepCollectionEquality().equals(
                    other.personalFinanceCategory, personalFinanceCategory)) &&
            (identical(other.ruleDetails, ruleDetails) ||
                const DeepCollectionEquality()
                    .equals(other.ruleDetails, ruleDetails)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(accessToken) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(personalFinanceCategory) ^
      const DeepCollectionEquality().hash(ruleDetails) ^
      runtimeType.hashCode;
}

extension $TransactionsRulesCreateRequestExtension
    on TransactionsRulesCreateRequest {
  TransactionsRulesCreateRequest copyWith(
      {String? clientId,
      String? accessToken,
      String? secret,
      String? personalFinanceCategory,
      TransactionsRuleDetails? ruleDetails}) {
    return TransactionsRulesCreateRequest(
        clientId: clientId ?? this.clientId,
        accessToken: accessToken ?? this.accessToken,
        secret: secret ?? this.secret,
        personalFinanceCategory:
            personalFinanceCategory ?? this.personalFinanceCategory,
        ruleDetails: ruleDetails ?? this.ruleDetails);
  }

  TransactionsRulesCreateRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String>? accessToken,
      Wrapped<String?>? secret,
      Wrapped<String>? personalFinanceCategory,
      Wrapped<TransactionsRuleDetails>? ruleDetails}) {
    return TransactionsRulesCreateRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        accessToken:
            (accessToken != null ? accessToken.value : this.accessToken),
        secret: (secret != null ? secret.value : this.secret),
        personalFinanceCategory: (personalFinanceCategory != null
            ? personalFinanceCategory.value
            : this.personalFinanceCategory),
        ruleDetails:
            (ruleDetails != null ? ruleDetails.value : this.ruleDetails));
  }
}

@JsonSerializable(explicitToJson: true)
class TransactionsRulesCreateResponse {
  TransactionsRulesCreateResponse({
    required this.rule,
    required this.requestId,
  });

  factory TransactionsRulesCreateResponse.fromJson(Map<String, dynamic> json) =>
      _$TransactionsRulesCreateResponseFromJson(json);

  @JsonKey(name: 'rule')
  final TransactionsCategoryRule rule;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$TransactionsRulesCreateResponseFromJson;
  static const toJsonFactory = _$TransactionsRulesCreateResponseToJson;
  Map<String, dynamic> toJson() =>
      _$TransactionsRulesCreateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransactionsRulesCreateResponse &&
            (identical(other.rule, rule) ||
                const DeepCollectionEquality().equals(other.rule, rule)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(rule) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $TransactionsRulesCreateResponseExtension
    on TransactionsRulesCreateResponse {
  TransactionsRulesCreateResponse copyWith(
      {TransactionsCategoryRule? rule, String? requestId}) {
    return TransactionsRulesCreateResponse(
        rule: rule ?? this.rule, requestId: requestId ?? this.requestId);
  }

  TransactionsRulesCreateResponse copyWithWrapped(
      {Wrapped<TransactionsCategoryRule>? rule, Wrapped<String>? requestId}) {
    return TransactionsRulesCreateResponse(
        rule: (rule != null ? rule.value : this.rule),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class TransactionsRulesListRequest {
  TransactionsRulesListRequest({
    this.clientId,
    required this.accessToken,
    this.secret,
  });

  factory TransactionsRulesListRequest.fromJson(Map<String, dynamic> json) =>
      _$TransactionsRulesListRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'access_token')
  final String accessToken;
  @JsonKey(name: 'secret')
  final String? secret;
  static const fromJsonFactory = _$TransactionsRulesListRequestFromJson;
  static const toJsonFactory = _$TransactionsRulesListRequestToJson;
  Map<String, dynamic> toJson() => _$TransactionsRulesListRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransactionsRulesListRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(accessToken) ^
      const DeepCollectionEquality().hash(secret) ^
      runtimeType.hashCode;
}

extension $TransactionsRulesListRequestExtension
    on TransactionsRulesListRequest {
  TransactionsRulesListRequest copyWith(
      {String? clientId, String? accessToken, String? secret}) {
    return TransactionsRulesListRequest(
        clientId: clientId ?? this.clientId,
        accessToken: accessToken ?? this.accessToken,
        secret: secret ?? this.secret);
  }

  TransactionsRulesListRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String>? accessToken,
      Wrapped<String?>? secret}) {
    return TransactionsRulesListRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        accessToken:
            (accessToken != null ? accessToken.value : this.accessToken),
        secret: (secret != null ? secret.value : this.secret));
  }
}

@JsonSerializable(explicitToJson: true)
class TransactionsRulesListResponse {
  TransactionsRulesListResponse({
    required this.rules,
    required this.requestId,
  });

  factory TransactionsRulesListResponse.fromJson(Map<String, dynamic> json) =>
      _$TransactionsRulesListResponseFromJson(json);

  @JsonKey(name: 'rules', defaultValue: <TransactionsCategoryRule>[])
  final List<TransactionsCategoryRule> rules;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$TransactionsRulesListResponseFromJson;
  static const toJsonFactory = _$TransactionsRulesListResponseToJson;
  Map<String, dynamic> toJson() => _$TransactionsRulesListResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransactionsRulesListResponse &&
            (identical(other.rules, rules) ||
                const DeepCollectionEquality().equals(other.rules, rules)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(rules) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $TransactionsRulesListResponseExtension
    on TransactionsRulesListResponse {
  TransactionsRulesListResponse copyWith(
      {List<TransactionsCategoryRule>? rules, String? requestId}) {
    return TransactionsRulesListResponse(
        rules: rules ?? this.rules, requestId: requestId ?? this.requestId);
  }

  TransactionsRulesListResponse copyWithWrapped(
      {Wrapped<List<TransactionsCategoryRule>>? rules,
      Wrapped<String>? requestId}) {
    return TransactionsRulesListResponse(
        rules: (rules != null ? rules.value : this.rules),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class TransactionsRulesRemoveRequest {
  TransactionsRulesRemoveRequest({
    this.clientId,
    required this.accessToken,
    this.secret,
    required this.ruleId,
  });

  factory TransactionsRulesRemoveRequest.fromJson(Map<String, dynamic> json) =>
      _$TransactionsRulesRemoveRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'access_token')
  final String accessToken;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'rule_id')
  final String ruleId;
  static const fromJsonFactory = _$TransactionsRulesRemoveRequestFromJson;
  static const toJsonFactory = _$TransactionsRulesRemoveRequestToJson;
  Map<String, dynamic> toJson() => _$TransactionsRulesRemoveRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransactionsRulesRemoveRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.ruleId, ruleId) ||
                const DeepCollectionEquality().equals(other.ruleId, ruleId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(accessToken) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(ruleId) ^
      runtimeType.hashCode;
}

extension $TransactionsRulesRemoveRequestExtension
    on TransactionsRulesRemoveRequest {
  TransactionsRulesRemoveRequest copyWith(
      {String? clientId, String? accessToken, String? secret, String? ruleId}) {
    return TransactionsRulesRemoveRequest(
        clientId: clientId ?? this.clientId,
        accessToken: accessToken ?? this.accessToken,
        secret: secret ?? this.secret,
        ruleId: ruleId ?? this.ruleId);
  }

  TransactionsRulesRemoveRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String>? accessToken,
      Wrapped<String?>? secret,
      Wrapped<String>? ruleId}) {
    return TransactionsRulesRemoveRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        accessToken:
            (accessToken != null ? accessToken.value : this.accessToken),
        secret: (secret != null ? secret.value : this.secret),
        ruleId: (ruleId != null ? ruleId.value : this.ruleId));
  }
}

@JsonSerializable(explicitToJson: true)
class TransactionsRulesRemoveResponse {
  TransactionsRulesRemoveResponse({
    required this.requestId,
  });

  factory TransactionsRulesRemoveResponse.fromJson(Map<String, dynamic> json) =>
      _$TransactionsRulesRemoveResponseFromJson(json);

  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$TransactionsRulesRemoveResponseFromJson;
  static const toJsonFactory = _$TransactionsRulesRemoveResponseToJson;
  Map<String, dynamic> toJson() =>
      _$TransactionsRulesRemoveResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransactionsRulesRemoveResponse &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(requestId) ^ runtimeType.hashCode;
}

extension $TransactionsRulesRemoveResponseExtension
    on TransactionsRulesRemoveResponse {
  TransactionsRulesRemoveResponse copyWith({String? requestId}) {
    return TransactionsRulesRemoveResponse(
        requestId: requestId ?? this.requestId);
  }

  TransactionsRulesRemoveResponse copyWithWrapped(
      {Wrapped<String>? requestId}) {
    return TransactionsRulesRemoveResponse(
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class TransactionsSyncRequest {
  TransactionsSyncRequest({
    this.clientId,
    required this.accessToken,
    this.secret,
    this.cursor,
    this.count,
    this.options,
  });

  factory TransactionsSyncRequest.fromJson(Map<String, dynamic> json) =>
      _$TransactionsSyncRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'access_token')
  final String accessToken;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'cursor')
  final String? cursor;
  @JsonKey(name: 'count')
  final int? count;
  @JsonKey(name: 'options')
  final TransactionsSyncRequestOptions? options;
  static const fromJsonFactory = _$TransactionsSyncRequestFromJson;
  static const toJsonFactory = _$TransactionsSyncRequestToJson;
  Map<String, dynamic> toJson() => _$TransactionsSyncRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransactionsSyncRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.cursor, cursor) ||
                const DeepCollectionEquality().equals(other.cursor, cursor)) &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)) &&
            (identical(other.options, options) ||
                const DeepCollectionEquality().equals(other.options, options)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(accessToken) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(cursor) ^
      const DeepCollectionEquality().hash(count) ^
      const DeepCollectionEquality().hash(options) ^
      runtimeType.hashCode;
}

extension $TransactionsSyncRequestExtension on TransactionsSyncRequest {
  TransactionsSyncRequest copyWith(
      {String? clientId,
      String? accessToken,
      String? secret,
      String? cursor,
      int? count,
      TransactionsSyncRequestOptions? options}) {
    return TransactionsSyncRequest(
        clientId: clientId ?? this.clientId,
        accessToken: accessToken ?? this.accessToken,
        secret: secret ?? this.secret,
        cursor: cursor ?? this.cursor,
        count: count ?? this.count,
        options: options ?? this.options);
  }

  TransactionsSyncRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String>? accessToken,
      Wrapped<String?>? secret,
      Wrapped<String?>? cursor,
      Wrapped<int?>? count,
      Wrapped<TransactionsSyncRequestOptions?>? options}) {
    return TransactionsSyncRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        accessToken:
            (accessToken != null ? accessToken.value : this.accessToken),
        secret: (secret != null ? secret.value : this.secret),
        cursor: (cursor != null ? cursor.value : this.cursor),
        count: (count != null ? count.value : this.count),
        options: (options != null ? options.value : this.options));
  }
}

@JsonSerializable(explicitToJson: true)
class TransactionsSyncRequestOptions {
  TransactionsSyncRequestOptions({
    this.includeOriginalDescription,
    this.includePersonalFinanceCategory,
  });

  factory TransactionsSyncRequestOptions.fromJson(Map<String, dynamic> json) =>
      _$TransactionsSyncRequestOptionsFromJson(json);

  @JsonKey(name: 'include_original_description', defaultValue: false)
  final bool? includeOriginalDescription;
  @JsonKey(name: 'include_personal_finance_category', defaultValue: false)
  final bool? includePersonalFinanceCategory;
  static const fromJsonFactory = _$TransactionsSyncRequestOptionsFromJson;
  static const toJsonFactory = _$TransactionsSyncRequestOptionsToJson;
  Map<String, dynamic> toJson() => _$TransactionsSyncRequestOptionsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransactionsSyncRequestOptions &&
            (identical(other.includeOriginalDescription,
                    includeOriginalDescription) ||
                const DeepCollectionEquality().equals(
                    other.includeOriginalDescription,
                    includeOriginalDescription)) &&
            (identical(other.includePersonalFinanceCategory,
                    includePersonalFinanceCategory) ||
                const DeepCollectionEquality().equals(
                    other.includePersonalFinanceCategory,
                    includePersonalFinanceCategory)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(includeOriginalDescription) ^
      const DeepCollectionEquality().hash(includePersonalFinanceCategory) ^
      runtimeType.hashCode;
}

extension $TransactionsSyncRequestOptionsExtension
    on TransactionsSyncRequestOptions {
  TransactionsSyncRequestOptions copyWith(
      {bool? includeOriginalDescription,
      bool? includePersonalFinanceCategory}) {
    return TransactionsSyncRequestOptions(
        includeOriginalDescription:
            includeOriginalDescription ?? this.includeOriginalDescription,
        includePersonalFinanceCategory: includePersonalFinanceCategory ??
            this.includePersonalFinanceCategory);
  }

  TransactionsSyncRequestOptions copyWithWrapped(
      {Wrapped<bool?>? includeOriginalDescription,
      Wrapped<bool?>? includePersonalFinanceCategory}) {
    return TransactionsSyncRequestOptions(
        includeOriginalDescription: (includeOriginalDescription != null
            ? includeOriginalDescription.value
            : this.includeOriginalDescription),
        includePersonalFinanceCategory: (includePersonalFinanceCategory != null
            ? includePersonalFinanceCategory.value
            : this.includePersonalFinanceCategory));
  }
}

@JsonSerializable(explicitToJson: true)
class TransactionsSyncResponse {
  TransactionsSyncResponse({
    required this.added,
    required this.modified,
    required this.removed,
    required this.nextCursor,
    required this.hasMore,
    required this.requestId,
  });

  factory TransactionsSyncResponse.fromJson(Map<String, dynamic> json) =>
      _$TransactionsSyncResponseFromJson(json);

  @JsonKey(name: 'added', defaultValue: <Transaction>[])
  final List<Transaction> added;
  @JsonKey(name: 'modified', defaultValue: <Transaction>[])
  final List<Transaction> modified;
  @JsonKey(name: 'removed', defaultValue: <RemovedTransaction>[])
  final List<RemovedTransaction> removed;
  @JsonKey(name: 'next_cursor')
  final String nextCursor;
  @JsonKey(name: 'has_more')
  final bool hasMore;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$TransactionsSyncResponseFromJson;
  static const toJsonFactory = _$TransactionsSyncResponseToJson;
  Map<String, dynamic> toJson() => _$TransactionsSyncResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransactionsSyncResponse &&
            (identical(other.added, added) ||
                const DeepCollectionEquality().equals(other.added, added)) &&
            (identical(other.modified, modified) ||
                const DeepCollectionEquality()
                    .equals(other.modified, modified)) &&
            (identical(other.removed, removed) ||
                const DeepCollectionEquality()
                    .equals(other.removed, removed)) &&
            (identical(other.nextCursor, nextCursor) ||
                const DeepCollectionEquality()
                    .equals(other.nextCursor, nextCursor)) &&
            (identical(other.hasMore, hasMore) ||
                const DeepCollectionEquality()
                    .equals(other.hasMore, hasMore)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(added) ^
      const DeepCollectionEquality().hash(modified) ^
      const DeepCollectionEquality().hash(removed) ^
      const DeepCollectionEquality().hash(nextCursor) ^
      const DeepCollectionEquality().hash(hasMore) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $TransactionsSyncResponseExtension on TransactionsSyncResponse {
  TransactionsSyncResponse copyWith(
      {List<Transaction>? added,
      List<Transaction>? modified,
      List<RemovedTransaction>? removed,
      String? nextCursor,
      bool? hasMore,
      String? requestId}) {
    return TransactionsSyncResponse(
        added: added ?? this.added,
        modified: modified ?? this.modified,
        removed: removed ?? this.removed,
        nextCursor: nextCursor ?? this.nextCursor,
        hasMore: hasMore ?? this.hasMore,
        requestId: requestId ?? this.requestId);
  }

  TransactionsSyncResponse copyWithWrapped(
      {Wrapped<List<Transaction>>? added,
      Wrapped<List<Transaction>>? modified,
      Wrapped<List<RemovedTransaction>>? removed,
      Wrapped<String>? nextCursor,
      Wrapped<bool>? hasMore,
      Wrapped<String>? requestId}) {
    return TransactionsSyncResponse(
        added: (added != null ? added.value : this.added),
        modified: (modified != null ? modified.value : this.modified),
        removed: (removed != null ? removed.value : this.removed),
        nextCursor: (nextCursor != null ? nextCursor.value : this.nextCursor),
        hasMore: (hasMore != null ? hasMore.value : this.hasMore),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class InstitutionsGetRequest {
  InstitutionsGetRequest({
    this.clientId,
    this.secret,
    required this.count,
    required this.offset,
    required this.countryCodes,
    this.options,
  });

  factory InstitutionsGetRequest.fromJson(Map<String, dynamic> json) =>
      _$InstitutionsGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'count')
  final int count;
  @JsonKey(name: 'offset')
  final int offset;
  @JsonKey(
    name: 'country_codes',
    toJson: countryCodeListToJson,
    fromJson: countryCodeListFromJson,
  )
  final List<enums.CountryCode> countryCodes;
  @JsonKey(name: 'options')
  final InstitutionsGetRequestOptions? options;
  static const fromJsonFactory = _$InstitutionsGetRequestFromJson;
  static const toJsonFactory = _$InstitutionsGetRequestToJson;
  Map<String, dynamic> toJson() => _$InstitutionsGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InstitutionsGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)) &&
            (identical(other.offset, offset) ||
                const DeepCollectionEquality().equals(other.offset, offset)) &&
            (identical(other.countryCodes, countryCodes) ||
                const DeepCollectionEquality()
                    .equals(other.countryCodes, countryCodes)) &&
            (identical(other.options, options) ||
                const DeepCollectionEquality().equals(other.options, options)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(count) ^
      const DeepCollectionEquality().hash(offset) ^
      const DeepCollectionEquality().hash(countryCodes) ^
      const DeepCollectionEquality().hash(options) ^
      runtimeType.hashCode;
}

extension $InstitutionsGetRequestExtension on InstitutionsGetRequest {
  InstitutionsGetRequest copyWith(
      {String? clientId,
      String? secret,
      int? count,
      int? offset,
      List<enums.CountryCode>? countryCodes,
      InstitutionsGetRequestOptions? options}) {
    return InstitutionsGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        count: count ?? this.count,
        offset: offset ?? this.offset,
        countryCodes: countryCodes ?? this.countryCodes,
        options: options ?? this.options);
  }

  InstitutionsGetRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<int>? count,
      Wrapped<int>? offset,
      Wrapped<List<enums.CountryCode>>? countryCodes,
      Wrapped<InstitutionsGetRequestOptions?>? options}) {
    return InstitutionsGetRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        count: (count != null ? count.value : this.count),
        offset: (offset != null ? offset.value : this.offset),
        countryCodes:
            (countryCodes != null ? countryCodes.value : this.countryCodes),
        options: (options != null ? options.value : this.options));
  }
}

@JsonSerializable(explicitToJson: true)
class InstitutionsGetRequestOptions {
  InstitutionsGetRequestOptions({
    this.products,
    this.routingNumbers,
    this.oauth,
    this.includeOptionalMetadata,
    this.includeAuthMetadata,
    this.includePaymentInitiationMetadata,
  });

  factory InstitutionsGetRequestOptions.fromJson(Map<String, dynamic> json) =>
      _$InstitutionsGetRequestOptionsFromJson(json);

  @JsonKey(
    name: 'products',
    toJson: productsListToJson,
    fromJson: productsListFromJson,
  )
  final List<enums.Products>? products;
  @JsonKey(name: 'routing_numbers', defaultValue: <String>[])
  final List<String>? routingNumbers;
  @JsonKey(name: 'oauth')
  final bool? oauth;
  @JsonKey(name: 'include_optional_metadata')
  final bool? includeOptionalMetadata;
  @JsonKey(name: 'include_auth_metadata', defaultValue: false)
  final bool? includeAuthMetadata;
  @JsonKey(name: 'include_payment_initiation_metadata', defaultValue: false)
  final bool? includePaymentInitiationMetadata;
  static const fromJsonFactory = _$InstitutionsGetRequestOptionsFromJson;
  static const toJsonFactory = _$InstitutionsGetRequestOptionsToJson;
  Map<String, dynamic> toJson() => _$InstitutionsGetRequestOptionsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InstitutionsGetRequestOptions &&
            (identical(other.products, products) ||
                const DeepCollectionEquality()
                    .equals(other.products, products)) &&
            (identical(other.routingNumbers, routingNumbers) ||
                const DeepCollectionEquality()
                    .equals(other.routingNumbers, routingNumbers)) &&
            (identical(other.oauth, oauth) ||
                const DeepCollectionEquality().equals(other.oauth, oauth)) &&
            (identical(
                    other.includeOptionalMetadata, includeOptionalMetadata) ||
                const DeepCollectionEquality().equals(
                    other.includeOptionalMetadata, includeOptionalMetadata)) &&
            (identical(other.includeAuthMetadata, includeAuthMetadata) ||
                const DeepCollectionEquality()
                    .equals(other.includeAuthMetadata, includeAuthMetadata)) &&
            (identical(other.includePaymentInitiationMetadata,
                    includePaymentInitiationMetadata) ||
                const DeepCollectionEquality().equals(
                    other.includePaymentInitiationMetadata,
                    includePaymentInitiationMetadata)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(products) ^
      const DeepCollectionEquality().hash(routingNumbers) ^
      const DeepCollectionEquality().hash(oauth) ^
      const DeepCollectionEquality().hash(includeOptionalMetadata) ^
      const DeepCollectionEquality().hash(includeAuthMetadata) ^
      const DeepCollectionEquality().hash(includePaymentInitiationMetadata) ^
      runtimeType.hashCode;
}

extension $InstitutionsGetRequestOptionsExtension
    on InstitutionsGetRequestOptions {
  InstitutionsGetRequestOptions copyWith(
      {List<enums.Products>? products,
      List<String>? routingNumbers,
      bool? oauth,
      bool? includeOptionalMetadata,
      bool? includeAuthMetadata,
      bool? includePaymentInitiationMetadata}) {
    return InstitutionsGetRequestOptions(
        products: products ?? this.products,
        routingNumbers: routingNumbers ?? this.routingNumbers,
        oauth: oauth ?? this.oauth,
        includeOptionalMetadata:
            includeOptionalMetadata ?? this.includeOptionalMetadata,
        includeAuthMetadata: includeAuthMetadata ?? this.includeAuthMetadata,
        includePaymentInitiationMetadata: includePaymentInitiationMetadata ??
            this.includePaymentInitiationMetadata);
  }

  InstitutionsGetRequestOptions copyWithWrapped(
      {Wrapped<List<enums.Products>?>? products,
      Wrapped<List<String>?>? routingNumbers,
      Wrapped<bool?>? oauth,
      Wrapped<bool?>? includeOptionalMetadata,
      Wrapped<bool?>? includeAuthMetadata,
      Wrapped<bool?>? includePaymentInitiationMetadata}) {
    return InstitutionsGetRequestOptions(
        products: (products != null ? products.value : this.products),
        routingNumbers: (routingNumbers != null
            ? routingNumbers.value
            : this.routingNumbers),
        oauth: (oauth != null ? oauth.value : this.oauth),
        includeOptionalMetadata: (includeOptionalMetadata != null
            ? includeOptionalMetadata.value
            : this.includeOptionalMetadata),
        includeAuthMetadata: (includeAuthMetadata != null
            ? includeAuthMetadata.value
            : this.includeAuthMetadata),
        includePaymentInitiationMetadata:
            (includePaymentInitiationMetadata != null
                ? includePaymentInitiationMetadata.value
                : this.includePaymentInitiationMetadata));
  }
}

@JsonSerializable(explicitToJson: true)
class InstitutionsGetResponse {
  InstitutionsGetResponse({
    required this.institutions,
    required this.total,
    required this.requestId,
  });

  factory InstitutionsGetResponse.fromJson(Map<String, dynamic> json) =>
      _$InstitutionsGetResponseFromJson(json);

  @JsonKey(name: 'institutions', defaultValue: <Institution>[])
  final List<Institution> institutions;
  @JsonKey(name: 'total')
  final int total;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$InstitutionsGetResponseFromJson;
  static const toJsonFactory = _$InstitutionsGetResponseToJson;
  Map<String, dynamic> toJson() => _$InstitutionsGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InstitutionsGetResponse &&
            (identical(other.institutions, institutions) ||
                const DeepCollectionEquality()
                    .equals(other.institutions, institutions)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(institutions) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $InstitutionsGetResponseExtension on InstitutionsGetResponse {
  InstitutionsGetResponse copyWith(
      {List<Institution>? institutions, int? total, String? requestId}) {
    return InstitutionsGetResponse(
        institutions: institutions ?? this.institutions,
        total: total ?? this.total,
        requestId: requestId ?? this.requestId);
  }

  InstitutionsGetResponse copyWithWrapped(
      {Wrapped<List<Institution>>? institutions,
      Wrapped<int>? total,
      Wrapped<String>? requestId}) {
    return InstitutionsGetResponse(
        institutions:
            (institutions != null ? institutions.value : this.institutions),
        total: (total != null ? total.value : this.total),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class InstitutionsSearchRequest {
  InstitutionsSearchRequest({
    this.clientId,
    this.secret,
    required this.query,
    required this.products,
    required this.countryCodes,
    this.options,
  });

  factory InstitutionsSearchRequest.fromJson(Map<String, dynamic> json) =>
      _$InstitutionsSearchRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'query')
  final String query;
  @JsonKey(
    name: 'products',
    toJson: productsListToJson,
    fromJson: productsListFromJson,
  )
  final List<enums.Products>? products;
  @JsonKey(
    name: 'country_codes',
    toJson: countryCodeListToJson,
    fromJson: countryCodeListFromJson,
  )
  final List<enums.CountryCode> countryCodes;
  @JsonKey(name: 'options')
  final InstitutionsSearchRequestOptions? options;
  static const fromJsonFactory = _$InstitutionsSearchRequestFromJson;
  static const toJsonFactory = _$InstitutionsSearchRequestToJson;
  Map<String, dynamic> toJson() => _$InstitutionsSearchRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InstitutionsSearchRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.query, query) ||
                const DeepCollectionEquality().equals(other.query, query)) &&
            (identical(other.products, products) ||
                const DeepCollectionEquality()
                    .equals(other.products, products)) &&
            (identical(other.countryCodes, countryCodes) ||
                const DeepCollectionEquality()
                    .equals(other.countryCodes, countryCodes)) &&
            (identical(other.options, options) ||
                const DeepCollectionEquality().equals(other.options, options)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(query) ^
      const DeepCollectionEquality().hash(products) ^
      const DeepCollectionEquality().hash(countryCodes) ^
      const DeepCollectionEquality().hash(options) ^
      runtimeType.hashCode;
}

extension $InstitutionsSearchRequestExtension on InstitutionsSearchRequest {
  InstitutionsSearchRequest copyWith(
      {String? clientId,
      String? secret,
      String? query,
      List<enums.Products>? products,
      List<enums.CountryCode>? countryCodes,
      InstitutionsSearchRequestOptions? options}) {
    return InstitutionsSearchRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        query: query ?? this.query,
        products: products ?? this.products,
        countryCodes: countryCodes ?? this.countryCodes,
        options: options ?? this.options);
  }

  InstitutionsSearchRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? query,
      Wrapped<List<enums.Products>?>? products,
      Wrapped<List<enums.CountryCode>>? countryCodes,
      Wrapped<InstitutionsSearchRequestOptions?>? options}) {
    return InstitutionsSearchRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        query: (query != null ? query.value : this.query),
        products: (products != null ? products.value : this.products),
        countryCodes:
            (countryCodes != null ? countryCodes.value : this.countryCodes),
        options: (options != null ? options.value : this.options));
  }
}

@JsonSerializable(explicitToJson: true)
class InstitutionsSearchRequestOptions {
  InstitutionsSearchRequestOptions({
    this.oauth,
    this.includeOptionalMetadata,
    this.includeAuthMetadata,
    this.includePaymentInitiationMetadata,
    this.paymentInitiation,
  });

  factory InstitutionsSearchRequestOptions.fromJson(
          Map<String, dynamic> json) =>
      _$InstitutionsSearchRequestOptionsFromJson(json);

  @JsonKey(name: 'oauth')
  final bool? oauth;
  @JsonKey(name: 'include_optional_metadata')
  final bool? includeOptionalMetadata;
  @JsonKey(name: 'include_auth_metadata', defaultValue: false)
  final bool? includeAuthMetadata;
  @JsonKey(name: 'include_payment_initiation_metadata', defaultValue: false)
  final bool? includePaymentInitiationMetadata;
  @JsonKey(name: 'payment_initiation')
  final InstitutionsSearchPaymentInitiationOptions? paymentInitiation;
  static const fromJsonFactory = _$InstitutionsSearchRequestOptionsFromJson;
  static const toJsonFactory = _$InstitutionsSearchRequestOptionsToJson;
  Map<String, dynamic> toJson() =>
      _$InstitutionsSearchRequestOptionsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InstitutionsSearchRequestOptions &&
            (identical(other.oauth, oauth) ||
                const DeepCollectionEquality().equals(other.oauth, oauth)) &&
            (identical(
                    other.includeOptionalMetadata, includeOptionalMetadata) ||
                const DeepCollectionEquality().equals(
                    other.includeOptionalMetadata, includeOptionalMetadata)) &&
            (identical(other.includeAuthMetadata, includeAuthMetadata) ||
                const DeepCollectionEquality()
                    .equals(other.includeAuthMetadata, includeAuthMetadata)) &&
            (identical(other.includePaymentInitiationMetadata,
                    includePaymentInitiationMetadata) ||
                const DeepCollectionEquality().equals(
                    other.includePaymentInitiationMetadata,
                    includePaymentInitiationMetadata)) &&
            (identical(other.paymentInitiation, paymentInitiation) ||
                const DeepCollectionEquality()
                    .equals(other.paymentInitiation, paymentInitiation)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(oauth) ^
      const DeepCollectionEquality().hash(includeOptionalMetadata) ^
      const DeepCollectionEquality().hash(includeAuthMetadata) ^
      const DeepCollectionEquality().hash(includePaymentInitiationMetadata) ^
      const DeepCollectionEquality().hash(paymentInitiation) ^
      runtimeType.hashCode;
}

extension $InstitutionsSearchRequestOptionsExtension
    on InstitutionsSearchRequestOptions {
  InstitutionsSearchRequestOptions copyWith(
      {bool? oauth,
      bool? includeOptionalMetadata,
      bool? includeAuthMetadata,
      bool? includePaymentInitiationMetadata,
      InstitutionsSearchPaymentInitiationOptions? paymentInitiation}) {
    return InstitutionsSearchRequestOptions(
        oauth: oauth ?? this.oauth,
        includeOptionalMetadata:
            includeOptionalMetadata ?? this.includeOptionalMetadata,
        includeAuthMetadata: includeAuthMetadata ?? this.includeAuthMetadata,
        includePaymentInitiationMetadata: includePaymentInitiationMetadata ??
            this.includePaymentInitiationMetadata,
        paymentInitiation: paymentInitiation ?? this.paymentInitiation);
  }

  InstitutionsSearchRequestOptions copyWithWrapped(
      {Wrapped<bool?>? oauth,
      Wrapped<bool?>? includeOptionalMetadata,
      Wrapped<bool?>? includeAuthMetadata,
      Wrapped<bool?>? includePaymentInitiationMetadata,
      Wrapped<InstitutionsSearchPaymentInitiationOptions?>?
          paymentInitiation}) {
    return InstitutionsSearchRequestOptions(
        oauth: (oauth != null ? oauth.value : this.oauth),
        includeOptionalMetadata: (includeOptionalMetadata != null
            ? includeOptionalMetadata.value
            : this.includeOptionalMetadata),
        includeAuthMetadata: (includeAuthMetadata != null
            ? includeAuthMetadata.value
            : this.includeAuthMetadata),
        includePaymentInitiationMetadata:
            (includePaymentInitiationMetadata != null
                ? includePaymentInitiationMetadata.value
                : this.includePaymentInitiationMetadata),
        paymentInitiation: (paymentInitiation != null
            ? paymentInitiation.value
            : this.paymentInitiation));
  }
}

@JsonSerializable(explicitToJson: true)
class InstitutionsSearchPaymentInitiationOptions {
  InstitutionsSearchPaymentInitiationOptions({
    this.paymentId,
    this.consentId,
  });

  factory InstitutionsSearchPaymentInitiationOptions.fromJson(
          Map<String, dynamic> json) =>
      _$InstitutionsSearchPaymentInitiationOptionsFromJson(json);

  @JsonKey(name: 'payment_id')
  final String? paymentId;
  @JsonKey(name: 'consent_id')
  final String? consentId;
  static const fromJsonFactory =
      _$InstitutionsSearchPaymentInitiationOptionsFromJson;
  static const toJsonFactory =
      _$InstitutionsSearchPaymentInitiationOptionsToJson;
  Map<String, dynamic> toJson() =>
      _$InstitutionsSearchPaymentInitiationOptionsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InstitutionsSearchPaymentInitiationOptions &&
            (identical(other.paymentId, paymentId) ||
                const DeepCollectionEquality()
                    .equals(other.paymentId, paymentId)) &&
            (identical(other.consentId, consentId) ||
                const DeepCollectionEquality()
                    .equals(other.consentId, consentId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(paymentId) ^
      const DeepCollectionEquality().hash(consentId) ^
      runtimeType.hashCode;
}

extension $InstitutionsSearchPaymentInitiationOptionsExtension
    on InstitutionsSearchPaymentInitiationOptions {
  InstitutionsSearchPaymentInitiationOptions copyWith(
      {String? paymentId, String? consentId}) {
    return InstitutionsSearchPaymentInitiationOptions(
        paymentId: paymentId ?? this.paymentId,
        consentId: consentId ?? this.consentId);
  }

  InstitutionsSearchPaymentInitiationOptions copyWithWrapped(
      {Wrapped<String?>? paymentId, Wrapped<String?>? consentId}) {
    return InstitutionsSearchPaymentInitiationOptions(
        paymentId: (paymentId != null ? paymentId.value : this.paymentId),
        consentId: (consentId != null ? consentId.value : this.consentId));
  }
}

@JsonSerializable(explicitToJson: true)
class InstitutionsSearchResponse {
  InstitutionsSearchResponse({
    required this.institutions,
    required this.requestId,
  });

  factory InstitutionsSearchResponse.fromJson(Map<String, dynamic> json) =>
      _$InstitutionsSearchResponseFromJson(json);

  @JsonKey(name: 'institutions', defaultValue: <Institution>[])
  final List<Institution> institutions;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$InstitutionsSearchResponseFromJson;
  static const toJsonFactory = _$InstitutionsSearchResponseToJson;
  Map<String, dynamic> toJson() => _$InstitutionsSearchResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InstitutionsSearchResponse &&
            (identical(other.institutions, institutions) ||
                const DeepCollectionEquality()
                    .equals(other.institutions, institutions)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(institutions) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $InstitutionsSearchResponseExtension on InstitutionsSearchResponse {
  InstitutionsSearchResponse copyWith(
      {List<Institution>? institutions, String? requestId}) {
    return InstitutionsSearchResponse(
        institutions: institutions ?? this.institutions,
        requestId: requestId ?? this.requestId);
  }

  InstitutionsSearchResponse copyWithWrapped(
      {Wrapped<List<Institution>>? institutions, Wrapped<String>? requestId}) {
    return InstitutionsSearchResponse(
        institutions:
            (institutions != null ? institutions.value : this.institutions),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class InstitutionsGetByIdRequest {
  InstitutionsGetByIdRequest({
    this.clientId,
    this.secret,
    required this.institutionId,
    required this.countryCodes,
    this.options,
  });

  factory InstitutionsGetByIdRequest.fromJson(Map<String, dynamic> json) =>
      _$InstitutionsGetByIdRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'institution_id')
  final String institutionId;
  @JsonKey(
    name: 'country_codes',
    toJson: countryCodeListToJson,
    fromJson: countryCodeListFromJson,
  )
  final List<enums.CountryCode> countryCodes;
  @JsonKey(name: 'options')
  final InstitutionsGetByIdRequestOptions? options;
  static const fromJsonFactory = _$InstitutionsGetByIdRequestFromJson;
  static const toJsonFactory = _$InstitutionsGetByIdRequestToJson;
  Map<String, dynamic> toJson() => _$InstitutionsGetByIdRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InstitutionsGetByIdRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.institutionId, institutionId) ||
                const DeepCollectionEquality()
                    .equals(other.institutionId, institutionId)) &&
            (identical(other.countryCodes, countryCodes) ||
                const DeepCollectionEquality()
                    .equals(other.countryCodes, countryCodes)) &&
            (identical(other.options, options) ||
                const DeepCollectionEquality().equals(other.options, options)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(institutionId) ^
      const DeepCollectionEquality().hash(countryCodes) ^
      const DeepCollectionEquality().hash(options) ^
      runtimeType.hashCode;
}

extension $InstitutionsGetByIdRequestExtension on InstitutionsGetByIdRequest {
  InstitutionsGetByIdRequest copyWith(
      {String? clientId,
      String? secret,
      String? institutionId,
      List<enums.CountryCode>? countryCodes,
      InstitutionsGetByIdRequestOptions? options}) {
    return InstitutionsGetByIdRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        institutionId: institutionId ?? this.institutionId,
        countryCodes: countryCodes ?? this.countryCodes,
        options: options ?? this.options);
  }

  InstitutionsGetByIdRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? institutionId,
      Wrapped<List<enums.CountryCode>>? countryCodes,
      Wrapped<InstitutionsGetByIdRequestOptions?>? options}) {
    return InstitutionsGetByIdRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        institutionId:
            (institutionId != null ? institutionId.value : this.institutionId),
        countryCodes:
            (countryCodes != null ? countryCodes.value : this.countryCodes),
        options: (options != null ? options.value : this.options));
  }
}

@JsonSerializable(explicitToJson: true)
class InstitutionsGetByIdRequestOptions {
  InstitutionsGetByIdRequestOptions({
    this.includeOptionalMetadata,
    this.includeStatus,
    this.includeAuthMetadata,
    this.includePaymentInitiationMetadata,
  });

  factory InstitutionsGetByIdRequestOptions.fromJson(
          Map<String, dynamic> json) =>
      _$InstitutionsGetByIdRequestOptionsFromJson(json);

  @JsonKey(name: 'include_optional_metadata', defaultValue: false)
  final bool? includeOptionalMetadata;
  @JsonKey(name: 'include_status', defaultValue: false)
  final bool? includeStatus;
  @JsonKey(name: 'include_auth_metadata', defaultValue: false)
  final bool? includeAuthMetadata;
  @JsonKey(name: 'include_payment_initiation_metadata', defaultValue: false)
  final bool? includePaymentInitiationMetadata;
  static const fromJsonFactory = _$InstitutionsGetByIdRequestOptionsFromJson;
  static const toJsonFactory = _$InstitutionsGetByIdRequestOptionsToJson;
  Map<String, dynamic> toJson() =>
      _$InstitutionsGetByIdRequestOptionsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InstitutionsGetByIdRequestOptions &&
            (identical(
                    other.includeOptionalMetadata, includeOptionalMetadata) ||
                const DeepCollectionEquality().equals(
                    other.includeOptionalMetadata, includeOptionalMetadata)) &&
            (identical(other.includeStatus, includeStatus) ||
                const DeepCollectionEquality()
                    .equals(other.includeStatus, includeStatus)) &&
            (identical(other.includeAuthMetadata, includeAuthMetadata) ||
                const DeepCollectionEquality()
                    .equals(other.includeAuthMetadata, includeAuthMetadata)) &&
            (identical(other.includePaymentInitiationMetadata,
                    includePaymentInitiationMetadata) ||
                const DeepCollectionEquality().equals(
                    other.includePaymentInitiationMetadata,
                    includePaymentInitiationMetadata)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(includeOptionalMetadata) ^
      const DeepCollectionEquality().hash(includeStatus) ^
      const DeepCollectionEquality().hash(includeAuthMetadata) ^
      const DeepCollectionEquality().hash(includePaymentInitiationMetadata) ^
      runtimeType.hashCode;
}

extension $InstitutionsGetByIdRequestOptionsExtension
    on InstitutionsGetByIdRequestOptions {
  InstitutionsGetByIdRequestOptions copyWith(
      {bool? includeOptionalMetadata,
      bool? includeStatus,
      bool? includeAuthMetadata,
      bool? includePaymentInitiationMetadata}) {
    return InstitutionsGetByIdRequestOptions(
        includeOptionalMetadata:
            includeOptionalMetadata ?? this.includeOptionalMetadata,
        includeStatus: includeStatus ?? this.includeStatus,
        includeAuthMetadata: includeAuthMetadata ?? this.includeAuthMetadata,
        includePaymentInitiationMetadata: includePaymentInitiationMetadata ??
            this.includePaymentInitiationMetadata);
  }

  InstitutionsGetByIdRequestOptions copyWithWrapped(
      {Wrapped<bool?>? includeOptionalMetadata,
      Wrapped<bool?>? includeStatus,
      Wrapped<bool?>? includeAuthMetadata,
      Wrapped<bool?>? includePaymentInitiationMetadata}) {
    return InstitutionsGetByIdRequestOptions(
        includeOptionalMetadata: (includeOptionalMetadata != null
            ? includeOptionalMetadata.value
            : this.includeOptionalMetadata),
        includeStatus:
            (includeStatus != null ? includeStatus.value : this.includeStatus),
        includeAuthMetadata: (includeAuthMetadata != null
            ? includeAuthMetadata.value
            : this.includeAuthMetadata),
        includePaymentInitiationMetadata:
            (includePaymentInitiationMetadata != null
                ? includePaymentInitiationMetadata.value
                : this.includePaymentInitiationMetadata));
  }
}

@JsonSerializable(explicitToJson: true)
class InstitutionsGetByIdResponse {
  InstitutionsGetByIdResponse({
    required this.institution,
    required this.requestId,
  });

  factory InstitutionsGetByIdResponse.fromJson(Map<String, dynamic> json) =>
      _$InstitutionsGetByIdResponseFromJson(json);

  @JsonKey(name: 'institution')
  final Institution institution;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$InstitutionsGetByIdResponseFromJson;
  static const toJsonFactory = _$InstitutionsGetByIdResponseToJson;
  Map<String, dynamic> toJson() => _$InstitutionsGetByIdResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InstitutionsGetByIdResponse &&
            (identical(other.institution, institution) ||
                const DeepCollectionEquality()
                    .equals(other.institution, institution)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(institution) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $InstitutionsGetByIdResponseExtension on InstitutionsGetByIdResponse {
  InstitutionsGetByIdResponse copyWith(
      {Institution? institution, String? requestId}) {
    return InstitutionsGetByIdResponse(
        institution: institution ?? this.institution,
        requestId: requestId ?? this.requestId);
  }

  InstitutionsGetByIdResponse copyWithWrapped(
      {Wrapped<Institution>? institution, Wrapped<String>? requestId}) {
    return InstitutionsGetByIdResponse(
        institution:
            (institution != null ? institution.value : this.institution),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class AccountsGetRequest {
  AccountsGetRequest({
    this.clientId,
    this.secret,
    required this.accessToken,
    this.options,
  });

  factory AccountsGetRequest.fromJson(Map<String, dynamic> json) =>
      _$AccountsGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'access_token')
  final String accessToken;
  @JsonKey(name: 'options')
  final AccountsGetRequestOptions? options;
  static const fromJsonFactory = _$AccountsGetRequestFromJson;
  static const toJsonFactory = _$AccountsGetRequestToJson;
  Map<String, dynamic> toJson() => _$AccountsGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AccountsGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)) &&
            (identical(other.options, options) ||
                const DeepCollectionEquality().equals(other.options, options)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(accessToken) ^
      const DeepCollectionEquality().hash(options) ^
      runtimeType.hashCode;
}

extension $AccountsGetRequestExtension on AccountsGetRequest {
  AccountsGetRequest copyWith(
      {String? clientId,
      String? secret,
      String? accessToken,
      AccountsGetRequestOptions? options}) {
    return AccountsGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        accessToken: accessToken ?? this.accessToken,
        options: options ?? this.options);
  }

  AccountsGetRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? accessToken,
      Wrapped<AccountsGetRequestOptions?>? options}) {
    return AccountsGetRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        accessToken:
            (accessToken != null ? accessToken.value : this.accessToken),
        options: (options != null ? options.value : this.options));
  }
}

@JsonSerializable(explicitToJson: true)
class AccountsGetRequestOptions {
  AccountsGetRequestOptions({
    this.accountIds,
  });

  factory AccountsGetRequestOptions.fromJson(Map<String, dynamic> json) =>
      _$AccountsGetRequestOptionsFromJson(json);

  @JsonKey(name: 'account_ids', defaultValue: <String>[])
  final List<String>? accountIds;
  static const fromJsonFactory = _$AccountsGetRequestOptionsFromJson;
  static const toJsonFactory = _$AccountsGetRequestOptionsToJson;
  Map<String, dynamic> toJson() => _$AccountsGetRequestOptionsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AccountsGetRequestOptions &&
            (identical(other.accountIds, accountIds) ||
                const DeepCollectionEquality()
                    .equals(other.accountIds, accountIds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountIds) ^ runtimeType.hashCode;
}

extension $AccountsGetRequestOptionsExtension on AccountsGetRequestOptions {
  AccountsGetRequestOptions copyWith({List<String>? accountIds}) {
    return AccountsGetRequestOptions(accountIds: accountIds ?? this.accountIds);
  }

  AccountsGetRequestOptions copyWithWrapped(
      {Wrapped<List<String>?>? accountIds}) {
    return AccountsGetRequestOptions(
        accountIds: (accountIds != null ? accountIds.value : this.accountIds));
  }
}

@JsonSerializable(explicitToJson: true)
class AccountsGetResponse {
  AccountsGetResponse({
    required this.accounts,
    required this.item,
    required this.requestId,
  });

  factory AccountsGetResponse.fromJson(Map<String, dynamic> json) =>
      _$AccountsGetResponseFromJson(json);

  @JsonKey(name: 'accounts', defaultValue: <AccountBase>[])
  final List<AccountBase> accounts;
  @JsonKey(name: 'item')
  final Item item;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$AccountsGetResponseFromJson;
  static const toJsonFactory = _$AccountsGetResponseToJson;
  Map<String, dynamic> toJson() => _$AccountsGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AccountsGetResponse &&
            (identical(other.accounts, accounts) ||
                const DeepCollectionEquality()
                    .equals(other.accounts, accounts)) &&
            (identical(other.item, item) ||
                const DeepCollectionEquality().equals(other.item, item)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accounts) ^
      const DeepCollectionEquality().hash(item) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $AccountsGetResponseExtension on AccountsGetResponse {
  AccountsGetResponse copyWith(
      {List<AccountBase>? accounts, Item? item, String? requestId}) {
    return AccountsGetResponse(
        accounts: accounts ?? this.accounts,
        item: item ?? this.item,
        requestId: requestId ?? this.requestId);
  }

  AccountsGetResponse copyWithWrapped(
      {Wrapped<List<AccountBase>>? accounts,
      Wrapped<Item>? item,
      Wrapped<String>? requestId}) {
    return AccountsGetResponse(
        accounts: (accounts != null ? accounts.value : this.accounts),
        item: (item != null ? item.value : this.item),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class CategoriesGetRequest {
  CategoriesGetRequest();

  factory CategoriesGetRequest.fromJson(Map<String, dynamic> json) =>
      _$CategoriesGetRequestFromJson(json);

  static const fromJsonFactory = _$CategoriesGetRequestFromJson;
  static const toJsonFactory = _$CategoriesGetRequestToJson;
  Map<String, dynamic> toJson() => _$CategoriesGetRequestToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => runtimeType.hashCode;
}

@JsonSerializable(explicitToJson: true)
class CategoriesGetResponse {
  CategoriesGetResponse({
    required this.categories,
    required this.requestId,
  });

  factory CategoriesGetResponse.fromJson(Map<String, dynamic> json) =>
      _$CategoriesGetResponseFromJson(json);

  @JsonKey(name: 'categories', defaultValue: <Category>[])
  final List<Category> categories;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$CategoriesGetResponseFromJson;
  static const toJsonFactory = _$CategoriesGetResponseToJson;
  Map<String, dynamic> toJson() => _$CategoriesGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CategoriesGetResponse &&
            (identical(other.categories, categories) ||
                const DeepCollectionEquality()
                    .equals(other.categories, categories)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(categories) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $CategoriesGetResponseExtension on CategoriesGetResponse {
  CategoriesGetResponse copyWith(
      {List<Category>? categories, String? requestId}) {
    return CategoriesGetResponse(
        categories: categories ?? this.categories,
        requestId: requestId ?? this.requestId);
  }

  CategoriesGetResponse copyWithWrapped(
      {Wrapped<List<Category>>? categories, Wrapped<String>? requestId}) {
    return CategoriesGetResponse(
        categories: (categories != null ? categories.value : this.categories),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class SandboxProcessorTokenCreateRequest {
  SandboxProcessorTokenCreateRequest({
    this.clientId,
    this.secret,
    required this.institutionId,
    this.options,
  });

  factory SandboxProcessorTokenCreateRequest.fromJson(
          Map<String, dynamic> json) =>
      _$SandboxProcessorTokenCreateRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'institution_id')
  final String institutionId;
  @JsonKey(name: 'options')
  final SandboxProcessorTokenCreateRequestOptions? options;
  static const fromJsonFactory = _$SandboxProcessorTokenCreateRequestFromJson;
  static const toJsonFactory = _$SandboxProcessorTokenCreateRequestToJson;
  Map<String, dynamic> toJson() =>
      _$SandboxProcessorTokenCreateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SandboxProcessorTokenCreateRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.institutionId, institutionId) ||
                const DeepCollectionEquality()
                    .equals(other.institutionId, institutionId)) &&
            (identical(other.options, options) ||
                const DeepCollectionEquality().equals(other.options, options)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(institutionId) ^
      const DeepCollectionEquality().hash(options) ^
      runtimeType.hashCode;
}

extension $SandboxProcessorTokenCreateRequestExtension
    on SandboxProcessorTokenCreateRequest {
  SandboxProcessorTokenCreateRequest copyWith(
      {String? clientId,
      String? secret,
      String? institutionId,
      SandboxProcessorTokenCreateRequestOptions? options}) {
    return SandboxProcessorTokenCreateRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        institutionId: institutionId ?? this.institutionId,
        options: options ?? this.options);
  }

  SandboxProcessorTokenCreateRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? institutionId,
      Wrapped<SandboxProcessorTokenCreateRequestOptions?>? options}) {
    return SandboxProcessorTokenCreateRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        institutionId:
            (institutionId != null ? institutionId.value : this.institutionId),
        options: (options != null ? options.value : this.options));
  }
}

@JsonSerializable(explicitToJson: true)
class SandboxProcessorTokenCreateRequestOptions {
  SandboxProcessorTokenCreateRequestOptions({
    this.overrideUsername,
    this.overridePassword,
  });

  factory SandboxProcessorTokenCreateRequestOptions.fromJson(
          Map<String, dynamic> json) =>
      _$SandboxProcessorTokenCreateRequestOptionsFromJson(json);

  @JsonKey(name: 'override_username')
  final String? overrideUsername;
  @JsonKey(name: 'override_password')
  final String? overridePassword;
  static const fromJsonFactory =
      _$SandboxProcessorTokenCreateRequestOptionsFromJson;
  static const toJsonFactory =
      _$SandboxProcessorTokenCreateRequestOptionsToJson;
  Map<String, dynamic> toJson() =>
      _$SandboxProcessorTokenCreateRequestOptionsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SandboxProcessorTokenCreateRequestOptions &&
            (identical(other.overrideUsername, overrideUsername) ||
                const DeepCollectionEquality()
                    .equals(other.overrideUsername, overrideUsername)) &&
            (identical(other.overridePassword, overridePassword) ||
                const DeepCollectionEquality()
                    .equals(other.overridePassword, overridePassword)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(overrideUsername) ^
      const DeepCollectionEquality().hash(overridePassword) ^
      runtimeType.hashCode;
}

extension $SandboxProcessorTokenCreateRequestOptionsExtension
    on SandboxProcessorTokenCreateRequestOptions {
  SandboxProcessorTokenCreateRequestOptions copyWith(
      {String? overrideUsername, String? overridePassword}) {
    return SandboxProcessorTokenCreateRequestOptions(
        overrideUsername: overrideUsername ?? this.overrideUsername,
        overridePassword: overridePassword ?? this.overridePassword);
  }

  SandboxProcessorTokenCreateRequestOptions copyWithWrapped(
      {Wrapped<String?>? overrideUsername,
      Wrapped<String?>? overridePassword}) {
    return SandboxProcessorTokenCreateRequestOptions(
        overrideUsername: (overrideUsername != null
            ? overrideUsername.value
            : this.overrideUsername),
        overridePassword: (overridePassword != null
            ? overridePassword.value
            : this.overridePassword));
  }
}

@JsonSerializable(explicitToJson: true)
class SandboxProcessorTokenCreateResponse {
  SandboxProcessorTokenCreateResponse({
    required this.processorToken,
    required this.requestId,
  });

  factory SandboxProcessorTokenCreateResponse.fromJson(
          Map<String, dynamic> json) =>
      _$SandboxProcessorTokenCreateResponseFromJson(json);

  @JsonKey(name: 'processor_token')
  final String processorToken;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$SandboxProcessorTokenCreateResponseFromJson;
  static const toJsonFactory = _$SandboxProcessorTokenCreateResponseToJson;
  Map<String, dynamic> toJson() =>
      _$SandboxProcessorTokenCreateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SandboxProcessorTokenCreateResponse &&
            (identical(other.processorToken, processorToken) ||
                const DeepCollectionEquality()
                    .equals(other.processorToken, processorToken)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(processorToken) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $SandboxProcessorTokenCreateResponseExtension
    on SandboxProcessorTokenCreateResponse {
  SandboxProcessorTokenCreateResponse copyWith(
      {String? processorToken, String? requestId}) {
    return SandboxProcessorTokenCreateResponse(
        processorToken: processorToken ?? this.processorToken,
        requestId: requestId ?? this.requestId);
  }

  SandboxProcessorTokenCreateResponse copyWithWrapped(
      {Wrapped<String>? processorToken, Wrapped<String>? requestId}) {
    return SandboxProcessorTokenCreateResponse(
        processorToken: (processorToken != null
            ? processorToken.value
            : this.processorToken),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class SandboxPublicTokenCreateRequest {
  SandboxPublicTokenCreateRequest({
    this.clientId,
    this.secret,
    required this.institutionId,
    required this.initialProducts,
    this.options,
    this.userToken,
  });

  factory SandboxPublicTokenCreateRequest.fromJson(Map<String, dynamic> json) =>
      _$SandboxPublicTokenCreateRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'institution_id')
  final String institutionId;
  @JsonKey(
    name: 'initial_products',
    toJson: productsListToJson,
    fromJson: productsListFromJson,
  )
  final List<enums.Products> initialProducts;
  @JsonKey(name: 'options')
  final SandboxPublicTokenCreateRequestOptions? options;
  @JsonKey(name: 'user_token')
  final String? userToken;
  static const fromJsonFactory = _$SandboxPublicTokenCreateRequestFromJson;
  static const toJsonFactory = _$SandboxPublicTokenCreateRequestToJson;
  Map<String, dynamic> toJson() =>
      _$SandboxPublicTokenCreateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SandboxPublicTokenCreateRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.institutionId, institutionId) ||
                const DeepCollectionEquality()
                    .equals(other.institutionId, institutionId)) &&
            (identical(other.initialProducts, initialProducts) ||
                const DeepCollectionEquality()
                    .equals(other.initialProducts, initialProducts)) &&
            (identical(other.options, options) ||
                const DeepCollectionEquality()
                    .equals(other.options, options)) &&
            (identical(other.userToken, userToken) ||
                const DeepCollectionEquality()
                    .equals(other.userToken, userToken)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(institutionId) ^
      const DeepCollectionEquality().hash(initialProducts) ^
      const DeepCollectionEquality().hash(options) ^
      const DeepCollectionEquality().hash(userToken) ^
      runtimeType.hashCode;
}

extension $SandboxPublicTokenCreateRequestExtension
    on SandboxPublicTokenCreateRequest {
  SandboxPublicTokenCreateRequest copyWith(
      {String? clientId,
      String? secret,
      String? institutionId,
      List<enums.Products>? initialProducts,
      SandboxPublicTokenCreateRequestOptions? options,
      String? userToken}) {
    return SandboxPublicTokenCreateRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        institutionId: institutionId ?? this.institutionId,
        initialProducts: initialProducts ?? this.initialProducts,
        options: options ?? this.options,
        userToken: userToken ?? this.userToken);
  }

  SandboxPublicTokenCreateRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? institutionId,
      Wrapped<List<enums.Products>>? initialProducts,
      Wrapped<SandboxPublicTokenCreateRequestOptions?>? options,
      Wrapped<String?>? userToken}) {
    return SandboxPublicTokenCreateRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        institutionId:
            (institutionId != null ? institutionId.value : this.institutionId),
        initialProducts: (initialProducts != null
            ? initialProducts.value
            : this.initialProducts),
        options: (options != null ? options.value : this.options),
        userToken: (userToken != null ? userToken.value : this.userToken));
  }
}

@JsonSerializable(explicitToJson: true)
class SandboxPublicTokenCreateRequestOptions {
  SandboxPublicTokenCreateRequestOptions({
    this.webhook,
    this.overrideUsername,
    this.overridePassword,
    this.transactions,
    this.incomeVerification,
  });

  factory SandboxPublicTokenCreateRequestOptions.fromJson(
          Map<String, dynamic> json) =>
      _$SandboxPublicTokenCreateRequestOptionsFromJson(json);

  @JsonKey(name: 'webhook')
  final String? webhook;
  @JsonKey(name: 'override_username')
  final String? overrideUsername;
  @JsonKey(name: 'override_password')
  final String? overridePassword;
  @JsonKey(name: 'transactions')
  final SandboxPublicTokenCreateRequestOptionsTransactions? transactions;
  @JsonKey(name: 'income_verification')
  final SandboxPublicTokenCreateRequestOptionsIncomeVerification?
      incomeVerification;
  static const fromJsonFactory =
      _$SandboxPublicTokenCreateRequestOptionsFromJson;
  static const toJsonFactory = _$SandboxPublicTokenCreateRequestOptionsToJson;
  Map<String, dynamic> toJson() =>
      _$SandboxPublicTokenCreateRequestOptionsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SandboxPublicTokenCreateRequestOptions &&
            (identical(other.webhook, webhook) ||
                const DeepCollectionEquality()
                    .equals(other.webhook, webhook)) &&
            (identical(other.overrideUsername, overrideUsername) ||
                const DeepCollectionEquality()
                    .equals(other.overrideUsername, overrideUsername)) &&
            (identical(other.overridePassword, overridePassword) ||
                const DeepCollectionEquality()
                    .equals(other.overridePassword, overridePassword)) &&
            (identical(other.transactions, transactions) ||
                const DeepCollectionEquality()
                    .equals(other.transactions, transactions)) &&
            (identical(other.incomeVerification, incomeVerification) ||
                const DeepCollectionEquality()
                    .equals(other.incomeVerification, incomeVerification)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(webhook) ^
      const DeepCollectionEquality().hash(overrideUsername) ^
      const DeepCollectionEquality().hash(overridePassword) ^
      const DeepCollectionEquality().hash(transactions) ^
      const DeepCollectionEquality().hash(incomeVerification) ^
      runtimeType.hashCode;
}

extension $SandboxPublicTokenCreateRequestOptionsExtension
    on SandboxPublicTokenCreateRequestOptions {
  SandboxPublicTokenCreateRequestOptions copyWith(
      {String? webhook,
      String? overrideUsername,
      String? overridePassword,
      SandboxPublicTokenCreateRequestOptionsTransactions? transactions,
      SandboxPublicTokenCreateRequestOptionsIncomeVerification?
          incomeVerification}) {
    return SandboxPublicTokenCreateRequestOptions(
        webhook: webhook ?? this.webhook,
        overrideUsername: overrideUsername ?? this.overrideUsername,
        overridePassword: overridePassword ?? this.overridePassword,
        transactions: transactions ?? this.transactions,
        incomeVerification: incomeVerification ?? this.incomeVerification);
  }

  SandboxPublicTokenCreateRequestOptions copyWithWrapped(
      {Wrapped<String?>? webhook,
      Wrapped<String?>? overrideUsername,
      Wrapped<String?>? overridePassword,
      Wrapped<SandboxPublicTokenCreateRequestOptionsTransactions?>?
          transactions,
      Wrapped<SandboxPublicTokenCreateRequestOptionsIncomeVerification?>?
          incomeVerification}) {
    return SandboxPublicTokenCreateRequestOptions(
        webhook: (webhook != null ? webhook.value : this.webhook),
        overrideUsername: (overrideUsername != null
            ? overrideUsername.value
            : this.overrideUsername),
        overridePassword: (overridePassword != null
            ? overridePassword.value
            : this.overridePassword),
        transactions:
            (transactions != null ? transactions.value : this.transactions),
        incomeVerification: (incomeVerification != null
            ? incomeVerification.value
            : this.incomeVerification));
  }
}

@JsonSerializable(explicitToJson: true)
class SandboxPublicTokenCreateRequestOptionsTransactions {
  SandboxPublicTokenCreateRequestOptionsTransactions({
    this.startDate,
    this.endDate,
  });

  factory SandboxPublicTokenCreateRequestOptionsTransactions.fromJson(
          Map<String, dynamic> json) =>
      _$SandboxPublicTokenCreateRequestOptionsTransactionsFromJson(json);

  @JsonKey(name: 'start_date', toJson: _dateToJson)
  final DateTime? startDate;
  @JsonKey(name: 'end_date', toJson: _dateToJson)
  final DateTime? endDate;
  static const fromJsonFactory =
      _$SandboxPublicTokenCreateRequestOptionsTransactionsFromJson;
  static const toJsonFactory =
      _$SandboxPublicTokenCreateRequestOptionsTransactionsToJson;
  Map<String, dynamic> toJson() =>
      _$SandboxPublicTokenCreateRequestOptionsTransactionsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SandboxPublicTokenCreateRequestOptionsTransactions &&
            (identical(other.startDate, startDate) ||
                const DeepCollectionEquality()
                    .equals(other.startDate, startDate)) &&
            (identical(other.endDate, endDate) ||
                const DeepCollectionEquality().equals(other.endDate, endDate)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(startDate) ^
      const DeepCollectionEquality().hash(endDate) ^
      runtimeType.hashCode;
}

extension $SandboxPublicTokenCreateRequestOptionsTransactionsExtension
    on SandboxPublicTokenCreateRequestOptionsTransactions {
  SandboxPublicTokenCreateRequestOptionsTransactions copyWith(
      {DateTime? startDate, DateTime? endDate}) {
    return SandboxPublicTokenCreateRequestOptionsTransactions(
        startDate: startDate ?? this.startDate,
        endDate: endDate ?? this.endDate);
  }

  SandboxPublicTokenCreateRequestOptionsTransactions copyWithWrapped(
      {Wrapped<DateTime?>? startDate, Wrapped<DateTime?>? endDate}) {
    return SandboxPublicTokenCreateRequestOptionsTransactions(
        startDate: (startDate != null ? startDate.value : this.startDate),
        endDate: (endDate != null ? endDate.value : this.endDate));
  }
}

@JsonSerializable(explicitToJson: true)
class SandboxPublicTokenCreateRequestOptionsIncomeVerification {
  SandboxPublicTokenCreateRequestOptionsIncomeVerification({
    this.incomeSourceTypes,
    this.bankIncome,
  });

  factory SandboxPublicTokenCreateRequestOptionsIncomeVerification.fromJson(
          Map<String, dynamic> json) =>
      _$SandboxPublicTokenCreateRequestOptionsIncomeVerificationFromJson(json);

  @JsonKey(
    name: 'income_source_types',
    toJson: incomeVerificationSourceTypeListToJson,
    fromJson: incomeVerificationSourceTypeListFromJson,
  )
  final List<enums.IncomeVerificationSourceType>? incomeSourceTypes;
  @JsonKey(name: 'bank_income')
  final SandboxPublicTokenCreateRequestIncomeVerificationBankIncome? bankIncome;
  static const fromJsonFactory =
      _$SandboxPublicTokenCreateRequestOptionsIncomeVerificationFromJson;
  static const toJsonFactory =
      _$SandboxPublicTokenCreateRequestOptionsIncomeVerificationToJson;
  Map<String, dynamic> toJson() =>
      _$SandboxPublicTokenCreateRequestOptionsIncomeVerificationToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SandboxPublicTokenCreateRequestOptionsIncomeVerification &&
            (identical(other.incomeSourceTypes, incomeSourceTypes) ||
                const DeepCollectionEquality()
                    .equals(other.incomeSourceTypes, incomeSourceTypes)) &&
            (identical(other.bankIncome, bankIncome) ||
                const DeepCollectionEquality()
                    .equals(other.bankIncome, bankIncome)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(incomeSourceTypes) ^
      const DeepCollectionEquality().hash(bankIncome) ^
      runtimeType.hashCode;
}

extension $SandboxPublicTokenCreateRequestOptionsIncomeVerificationExtension
    on SandboxPublicTokenCreateRequestOptionsIncomeVerification {
  SandboxPublicTokenCreateRequestOptionsIncomeVerification copyWith(
      {List<enums.IncomeVerificationSourceType>? incomeSourceTypes,
      SandboxPublicTokenCreateRequestIncomeVerificationBankIncome?
          bankIncome}) {
    return SandboxPublicTokenCreateRequestOptionsIncomeVerification(
        incomeSourceTypes: incomeSourceTypes ?? this.incomeSourceTypes,
        bankIncome: bankIncome ?? this.bankIncome);
  }

  SandboxPublicTokenCreateRequestOptionsIncomeVerification copyWithWrapped(
      {Wrapped<List<enums.IncomeVerificationSourceType>?>? incomeSourceTypes,
      Wrapped<SandboxPublicTokenCreateRequestIncomeVerificationBankIncome?>?
          bankIncome}) {
    return SandboxPublicTokenCreateRequestOptionsIncomeVerification(
        incomeSourceTypes: (incomeSourceTypes != null
            ? incomeSourceTypes.value
            : this.incomeSourceTypes),
        bankIncome: (bankIncome != null ? bankIncome.value : this.bankIncome));
  }
}

@JsonSerializable(explicitToJson: true)
class SandboxPublicTokenCreateRequestIncomeVerificationBankIncome {
  SandboxPublicTokenCreateRequestIncomeVerificationBankIncome({
    this.daysRequested,
  });

  factory SandboxPublicTokenCreateRequestIncomeVerificationBankIncome.fromJson(
          Map<String, dynamic> json) =>
      _$SandboxPublicTokenCreateRequestIncomeVerificationBankIncomeFromJson(
          json);

  @JsonKey(name: 'days_requested')
  final int? daysRequested;
  static const fromJsonFactory =
      _$SandboxPublicTokenCreateRequestIncomeVerificationBankIncomeFromJson;
  static const toJsonFactory =
      _$SandboxPublicTokenCreateRequestIncomeVerificationBankIncomeToJson;
  Map<String, dynamic> toJson() =>
      _$SandboxPublicTokenCreateRequestIncomeVerificationBankIncomeToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SandboxPublicTokenCreateRequestIncomeVerificationBankIncome &&
            (identical(other.daysRequested, daysRequested) ||
                const DeepCollectionEquality()
                    .equals(other.daysRequested, daysRequested)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(daysRequested) ^ runtimeType.hashCode;
}

extension $SandboxPublicTokenCreateRequestIncomeVerificationBankIncomeExtension
    on SandboxPublicTokenCreateRequestIncomeVerificationBankIncome {
  SandboxPublicTokenCreateRequestIncomeVerificationBankIncome copyWith(
      {int? daysRequested}) {
    return SandboxPublicTokenCreateRequestIncomeVerificationBankIncome(
        daysRequested: daysRequested ?? this.daysRequested);
  }

  SandboxPublicTokenCreateRequestIncomeVerificationBankIncome copyWithWrapped(
      {Wrapped<int?>? daysRequested}) {
    return SandboxPublicTokenCreateRequestIncomeVerificationBankIncome(
        daysRequested:
            (daysRequested != null ? daysRequested.value : this.daysRequested));
  }
}

@JsonSerializable(explicitToJson: true)
class SandboxPublicTokenCreateResponse {
  SandboxPublicTokenCreateResponse({
    required this.publicToken,
    required this.requestId,
  });

  factory SandboxPublicTokenCreateResponse.fromJson(
          Map<String, dynamic> json) =>
      _$SandboxPublicTokenCreateResponseFromJson(json);

  @JsonKey(name: 'public_token')
  final String publicToken;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$SandboxPublicTokenCreateResponseFromJson;
  static const toJsonFactory = _$SandboxPublicTokenCreateResponseToJson;
  Map<String, dynamic> toJson() =>
      _$SandboxPublicTokenCreateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SandboxPublicTokenCreateResponse &&
            (identical(other.publicToken, publicToken) ||
                const DeepCollectionEquality()
                    .equals(other.publicToken, publicToken)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(publicToken) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $SandboxPublicTokenCreateResponseExtension
    on SandboxPublicTokenCreateResponse {
  SandboxPublicTokenCreateResponse copyWith(
      {String? publicToken, String? requestId}) {
    return SandboxPublicTokenCreateResponse(
        publicToken: publicToken ?? this.publicToken,
        requestId: requestId ?? this.requestId);
  }

  SandboxPublicTokenCreateResponse copyWithWrapped(
      {Wrapped<String>? publicToken, Wrapped<String>? requestId}) {
    return SandboxPublicTokenCreateResponse(
        publicToken:
            (publicToken != null ? publicToken.value : this.publicToken),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class SandboxItemFireWebhookRequest {
  SandboxItemFireWebhookRequest({
    this.clientId,
    this.secret,
    required this.accessToken,
    this.webhookType,
    required this.webhookCode,
  });

  factory SandboxItemFireWebhookRequest.fromJson(Map<String, dynamic> json) =>
      _$SandboxItemFireWebhookRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'access_token')
  final String accessToken;
  @JsonKey(
    name: 'webhook_type',
    toJson: webhookTypeToJson,
    fromJson: webhookTypeFromJson,
  )
  final enums.WebhookType? webhookType;
  @JsonKey(
    name: 'webhook_code',
    toJson: sandboxItemFireWebhookRequestWebhookCodeToJson,
    fromJson: sandboxItemFireWebhookRequestWebhookCodeFromJson,
  )
  final enums.SandboxItemFireWebhookRequestWebhookCode webhookCode;
  static const fromJsonFactory = _$SandboxItemFireWebhookRequestFromJson;
  static const toJsonFactory = _$SandboxItemFireWebhookRequestToJson;
  Map<String, dynamic> toJson() => _$SandboxItemFireWebhookRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SandboxItemFireWebhookRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)) &&
            (identical(other.webhookType, webhookType) ||
                const DeepCollectionEquality()
                    .equals(other.webhookType, webhookType)) &&
            (identical(other.webhookCode, webhookCode) ||
                const DeepCollectionEquality()
                    .equals(other.webhookCode, webhookCode)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(accessToken) ^
      const DeepCollectionEquality().hash(webhookType) ^
      const DeepCollectionEquality().hash(webhookCode) ^
      runtimeType.hashCode;
}

extension $SandboxItemFireWebhookRequestExtension
    on SandboxItemFireWebhookRequest {
  SandboxItemFireWebhookRequest copyWith(
      {String? clientId,
      String? secret,
      String? accessToken,
      enums.WebhookType? webhookType,
      enums.SandboxItemFireWebhookRequestWebhookCode? webhookCode}) {
    return SandboxItemFireWebhookRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        accessToken: accessToken ?? this.accessToken,
        webhookType: webhookType ?? this.webhookType,
        webhookCode: webhookCode ?? this.webhookCode);
  }

  SandboxItemFireWebhookRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? accessToken,
      Wrapped<enums.WebhookType?>? webhookType,
      Wrapped<enums.SandboxItemFireWebhookRequestWebhookCode>? webhookCode}) {
    return SandboxItemFireWebhookRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        accessToken:
            (accessToken != null ? accessToken.value : this.accessToken),
        webhookType:
            (webhookType != null ? webhookType.value : this.webhookType),
        webhookCode:
            (webhookCode != null ? webhookCode.value : this.webhookCode));
  }
}

@JsonSerializable(explicitToJson: true)
class SandboxItemFireWebhookResponse {
  SandboxItemFireWebhookResponse({
    required this.webhookFired,
    required this.requestId,
  });

  factory SandboxItemFireWebhookResponse.fromJson(Map<String, dynamic> json) =>
      _$SandboxItemFireWebhookResponseFromJson(json);

  @JsonKey(name: 'webhook_fired')
  final bool webhookFired;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$SandboxItemFireWebhookResponseFromJson;
  static const toJsonFactory = _$SandboxItemFireWebhookResponseToJson;
  Map<String, dynamic> toJson() => _$SandboxItemFireWebhookResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SandboxItemFireWebhookResponse &&
            (identical(other.webhookFired, webhookFired) ||
                const DeepCollectionEquality()
                    .equals(other.webhookFired, webhookFired)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(webhookFired) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $SandboxItemFireWebhookResponseExtension
    on SandboxItemFireWebhookResponse {
  SandboxItemFireWebhookResponse copyWith(
      {bool? webhookFired, String? requestId}) {
    return SandboxItemFireWebhookResponse(
        webhookFired: webhookFired ?? this.webhookFired,
        requestId: requestId ?? this.requestId);
  }

  SandboxItemFireWebhookResponse copyWithWrapped(
      {Wrapped<bool>? webhookFired, Wrapped<String>? requestId}) {
    return SandboxItemFireWebhookResponse(
        webhookFired:
            (webhookFired != null ? webhookFired.value : this.webhookFired),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class AccountsBalanceGetRequest {
  AccountsBalanceGetRequest({
    required this.accessToken,
    this.secret,
    this.clientId,
    this.options,
  });

  factory AccountsBalanceGetRequest.fromJson(Map<String, dynamic> json) =>
      _$AccountsBalanceGetRequestFromJson(json);

  @JsonKey(name: 'access_token')
  final String accessToken;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'options')
  final AccountsBalanceGetRequestOptions? options;
  static const fromJsonFactory = _$AccountsBalanceGetRequestFromJson;
  static const toJsonFactory = _$AccountsBalanceGetRequestToJson;
  Map<String, dynamic> toJson() => _$AccountsBalanceGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AccountsBalanceGetRequest &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.options, options) ||
                const DeepCollectionEquality().equals(other.options, options)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accessToken) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(options) ^
      runtimeType.hashCode;
}

extension $AccountsBalanceGetRequestExtension on AccountsBalanceGetRequest {
  AccountsBalanceGetRequest copyWith(
      {String? accessToken,
      String? secret,
      String? clientId,
      AccountsBalanceGetRequestOptions? options}) {
    return AccountsBalanceGetRequest(
        accessToken: accessToken ?? this.accessToken,
        secret: secret ?? this.secret,
        clientId: clientId ?? this.clientId,
        options: options ?? this.options);
  }

  AccountsBalanceGetRequest copyWithWrapped(
      {Wrapped<String>? accessToken,
      Wrapped<String?>? secret,
      Wrapped<String?>? clientId,
      Wrapped<AccountsBalanceGetRequestOptions?>? options}) {
    return AccountsBalanceGetRequest(
        accessToken:
            (accessToken != null ? accessToken.value : this.accessToken),
        secret: (secret != null ? secret.value : this.secret),
        clientId: (clientId != null ? clientId.value : this.clientId),
        options: (options != null ? options.value : this.options));
  }
}

@JsonSerializable(explicitToJson: true)
class AccountsBalanceGetRequestOptions {
  AccountsBalanceGetRequestOptions({
    this.accountIds,
    this.minLastUpdatedDatetime,
  });

  factory AccountsBalanceGetRequestOptions.fromJson(
          Map<String, dynamic> json) =>
      _$AccountsBalanceGetRequestOptionsFromJson(json);

  @JsonKey(name: 'account_ids', defaultValue: <String>[])
  final List<String>? accountIds;
  @JsonKey(name: 'min_last_updated_datetime')
  final String? minLastUpdatedDatetime;
  static const fromJsonFactory = _$AccountsBalanceGetRequestOptionsFromJson;
  static const toJsonFactory = _$AccountsBalanceGetRequestOptionsToJson;
  Map<String, dynamic> toJson() =>
      _$AccountsBalanceGetRequestOptionsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AccountsBalanceGetRequestOptions &&
            (identical(other.accountIds, accountIds) ||
                const DeepCollectionEquality()
                    .equals(other.accountIds, accountIds)) &&
            (identical(other.minLastUpdatedDatetime, minLastUpdatedDatetime) ||
                const DeepCollectionEquality().equals(
                    other.minLastUpdatedDatetime, minLastUpdatedDatetime)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountIds) ^
      const DeepCollectionEquality().hash(minLastUpdatedDatetime) ^
      runtimeType.hashCode;
}

extension $AccountsBalanceGetRequestOptionsExtension
    on AccountsBalanceGetRequestOptions {
  AccountsBalanceGetRequestOptions copyWith(
      {List<String>? accountIds, String? minLastUpdatedDatetime}) {
    return AccountsBalanceGetRequestOptions(
        accountIds: accountIds ?? this.accountIds,
        minLastUpdatedDatetime:
            minLastUpdatedDatetime ?? this.minLastUpdatedDatetime);
  }

  AccountsBalanceGetRequestOptions copyWithWrapped(
      {Wrapped<List<String>?>? accountIds,
      Wrapped<String?>? minLastUpdatedDatetime}) {
    return AccountsBalanceGetRequestOptions(
        accountIds: (accountIds != null ? accountIds.value : this.accountIds),
        minLastUpdatedDatetime: (minLastUpdatedDatetime != null
            ? minLastUpdatedDatetime.value
            : this.minLastUpdatedDatetime));
  }
}

@JsonSerializable(explicitToJson: true)
class IdentityGetRequest {
  IdentityGetRequest({
    this.clientId,
    this.secret,
    required this.accessToken,
    this.options,
  });

  factory IdentityGetRequest.fromJson(Map<String, dynamic> json) =>
      _$IdentityGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'access_token')
  final String accessToken;
  @JsonKey(name: 'options')
  final IdentityGetRequestOptions? options;
  static const fromJsonFactory = _$IdentityGetRequestFromJson;
  static const toJsonFactory = _$IdentityGetRequestToJson;
  Map<String, dynamic> toJson() => _$IdentityGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IdentityGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)) &&
            (identical(other.options, options) ||
                const DeepCollectionEquality().equals(other.options, options)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(accessToken) ^
      const DeepCollectionEquality().hash(options) ^
      runtimeType.hashCode;
}

extension $IdentityGetRequestExtension on IdentityGetRequest {
  IdentityGetRequest copyWith(
      {String? clientId,
      String? secret,
      String? accessToken,
      IdentityGetRequestOptions? options}) {
    return IdentityGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        accessToken: accessToken ?? this.accessToken,
        options: options ?? this.options);
  }

  IdentityGetRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? accessToken,
      Wrapped<IdentityGetRequestOptions?>? options}) {
    return IdentityGetRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        accessToken:
            (accessToken != null ? accessToken.value : this.accessToken),
        options: (options != null ? options.value : this.options));
  }
}

@JsonSerializable(explicitToJson: true)
class IdentityGetRequestOptions {
  IdentityGetRequestOptions({
    this.accountIds,
  });

  factory IdentityGetRequestOptions.fromJson(Map<String, dynamic> json) =>
      _$IdentityGetRequestOptionsFromJson(json);

  @JsonKey(name: 'account_ids', defaultValue: <String>[])
  final List<String>? accountIds;
  static const fromJsonFactory = _$IdentityGetRequestOptionsFromJson;
  static const toJsonFactory = _$IdentityGetRequestOptionsToJson;
  Map<String, dynamic> toJson() => _$IdentityGetRequestOptionsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IdentityGetRequestOptions &&
            (identical(other.accountIds, accountIds) ||
                const DeepCollectionEquality()
                    .equals(other.accountIds, accountIds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountIds) ^ runtimeType.hashCode;
}

extension $IdentityGetRequestOptionsExtension on IdentityGetRequestOptions {
  IdentityGetRequestOptions copyWith({List<String>? accountIds}) {
    return IdentityGetRequestOptions(accountIds: accountIds ?? this.accountIds);
  }

  IdentityGetRequestOptions copyWithWrapped(
      {Wrapped<List<String>?>? accountIds}) {
    return IdentityGetRequestOptions(
        accountIds: (accountIds != null ? accountIds.value : this.accountIds));
  }
}

@JsonSerializable(explicitToJson: true)
class IdentityGetResponse {
  IdentityGetResponse({
    required this.accounts,
    required this.item,
    required this.requestId,
  });

  factory IdentityGetResponse.fromJson(Map<String, dynamic> json) =>
      _$IdentityGetResponseFromJson(json);

  @JsonKey(name: 'accounts', defaultValue: <AccountIdentity>[])
  final List<AccountIdentity> accounts;
  @JsonKey(name: 'item')
  final Item item;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$IdentityGetResponseFromJson;
  static const toJsonFactory = _$IdentityGetResponseToJson;
  Map<String, dynamic> toJson() => _$IdentityGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IdentityGetResponse &&
            (identical(other.accounts, accounts) ||
                const DeepCollectionEquality()
                    .equals(other.accounts, accounts)) &&
            (identical(other.item, item) ||
                const DeepCollectionEquality().equals(other.item, item)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accounts) ^
      const DeepCollectionEquality().hash(item) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $IdentityGetResponseExtension on IdentityGetResponse {
  IdentityGetResponse copyWith(
      {List<AccountIdentity>? accounts, Item? item, String? requestId}) {
    return IdentityGetResponse(
        accounts: accounts ?? this.accounts,
        item: item ?? this.item,
        requestId: requestId ?? this.requestId);
  }

  IdentityGetResponse copyWithWrapped(
      {Wrapped<List<AccountIdentity>>? accounts,
      Wrapped<Item>? item,
      Wrapped<String>? requestId}) {
    return IdentityGetResponse(
        accounts: (accounts != null ? accounts.value : this.accounts),
        item: (item != null ? item.value : this.item),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class IdentityMatchRequest {
  IdentityMatchRequest({
    this.clientId,
    this.secret,
    required this.accessToken,
    this.user,
    this.options,
  });

  factory IdentityMatchRequest.fromJson(Map<String, dynamic> json) =>
      _$IdentityMatchRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'access_token')
  final String accessToken;
  @JsonKey(name: 'user')
  final IdentityMatchUser? user;
  @JsonKey(name: 'options')
  final IdentityMatchRequestOptions? options;
  static const fromJsonFactory = _$IdentityMatchRequestFromJson;
  static const toJsonFactory = _$IdentityMatchRequestToJson;
  Map<String, dynamic> toJson() => _$IdentityMatchRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IdentityMatchRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)) &&
            (identical(other.user, user) ||
                const DeepCollectionEquality().equals(other.user, user)) &&
            (identical(other.options, options) ||
                const DeepCollectionEquality().equals(other.options, options)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(accessToken) ^
      const DeepCollectionEquality().hash(user) ^
      const DeepCollectionEquality().hash(options) ^
      runtimeType.hashCode;
}

extension $IdentityMatchRequestExtension on IdentityMatchRequest {
  IdentityMatchRequest copyWith(
      {String? clientId,
      String? secret,
      String? accessToken,
      IdentityMatchUser? user,
      IdentityMatchRequestOptions? options}) {
    return IdentityMatchRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        accessToken: accessToken ?? this.accessToken,
        user: user ?? this.user,
        options: options ?? this.options);
  }

  IdentityMatchRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? accessToken,
      Wrapped<IdentityMatchUser?>? user,
      Wrapped<IdentityMatchRequestOptions?>? options}) {
    return IdentityMatchRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        accessToken:
            (accessToken != null ? accessToken.value : this.accessToken),
        user: (user != null ? user.value : this.user),
        options: (options != null ? options.value : this.options));
  }
}

@JsonSerializable(explicitToJson: true)
class IdentityMatchRequestOptions {
  IdentityMatchRequestOptions({
    this.accountIds,
  });

  factory IdentityMatchRequestOptions.fromJson(Map<String, dynamic> json) =>
      _$IdentityMatchRequestOptionsFromJson(json);

  @JsonKey(name: 'account_ids', defaultValue: <String>[])
  final List<String>? accountIds;
  static const fromJsonFactory = _$IdentityMatchRequestOptionsFromJson;
  static const toJsonFactory = _$IdentityMatchRequestOptionsToJson;
  Map<String, dynamic> toJson() => _$IdentityMatchRequestOptionsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IdentityMatchRequestOptions &&
            (identical(other.accountIds, accountIds) ||
                const DeepCollectionEquality()
                    .equals(other.accountIds, accountIds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountIds) ^ runtimeType.hashCode;
}

extension $IdentityMatchRequestOptionsExtension on IdentityMatchRequestOptions {
  IdentityMatchRequestOptions copyWith({List<String>? accountIds}) {
    return IdentityMatchRequestOptions(
        accountIds: accountIds ?? this.accountIds);
  }

  IdentityMatchRequestOptions copyWithWrapped(
      {Wrapped<List<String>?>? accountIds}) {
    return IdentityMatchRequestOptions(
        accountIds: (accountIds != null ? accountIds.value : this.accountIds));
  }
}

@JsonSerializable(explicitToJson: true)
class IdentityMatchUser {
  IdentityMatchUser({
    this.legalName,
    this.phoneNumber,
    this.emailAddress,
    this.address,
  });

  factory IdentityMatchUser.fromJson(Map<String, dynamic> json) =>
      _$IdentityMatchUserFromJson(json);

  @JsonKey(name: 'legal_name')
  final String? legalName;
  @JsonKey(name: 'phone_number')
  final String? phoneNumber;
  @JsonKey(name: 'email_address')
  final String? emailAddress;
  @JsonKey(name: 'address')
  final AddressDataNullable? address;
  static const fromJsonFactory = _$IdentityMatchUserFromJson;
  static const toJsonFactory = _$IdentityMatchUserToJson;
  Map<String, dynamic> toJson() => _$IdentityMatchUserToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IdentityMatchUser &&
            (identical(other.legalName, legalName) ||
                const DeepCollectionEquality()
                    .equals(other.legalName, legalName)) &&
            (identical(other.phoneNumber, phoneNumber) ||
                const DeepCollectionEquality()
                    .equals(other.phoneNumber, phoneNumber)) &&
            (identical(other.emailAddress, emailAddress) ||
                const DeepCollectionEquality()
                    .equals(other.emailAddress, emailAddress)) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality().equals(other.address, address)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(legalName) ^
      const DeepCollectionEquality().hash(phoneNumber) ^
      const DeepCollectionEquality().hash(emailAddress) ^
      const DeepCollectionEquality().hash(address) ^
      runtimeType.hashCode;
}

extension $IdentityMatchUserExtension on IdentityMatchUser {
  IdentityMatchUser copyWith(
      {String? legalName,
      String? phoneNumber,
      String? emailAddress,
      AddressDataNullable? address}) {
    return IdentityMatchUser(
        legalName: legalName ?? this.legalName,
        phoneNumber: phoneNumber ?? this.phoneNumber,
        emailAddress: emailAddress ?? this.emailAddress,
        address: address ?? this.address);
  }

  IdentityMatchUser copyWithWrapped(
      {Wrapped<String?>? legalName,
      Wrapped<String?>? phoneNumber,
      Wrapped<String?>? emailAddress,
      Wrapped<AddressDataNullable?>? address}) {
    return IdentityMatchUser(
        legalName: (legalName != null ? legalName.value : this.legalName),
        phoneNumber:
            (phoneNumber != null ? phoneNumber.value : this.phoneNumber),
        emailAddress:
            (emailAddress != null ? emailAddress.value : this.emailAddress),
        address: (address != null ? address.value : this.address));
  }
}

@JsonSerializable(explicitToJson: true)
class IdentityMatchResponse {
  IdentityMatchResponse({
    required this.accounts,
    required this.item,
    required this.requestId,
  });

  factory IdentityMatchResponse.fromJson(Map<String, dynamic> json) =>
      _$IdentityMatchResponseFromJson(json);

  @JsonKey(name: 'accounts', defaultValue: <AccountIdentityMatchScore>[])
  final List<AccountIdentityMatchScore> accounts;
  @JsonKey(name: 'item')
  final Item item;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$IdentityMatchResponseFromJson;
  static const toJsonFactory = _$IdentityMatchResponseToJson;
  Map<String, dynamic> toJson() => _$IdentityMatchResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IdentityMatchResponse &&
            (identical(other.accounts, accounts) ||
                const DeepCollectionEquality()
                    .equals(other.accounts, accounts)) &&
            (identical(other.item, item) ||
                const DeepCollectionEquality().equals(other.item, item)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accounts) ^
      const DeepCollectionEquality().hash(item) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $IdentityMatchResponseExtension on IdentityMatchResponse {
  IdentityMatchResponse copyWith(
      {List<AccountIdentityMatchScore>? accounts,
      Item? item,
      String? requestId}) {
    return IdentityMatchResponse(
        accounts: accounts ?? this.accounts,
        item: item ?? this.item,
        requestId: requestId ?? this.requestId);
  }

  IdentityMatchResponse copyWithWrapped(
      {Wrapped<List<AccountIdentityMatchScore>>? accounts,
      Wrapped<Item>? item,
      Wrapped<String>? requestId}) {
    return IdentityMatchResponse(
        accounts: (accounts != null ? accounts.value : this.accounts),
        item: (item != null ? item.value : this.item),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class ProcessorAuthGetRequest {
  ProcessorAuthGetRequest({
    this.clientId,
    this.secret,
    required this.processorToken,
  });

  factory ProcessorAuthGetRequest.fromJson(Map<String, dynamic> json) =>
      _$ProcessorAuthGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'processor_token')
  final String processorToken;
  static const fromJsonFactory = _$ProcessorAuthGetRequestFromJson;
  static const toJsonFactory = _$ProcessorAuthGetRequestToJson;
  Map<String, dynamic> toJson() => _$ProcessorAuthGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ProcessorAuthGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.processorToken, processorToken) ||
                const DeepCollectionEquality()
                    .equals(other.processorToken, processorToken)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(processorToken) ^
      runtimeType.hashCode;
}

extension $ProcessorAuthGetRequestExtension on ProcessorAuthGetRequest {
  ProcessorAuthGetRequest copyWith(
      {String? clientId, String? secret, String? processorToken}) {
    return ProcessorAuthGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        processorToken: processorToken ?? this.processorToken);
  }

  ProcessorAuthGetRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? processorToken}) {
    return ProcessorAuthGetRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        processorToken: (processorToken != null
            ? processorToken.value
            : this.processorToken));
  }
}

@JsonSerializable(explicitToJson: true)
class ProcessorAuthGetResponse {
  ProcessorAuthGetResponse({
    required this.requestId,
    required this.numbers,
    required this.account,
  });

  factory ProcessorAuthGetResponse.fromJson(Map<String, dynamic> json) =>
      _$ProcessorAuthGetResponseFromJson(json);

  @JsonKey(name: 'request_id')
  final String requestId;
  @JsonKey(name: 'numbers')
  final ProcessorNumber numbers;
  @JsonKey(name: 'account')
  final AccountBase account;
  static const fromJsonFactory = _$ProcessorAuthGetResponseFromJson;
  static const toJsonFactory = _$ProcessorAuthGetResponseToJson;
  Map<String, dynamic> toJson() => _$ProcessorAuthGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ProcessorAuthGetResponse &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)) &&
            (identical(other.numbers, numbers) ||
                const DeepCollectionEquality()
                    .equals(other.numbers, numbers)) &&
            (identical(other.account, account) ||
                const DeepCollectionEquality().equals(other.account, account)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(requestId) ^
      const DeepCollectionEquality().hash(numbers) ^
      const DeepCollectionEquality().hash(account) ^
      runtimeType.hashCode;
}

extension $ProcessorAuthGetResponseExtension on ProcessorAuthGetResponse {
  ProcessorAuthGetResponse copyWith(
      {String? requestId, ProcessorNumber? numbers, AccountBase? account}) {
    return ProcessorAuthGetResponse(
        requestId: requestId ?? this.requestId,
        numbers: numbers ?? this.numbers,
        account: account ?? this.account);
  }

  ProcessorAuthGetResponse copyWithWrapped(
      {Wrapped<String>? requestId,
      Wrapped<ProcessorNumber>? numbers,
      Wrapped<AccountBase>? account}) {
    return ProcessorAuthGetResponse(
        requestId: (requestId != null ? requestId.value : this.requestId),
        numbers: (numbers != null ? numbers.value : this.numbers),
        account: (account != null ? account.value : this.account));
  }
}

@JsonSerializable(explicitToJson: true)
class ProcessorBankTransferCreateRequest {
  ProcessorBankTransferCreateRequest({
    this.clientId,
    this.secret,
    required this.idempotencyKey,
    required this.processorToken,
    required this.type,
    required this.network,
    required this.amount,
    required this.isoCurrencyCode,
    required this.description,
    this.achClass,
    required this.user,
    this.customTag,
    this.metadata,
    this.originationAccountId,
  });

  factory ProcessorBankTransferCreateRequest.fromJson(
          Map<String, dynamic> json) =>
      _$ProcessorBankTransferCreateRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'idempotency_key')
  final String idempotencyKey;
  @JsonKey(name: 'processor_token')
  final String processorToken;
  @JsonKey(
    name: 'type',
    toJson: bankTransferTypeToJson,
    fromJson: bankTransferTypeFromJson,
  )
  final enums.BankTransferType type;
  @JsonKey(
    name: 'network',
    toJson: bankTransferNetworkToJson,
    fromJson: bankTransferNetworkFromJson,
  )
  final enums.BankTransferNetwork network;
  @JsonKey(name: 'amount')
  final String amount;
  @JsonKey(name: 'iso_currency_code')
  final String isoCurrencyCode;
  @JsonKey(name: 'description')
  final String description;
  @JsonKey(
    name: 'ach_class',
    toJson: aCHClassToJson,
    fromJson: aCHClassFromJson,
  )
  final enums.ACHClass? achClass;
  @JsonKey(name: 'user')
  final BankTransferUser user;
  @JsonKey(name: 'custom_tag')
  final String? customTag;
  @JsonKey(name: 'metadata')
  final BankTransferMetadata? metadata;
  @JsonKey(name: 'origination_account_id')
  final String? originationAccountId;
  static const fromJsonFactory = _$ProcessorBankTransferCreateRequestFromJson;
  static const toJsonFactory = _$ProcessorBankTransferCreateRequestToJson;
  Map<String, dynamic> toJson() =>
      _$ProcessorBankTransferCreateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ProcessorBankTransferCreateRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.idempotencyKey, idempotencyKey) ||
                const DeepCollectionEquality()
                    .equals(other.idempotencyKey, idempotencyKey)) &&
            (identical(other.processorToken, processorToken) ||
                const DeepCollectionEquality()
                    .equals(other.processorToken, processorToken)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.network, network) ||
                const DeepCollectionEquality()
                    .equals(other.network, network)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.achClass, achClass) ||
                const DeepCollectionEquality()
                    .equals(other.achClass, achClass)) &&
            (identical(other.user, user) ||
                const DeepCollectionEquality().equals(other.user, user)) &&
            (identical(other.customTag, customTag) ||
                const DeepCollectionEquality()
                    .equals(other.customTag, customTag)) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality()
                    .equals(other.metadata, metadata)) &&
            (identical(other.originationAccountId, originationAccountId) ||
                const DeepCollectionEquality()
                    .equals(other.originationAccountId, originationAccountId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(idempotencyKey) ^
      const DeepCollectionEquality().hash(processorToken) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(network) ^
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(achClass) ^
      const DeepCollectionEquality().hash(user) ^
      const DeepCollectionEquality().hash(customTag) ^
      const DeepCollectionEquality().hash(metadata) ^
      const DeepCollectionEquality().hash(originationAccountId) ^
      runtimeType.hashCode;
}

extension $ProcessorBankTransferCreateRequestExtension
    on ProcessorBankTransferCreateRequest {
  ProcessorBankTransferCreateRequest copyWith(
      {String? clientId,
      String? secret,
      String? idempotencyKey,
      String? processorToken,
      enums.BankTransferType? type,
      enums.BankTransferNetwork? network,
      String? amount,
      String? isoCurrencyCode,
      String? description,
      enums.ACHClass? achClass,
      BankTransferUser? user,
      String? customTag,
      BankTransferMetadata? metadata,
      String? originationAccountId}) {
    return ProcessorBankTransferCreateRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        idempotencyKey: idempotencyKey ?? this.idempotencyKey,
        processorToken: processorToken ?? this.processorToken,
        type: type ?? this.type,
        network: network ?? this.network,
        amount: amount ?? this.amount,
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode,
        description: description ?? this.description,
        achClass: achClass ?? this.achClass,
        user: user ?? this.user,
        customTag: customTag ?? this.customTag,
        metadata: metadata ?? this.metadata,
        originationAccountId:
            originationAccountId ?? this.originationAccountId);
  }

  ProcessorBankTransferCreateRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? idempotencyKey,
      Wrapped<String>? processorToken,
      Wrapped<enums.BankTransferType>? type,
      Wrapped<enums.BankTransferNetwork>? network,
      Wrapped<String>? amount,
      Wrapped<String>? isoCurrencyCode,
      Wrapped<String>? description,
      Wrapped<enums.ACHClass?>? achClass,
      Wrapped<BankTransferUser>? user,
      Wrapped<String?>? customTag,
      Wrapped<BankTransferMetadata?>? metadata,
      Wrapped<String?>? originationAccountId}) {
    return ProcessorBankTransferCreateRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        idempotencyKey: (idempotencyKey != null
            ? idempotencyKey.value
            : this.idempotencyKey),
        processorToken: (processorToken != null
            ? processorToken.value
            : this.processorToken),
        type: (type != null ? type.value : this.type),
        network: (network != null ? network.value : this.network),
        amount: (amount != null ? amount.value : this.amount),
        isoCurrencyCode: (isoCurrencyCode != null
            ? isoCurrencyCode.value
            : this.isoCurrencyCode),
        description:
            (description != null ? description.value : this.description),
        achClass: (achClass != null ? achClass.value : this.achClass),
        user: (user != null ? user.value : this.user),
        customTag: (customTag != null ? customTag.value : this.customTag),
        metadata: (metadata != null ? metadata.value : this.metadata),
        originationAccountId: (originationAccountId != null
            ? originationAccountId.value
            : this.originationAccountId));
  }
}

@JsonSerializable(explicitToJson: true)
class ProcessorBankTransferCreateResponse {
  ProcessorBankTransferCreateResponse({
    required this.bankTransfer,
    required this.requestId,
  });

  factory ProcessorBankTransferCreateResponse.fromJson(
          Map<String, dynamic> json) =>
      _$ProcessorBankTransferCreateResponseFromJson(json);

  @JsonKey(name: 'bank_transfer')
  final BankTransfer bankTransfer;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$ProcessorBankTransferCreateResponseFromJson;
  static const toJsonFactory = _$ProcessorBankTransferCreateResponseToJson;
  Map<String, dynamic> toJson() =>
      _$ProcessorBankTransferCreateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ProcessorBankTransferCreateResponse &&
            (identical(other.bankTransfer, bankTransfer) ||
                const DeepCollectionEquality()
                    .equals(other.bankTransfer, bankTransfer)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(bankTransfer) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $ProcessorBankTransferCreateResponseExtension
    on ProcessorBankTransferCreateResponse {
  ProcessorBankTransferCreateResponse copyWith(
      {BankTransfer? bankTransfer, String? requestId}) {
    return ProcessorBankTransferCreateResponse(
        bankTransfer: bankTransfer ?? this.bankTransfer,
        requestId: requestId ?? this.requestId);
  }

  ProcessorBankTransferCreateResponse copyWithWrapped(
      {Wrapped<BankTransfer>? bankTransfer, Wrapped<String>? requestId}) {
    return ProcessorBankTransferCreateResponse(
        bankTransfer:
            (bankTransfer != null ? bankTransfer.value : this.bankTransfer),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class ProcessorNumber {
  ProcessorNumber({
    this.ach,
    this.eft,
    this.international,
    this.bacs,
  });

  factory ProcessorNumber.fromJson(Map<String, dynamic> json) =>
      _$ProcessorNumberFromJson(json);

  @JsonKey(name: 'ach')
  final NumbersACHNullable? ach;
  @JsonKey(name: 'eft')
  final NumbersEFTNullable? eft;
  @JsonKey(name: 'international')
  final NumbersInternationalNullable? international;
  @JsonKey(name: 'bacs')
  final NumbersBACSNullable? bacs;
  static const fromJsonFactory = _$ProcessorNumberFromJson;
  static const toJsonFactory = _$ProcessorNumberToJson;
  Map<String, dynamic> toJson() => _$ProcessorNumberToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ProcessorNumber &&
            (identical(other.ach, ach) ||
                const DeepCollectionEquality().equals(other.ach, ach)) &&
            (identical(other.eft, eft) ||
                const DeepCollectionEquality().equals(other.eft, eft)) &&
            (identical(other.international, international) ||
                const DeepCollectionEquality()
                    .equals(other.international, international)) &&
            (identical(other.bacs, bacs) ||
                const DeepCollectionEquality().equals(other.bacs, bacs)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ach) ^
      const DeepCollectionEquality().hash(eft) ^
      const DeepCollectionEquality().hash(international) ^
      const DeepCollectionEquality().hash(bacs) ^
      runtimeType.hashCode;
}

extension $ProcessorNumberExtension on ProcessorNumber {
  ProcessorNumber copyWith(
      {NumbersACHNullable? ach,
      NumbersEFTNullable? eft,
      NumbersInternationalNullable? international,
      NumbersBACSNullable? bacs}) {
    return ProcessorNumber(
        ach: ach ?? this.ach,
        eft: eft ?? this.eft,
        international: international ?? this.international,
        bacs: bacs ?? this.bacs);
  }

  ProcessorNumber copyWithWrapped(
      {Wrapped<NumbersACHNullable?>? ach,
      Wrapped<NumbersEFTNullable?>? eft,
      Wrapped<NumbersInternationalNullable?>? international,
      Wrapped<NumbersBACSNullable?>? bacs}) {
    return ProcessorNumber(
        ach: (ach != null ? ach.value : this.ach),
        eft: (eft != null ? eft.value : this.eft),
        international:
            (international != null ? international.value : this.international),
        bacs: (bacs != null ? bacs.value : this.bacs));
  }
}

@JsonSerializable(explicitToJson: true)
class ProcessorIdentityGetRequest {
  ProcessorIdentityGetRequest({
    this.clientId,
    this.secret,
    required this.processorToken,
  });

  factory ProcessorIdentityGetRequest.fromJson(Map<String, dynamic> json) =>
      _$ProcessorIdentityGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'processor_token')
  final String processorToken;
  static const fromJsonFactory = _$ProcessorIdentityGetRequestFromJson;
  static const toJsonFactory = _$ProcessorIdentityGetRequestToJson;
  Map<String, dynamic> toJson() => _$ProcessorIdentityGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ProcessorIdentityGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.processorToken, processorToken) ||
                const DeepCollectionEquality()
                    .equals(other.processorToken, processorToken)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(processorToken) ^
      runtimeType.hashCode;
}

extension $ProcessorIdentityGetRequestExtension on ProcessorIdentityGetRequest {
  ProcessorIdentityGetRequest copyWith(
      {String? clientId, String? secret, String? processorToken}) {
    return ProcessorIdentityGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        processorToken: processorToken ?? this.processorToken);
  }

  ProcessorIdentityGetRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? processorToken}) {
    return ProcessorIdentityGetRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        processorToken: (processorToken != null
            ? processorToken.value
            : this.processorToken));
  }
}

@JsonSerializable(explicitToJson: true)
class ProcessorIdentityGetResponse {
  ProcessorIdentityGetResponse({
    required this.account,
    required this.requestId,
  });

  factory ProcessorIdentityGetResponse.fromJson(Map<String, dynamic> json) =>
      _$ProcessorIdentityGetResponseFromJson(json);

  @JsonKey(name: 'account')
  final AccountIdentity account;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$ProcessorIdentityGetResponseFromJson;
  static const toJsonFactory = _$ProcessorIdentityGetResponseToJson;
  Map<String, dynamic> toJson() => _$ProcessorIdentityGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ProcessorIdentityGetResponse &&
            (identical(other.account, account) ||
                const DeepCollectionEquality()
                    .equals(other.account, account)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(account) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $ProcessorIdentityGetResponseExtension
    on ProcessorIdentityGetResponse {
  ProcessorIdentityGetResponse copyWith(
      {AccountIdentity? account, String? requestId}) {
    return ProcessorIdentityGetResponse(
        account: account ?? this.account,
        requestId: requestId ?? this.requestId);
  }

  ProcessorIdentityGetResponse copyWithWrapped(
      {Wrapped<AccountIdentity>? account, Wrapped<String>? requestId}) {
    return ProcessorIdentityGetResponse(
        account: (account != null ? account.value : this.account),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class ProcessorBalanceGetRequest {
  ProcessorBalanceGetRequest({
    this.clientId,
    this.secret,
    required this.processorToken,
    this.options,
  });

  factory ProcessorBalanceGetRequest.fromJson(Map<String, dynamic> json) =>
      _$ProcessorBalanceGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'processor_token')
  final String processorToken;
  @JsonKey(name: 'options')
  final ProcessorBalanceGetRequestOptions? options;
  static const fromJsonFactory = _$ProcessorBalanceGetRequestFromJson;
  static const toJsonFactory = _$ProcessorBalanceGetRequestToJson;
  Map<String, dynamic> toJson() => _$ProcessorBalanceGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ProcessorBalanceGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.processorToken, processorToken) ||
                const DeepCollectionEquality()
                    .equals(other.processorToken, processorToken)) &&
            (identical(other.options, options) ||
                const DeepCollectionEquality().equals(other.options, options)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(processorToken) ^
      const DeepCollectionEquality().hash(options) ^
      runtimeType.hashCode;
}

extension $ProcessorBalanceGetRequestExtension on ProcessorBalanceGetRequest {
  ProcessorBalanceGetRequest copyWith(
      {String? clientId,
      String? secret,
      String? processorToken,
      ProcessorBalanceGetRequestOptions? options}) {
    return ProcessorBalanceGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        processorToken: processorToken ?? this.processorToken,
        options: options ?? this.options);
  }

  ProcessorBalanceGetRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? processorToken,
      Wrapped<ProcessorBalanceGetRequestOptions?>? options}) {
    return ProcessorBalanceGetRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        processorToken: (processorToken != null
            ? processorToken.value
            : this.processorToken),
        options: (options != null ? options.value : this.options));
  }
}

@JsonSerializable(explicitToJson: true)
class ProcessorBalanceGetRequestOptions {
  ProcessorBalanceGetRequestOptions({
    this.minLastUpdatedDatetime,
  });

  factory ProcessorBalanceGetRequestOptions.fromJson(
          Map<String, dynamic> json) =>
      _$ProcessorBalanceGetRequestOptionsFromJson(json);

  @JsonKey(name: 'min_last_updated_datetime')
  final String? minLastUpdatedDatetime;
  static const fromJsonFactory = _$ProcessorBalanceGetRequestOptionsFromJson;
  static const toJsonFactory = _$ProcessorBalanceGetRequestOptionsToJson;
  Map<String, dynamic> toJson() =>
      _$ProcessorBalanceGetRequestOptionsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ProcessorBalanceGetRequestOptions &&
            (identical(other.minLastUpdatedDatetime, minLastUpdatedDatetime) ||
                const DeepCollectionEquality().equals(
                    other.minLastUpdatedDatetime, minLastUpdatedDatetime)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(minLastUpdatedDatetime) ^
      runtimeType.hashCode;
}

extension $ProcessorBalanceGetRequestOptionsExtension
    on ProcessorBalanceGetRequestOptions {
  ProcessorBalanceGetRequestOptions copyWith({String? minLastUpdatedDatetime}) {
    return ProcessorBalanceGetRequestOptions(
        minLastUpdatedDatetime:
            minLastUpdatedDatetime ?? this.minLastUpdatedDatetime);
  }

  ProcessorBalanceGetRequestOptions copyWithWrapped(
      {Wrapped<String?>? minLastUpdatedDatetime}) {
    return ProcessorBalanceGetRequestOptions(
        minLastUpdatedDatetime: (minLastUpdatedDatetime != null
            ? minLastUpdatedDatetime.value
            : this.minLastUpdatedDatetime));
  }
}

@JsonSerializable(explicitToJson: true)
class ProcessorBalanceGetResponse {
  ProcessorBalanceGetResponse({
    required this.account,
    required this.requestId,
  });

  factory ProcessorBalanceGetResponse.fromJson(Map<String, dynamic> json) =>
      _$ProcessorBalanceGetResponseFromJson(json);

  @JsonKey(name: 'account')
  final AccountBase account;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$ProcessorBalanceGetResponseFromJson;
  static const toJsonFactory = _$ProcessorBalanceGetResponseToJson;
  Map<String, dynamic> toJson() => _$ProcessorBalanceGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ProcessorBalanceGetResponse &&
            (identical(other.account, account) ||
                const DeepCollectionEquality()
                    .equals(other.account, account)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(account) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $ProcessorBalanceGetResponseExtension on ProcessorBalanceGetResponse {
  ProcessorBalanceGetResponse copyWith(
      {AccountBase? account, String? requestId}) {
    return ProcessorBalanceGetResponse(
        account: account ?? this.account,
        requestId: requestId ?? this.requestId);
  }

  ProcessorBalanceGetResponse copyWithWrapped(
      {Wrapped<AccountBase>? account, Wrapped<String>? requestId}) {
    return ProcessorBalanceGetResponse(
        account: (account != null ? account.value : this.account),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class WebhookVerificationKeyGetRequest {
  WebhookVerificationKeyGetRequest({
    this.clientId,
    this.secret,
    required this.keyId,
  });

  factory WebhookVerificationKeyGetRequest.fromJson(
          Map<String, dynamic> json) =>
      _$WebhookVerificationKeyGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'key_id')
  final String keyId;
  static const fromJsonFactory = _$WebhookVerificationKeyGetRequestFromJson;
  static const toJsonFactory = _$WebhookVerificationKeyGetRequestToJson;
  Map<String, dynamic> toJson() =>
      _$WebhookVerificationKeyGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WebhookVerificationKeyGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.keyId, keyId) ||
                const DeepCollectionEquality().equals(other.keyId, keyId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(keyId) ^
      runtimeType.hashCode;
}

extension $WebhookVerificationKeyGetRequestExtension
    on WebhookVerificationKeyGetRequest {
  WebhookVerificationKeyGetRequest copyWith(
      {String? clientId, String? secret, String? keyId}) {
    return WebhookVerificationKeyGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        keyId: keyId ?? this.keyId);
  }

  WebhookVerificationKeyGetRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? keyId}) {
    return WebhookVerificationKeyGetRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        keyId: (keyId != null ? keyId.value : this.keyId));
  }
}

@JsonSerializable(explicitToJson: true)
class WebhookVerificationKeyGetResponse {
  WebhookVerificationKeyGetResponse({
    required this.key,
    required this.requestId,
  });

  factory WebhookVerificationKeyGetResponse.fromJson(
          Map<String, dynamic> json) =>
      _$WebhookVerificationKeyGetResponseFromJson(json);

  @JsonKey(name: 'key')
  final JWKPublicKey key;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$WebhookVerificationKeyGetResponseFromJson;
  static const toJsonFactory = _$WebhookVerificationKeyGetResponseToJson;
  Map<String, dynamic> toJson() =>
      _$WebhookVerificationKeyGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WebhookVerificationKeyGetResponse &&
            (identical(other.key, key) ||
                const DeepCollectionEquality().equals(other.key, key)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(key) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $WebhookVerificationKeyGetResponseExtension
    on WebhookVerificationKeyGetResponse {
  WebhookVerificationKeyGetResponse copyWith(
      {JWKPublicKey? key, String? requestId}) {
    return WebhookVerificationKeyGetResponse(
        key: key ?? this.key, requestId: requestId ?? this.requestId);
  }

  WebhookVerificationKeyGetResponse copyWithWrapped(
      {Wrapped<JWKPublicKey>? key, Wrapped<String>? requestId}) {
    return WebhookVerificationKeyGetResponse(
        key: (key != null ? key.value : this.key),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class JWKPublicKey {
  JWKPublicKey({
    required this.alg,
    required this.crv,
    required this.kid,
    required this.kty,
    required this.use,
    required this.x,
    required this.y,
    required this.createdAt,
    required this.expiredAt,
  });

  factory JWKPublicKey.fromJson(Map<String, dynamic> json) =>
      _$JWKPublicKeyFromJson(json);

  @JsonKey(name: 'alg')
  final String alg;
  @JsonKey(name: 'crv')
  final String crv;
  @JsonKey(name: 'kid')
  final String kid;
  @JsonKey(name: 'kty')
  final String kty;
  @JsonKey(name: 'use')
  final String use;
  @JsonKey(name: 'x')
  final String x;
  @JsonKey(name: 'y')
  final String y;
  @JsonKey(name: 'created_at')
  final int createdAt;
  @JsonKey(name: 'expired_at')
  final int? expiredAt;
  static const fromJsonFactory = _$JWKPublicKeyFromJson;
  static const toJsonFactory = _$JWKPublicKeyToJson;
  Map<String, dynamic> toJson() => _$JWKPublicKeyToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is JWKPublicKey &&
            (identical(other.alg, alg) ||
                const DeepCollectionEquality().equals(other.alg, alg)) &&
            (identical(other.crv, crv) ||
                const DeepCollectionEquality().equals(other.crv, crv)) &&
            (identical(other.kid, kid) ||
                const DeepCollectionEquality().equals(other.kid, kid)) &&
            (identical(other.kty, kty) ||
                const DeepCollectionEquality().equals(other.kty, kty)) &&
            (identical(other.use, use) ||
                const DeepCollectionEquality().equals(other.use, use)) &&
            (identical(other.x, x) ||
                const DeepCollectionEquality().equals(other.x, x)) &&
            (identical(other.y, y) ||
                const DeepCollectionEquality().equals(other.y, y)) &&
            (identical(other.createdAt, createdAt) ||
                const DeepCollectionEquality()
                    .equals(other.createdAt, createdAt)) &&
            (identical(other.expiredAt, expiredAt) ||
                const DeepCollectionEquality()
                    .equals(other.expiredAt, expiredAt)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(alg) ^
      const DeepCollectionEquality().hash(crv) ^
      const DeepCollectionEquality().hash(kid) ^
      const DeepCollectionEquality().hash(kty) ^
      const DeepCollectionEquality().hash(use) ^
      const DeepCollectionEquality().hash(x) ^
      const DeepCollectionEquality().hash(y) ^
      const DeepCollectionEquality().hash(createdAt) ^
      const DeepCollectionEquality().hash(expiredAt) ^
      runtimeType.hashCode;
}

extension $JWKPublicKeyExtension on JWKPublicKey {
  JWKPublicKey copyWith(
      {String? alg,
      String? crv,
      String? kid,
      String? kty,
      String? use,
      String? x,
      String? y,
      int? createdAt,
      int? expiredAt}) {
    return JWKPublicKey(
        alg: alg ?? this.alg,
        crv: crv ?? this.crv,
        kid: kid ?? this.kid,
        kty: kty ?? this.kty,
        use: use ?? this.use,
        x: x ?? this.x,
        y: y ?? this.y,
        createdAt: createdAt ?? this.createdAt,
        expiredAt: expiredAt ?? this.expiredAt);
  }

  JWKPublicKey copyWithWrapped(
      {Wrapped<String>? alg,
      Wrapped<String>? crv,
      Wrapped<String>? kid,
      Wrapped<String>? kty,
      Wrapped<String>? use,
      Wrapped<String>? x,
      Wrapped<String>? y,
      Wrapped<int>? createdAt,
      Wrapped<int?>? expiredAt}) {
    return JWKPublicKey(
        alg: (alg != null ? alg.value : this.alg),
        crv: (crv != null ? crv.value : this.crv),
        kid: (kid != null ? kid.value : this.kid),
        kty: (kty != null ? kty.value : this.kty),
        use: (use != null ? use.value : this.use),
        x: (x != null ? x.value : this.x),
        y: (y != null ? y.value : this.y),
        createdAt: (createdAt != null ? createdAt.value : this.createdAt),
        expiredAt: (expiredAt != null ? expiredAt.value : this.expiredAt));
  }
}

@JsonSerializable(explicitToJson: true)
class LiabilitiesGetRequest {
  LiabilitiesGetRequest({
    this.clientId,
    this.secret,
    required this.accessToken,
    this.options,
  });

  factory LiabilitiesGetRequest.fromJson(Map<String, dynamic> json) =>
      _$LiabilitiesGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'access_token')
  final String accessToken;
  @JsonKey(name: 'options')
  final LiabilitiesGetRequestOptions? options;
  static const fromJsonFactory = _$LiabilitiesGetRequestFromJson;
  static const toJsonFactory = _$LiabilitiesGetRequestToJson;
  Map<String, dynamic> toJson() => _$LiabilitiesGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LiabilitiesGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)) &&
            (identical(other.options, options) ||
                const DeepCollectionEquality().equals(other.options, options)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(accessToken) ^
      const DeepCollectionEquality().hash(options) ^
      runtimeType.hashCode;
}

extension $LiabilitiesGetRequestExtension on LiabilitiesGetRequest {
  LiabilitiesGetRequest copyWith(
      {String? clientId,
      String? secret,
      String? accessToken,
      LiabilitiesGetRequestOptions? options}) {
    return LiabilitiesGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        accessToken: accessToken ?? this.accessToken,
        options: options ?? this.options);
  }

  LiabilitiesGetRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? accessToken,
      Wrapped<LiabilitiesGetRequestOptions?>? options}) {
    return LiabilitiesGetRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        accessToken:
            (accessToken != null ? accessToken.value : this.accessToken),
        options: (options != null ? options.value : this.options));
  }
}

@JsonSerializable(explicitToJson: true)
class LiabilitiesGetRequestOptions {
  LiabilitiesGetRequestOptions({
    this.accountIds,
  });

  factory LiabilitiesGetRequestOptions.fromJson(Map<String, dynamic> json) =>
      _$LiabilitiesGetRequestOptionsFromJson(json);

  @JsonKey(name: 'account_ids', defaultValue: <String>[])
  final List<String>? accountIds;
  static const fromJsonFactory = _$LiabilitiesGetRequestOptionsFromJson;
  static const toJsonFactory = _$LiabilitiesGetRequestOptionsToJson;
  Map<String, dynamic> toJson() => _$LiabilitiesGetRequestOptionsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LiabilitiesGetRequestOptions &&
            (identical(other.accountIds, accountIds) ||
                const DeepCollectionEquality()
                    .equals(other.accountIds, accountIds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountIds) ^ runtimeType.hashCode;
}

extension $LiabilitiesGetRequestOptionsExtension
    on LiabilitiesGetRequestOptions {
  LiabilitiesGetRequestOptions copyWith({List<String>? accountIds}) {
    return LiabilitiesGetRequestOptions(
        accountIds: accountIds ?? this.accountIds);
  }

  LiabilitiesGetRequestOptions copyWithWrapped(
      {Wrapped<List<String>?>? accountIds}) {
    return LiabilitiesGetRequestOptions(
        accountIds: (accountIds != null ? accountIds.value : this.accountIds));
  }
}

@JsonSerializable(explicitToJson: true)
class LiabilitiesGetResponse {
  LiabilitiesGetResponse({
    required this.accounts,
    required this.item,
    required this.liabilities,
    required this.requestId,
  });

  factory LiabilitiesGetResponse.fromJson(Map<String, dynamic> json) =>
      _$LiabilitiesGetResponseFromJson(json);

  @JsonKey(name: 'accounts', defaultValue: <AccountBase>[])
  final List<AccountBase> accounts;
  @JsonKey(name: 'item')
  final Item item;
  @JsonKey(name: 'liabilities')
  final LiabilitiesObject liabilities;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$LiabilitiesGetResponseFromJson;
  static const toJsonFactory = _$LiabilitiesGetResponseToJson;
  Map<String, dynamic> toJson() => _$LiabilitiesGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LiabilitiesGetResponse &&
            (identical(other.accounts, accounts) ||
                const DeepCollectionEquality()
                    .equals(other.accounts, accounts)) &&
            (identical(other.item, item) ||
                const DeepCollectionEquality().equals(other.item, item)) &&
            (identical(other.liabilities, liabilities) ||
                const DeepCollectionEquality()
                    .equals(other.liabilities, liabilities)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accounts) ^
      const DeepCollectionEquality().hash(item) ^
      const DeepCollectionEquality().hash(liabilities) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $LiabilitiesGetResponseExtension on LiabilitiesGetResponse {
  LiabilitiesGetResponse copyWith(
      {List<AccountBase>? accounts,
      Item? item,
      LiabilitiesObject? liabilities,
      String? requestId}) {
    return LiabilitiesGetResponse(
        accounts: accounts ?? this.accounts,
        item: item ?? this.item,
        liabilities: liabilities ?? this.liabilities,
        requestId: requestId ?? this.requestId);
  }

  LiabilitiesGetResponse copyWithWrapped(
      {Wrapped<List<AccountBase>>? accounts,
      Wrapped<Item>? item,
      Wrapped<LiabilitiesObject>? liabilities,
      Wrapped<String>? requestId}) {
    return LiabilitiesGetResponse(
        accounts: (accounts != null ? accounts.value : this.accounts),
        item: (item != null ? item.value : this.item),
        liabilities:
            (liabilities != null ? liabilities.value : this.liabilities),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentInitiationRecipientCreateRequest {
  PaymentInitiationRecipientCreateRequest({
    this.clientId,
    this.secret,
    required this.name,
    this.iban,
    this.bacs,
    this.address,
  });

  factory PaymentInitiationRecipientCreateRequest.fromJson(
          Map<String, dynamic> json) =>
      _$PaymentInitiationRecipientCreateRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'iban')
  final String? iban;
  @JsonKey(name: 'bacs')
  final RecipientBACSNullable? bacs;
  @JsonKey(name: 'address')
  final PaymentInitiationAddress? address;
  static const fromJsonFactory =
      _$PaymentInitiationRecipientCreateRequestFromJson;
  static const toJsonFactory = _$PaymentInitiationRecipientCreateRequestToJson;
  Map<String, dynamic> toJson() =>
      _$PaymentInitiationRecipientCreateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentInitiationRecipientCreateRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.iban, iban) ||
                const DeepCollectionEquality().equals(other.iban, iban)) &&
            (identical(other.bacs, bacs) ||
                const DeepCollectionEquality().equals(other.bacs, bacs)) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality().equals(other.address, address)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(iban) ^
      const DeepCollectionEquality().hash(bacs) ^
      const DeepCollectionEquality().hash(address) ^
      runtimeType.hashCode;
}

extension $PaymentInitiationRecipientCreateRequestExtension
    on PaymentInitiationRecipientCreateRequest {
  PaymentInitiationRecipientCreateRequest copyWith(
      {String? clientId,
      String? secret,
      String? name,
      String? iban,
      RecipientBACSNullable? bacs,
      PaymentInitiationAddress? address}) {
    return PaymentInitiationRecipientCreateRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        name: name ?? this.name,
        iban: iban ?? this.iban,
        bacs: bacs ?? this.bacs,
        address: address ?? this.address);
  }

  PaymentInitiationRecipientCreateRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? name,
      Wrapped<String?>? iban,
      Wrapped<RecipientBACSNullable?>? bacs,
      Wrapped<PaymentInitiationAddress?>? address}) {
    return PaymentInitiationRecipientCreateRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        name: (name != null ? name.value : this.name),
        iban: (iban != null ? iban.value : this.iban),
        bacs: (bacs != null ? bacs.value : this.bacs),
        address: (address != null ? address.value : this.address));
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentInitiationRecipientCreateResponse {
  PaymentInitiationRecipientCreateResponse({
    required this.recipientId,
    required this.requestId,
  });

  factory PaymentInitiationRecipientCreateResponse.fromJson(
          Map<String, dynamic> json) =>
      _$PaymentInitiationRecipientCreateResponseFromJson(json);

  @JsonKey(name: 'recipient_id')
  final String recipientId;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory =
      _$PaymentInitiationRecipientCreateResponseFromJson;
  static const toJsonFactory = _$PaymentInitiationRecipientCreateResponseToJson;
  Map<String, dynamic> toJson() =>
      _$PaymentInitiationRecipientCreateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentInitiationRecipientCreateResponse &&
            (identical(other.recipientId, recipientId) ||
                const DeepCollectionEquality()
                    .equals(other.recipientId, recipientId)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(recipientId) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $PaymentInitiationRecipientCreateResponseExtension
    on PaymentInitiationRecipientCreateResponse {
  PaymentInitiationRecipientCreateResponse copyWith(
      {String? recipientId, String? requestId}) {
    return PaymentInitiationRecipientCreateResponse(
        recipientId: recipientId ?? this.recipientId,
        requestId: requestId ?? this.requestId);
  }

  PaymentInitiationRecipientCreateResponse copyWithWrapped(
      {Wrapped<String>? recipientId, Wrapped<String>? requestId}) {
    return PaymentInitiationRecipientCreateResponse(
        recipientId:
            (recipientId != null ? recipientId.value : this.recipientId),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentInitiationPaymentReverseResponse {
  PaymentInitiationPaymentReverseResponse({
    required this.refundId,
    required this.status,
    required this.requestId,
  });

  factory PaymentInitiationPaymentReverseResponse.fromJson(
          Map<String, dynamic> json) =>
      _$PaymentInitiationPaymentReverseResponseFromJson(json);

  @JsonKey(name: 'refund_id')
  final String refundId;
  @JsonKey(
    name: 'status',
    toJson: walletTransactionStatusToJson,
    fromJson: walletTransactionStatusFromJson,
  )
  final enums.WalletTransactionStatus status;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory =
      _$PaymentInitiationPaymentReverseResponseFromJson;
  static const toJsonFactory = _$PaymentInitiationPaymentReverseResponseToJson;
  Map<String, dynamic> toJson() =>
      _$PaymentInitiationPaymentReverseResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentInitiationPaymentReverseResponse &&
            (identical(other.refundId, refundId) ||
                const DeepCollectionEquality()
                    .equals(other.refundId, refundId)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(refundId) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $PaymentInitiationPaymentReverseResponseExtension
    on PaymentInitiationPaymentReverseResponse {
  PaymentInitiationPaymentReverseResponse copyWith(
      {String? refundId,
      enums.WalletTransactionStatus? status,
      String? requestId}) {
    return PaymentInitiationPaymentReverseResponse(
        refundId: refundId ?? this.refundId,
        status: status ?? this.status,
        requestId: requestId ?? this.requestId);
  }

  PaymentInitiationPaymentReverseResponse copyWithWrapped(
      {Wrapped<String>? refundId,
      Wrapped<enums.WalletTransactionStatus>? status,
      Wrapped<String>? requestId}) {
    return PaymentInitiationPaymentReverseResponse(
        refundId: (refundId != null ? refundId.value : this.refundId),
        status: (status != null ? status.value : this.status),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentInitiationRecipientGetRequest {
  PaymentInitiationRecipientGetRequest({
    this.clientId,
    this.secret,
    required this.recipientId,
  });

  factory PaymentInitiationRecipientGetRequest.fromJson(
          Map<String, dynamic> json) =>
      _$PaymentInitiationRecipientGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'recipient_id')
  final String recipientId;
  static const fromJsonFactory = _$PaymentInitiationRecipientGetRequestFromJson;
  static const toJsonFactory = _$PaymentInitiationRecipientGetRequestToJson;
  Map<String, dynamic> toJson() =>
      _$PaymentInitiationRecipientGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentInitiationRecipientGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.recipientId, recipientId) ||
                const DeepCollectionEquality()
                    .equals(other.recipientId, recipientId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(recipientId) ^
      runtimeType.hashCode;
}

extension $PaymentInitiationRecipientGetRequestExtension
    on PaymentInitiationRecipientGetRequest {
  PaymentInitiationRecipientGetRequest copyWith(
      {String? clientId, String? secret, String? recipientId}) {
    return PaymentInitiationRecipientGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        recipientId: recipientId ?? this.recipientId);
  }

  PaymentInitiationRecipientGetRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? recipientId}) {
    return PaymentInitiationRecipientGetRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        recipientId:
            (recipientId != null ? recipientId.value : this.recipientId));
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentInitiationRecipientGetResponse {
  PaymentInitiationRecipientGetResponse({
    required this.requestId,
    required this.recipientId,
    required this.name,
    this.address,
    this.iban,
    this.bacs,
  });

  factory PaymentInitiationRecipientGetResponse.fromJson(
          Map<String, dynamic> json) =>
      _$PaymentInitiationRecipientGetResponseFromJson(json);

  @JsonKey(name: 'request_id')
  final String requestId;
  @JsonKey(name: 'recipient_id')
  final String recipientId;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'address')
  final PaymentInitiationAddress? address;
  @JsonKey(name: 'iban')
  final String? iban;
  @JsonKey(name: 'bacs')
  final RecipientBACSNullable? bacs;
  static const fromJsonFactory =
      _$PaymentInitiationRecipientGetResponseFromJson;
  static const toJsonFactory = _$PaymentInitiationRecipientGetResponseToJson;
  Map<String, dynamic> toJson() =>
      _$PaymentInitiationRecipientGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentInitiationRecipientGetResponse &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)) &&
            (identical(other.recipientId, recipientId) ||
                const DeepCollectionEquality()
                    .equals(other.recipientId, recipientId)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality()
                    .equals(other.address, address)) &&
            (identical(other.iban, iban) ||
                const DeepCollectionEquality().equals(other.iban, iban)) &&
            (identical(other.bacs, bacs) ||
                const DeepCollectionEquality().equals(other.bacs, bacs)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(requestId) ^
      const DeepCollectionEquality().hash(recipientId) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(iban) ^
      const DeepCollectionEquality().hash(bacs) ^
      runtimeType.hashCode;
}

extension $PaymentInitiationRecipientGetResponseExtension
    on PaymentInitiationRecipientGetResponse {
  PaymentInitiationRecipientGetResponse copyWith(
      {String? requestId,
      String? recipientId,
      String? name,
      PaymentInitiationAddress? address,
      String? iban,
      RecipientBACSNullable? bacs}) {
    return PaymentInitiationRecipientGetResponse(
        requestId: requestId ?? this.requestId,
        recipientId: recipientId ?? this.recipientId,
        name: name ?? this.name,
        address: address ?? this.address,
        iban: iban ?? this.iban,
        bacs: bacs ?? this.bacs);
  }

  PaymentInitiationRecipientGetResponse copyWithWrapped(
      {Wrapped<String>? requestId,
      Wrapped<String>? recipientId,
      Wrapped<String>? name,
      Wrapped<PaymentInitiationAddress?>? address,
      Wrapped<String?>? iban,
      Wrapped<RecipientBACSNullable?>? bacs}) {
    return PaymentInitiationRecipientGetResponse(
        requestId: (requestId != null ? requestId.value : this.requestId),
        recipientId:
            (recipientId != null ? recipientId.value : this.recipientId),
        name: (name != null ? name.value : this.name),
        address: (address != null ? address.value : this.address),
        iban: (iban != null ? iban.value : this.iban),
        bacs: (bacs != null ? bacs.value : this.bacs));
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentInitiationRecipient {
  PaymentInitiationRecipient({
    required this.recipientId,
    required this.name,
    this.address,
    this.iban,
    this.bacs,
  });

  factory PaymentInitiationRecipient.fromJson(Map<String, dynamic> json) =>
      _$PaymentInitiationRecipientFromJson(json);

  @JsonKey(name: 'recipient_id')
  final String recipientId;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'address')
  final PaymentInitiationAddress? address;
  @JsonKey(name: 'iban')
  final String? iban;
  @JsonKey(name: 'bacs')
  final RecipientBACSNullable? bacs;
  static const fromJsonFactory = _$PaymentInitiationRecipientFromJson;
  static const toJsonFactory = _$PaymentInitiationRecipientToJson;
  Map<String, dynamic> toJson() => _$PaymentInitiationRecipientToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentInitiationRecipient &&
            (identical(other.recipientId, recipientId) ||
                const DeepCollectionEquality()
                    .equals(other.recipientId, recipientId)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality()
                    .equals(other.address, address)) &&
            (identical(other.iban, iban) ||
                const DeepCollectionEquality().equals(other.iban, iban)) &&
            (identical(other.bacs, bacs) ||
                const DeepCollectionEquality().equals(other.bacs, bacs)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(recipientId) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(iban) ^
      const DeepCollectionEquality().hash(bacs) ^
      runtimeType.hashCode;
}

extension $PaymentInitiationRecipientExtension on PaymentInitiationRecipient {
  PaymentInitiationRecipient copyWith(
      {String? recipientId,
      String? name,
      PaymentInitiationAddress? address,
      String? iban,
      RecipientBACSNullable? bacs}) {
    return PaymentInitiationRecipient(
        recipientId: recipientId ?? this.recipientId,
        name: name ?? this.name,
        address: address ?? this.address,
        iban: iban ?? this.iban,
        bacs: bacs ?? this.bacs);
  }

  PaymentInitiationRecipient copyWithWrapped(
      {Wrapped<String>? recipientId,
      Wrapped<String>? name,
      Wrapped<PaymentInitiationAddress?>? address,
      Wrapped<String?>? iban,
      Wrapped<RecipientBACSNullable?>? bacs}) {
    return PaymentInitiationRecipient(
        recipientId:
            (recipientId != null ? recipientId.value : this.recipientId),
        name: (name != null ? name.value : this.name),
        address: (address != null ? address.value : this.address),
        iban: (iban != null ? iban.value : this.iban),
        bacs: (bacs != null ? bacs.value : this.bacs));
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentInitiationRecipientListRequest {
  PaymentInitiationRecipientListRequest({
    this.clientId,
    this.secret,
  });

  factory PaymentInitiationRecipientListRequest.fromJson(
          Map<String, dynamic> json) =>
      _$PaymentInitiationRecipientListRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  static const fromJsonFactory =
      _$PaymentInitiationRecipientListRequestFromJson;
  static const toJsonFactory = _$PaymentInitiationRecipientListRequestToJson;
  Map<String, dynamic> toJson() =>
      _$PaymentInitiationRecipientListRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentInitiationRecipientListRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      runtimeType.hashCode;
}

extension $PaymentInitiationRecipientListRequestExtension
    on PaymentInitiationRecipientListRequest {
  PaymentInitiationRecipientListRequest copyWith(
      {String? clientId, String? secret}) {
    return PaymentInitiationRecipientListRequest(
        clientId: clientId ?? this.clientId, secret: secret ?? this.secret);
  }

  PaymentInitiationRecipientListRequest copyWithWrapped(
      {Wrapped<String?>? clientId, Wrapped<String?>? secret}) {
    return PaymentInitiationRecipientListRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret));
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentInitiationRecipientListResponse {
  PaymentInitiationRecipientListResponse({
    required this.recipients,
    required this.requestId,
  });

  factory PaymentInitiationRecipientListResponse.fromJson(
          Map<String, dynamic> json) =>
      _$PaymentInitiationRecipientListResponseFromJson(json);

  @JsonKey(name: 'recipients', defaultValue: <PaymentInitiationRecipient>[])
  final List<PaymentInitiationRecipient> recipients;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory =
      _$PaymentInitiationRecipientListResponseFromJson;
  static const toJsonFactory = _$PaymentInitiationRecipientListResponseToJson;
  Map<String, dynamic> toJson() =>
      _$PaymentInitiationRecipientListResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentInitiationRecipientListResponse &&
            (identical(other.recipients, recipients) ||
                const DeepCollectionEquality()
                    .equals(other.recipients, recipients)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(recipients) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $PaymentInitiationRecipientListResponseExtension
    on PaymentInitiationRecipientListResponse {
  PaymentInitiationRecipientListResponse copyWith(
      {List<PaymentInitiationRecipient>? recipients, String? requestId}) {
    return PaymentInitiationRecipientListResponse(
        recipients: recipients ?? this.recipients,
        requestId: requestId ?? this.requestId);
  }

  PaymentInitiationRecipientListResponse copyWithWrapped(
      {Wrapped<List<PaymentInitiationRecipient>>? recipients,
      Wrapped<String>? requestId}) {
    return PaymentInitiationRecipientListResponse(
        recipients: (recipients != null ? recipients.value : this.recipients),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentInitiationPaymentCreateRequest {
  PaymentInitiationPaymentCreateRequest({
    this.clientId,
    this.secret,
    required this.recipientId,
    required this.reference,
    required this.amount,
    this.schedule,
    this.options,
  });

  factory PaymentInitiationPaymentCreateRequest.fromJson(
          Map<String, dynamic> json) =>
      _$PaymentInitiationPaymentCreateRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'recipient_id')
  final String recipientId;
  @JsonKey(name: 'reference')
  final String reference;
  @JsonKey(name: 'amount')
  final PaymentAmount amount;
  @JsonKey(name: 'schedule')
  final ExternalPaymentScheduleRequest? schedule;
  @JsonKey(name: 'options')
  final ExternalPaymentOptions? options;
  static const fromJsonFactory =
      _$PaymentInitiationPaymentCreateRequestFromJson;
  static const toJsonFactory = _$PaymentInitiationPaymentCreateRequestToJson;
  Map<String, dynamic> toJson() =>
      _$PaymentInitiationPaymentCreateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentInitiationPaymentCreateRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.recipientId, recipientId) ||
                const DeepCollectionEquality()
                    .equals(other.recipientId, recipientId)) &&
            (identical(other.reference, reference) ||
                const DeepCollectionEquality()
                    .equals(other.reference, reference)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.schedule, schedule) ||
                const DeepCollectionEquality()
                    .equals(other.schedule, schedule)) &&
            (identical(other.options, options) ||
                const DeepCollectionEquality().equals(other.options, options)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(recipientId) ^
      const DeepCollectionEquality().hash(reference) ^
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(schedule) ^
      const DeepCollectionEquality().hash(options) ^
      runtimeType.hashCode;
}

extension $PaymentInitiationPaymentCreateRequestExtension
    on PaymentInitiationPaymentCreateRequest {
  PaymentInitiationPaymentCreateRequest copyWith(
      {String? clientId,
      String? secret,
      String? recipientId,
      String? reference,
      PaymentAmount? amount,
      ExternalPaymentScheduleRequest? schedule,
      ExternalPaymentOptions? options}) {
    return PaymentInitiationPaymentCreateRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        recipientId: recipientId ?? this.recipientId,
        reference: reference ?? this.reference,
        amount: amount ?? this.amount,
        schedule: schedule ?? this.schedule,
        options: options ?? this.options);
  }

  PaymentInitiationPaymentCreateRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? recipientId,
      Wrapped<String>? reference,
      Wrapped<PaymentAmount>? amount,
      Wrapped<ExternalPaymentScheduleRequest?>? schedule,
      Wrapped<ExternalPaymentOptions?>? options}) {
    return PaymentInitiationPaymentCreateRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        recipientId:
            (recipientId != null ? recipientId.value : this.recipientId),
        reference: (reference != null ? reference.value : this.reference),
        amount: (amount != null ? amount.value : this.amount),
        schedule: (schedule != null ? schedule.value : this.schedule),
        options: (options != null ? options.value : this.options));
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentInitiationPaymentReverseRequest {
  PaymentInitiationPaymentReverseRequest({
    this.clientId,
    this.secret,
    required this.paymentId,
    required this.idempotencyKey,
    required this.reference,
    this.amount,
  });

  factory PaymentInitiationPaymentReverseRequest.fromJson(
          Map<String, dynamic> json) =>
      _$PaymentInitiationPaymentReverseRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'payment_id')
  final String paymentId;
  @JsonKey(name: 'idempotency_key')
  final String idempotencyKey;
  @JsonKey(name: 'reference')
  final String reference;
  @JsonKey(name: 'amount')
  final PaymentAmountToRefund? amount;
  static const fromJsonFactory =
      _$PaymentInitiationPaymentReverseRequestFromJson;
  static const toJsonFactory = _$PaymentInitiationPaymentReverseRequestToJson;
  Map<String, dynamic> toJson() =>
      _$PaymentInitiationPaymentReverseRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentInitiationPaymentReverseRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.paymentId, paymentId) ||
                const DeepCollectionEquality()
                    .equals(other.paymentId, paymentId)) &&
            (identical(other.idempotencyKey, idempotencyKey) ||
                const DeepCollectionEquality()
                    .equals(other.idempotencyKey, idempotencyKey)) &&
            (identical(other.reference, reference) ||
                const DeepCollectionEquality()
                    .equals(other.reference, reference)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(paymentId) ^
      const DeepCollectionEquality().hash(idempotencyKey) ^
      const DeepCollectionEquality().hash(reference) ^
      const DeepCollectionEquality().hash(amount) ^
      runtimeType.hashCode;
}

extension $PaymentInitiationPaymentReverseRequestExtension
    on PaymentInitiationPaymentReverseRequest {
  PaymentInitiationPaymentReverseRequest copyWith(
      {String? clientId,
      String? secret,
      String? paymentId,
      String? idempotencyKey,
      String? reference,
      PaymentAmountToRefund? amount}) {
    return PaymentInitiationPaymentReverseRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        paymentId: paymentId ?? this.paymentId,
        idempotencyKey: idempotencyKey ?? this.idempotencyKey,
        reference: reference ?? this.reference,
        amount: amount ?? this.amount);
  }

  PaymentInitiationPaymentReverseRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? paymentId,
      Wrapped<String>? idempotencyKey,
      Wrapped<String>? reference,
      Wrapped<PaymentAmountToRefund?>? amount}) {
    return PaymentInitiationPaymentReverseRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        paymentId: (paymentId != null ? paymentId.value : this.paymentId),
        idempotencyKey: (idempotencyKey != null
            ? idempotencyKey.value
            : this.idempotencyKey),
        reference: (reference != null ? reference.value : this.reference),
        amount: (amount != null ? amount.value : this.amount));
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentInitiationPaymentCreateResponse {
  PaymentInitiationPaymentCreateResponse({
    required this.paymentId,
    required this.status,
    required this.requestId,
  });

  factory PaymentInitiationPaymentCreateResponse.fromJson(
          Map<String, dynamic> json) =>
      _$PaymentInitiationPaymentCreateResponseFromJson(json);

  @JsonKey(name: 'payment_id')
  final String paymentId;
  @JsonKey(
    name: 'status',
    toJson: paymentInitiationPaymentCreateStatusToJson,
    fromJson: paymentInitiationPaymentCreateStatusFromJson,
  )
  final enums.PaymentInitiationPaymentCreateStatus status;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory =
      _$PaymentInitiationPaymentCreateResponseFromJson;
  static const toJsonFactory = _$PaymentInitiationPaymentCreateResponseToJson;
  Map<String, dynamic> toJson() =>
      _$PaymentInitiationPaymentCreateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentInitiationPaymentCreateResponse &&
            (identical(other.paymentId, paymentId) ||
                const DeepCollectionEquality()
                    .equals(other.paymentId, paymentId)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(paymentId) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $PaymentInitiationPaymentCreateResponseExtension
    on PaymentInitiationPaymentCreateResponse {
  PaymentInitiationPaymentCreateResponse copyWith(
      {String? paymentId,
      enums.PaymentInitiationPaymentCreateStatus? status,
      String? requestId}) {
    return PaymentInitiationPaymentCreateResponse(
        paymentId: paymentId ?? this.paymentId,
        status: status ?? this.status,
        requestId: requestId ?? this.requestId);
  }

  PaymentInitiationPaymentCreateResponse copyWithWrapped(
      {Wrapped<String>? paymentId,
      Wrapped<enums.PaymentInitiationPaymentCreateStatus>? status,
      Wrapped<String>? requestId}) {
    return PaymentInitiationPaymentCreateResponse(
        paymentId: (paymentId != null ? paymentId.value : this.paymentId),
        status: (status != null ? status.value : this.status),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class SandboxItemResetLoginRequest {
  SandboxItemResetLoginRequest({
    this.clientId,
    this.secret,
    required this.accessToken,
  });

  factory SandboxItemResetLoginRequest.fromJson(Map<String, dynamic> json) =>
      _$SandboxItemResetLoginRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'access_token')
  final String accessToken;
  static const fromJsonFactory = _$SandboxItemResetLoginRequestFromJson;
  static const toJsonFactory = _$SandboxItemResetLoginRequestToJson;
  Map<String, dynamic> toJson() => _$SandboxItemResetLoginRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SandboxItemResetLoginRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(accessToken) ^
      runtimeType.hashCode;
}

extension $SandboxItemResetLoginRequestExtension
    on SandboxItemResetLoginRequest {
  SandboxItemResetLoginRequest copyWith(
      {String? clientId, String? secret, String? accessToken}) {
    return SandboxItemResetLoginRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        accessToken: accessToken ?? this.accessToken);
  }

  SandboxItemResetLoginRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? accessToken}) {
    return SandboxItemResetLoginRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        accessToken:
            (accessToken != null ? accessToken.value : this.accessToken));
  }
}

@JsonSerializable(explicitToJson: true)
class SandboxItemResetLoginResponse {
  SandboxItemResetLoginResponse({
    required this.resetLogin,
    required this.requestId,
  });

  factory SandboxItemResetLoginResponse.fromJson(Map<String, dynamic> json) =>
      _$SandboxItemResetLoginResponseFromJson(json);

  @JsonKey(name: 'reset_login')
  final bool resetLogin;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$SandboxItemResetLoginResponseFromJson;
  static const toJsonFactory = _$SandboxItemResetLoginResponseToJson;
  Map<String, dynamic> toJson() => _$SandboxItemResetLoginResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SandboxItemResetLoginResponse &&
            (identical(other.resetLogin, resetLogin) ||
                const DeepCollectionEquality()
                    .equals(other.resetLogin, resetLogin)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(resetLogin) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $SandboxItemResetLoginResponseExtension
    on SandboxItemResetLoginResponse {
  SandboxItemResetLoginResponse copyWith(
      {bool? resetLogin, String? requestId}) {
    return SandboxItemResetLoginResponse(
        resetLogin: resetLogin ?? this.resetLogin,
        requestId: requestId ?? this.requestId);
  }

  SandboxItemResetLoginResponse copyWithWrapped(
      {Wrapped<bool>? resetLogin, Wrapped<String>? requestId}) {
    return SandboxItemResetLoginResponse(
        resetLogin: (resetLogin != null ? resetLogin.value : this.resetLogin),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class SandboxPaymentProfileResetLoginRequest {
  SandboxPaymentProfileResetLoginRequest({
    this.clientId,
    this.secret,
    required this.paymentProfileToken,
  });

  factory SandboxPaymentProfileResetLoginRequest.fromJson(
          Map<String, dynamic> json) =>
      _$SandboxPaymentProfileResetLoginRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'payment_profile_token')
  final String paymentProfileToken;
  static const fromJsonFactory =
      _$SandboxPaymentProfileResetLoginRequestFromJson;
  static const toJsonFactory = _$SandboxPaymentProfileResetLoginRequestToJson;
  Map<String, dynamic> toJson() =>
      _$SandboxPaymentProfileResetLoginRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SandboxPaymentProfileResetLoginRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.paymentProfileToken, paymentProfileToken) ||
                const DeepCollectionEquality()
                    .equals(other.paymentProfileToken, paymentProfileToken)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(paymentProfileToken) ^
      runtimeType.hashCode;
}

extension $SandboxPaymentProfileResetLoginRequestExtension
    on SandboxPaymentProfileResetLoginRequest {
  SandboxPaymentProfileResetLoginRequest copyWith(
      {String? clientId, String? secret, String? paymentProfileToken}) {
    return SandboxPaymentProfileResetLoginRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        paymentProfileToken: paymentProfileToken ?? this.paymentProfileToken);
  }

  SandboxPaymentProfileResetLoginRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? paymentProfileToken}) {
    return SandboxPaymentProfileResetLoginRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        paymentProfileToken: (paymentProfileToken != null
            ? paymentProfileToken.value
            : this.paymentProfileToken));
  }
}

@JsonSerializable(explicitToJson: true)
class SandboxPaymentProfileResetLoginResponse {
  SandboxPaymentProfileResetLoginResponse({
    required this.resetLogin,
    required this.requestId,
  });

  factory SandboxPaymentProfileResetLoginResponse.fromJson(
          Map<String, dynamic> json) =>
      _$SandboxPaymentProfileResetLoginResponseFromJson(json);

  @JsonKey(name: 'reset_login')
  final bool resetLogin;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory =
      _$SandboxPaymentProfileResetLoginResponseFromJson;
  static const toJsonFactory = _$SandboxPaymentProfileResetLoginResponseToJson;
  Map<String, dynamic> toJson() =>
      _$SandboxPaymentProfileResetLoginResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SandboxPaymentProfileResetLoginResponse &&
            (identical(other.resetLogin, resetLogin) ||
                const DeepCollectionEquality()
                    .equals(other.resetLogin, resetLogin)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(resetLogin) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $SandboxPaymentProfileResetLoginResponseExtension
    on SandboxPaymentProfileResetLoginResponse {
  SandboxPaymentProfileResetLoginResponse copyWith(
      {bool? resetLogin, String? requestId}) {
    return SandboxPaymentProfileResetLoginResponse(
        resetLogin: resetLogin ?? this.resetLogin,
        requestId: requestId ?? this.requestId);
  }

  SandboxPaymentProfileResetLoginResponse copyWithWrapped(
      {Wrapped<bool>? resetLogin, Wrapped<String>? requestId}) {
    return SandboxPaymentProfileResetLoginResponse(
        resetLogin: (resetLogin != null ? resetLogin.value : this.resetLogin),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class SandboxItemSetVerificationStatusRequest {
  SandboxItemSetVerificationStatusRequest({
    this.clientId,
    this.secret,
    required this.accessToken,
    required this.accountId,
    required this.verificationStatus,
  });

  factory SandboxItemSetVerificationStatusRequest.fromJson(
          Map<String, dynamic> json) =>
      _$SandboxItemSetVerificationStatusRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'access_token')
  final String accessToken;
  @JsonKey(name: 'account_id')
  final String accountId;
  @JsonKey(
    name: 'verification_status',
    toJson: sandboxItemSetVerificationStatusRequestVerificationStatusToJson,
    fromJson: sandboxItemSetVerificationStatusRequestVerificationStatusFromJson,
  )
  final enums.SandboxItemSetVerificationStatusRequestVerificationStatus
      verificationStatus;
  static const fromJsonFactory =
      _$SandboxItemSetVerificationStatusRequestFromJson;
  static const toJsonFactory = _$SandboxItemSetVerificationStatusRequestToJson;
  Map<String, dynamic> toJson() =>
      _$SandboxItemSetVerificationStatusRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SandboxItemSetVerificationStatusRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)) &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.verificationStatus, verificationStatus) ||
                const DeepCollectionEquality()
                    .equals(other.verificationStatus, verificationStatus)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(accessToken) ^
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(verificationStatus) ^
      runtimeType.hashCode;
}

extension $SandboxItemSetVerificationStatusRequestExtension
    on SandboxItemSetVerificationStatusRequest {
  SandboxItemSetVerificationStatusRequest copyWith(
      {String? clientId,
      String? secret,
      String? accessToken,
      String? accountId,
      enums.SandboxItemSetVerificationStatusRequestVerificationStatus?
          verificationStatus}) {
    return SandboxItemSetVerificationStatusRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        accessToken: accessToken ?? this.accessToken,
        accountId: accountId ?? this.accountId,
        verificationStatus: verificationStatus ?? this.verificationStatus);
  }

  SandboxItemSetVerificationStatusRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? accessToken,
      Wrapped<String>? accountId,
      Wrapped<enums.SandboxItemSetVerificationStatusRequestVerificationStatus>?
          verificationStatus}) {
    return SandboxItemSetVerificationStatusRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        accessToken:
            (accessToken != null ? accessToken.value : this.accessToken),
        accountId: (accountId != null ? accountId.value : this.accountId),
        verificationStatus: (verificationStatus != null
            ? verificationStatus.value
            : this.verificationStatus));
  }
}

@JsonSerializable(explicitToJson: true)
class SandboxItemSetVerificationStatusResponse {
  SandboxItemSetVerificationStatusResponse({
    required this.requestId,
  });

  factory SandboxItemSetVerificationStatusResponse.fromJson(
          Map<String, dynamic> json) =>
      _$SandboxItemSetVerificationStatusResponseFromJson(json);

  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory =
      _$SandboxItemSetVerificationStatusResponseFromJson;
  static const toJsonFactory = _$SandboxItemSetVerificationStatusResponseToJson;
  Map<String, dynamic> toJson() =>
      _$SandboxItemSetVerificationStatusResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SandboxItemSetVerificationStatusResponse &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(requestId) ^ runtimeType.hashCode;
}

extension $SandboxItemSetVerificationStatusResponseExtension
    on SandboxItemSetVerificationStatusResponse {
  SandboxItemSetVerificationStatusResponse copyWith({String? requestId}) {
    return SandboxItemSetVerificationStatusResponse(
        requestId: requestId ?? this.requestId);
  }

  SandboxItemSetVerificationStatusResponse copyWithWrapped(
      {Wrapped<String>? requestId}) {
    return SandboxItemSetVerificationStatusResponse(
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class UserCreateRequest {
  UserCreateRequest({
    this.clientId,
    this.secret,
    required this.clientUserId,
  });

  factory UserCreateRequest.fromJson(Map<String, dynamic> json) =>
      _$UserCreateRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'client_user_id')
  final String clientUserId;
  static const fromJsonFactory = _$UserCreateRequestFromJson;
  static const toJsonFactory = _$UserCreateRequestToJson;
  Map<String, dynamic> toJson() => _$UserCreateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is UserCreateRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.clientUserId, clientUserId) ||
                const DeepCollectionEquality()
                    .equals(other.clientUserId, clientUserId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(clientUserId) ^
      runtimeType.hashCode;
}

extension $UserCreateRequestExtension on UserCreateRequest {
  UserCreateRequest copyWith(
      {String? clientId, String? secret, String? clientUserId}) {
    return UserCreateRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        clientUserId: clientUserId ?? this.clientUserId);
  }

  UserCreateRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? clientUserId}) {
    return UserCreateRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        clientUserId:
            (clientUserId != null ? clientUserId.value : this.clientUserId));
  }
}

@JsonSerializable(explicitToJson: true)
class UserCreateResponse {
  UserCreateResponse({
    required this.userToken,
    required this.userId,
    required this.requestId,
  });

  factory UserCreateResponse.fromJson(Map<String, dynamic> json) =>
      _$UserCreateResponseFromJson(json);

  @JsonKey(name: 'user_token')
  final String userToken;
  @JsonKey(name: 'user_id')
  final String userId;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$UserCreateResponseFromJson;
  static const toJsonFactory = _$UserCreateResponseToJson;
  Map<String, dynamic> toJson() => _$UserCreateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is UserCreateResponse &&
            (identical(other.userToken, userToken) ||
                const DeepCollectionEquality()
                    .equals(other.userToken, userToken)) &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(userToken) ^
      const DeepCollectionEquality().hash(userId) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $UserCreateResponseExtension on UserCreateResponse {
  UserCreateResponse copyWith(
      {String? userToken, String? userId, String? requestId}) {
    return UserCreateResponse(
        userToken: userToken ?? this.userToken,
        userId: userId ?? this.userId,
        requestId: requestId ?? this.requestId);
  }

  UserCreateResponse copyWithWrapped(
      {Wrapped<String>? userToken,
      Wrapped<String>? userId,
      Wrapped<String>? requestId}) {
    return UserCreateResponse(
        userToken: (userToken != null ? userToken.value : this.userToken),
        userId: (userId != null ? userId.value : this.userId),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class CreditSessionsGetRequest {
  CreditSessionsGetRequest({
    this.clientId,
    this.secret,
    required this.userToken,
  });

  factory CreditSessionsGetRequest.fromJson(Map<String, dynamic> json) =>
      _$CreditSessionsGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'user_token')
  final String userToken;
  static const fromJsonFactory = _$CreditSessionsGetRequestFromJson;
  static const toJsonFactory = _$CreditSessionsGetRequestToJson;
  Map<String, dynamic> toJson() => _$CreditSessionsGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CreditSessionsGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.userToken, userToken) ||
                const DeepCollectionEquality()
                    .equals(other.userToken, userToken)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(userToken) ^
      runtimeType.hashCode;
}

extension $CreditSessionsGetRequestExtension on CreditSessionsGetRequest {
  CreditSessionsGetRequest copyWith(
      {String? clientId, String? secret, String? userToken}) {
    return CreditSessionsGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        userToken: userToken ?? this.userToken);
  }

  CreditSessionsGetRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? userToken}) {
    return CreditSessionsGetRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        userToken: (userToken != null ? userToken.value : this.userToken));
  }
}

@JsonSerializable(explicitToJson: true)
class CreditSessionsGetResponse {
  CreditSessionsGetResponse({
    this.sessions,
    required this.requestId,
  });

  factory CreditSessionsGetResponse.fromJson(Map<String, dynamic> json) =>
      _$CreditSessionsGetResponseFromJson(json);

  @JsonKey(name: 'sessions', defaultValue: <CreditSession>[])
  final List<CreditSession>? sessions;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$CreditSessionsGetResponseFromJson;
  static const toJsonFactory = _$CreditSessionsGetResponseToJson;
  Map<String, dynamic> toJson() => _$CreditSessionsGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CreditSessionsGetResponse &&
            (identical(other.sessions, sessions) ||
                const DeepCollectionEquality()
                    .equals(other.sessions, sessions)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(sessions) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $CreditSessionsGetResponseExtension on CreditSessionsGetResponse {
  CreditSessionsGetResponse copyWith(
      {List<CreditSession>? sessions, String? requestId}) {
    return CreditSessionsGetResponse(
        sessions: sessions ?? this.sessions,
        requestId: requestId ?? this.requestId);
  }

  CreditSessionsGetResponse copyWithWrapped(
      {Wrapped<List<CreditSession>?>? sessions, Wrapped<String>? requestId}) {
    return CreditSessionsGetResponse(
        sessions: (sessions != null ? sessions.value : this.sessions),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class CreditSession {
  CreditSession({
    this.linkSessionId,
    this.sessionStartTime,
    this.results,
    this.errors,
  });

  factory CreditSession.fromJson(Map<String, dynamic> json) =>
      _$CreditSessionFromJson(json);

  @JsonKey(name: 'link_session_id')
  final String? linkSessionId;
  @JsonKey(name: 'session_start_time')
  final DateTime? sessionStartTime;
  @JsonKey(name: 'results')
  final CreditSessionResults? results;
  @JsonKey(name: 'errors', defaultValue: <CreditSessionError>[])
  final List<CreditSessionError>? errors;
  static const fromJsonFactory = _$CreditSessionFromJson;
  static const toJsonFactory = _$CreditSessionToJson;
  Map<String, dynamic> toJson() => _$CreditSessionToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CreditSession &&
            (identical(other.linkSessionId, linkSessionId) ||
                const DeepCollectionEquality()
                    .equals(other.linkSessionId, linkSessionId)) &&
            (identical(other.sessionStartTime, sessionStartTime) ||
                const DeepCollectionEquality()
                    .equals(other.sessionStartTime, sessionStartTime)) &&
            (identical(other.results, results) ||
                const DeepCollectionEquality()
                    .equals(other.results, results)) &&
            (identical(other.errors, errors) ||
                const DeepCollectionEquality().equals(other.errors, errors)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(linkSessionId) ^
      const DeepCollectionEquality().hash(sessionStartTime) ^
      const DeepCollectionEquality().hash(results) ^
      const DeepCollectionEquality().hash(errors) ^
      runtimeType.hashCode;
}

extension $CreditSessionExtension on CreditSession {
  CreditSession copyWith(
      {String? linkSessionId,
      DateTime? sessionStartTime,
      CreditSessionResults? results,
      List<CreditSessionError>? errors}) {
    return CreditSession(
        linkSessionId: linkSessionId ?? this.linkSessionId,
        sessionStartTime: sessionStartTime ?? this.sessionStartTime,
        results: results ?? this.results,
        errors: errors ?? this.errors);
  }

  CreditSession copyWithWrapped(
      {Wrapped<String?>? linkSessionId,
      Wrapped<DateTime?>? sessionStartTime,
      Wrapped<CreditSessionResults?>? results,
      Wrapped<List<CreditSessionError>?>? errors}) {
    return CreditSession(
        linkSessionId:
            (linkSessionId != null ? linkSessionId.value : this.linkSessionId),
        sessionStartTime: (sessionStartTime != null
            ? sessionStartTime.value
            : this.sessionStartTime),
        results: (results != null ? results.value : this.results),
        errors: (errors != null ? errors.value : this.errors));
  }
}

@JsonSerializable(explicitToJson: true)
class CreditSessionResults {
  CreditSessionResults({
    this.itemAddResults,
    this.bankIncomeResults,
    this.payrollIncomeResults,
    this.documentIncomeResults,
  });

  factory CreditSessionResults.fromJson(Map<String, dynamic> json) =>
      _$CreditSessionResultsFromJson(json);

  @JsonKey(
      name: 'item_add_results', defaultValue: <CreditSessionItemAddResult>[])
  final List<CreditSessionItemAddResult>? itemAddResults;
  @JsonKey(
      name: 'bank_income_results',
      defaultValue: <CreditSessionBankIncomeResult>[])
  final List<CreditSessionBankIncomeResult>? bankIncomeResults;
  @JsonKey(
      name: 'payroll_income_results',
      defaultValue: <CreditSessionPayrollIncomeResult>[])
  final List<CreditSessionPayrollIncomeResult>? payrollIncomeResults;
  @JsonKey(name: 'document_income_results')
  final CreditSessionDocumentIncomeResult? documentIncomeResults;
  static const fromJsonFactory = _$CreditSessionResultsFromJson;
  static const toJsonFactory = _$CreditSessionResultsToJson;
  Map<String, dynamic> toJson() => _$CreditSessionResultsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CreditSessionResults &&
            (identical(other.itemAddResults, itemAddResults) ||
                const DeepCollectionEquality()
                    .equals(other.itemAddResults, itemAddResults)) &&
            (identical(other.bankIncomeResults, bankIncomeResults) ||
                const DeepCollectionEquality()
                    .equals(other.bankIncomeResults, bankIncomeResults)) &&
            (identical(other.payrollIncomeResults, payrollIncomeResults) ||
                const DeepCollectionEquality().equals(
                    other.payrollIncomeResults, payrollIncomeResults)) &&
            (identical(other.documentIncomeResults, documentIncomeResults) ||
                const DeepCollectionEquality().equals(
                    other.documentIncomeResults, documentIncomeResults)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(itemAddResults) ^
      const DeepCollectionEquality().hash(bankIncomeResults) ^
      const DeepCollectionEquality().hash(payrollIncomeResults) ^
      const DeepCollectionEquality().hash(documentIncomeResults) ^
      runtimeType.hashCode;
}

extension $CreditSessionResultsExtension on CreditSessionResults {
  CreditSessionResults copyWith(
      {List<CreditSessionItemAddResult>? itemAddResults,
      List<CreditSessionBankIncomeResult>? bankIncomeResults,
      List<CreditSessionPayrollIncomeResult>? payrollIncomeResults,
      CreditSessionDocumentIncomeResult? documentIncomeResults}) {
    return CreditSessionResults(
        itemAddResults: itemAddResults ?? this.itemAddResults,
        bankIncomeResults: bankIncomeResults ?? this.bankIncomeResults,
        payrollIncomeResults: payrollIncomeResults ?? this.payrollIncomeResults,
        documentIncomeResults:
            documentIncomeResults ?? this.documentIncomeResults);
  }

  CreditSessionResults copyWithWrapped(
      {Wrapped<List<CreditSessionItemAddResult>?>? itemAddResults,
      Wrapped<List<CreditSessionBankIncomeResult>?>? bankIncomeResults,
      Wrapped<List<CreditSessionPayrollIncomeResult>?>? payrollIncomeResults,
      Wrapped<CreditSessionDocumentIncomeResult?>? documentIncomeResults}) {
    return CreditSessionResults(
        itemAddResults: (itemAddResults != null
            ? itemAddResults.value
            : this.itemAddResults),
        bankIncomeResults: (bankIncomeResults != null
            ? bankIncomeResults.value
            : this.bankIncomeResults),
        payrollIncomeResults: (payrollIncomeResults != null
            ? payrollIncomeResults.value
            : this.payrollIncomeResults),
        documentIncomeResults: (documentIncomeResults != null
            ? documentIncomeResults.value
            : this.documentIncomeResults));
  }
}

@JsonSerializable(explicitToJson: true)
class CreditSessionItemAddResult {
  CreditSessionItemAddResult({
    this.publicToken,
    this.itemId,
    this.institutionId,
  });

  factory CreditSessionItemAddResult.fromJson(Map<String, dynamic> json) =>
      _$CreditSessionItemAddResultFromJson(json);

  @JsonKey(name: 'public_token')
  final String? publicToken;
  @JsonKey(name: 'item_id')
  final String? itemId;
  @JsonKey(name: 'institution_id')
  final String? institutionId;
  static const fromJsonFactory = _$CreditSessionItemAddResultFromJson;
  static const toJsonFactory = _$CreditSessionItemAddResultToJson;
  Map<String, dynamic> toJson() => _$CreditSessionItemAddResultToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CreditSessionItemAddResult &&
            (identical(other.publicToken, publicToken) ||
                const DeepCollectionEquality()
                    .equals(other.publicToken, publicToken)) &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)) &&
            (identical(other.institutionId, institutionId) ||
                const DeepCollectionEquality()
                    .equals(other.institutionId, institutionId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(publicToken) ^
      const DeepCollectionEquality().hash(itemId) ^
      const DeepCollectionEquality().hash(institutionId) ^
      runtimeType.hashCode;
}

extension $CreditSessionItemAddResultExtension on CreditSessionItemAddResult {
  CreditSessionItemAddResult copyWith(
      {String? publicToken, String? itemId, String? institutionId}) {
    return CreditSessionItemAddResult(
        publicToken: publicToken ?? this.publicToken,
        itemId: itemId ?? this.itemId,
        institutionId: institutionId ?? this.institutionId);
  }

  CreditSessionItemAddResult copyWithWrapped(
      {Wrapped<String?>? publicToken,
      Wrapped<String?>? itemId,
      Wrapped<String?>? institutionId}) {
    return CreditSessionItemAddResult(
        publicToken:
            (publicToken != null ? publicToken.value : this.publicToken),
        itemId: (itemId != null ? itemId.value : this.itemId),
        institutionId:
            (institutionId != null ? institutionId.value : this.institutionId));
  }
}

@JsonSerializable(explicitToJson: true)
class CreditSessionBankIncomeResult {
  CreditSessionBankIncomeResult({
    this.status,
    this.itemId,
    this.institutionId,
  });

  factory CreditSessionBankIncomeResult.fromJson(Map<String, dynamic> json) =>
      _$CreditSessionBankIncomeResultFromJson(json);

  @JsonKey(
    name: 'status',
    toJson: creditSessionBankIncomeStatusToJson,
    fromJson: creditSessionBankIncomeStatusFromJson,
  )
  final enums.CreditSessionBankIncomeStatus? status;
  @JsonKey(name: 'item_id')
  final String? itemId;
  @JsonKey(name: 'institution_id')
  final String? institutionId;
  static const fromJsonFactory = _$CreditSessionBankIncomeResultFromJson;
  static const toJsonFactory = _$CreditSessionBankIncomeResultToJson;
  Map<String, dynamic> toJson() => _$CreditSessionBankIncomeResultToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CreditSessionBankIncomeResult &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)) &&
            (identical(other.institutionId, institutionId) ||
                const DeepCollectionEquality()
                    .equals(other.institutionId, institutionId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(itemId) ^
      const DeepCollectionEquality().hash(institutionId) ^
      runtimeType.hashCode;
}

extension $CreditSessionBankIncomeResultExtension
    on CreditSessionBankIncomeResult {
  CreditSessionBankIncomeResult copyWith(
      {enums.CreditSessionBankIncomeStatus? status,
      String? itemId,
      String? institutionId}) {
    return CreditSessionBankIncomeResult(
        status: status ?? this.status,
        itemId: itemId ?? this.itemId,
        institutionId: institutionId ?? this.institutionId);
  }

  CreditSessionBankIncomeResult copyWithWrapped(
      {Wrapped<enums.CreditSessionBankIncomeStatus?>? status,
      Wrapped<String?>? itemId,
      Wrapped<String?>? institutionId}) {
    return CreditSessionBankIncomeResult(
        status: (status != null ? status.value : this.status),
        itemId: (itemId != null ? itemId.value : this.itemId),
        institutionId:
            (institutionId != null ? institutionId.value : this.institutionId));
  }
}

@JsonSerializable(explicitToJson: true)
class CreditSessionError {
  CreditSessionError({
    this.errorType,
    this.errorCode,
    this.errorMessage,
    this.displayMessage,
  });

  factory CreditSessionError.fromJson(Map<String, dynamic> json) =>
      _$CreditSessionErrorFromJson(json);

  @JsonKey(name: 'error_type')
  final String? errorType;
  @JsonKey(name: 'error_code')
  final String? errorCode;
  @JsonKey(name: 'error_message')
  final String? errorMessage;
  @JsonKey(name: 'display_message')
  final String? displayMessage;
  static const fromJsonFactory = _$CreditSessionErrorFromJson;
  static const toJsonFactory = _$CreditSessionErrorToJson;
  Map<String, dynamic> toJson() => _$CreditSessionErrorToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CreditSessionError &&
            (identical(other.errorType, errorType) ||
                const DeepCollectionEquality()
                    .equals(other.errorType, errorType)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.errorMessage, errorMessage) ||
                const DeepCollectionEquality()
                    .equals(other.errorMessage, errorMessage)) &&
            (identical(other.displayMessage, displayMessage) ||
                const DeepCollectionEquality()
                    .equals(other.displayMessage, displayMessage)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(errorType) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(errorMessage) ^
      const DeepCollectionEquality().hash(displayMessage) ^
      runtimeType.hashCode;
}

extension $CreditSessionErrorExtension on CreditSessionError {
  CreditSessionError copyWith(
      {String? errorType,
      String? errorCode,
      String? errorMessage,
      String? displayMessage}) {
    return CreditSessionError(
        errorType: errorType ?? this.errorType,
        errorCode: errorCode ?? this.errorCode,
        errorMessage: errorMessage ?? this.errorMessage,
        displayMessage: displayMessage ?? this.displayMessage);
  }

  CreditSessionError copyWithWrapped(
      {Wrapped<String?>? errorType,
      Wrapped<String?>? errorCode,
      Wrapped<String?>? errorMessage,
      Wrapped<String?>? displayMessage}) {
    return CreditSessionError(
        errorType: (errorType != null ? errorType.value : this.errorType),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        errorMessage:
            (errorMessage != null ? errorMessage.value : this.errorMessage),
        displayMessage: (displayMessage != null
            ? displayMessage.value
            : this.displayMessage));
  }
}

@JsonSerializable(explicitToJson: true)
class CreditSessionPayrollIncomeResult {
  CreditSessionPayrollIncomeResult({
    this.numPaystubsRetrieved,
    this.numW2sRetrieved,
    this.institutionId,
    this.institutionName,
  });

  factory CreditSessionPayrollIncomeResult.fromJson(
          Map<String, dynamic> json) =>
      _$CreditSessionPayrollIncomeResultFromJson(json);

  @JsonKey(name: 'num_paystubs_retrieved')
  final int? numPaystubsRetrieved;
  @JsonKey(name: 'num_w2s_retrieved')
  final int? numW2sRetrieved;
  @JsonKey(name: 'institution_id')
  final String? institutionId;
  @JsonKey(name: 'institution_name')
  final String? institutionName;
  static const fromJsonFactory = _$CreditSessionPayrollIncomeResultFromJson;
  static const toJsonFactory = _$CreditSessionPayrollIncomeResultToJson;
  Map<String, dynamic> toJson() =>
      _$CreditSessionPayrollIncomeResultToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CreditSessionPayrollIncomeResult &&
            (identical(other.numPaystubsRetrieved, numPaystubsRetrieved) ||
                const DeepCollectionEquality().equals(
                    other.numPaystubsRetrieved, numPaystubsRetrieved)) &&
            (identical(other.numW2sRetrieved, numW2sRetrieved) ||
                const DeepCollectionEquality()
                    .equals(other.numW2sRetrieved, numW2sRetrieved)) &&
            (identical(other.institutionId, institutionId) ||
                const DeepCollectionEquality()
                    .equals(other.institutionId, institutionId)) &&
            (identical(other.institutionName, institutionName) ||
                const DeepCollectionEquality()
                    .equals(other.institutionName, institutionName)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(numPaystubsRetrieved) ^
      const DeepCollectionEquality().hash(numW2sRetrieved) ^
      const DeepCollectionEquality().hash(institutionId) ^
      const DeepCollectionEquality().hash(institutionName) ^
      runtimeType.hashCode;
}

extension $CreditSessionPayrollIncomeResultExtension
    on CreditSessionPayrollIncomeResult {
  CreditSessionPayrollIncomeResult copyWith(
      {int? numPaystubsRetrieved,
      int? numW2sRetrieved,
      String? institutionId,
      String? institutionName}) {
    return CreditSessionPayrollIncomeResult(
        numPaystubsRetrieved: numPaystubsRetrieved ?? this.numPaystubsRetrieved,
        numW2sRetrieved: numW2sRetrieved ?? this.numW2sRetrieved,
        institutionId: institutionId ?? this.institutionId,
        institutionName: institutionName ?? this.institutionName);
  }

  CreditSessionPayrollIncomeResult copyWithWrapped(
      {Wrapped<int?>? numPaystubsRetrieved,
      Wrapped<int?>? numW2sRetrieved,
      Wrapped<String?>? institutionId,
      Wrapped<String?>? institutionName}) {
    return CreditSessionPayrollIncomeResult(
        numPaystubsRetrieved: (numPaystubsRetrieved != null
            ? numPaystubsRetrieved.value
            : this.numPaystubsRetrieved),
        numW2sRetrieved: (numW2sRetrieved != null
            ? numW2sRetrieved.value
            : this.numW2sRetrieved),
        institutionId:
            (institutionId != null ? institutionId.value : this.institutionId),
        institutionName: (institutionName != null
            ? institutionName.value
            : this.institutionName));
  }
}

@JsonSerializable(explicitToJson: true)
class CreditSessionDocumentIncomeResult {
  CreditSessionDocumentIncomeResult({
    required this.numPaystubsUploaded,
    required this.numW2sUploaded,
  });

  factory CreditSessionDocumentIncomeResult.fromJson(
          Map<String, dynamic> json) =>
      _$CreditSessionDocumentIncomeResultFromJson(json);

  @JsonKey(name: 'num_paystubs_uploaded')
  final int numPaystubsUploaded;
  @JsonKey(name: 'num_w2s_uploaded')
  final int numW2sUploaded;
  static const fromJsonFactory = _$CreditSessionDocumentIncomeResultFromJson;
  static const toJsonFactory = _$CreditSessionDocumentIncomeResultToJson;
  Map<String, dynamic> toJson() =>
      _$CreditSessionDocumentIncomeResultToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CreditSessionDocumentIncomeResult &&
            (identical(other.numPaystubsUploaded, numPaystubsUploaded) ||
                const DeepCollectionEquality()
                    .equals(other.numPaystubsUploaded, numPaystubsUploaded)) &&
            (identical(other.numW2sUploaded, numW2sUploaded) ||
                const DeepCollectionEquality()
                    .equals(other.numW2sUploaded, numW2sUploaded)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(numPaystubsUploaded) ^
      const DeepCollectionEquality().hash(numW2sUploaded) ^
      runtimeType.hashCode;
}

extension $CreditSessionDocumentIncomeResultExtension
    on CreditSessionDocumentIncomeResult {
  CreditSessionDocumentIncomeResult copyWith(
      {int? numPaystubsUploaded, int? numW2sUploaded}) {
    return CreditSessionDocumentIncomeResult(
        numPaystubsUploaded: numPaystubsUploaded ?? this.numPaystubsUploaded,
        numW2sUploaded: numW2sUploaded ?? this.numW2sUploaded);
  }

  CreditSessionDocumentIncomeResult copyWithWrapped(
      {Wrapped<int>? numPaystubsUploaded, Wrapped<int>? numW2sUploaded}) {
    return CreditSessionDocumentIncomeResult(
        numPaystubsUploaded: (numPaystubsUploaded != null
            ? numPaystubsUploaded.value
            : this.numPaystubsUploaded),
        numW2sUploaded: (numW2sUploaded != null
            ? numW2sUploaded.value
            : this.numW2sUploaded));
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentInitiationPaymentGetRequest {
  PaymentInitiationPaymentGetRequest({
    this.clientId,
    this.secret,
    required this.paymentId,
  });

  factory PaymentInitiationPaymentGetRequest.fromJson(
          Map<String, dynamic> json) =>
      _$PaymentInitiationPaymentGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'payment_id')
  final String paymentId;
  static const fromJsonFactory = _$PaymentInitiationPaymentGetRequestFromJson;
  static const toJsonFactory = _$PaymentInitiationPaymentGetRequestToJson;
  Map<String, dynamic> toJson() =>
      _$PaymentInitiationPaymentGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentInitiationPaymentGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.paymentId, paymentId) ||
                const DeepCollectionEquality()
                    .equals(other.paymentId, paymentId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(paymentId) ^
      runtimeType.hashCode;
}

extension $PaymentInitiationPaymentGetRequestExtension
    on PaymentInitiationPaymentGetRequest {
  PaymentInitiationPaymentGetRequest copyWith(
      {String? clientId, String? secret, String? paymentId}) {
    return PaymentInitiationPaymentGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        paymentId: paymentId ?? this.paymentId);
  }

  PaymentInitiationPaymentGetRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? paymentId}) {
    return PaymentInitiationPaymentGetRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        paymentId: (paymentId != null ? paymentId.value : this.paymentId));
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentInitiationPaymentGetResponse {
  PaymentInitiationPaymentGetResponse({
    required this.requestId,
    required this.paymentId,
    required this.amount,
    required this.status,
    required this.recipientId,
    required this.reference,
    this.adjustedReference,
    required this.lastStatusUpdate,
    this.schedule,
    this.refundDetails,
    required this.bacs,
    required this.iban,
    this.refundIds,
    this.amountRefunded,
    this.walletId,
    this.scheme,
    this.adjustedScheme,
    this.consentId,
    this.transactionId,
  });

  factory PaymentInitiationPaymentGetResponse.fromJson(
          Map<String, dynamic> json) =>
      _$PaymentInitiationPaymentGetResponseFromJson(json);

  @JsonKey(name: 'request_id')
  final String requestId;
  @JsonKey(name: 'payment_id')
  final String paymentId;
  @JsonKey(name: 'amount')
  final PaymentAmount amount;
  @JsonKey(
    name: 'status',
    toJson: paymentInitiationPaymentStatusToJson,
    fromJson: paymentInitiationPaymentStatusFromJson,
  )
  final enums.PaymentInitiationPaymentStatus status;
  @JsonKey(name: 'recipient_id')
  final String recipientId;
  @JsonKey(name: 'reference')
  final String reference;
  @JsonKey(name: 'adjusted_reference')
  final String? adjustedReference;
  @JsonKey(name: 'last_status_update')
  final DateTime lastStatusUpdate;
  @JsonKey(name: 'schedule')
  final ExternalPaymentScheduleGet? schedule;
  @JsonKey(name: 'refund_details')
  final ExternalPaymentRefundDetails? refundDetails;
  @JsonKey(name: 'bacs')
  final SenderBACSNullable? bacs;
  @JsonKey(name: 'iban')
  final String? iban;
  @JsonKey(name: 'refund_ids', defaultValue: <String>[])
  final List<String>? refundIds;
  @JsonKey(name: 'amount_refunded')
  final PaymentAmountRefunded? amountRefunded;
  @JsonKey(name: 'wallet_id')
  final String? walletId;
  @JsonKey(
    name: 'scheme',
    toJson: paymentSchemeToJson,
    fromJson: paymentSchemeFromJson,
  )
  final enums.PaymentScheme? scheme;
  @JsonKey(
    name: 'adjusted_scheme',
    toJson: paymentSchemeToJson,
    fromJson: paymentSchemeFromJson,
  )
  final enums.PaymentScheme? adjustedScheme;
  @JsonKey(name: 'consent_id')
  final String? consentId;
  @JsonKey(name: 'transaction_id')
  final String? transactionId;
  static const fromJsonFactory = _$PaymentInitiationPaymentGetResponseFromJson;
  static const toJsonFactory = _$PaymentInitiationPaymentGetResponseToJson;
  Map<String, dynamic> toJson() =>
      _$PaymentInitiationPaymentGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentInitiationPaymentGetResponse &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)) &&
            (identical(other.paymentId, paymentId) ||
                const DeepCollectionEquality()
                    .equals(other.paymentId, paymentId)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.recipientId, recipientId) ||
                const DeepCollectionEquality()
                    .equals(other.recipientId, recipientId)) &&
            (identical(other.reference, reference) ||
                const DeepCollectionEquality()
                    .equals(other.reference, reference)) &&
            (identical(other.adjustedReference, adjustedReference) ||
                const DeepCollectionEquality()
                    .equals(other.adjustedReference, adjustedReference)) &&
            (identical(other.lastStatusUpdate, lastStatusUpdate) ||
                const DeepCollectionEquality()
                    .equals(other.lastStatusUpdate, lastStatusUpdate)) &&
            (identical(other.schedule, schedule) ||
                const DeepCollectionEquality()
                    .equals(other.schedule, schedule)) &&
            (identical(other.refundDetails, refundDetails) ||
                const DeepCollectionEquality()
                    .equals(other.refundDetails, refundDetails)) &&
            (identical(other.bacs, bacs) ||
                const DeepCollectionEquality().equals(other.bacs, bacs)) &&
            (identical(other.iban, iban) ||
                const DeepCollectionEquality().equals(other.iban, iban)) &&
            (identical(other.refundIds, refundIds) ||
                const DeepCollectionEquality()
                    .equals(other.refundIds, refundIds)) &&
            (identical(other.amountRefunded, amountRefunded) ||
                const DeepCollectionEquality()
                    .equals(other.amountRefunded, amountRefunded)) &&
            (identical(other.walletId, walletId) ||
                const DeepCollectionEquality()
                    .equals(other.walletId, walletId)) &&
            (identical(other.scheme, scheme) ||
                const DeepCollectionEquality().equals(other.scheme, scheme)) &&
            (identical(other.adjustedScheme, adjustedScheme) ||
                const DeepCollectionEquality()
                    .equals(other.adjustedScheme, adjustedScheme)) &&
            (identical(other.consentId, consentId) ||
                const DeepCollectionEquality()
                    .equals(other.consentId, consentId)) &&
            (identical(other.transactionId, transactionId) ||
                const DeepCollectionEquality()
                    .equals(other.transactionId, transactionId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(requestId) ^
      const DeepCollectionEquality().hash(paymentId) ^
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(recipientId) ^
      const DeepCollectionEquality().hash(reference) ^
      const DeepCollectionEquality().hash(adjustedReference) ^
      const DeepCollectionEquality().hash(lastStatusUpdate) ^
      const DeepCollectionEquality().hash(schedule) ^
      const DeepCollectionEquality().hash(refundDetails) ^
      const DeepCollectionEquality().hash(bacs) ^
      const DeepCollectionEquality().hash(iban) ^
      const DeepCollectionEquality().hash(refundIds) ^
      const DeepCollectionEquality().hash(amountRefunded) ^
      const DeepCollectionEquality().hash(walletId) ^
      const DeepCollectionEquality().hash(scheme) ^
      const DeepCollectionEquality().hash(adjustedScheme) ^
      const DeepCollectionEquality().hash(consentId) ^
      const DeepCollectionEquality().hash(transactionId) ^
      runtimeType.hashCode;
}

extension $PaymentInitiationPaymentGetResponseExtension
    on PaymentInitiationPaymentGetResponse {
  PaymentInitiationPaymentGetResponse copyWith(
      {String? requestId,
      String? paymentId,
      PaymentAmount? amount,
      enums.PaymentInitiationPaymentStatus? status,
      String? recipientId,
      String? reference,
      String? adjustedReference,
      DateTime? lastStatusUpdate,
      ExternalPaymentScheduleGet? schedule,
      ExternalPaymentRefundDetails? refundDetails,
      SenderBACSNullable? bacs,
      String? iban,
      List<String>? refundIds,
      PaymentAmountRefunded? amountRefunded,
      String? walletId,
      enums.PaymentScheme? scheme,
      enums.PaymentScheme? adjustedScheme,
      String? consentId,
      String? transactionId}) {
    return PaymentInitiationPaymentGetResponse(
        requestId: requestId ?? this.requestId,
        paymentId: paymentId ?? this.paymentId,
        amount: amount ?? this.amount,
        status: status ?? this.status,
        recipientId: recipientId ?? this.recipientId,
        reference: reference ?? this.reference,
        adjustedReference: adjustedReference ?? this.adjustedReference,
        lastStatusUpdate: lastStatusUpdate ?? this.lastStatusUpdate,
        schedule: schedule ?? this.schedule,
        refundDetails: refundDetails ?? this.refundDetails,
        bacs: bacs ?? this.bacs,
        iban: iban ?? this.iban,
        refundIds: refundIds ?? this.refundIds,
        amountRefunded: amountRefunded ?? this.amountRefunded,
        walletId: walletId ?? this.walletId,
        scheme: scheme ?? this.scheme,
        adjustedScheme: adjustedScheme ?? this.adjustedScheme,
        consentId: consentId ?? this.consentId,
        transactionId: transactionId ?? this.transactionId);
  }

  PaymentInitiationPaymentGetResponse copyWithWrapped(
      {Wrapped<String>? requestId,
      Wrapped<String>? paymentId,
      Wrapped<PaymentAmount>? amount,
      Wrapped<enums.PaymentInitiationPaymentStatus>? status,
      Wrapped<String>? recipientId,
      Wrapped<String>? reference,
      Wrapped<String?>? adjustedReference,
      Wrapped<DateTime>? lastStatusUpdate,
      Wrapped<ExternalPaymentScheduleGet?>? schedule,
      Wrapped<ExternalPaymentRefundDetails?>? refundDetails,
      Wrapped<SenderBACSNullable?>? bacs,
      Wrapped<String?>? iban,
      Wrapped<List<String>?>? refundIds,
      Wrapped<PaymentAmountRefunded?>? amountRefunded,
      Wrapped<String?>? walletId,
      Wrapped<enums.PaymentScheme?>? scheme,
      Wrapped<enums.PaymentScheme?>? adjustedScheme,
      Wrapped<String?>? consentId,
      Wrapped<String?>? transactionId}) {
    return PaymentInitiationPaymentGetResponse(
        requestId: (requestId != null ? requestId.value : this.requestId),
        paymentId: (paymentId != null ? paymentId.value : this.paymentId),
        amount: (amount != null ? amount.value : this.amount),
        status: (status != null ? status.value : this.status),
        recipientId:
            (recipientId != null ? recipientId.value : this.recipientId),
        reference: (reference != null ? reference.value : this.reference),
        adjustedReference: (adjustedReference != null
            ? adjustedReference.value
            : this.adjustedReference),
        lastStatusUpdate: (lastStatusUpdate != null
            ? lastStatusUpdate.value
            : this.lastStatusUpdate),
        schedule: (schedule != null ? schedule.value : this.schedule),
        refundDetails:
            (refundDetails != null ? refundDetails.value : this.refundDetails),
        bacs: (bacs != null ? bacs.value : this.bacs),
        iban: (iban != null ? iban.value : this.iban),
        refundIds: (refundIds != null ? refundIds.value : this.refundIds),
        amountRefunded: (amountRefunded != null
            ? amountRefunded.value
            : this.amountRefunded),
        walletId: (walletId != null ? walletId.value : this.walletId),
        scheme: (scheme != null ? scheme.value : this.scheme),
        adjustedScheme: (adjustedScheme != null
            ? adjustedScheme.value
            : this.adjustedScheme),
        consentId: (consentId != null ? consentId.value : this.consentId),
        transactionId:
            (transactionId != null ? transactionId.value : this.transactionId));
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentInitiationPayment {
  PaymentInitiationPayment({
    required this.paymentId,
    required this.amount,
    required this.status,
    required this.recipientId,
    required this.reference,
    this.adjustedReference,
    required this.lastStatusUpdate,
    this.schedule,
    this.refundDetails,
    required this.bacs,
    required this.iban,
    this.refundIds,
    this.amountRefunded,
    this.walletId,
    this.scheme,
    this.adjustedScheme,
    this.consentId,
    this.transactionId,
  });

  factory PaymentInitiationPayment.fromJson(Map<String, dynamic> json) =>
      _$PaymentInitiationPaymentFromJson(json);

  @JsonKey(name: 'payment_id')
  final String paymentId;
  @JsonKey(name: 'amount')
  final PaymentAmount amount;
  @JsonKey(
    name: 'status',
    toJson: paymentInitiationPaymentStatusToJson,
    fromJson: paymentInitiationPaymentStatusFromJson,
  )
  final enums.PaymentInitiationPaymentStatus status;
  @JsonKey(name: 'recipient_id')
  final String recipientId;
  @JsonKey(name: 'reference')
  final String reference;
  @JsonKey(name: 'adjusted_reference')
  final String? adjustedReference;
  @JsonKey(name: 'last_status_update')
  final DateTime lastStatusUpdate;
  @JsonKey(name: 'schedule')
  final ExternalPaymentScheduleGet? schedule;
  @JsonKey(name: 'refund_details')
  final ExternalPaymentRefundDetails? refundDetails;
  @JsonKey(name: 'bacs')
  final SenderBACSNullable? bacs;
  @JsonKey(name: 'iban')
  final String? iban;
  @JsonKey(name: 'refund_ids', defaultValue: <String>[])
  final List<String>? refundIds;
  @JsonKey(name: 'amount_refunded')
  final PaymentAmountRefunded? amountRefunded;
  @JsonKey(name: 'wallet_id')
  final String? walletId;
  @JsonKey(
    name: 'scheme',
    toJson: paymentSchemeToJson,
    fromJson: paymentSchemeFromJson,
  )
  final enums.PaymentScheme? scheme;
  @JsonKey(
    name: 'adjusted_scheme',
    toJson: paymentSchemeToJson,
    fromJson: paymentSchemeFromJson,
  )
  final enums.PaymentScheme? adjustedScheme;
  @JsonKey(name: 'consent_id')
  final String? consentId;
  @JsonKey(name: 'transaction_id')
  final String? transactionId;
  static const fromJsonFactory = _$PaymentInitiationPaymentFromJson;
  static const toJsonFactory = _$PaymentInitiationPaymentToJson;
  Map<String, dynamic> toJson() => _$PaymentInitiationPaymentToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentInitiationPayment &&
            (identical(other.paymentId, paymentId) ||
                const DeepCollectionEquality()
                    .equals(other.paymentId, paymentId)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.recipientId, recipientId) ||
                const DeepCollectionEquality()
                    .equals(other.recipientId, recipientId)) &&
            (identical(other.reference, reference) ||
                const DeepCollectionEquality()
                    .equals(other.reference, reference)) &&
            (identical(other.adjustedReference, adjustedReference) ||
                const DeepCollectionEquality()
                    .equals(other.adjustedReference, adjustedReference)) &&
            (identical(other.lastStatusUpdate, lastStatusUpdate) ||
                const DeepCollectionEquality()
                    .equals(other.lastStatusUpdate, lastStatusUpdate)) &&
            (identical(other.schedule, schedule) ||
                const DeepCollectionEquality()
                    .equals(other.schedule, schedule)) &&
            (identical(other.refundDetails, refundDetails) ||
                const DeepCollectionEquality()
                    .equals(other.refundDetails, refundDetails)) &&
            (identical(other.bacs, bacs) ||
                const DeepCollectionEquality().equals(other.bacs, bacs)) &&
            (identical(other.iban, iban) ||
                const DeepCollectionEquality().equals(other.iban, iban)) &&
            (identical(other.refundIds, refundIds) ||
                const DeepCollectionEquality()
                    .equals(other.refundIds, refundIds)) &&
            (identical(other.amountRefunded, amountRefunded) ||
                const DeepCollectionEquality()
                    .equals(other.amountRefunded, amountRefunded)) &&
            (identical(other.walletId, walletId) ||
                const DeepCollectionEquality()
                    .equals(other.walletId, walletId)) &&
            (identical(other.scheme, scheme) ||
                const DeepCollectionEquality().equals(other.scheme, scheme)) &&
            (identical(other.adjustedScheme, adjustedScheme) ||
                const DeepCollectionEquality()
                    .equals(other.adjustedScheme, adjustedScheme)) &&
            (identical(other.consentId, consentId) ||
                const DeepCollectionEquality()
                    .equals(other.consentId, consentId)) &&
            (identical(other.transactionId, transactionId) ||
                const DeepCollectionEquality()
                    .equals(other.transactionId, transactionId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(paymentId) ^
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(recipientId) ^
      const DeepCollectionEquality().hash(reference) ^
      const DeepCollectionEquality().hash(adjustedReference) ^
      const DeepCollectionEquality().hash(lastStatusUpdate) ^
      const DeepCollectionEquality().hash(schedule) ^
      const DeepCollectionEquality().hash(refundDetails) ^
      const DeepCollectionEquality().hash(bacs) ^
      const DeepCollectionEquality().hash(iban) ^
      const DeepCollectionEquality().hash(refundIds) ^
      const DeepCollectionEquality().hash(amountRefunded) ^
      const DeepCollectionEquality().hash(walletId) ^
      const DeepCollectionEquality().hash(scheme) ^
      const DeepCollectionEquality().hash(adjustedScheme) ^
      const DeepCollectionEquality().hash(consentId) ^
      const DeepCollectionEquality().hash(transactionId) ^
      runtimeType.hashCode;
}

extension $PaymentInitiationPaymentExtension on PaymentInitiationPayment {
  PaymentInitiationPayment copyWith(
      {String? paymentId,
      PaymentAmount? amount,
      enums.PaymentInitiationPaymentStatus? status,
      String? recipientId,
      String? reference,
      String? adjustedReference,
      DateTime? lastStatusUpdate,
      ExternalPaymentScheduleGet? schedule,
      ExternalPaymentRefundDetails? refundDetails,
      SenderBACSNullable? bacs,
      String? iban,
      List<String>? refundIds,
      PaymentAmountRefunded? amountRefunded,
      String? walletId,
      enums.PaymentScheme? scheme,
      enums.PaymentScheme? adjustedScheme,
      String? consentId,
      String? transactionId}) {
    return PaymentInitiationPayment(
        paymentId: paymentId ?? this.paymentId,
        amount: amount ?? this.amount,
        status: status ?? this.status,
        recipientId: recipientId ?? this.recipientId,
        reference: reference ?? this.reference,
        adjustedReference: adjustedReference ?? this.adjustedReference,
        lastStatusUpdate: lastStatusUpdate ?? this.lastStatusUpdate,
        schedule: schedule ?? this.schedule,
        refundDetails: refundDetails ?? this.refundDetails,
        bacs: bacs ?? this.bacs,
        iban: iban ?? this.iban,
        refundIds: refundIds ?? this.refundIds,
        amountRefunded: amountRefunded ?? this.amountRefunded,
        walletId: walletId ?? this.walletId,
        scheme: scheme ?? this.scheme,
        adjustedScheme: adjustedScheme ?? this.adjustedScheme,
        consentId: consentId ?? this.consentId,
        transactionId: transactionId ?? this.transactionId);
  }

  PaymentInitiationPayment copyWithWrapped(
      {Wrapped<String>? paymentId,
      Wrapped<PaymentAmount>? amount,
      Wrapped<enums.PaymentInitiationPaymentStatus>? status,
      Wrapped<String>? recipientId,
      Wrapped<String>? reference,
      Wrapped<String?>? adjustedReference,
      Wrapped<DateTime>? lastStatusUpdate,
      Wrapped<ExternalPaymentScheduleGet?>? schedule,
      Wrapped<ExternalPaymentRefundDetails?>? refundDetails,
      Wrapped<SenderBACSNullable?>? bacs,
      Wrapped<String?>? iban,
      Wrapped<List<String>?>? refundIds,
      Wrapped<PaymentAmountRefunded?>? amountRefunded,
      Wrapped<String?>? walletId,
      Wrapped<enums.PaymentScheme?>? scheme,
      Wrapped<enums.PaymentScheme?>? adjustedScheme,
      Wrapped<String?>? consentId,
      Wrapped<String?>? transactionId}) {
    return PaymentInitiationPayment(
        paymentId: (paymentId != null ? paymentId.value : this.paymentId),
        amount: (amount != null ? amount.value : this.amount),
        status: (status != null ? status.value : this.status),
        recipientId:
            (recipientId != null ? recipientId.value : this.recipientId),
        reference: (reference != null ? reference.value : this.reference),
        adjustedReference: (adjustedReference != null
            ? adjustedReference.value
            : this.adjustedReference),
        lastStatusUpdate: (lastStatusUpdate != null
            ? lastStatusUpdate.value
            : this.lastStatusUpdate),
        schedule: (schedule != null ? schedule.value : this.schedule),
        refundDetails:
            (refundDetails != null ? refundDetails.value : this.refundDetails),
        bacs: (bacs != null ? bacs.value : this.bacs),
        iban: (iban != null ? iban.value : this.iban),
        refundIds: (refundIds != null ? refundIds.value : this.refundIds),
        amountRefunded: (amountRefunded != null
            ? amountRefunded.value
            : this.amountRefunded),
        walletId: (walletId != null ? walletId.value : this.walletId),
        scheme: (scheme != null ? scheme.value : this.scheme),
        adjustedScheme: (adjustedScheme != null
            ? adjustedScheme.value
            : this.adjustedScheme),
        consentId: (consentId != null ? consentId.value : this.consentId),
        transactionId:
            (transactionId != null ? transactionId.value : this.transactionId));
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentInitiationPaymentTokenCreateRequest {
  PaymentInitiationPaymentTokenCreateRequest({
    this.clientId,
    this.secret,
    required this.paymentId,
  });

  factory PaymentInitiationPaymentTokenCreateRequest.fromJson(
          Map<String, dynamic> json) =>
      _$PaymentInitiationPaymentTokenCreateRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'payment_id')
  final String paymentId;
  static const fromJsonFactory =
      _$PaymentInitiationPaymentTokenCreateRequestFromJson;
  static const toJsonFactory =
      _$PaymentInitiationPaymentTokenCreateRequestToJson;
  Map<String, dynamic> toJson() =>
      _$PaymentInitiationPaymentTokenCreateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentInitiationPaymentTokenCreateRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.paymentId, paymentId) ||
                const DeepCollectionEquality()
                    .equals(other.paymentId, paymentId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(paymentId) ^
      runtimeType.hashCode;
}

extension $PaymentInitiationPaymentTokenCreateRequestExtension
    on PaymentInitiationPaymentTokenCreateRequest {
  PaymentInitiationPaymentTokenCreateRequest copyWith(
      {String? clientId, String? secret, String? paymentId}) {
    return PaymentInitiationPaymentTokenCreateRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        paymentId: paymentId ?? this.paymentId);
  }

  PaymentInitiationPaymentTokenCreateRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? paymentId}) {
    return PaymentInitiationPaymentTokenCreateRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        paymentId: (paymentId != null ? paymentId.value : this.paymentId));
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentInitiationPaymentTokenCreateResponse {
  PaymentInitiationPaymentTokenCreateResponse({
    required this.paymentToken,
    required this.paymentTokenExpirationTime,
    required this.requestId,
  });

  factory PaymentInitiationPaymentTokenCreateResponse.fromJson(
          Map<String, dynamic> json) =>
      _$PaymentInitiationPaymentTokenCreateResponseFromJson(json);

  @JsonKey(name: 'payment_token')
  final String paymentToken;
  @JsonKey(name: 'payment_token_expiration_time')
  final DateTime paymentTokenExpirationTime;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory =
      _$PaymentInitiationPaymentTokenCreateResponseFromJson;
  static const toJsonFactory =
      _$PaymentInitiationPaymentTokenCreateResponseToJson;
  Map<String, dynamic> toJson() =>
      _$PaymentInitiationPaymentTokenCreateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentInitiationPaymentTokenCreateResponse &&
            (identical(other.paymentToken, paymentToken) ||
                const DeepCollectionEquality()
                    .equals(other.paymentToken, paymentToken)) &&
            (identical(other.paymentTokenExpirationTime,
                    paymentTokenExpirationTime) ||
                const DeepCollectionEquality().equals(
                    other.paymentTokenExpirationTime,
                    paymentTokenExpirationTime)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(paymentToken) ^
      const DeepCollectionEquality().hash(paymentTokenExpirationTime) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $PaymentInitiationPaymentTokenCreateResponseExtension
    on PaymentInitiationPaymentTokenCreateResponse {
  PaymentInitiationPaymentTokenCreateResponse copyWith(
      {String? paymentToken,
      DateTime? paymentTokenExpirationTime,
      String? requestId}) {
    return PaymentInitiationPaymentTokenCreateResponse(
        paymentToken: paymentToken ?? this.paymentToken,
        paymentTokenExpirationTime:
            paymentTokenExpirationTime ?? this.paymentTokenExpirationTime,
        requestId: requestId ?? this.requestId);
  }

  PaymentInitiationPaymentTokenCreateResponse copyWithWrapped(
      {Wrapped<String>? paymentToken,
      Wrapped<DateTime>? paymentTokenExpirationTime,
      Wrapped<String>? requestId}) {
    return PaymentInitiationPaymentTokenCreateResponse(
        paymentToken:
            (paymentToken != null ? paymentToken.value : this.paymentToken),
        paymentTokenExpirationTime: (paymentTokenExpirationTime != null
            ? paymentTokenExpirationTime.value
            : this.paymentTokenExpirationTime),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentInitiationConsentCreateRequest {
  PaymentInitiationConsentCreateRequest({
    this.clientId,
    this.secret,
    required this.recipientId,
    required this.reference,
    required this.scopes,
    required this.constraints,
    this.options,
  });

  factory PaymentInitiationConsentCreateRequest.fromJson(
          Map<String, dynamic> json) =>
      _$PaymentInitiationConsentCreateRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'recipient_id')
  final String recipientId;
  @JsonKey(name: 'reference')
  final String reference;
  @JsonKey(
    name: 'scopes',
    toJson: paymentInitiationConsentScopeListToJson,
    fromJson: paymentInitiationConsentScopeListFromJson,
  )
  final List<enums.PaymentInitiationConsentScope> scopes;
  @JsonKey(name: 'constraints')
  final PaymentInitiationConsentConstraints constraints;
  @JsonKey(name: 'options')
  final ExternalPaymentInitiationConsentOptions? options;
  static const fromJsonFactory =
      _$PaymentInitiationConsentCreateRequestFromJson;
  static const toJsonFactory = _$PaymentInitiationConsentCreateRequestToJson;
  Map<String, dynamic> toJson() =>
      _$PaymentInitiationConsentCreateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentInitiationConsentCreateRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.recipientId, recipientId) ||
                const DeepCollectionEquality()
                    .equals(other.recipientId, recipientId)) &&
            (identical(other.reference, reference) ||
                const DeepCollectionEquality()
                    .equals(other.reference, reference)) &&
            (identical(other.scopes, scopes) ||
                const DeepCollectionEquality().equals(other.scopes, scopes)) &&
            (identical(other.constraints, constraints) ||
                const DeepCollectionEquality()
                    .equals(other.constraints, constraints)) &&
            (identical(other.options, options) ||
                const DeepCollectionEquality().equals(other.options, options)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(recipientId) ^
      const DeepCollectionEquality().hash(reference) ^
      const DeepCollectionEquality().hash(scopes) ^
      const DeepCollectionEquality().hash(constraints) ^
      const DeepCollectionEquality().hash(options) ^
      runtimeType.hashCode;
}

extension $PaymentInitiationConsentCreateRequestExtension
    on PaymentInitiationConsentCreateRequest {
  PaymentInitiationConsentCreateRequest copyWith(
      {String? clientId,
      String? secret,
      String? recipientId,
      String? reference,
      List<enums.PaymentInitiationConsentScope>? scopes,
      PaymentInitiationConsentConstraints? constraints,
      ExternalPaymentInitiationConsentOptions? options}) {
    return PaymentInitiationConsentCreateRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        recipientId: recipientId ?? this.recipientId,
        reference: reference ?? this.reference,
        scopes: scopes ?? this.scopes,
        constraints: constraints ?? this.constraints,
        options: options ?? this.options);
  }

  PaymentInitiationConsentCreateRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? recipientId,
      Wrapped<String>? reference,
      Wrapped<List<enums.PaymentInitiationConsentScope>>? scopes,
      Wrapped<PaymentInitiationConsentConstraints>? constraints,
      Wrapped<ExternalPaymentInitiationConsentOptions?>? options}) {
    return PaymentInitiationConsentCreateRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        recipientId:
            (recipientId != null ? recipientId.value : this.recipientId),
        reference: (reference != null ? reference.value : this.reference),
        scopes: (scopes != null ? scopes.value : this.scopes),
        constraints:
            (constraints != null ? constraints.value : this.constraints),
        options: (options != null ? options.value : this.options));
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentInitiationConsentCreateResponse {
  PaymentInitiationConsentCreateResponse({
    required this.consentId,
    required this.status,
    required this.requestId,
  });

  factory PaymentInitiationConsentCreateResponse.fromJson(
          Map<String, dynamic> json) =>
      _$PaymentInitiationConsentCreateResponseFromJson(json);

  @JsonKey(name: 'consent_id')
  final String consentId;
  @JsonKey(
    name: 'status',
    toJson: paymentInitiationConsentStatusToJson,
    fromJson: paymentInitiationConsentStatusFromJson,
  )
  final enums.PaymentInitiationConsentStatus status;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory =
      _$PaymentInitiationConsentCreateResponseFromJson;
  static const toJsonFactory = _$PaymentInitiationConsentCreateResponseToJson;
  Map<String, dynamic> toJson() =>
      _$PaymentInitiationConsentCreateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentInitiationConsentCreateResponse &&
            (identical(other.consentId, consentId) ||
                const DeepCollectionEquality()
                    .equals(other.consentId, consentId)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(consentId) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $PaymentInitiationConsentCreateResponseExtension
    on PaymentInitiationConsentCreateResponse {
  PaymentInitiationConsentCreateResponse copyWith(
      {String? consentId,
      enums.PaymentInitiationConsentStatus? status,
      String? requestId}) {
    return PaymentInitiationConsentCreateResponse(
        consentId: consentId ?? this.consentId,
        status: status ?? this.status,
        requestId: requestId ?? this.requestId);
  }

  PaymentInitiationConsentCreateResponse copyWithWrapped(
      {Wrapped<String>? consentId,
      Wrapped<enums.PaymentInitiationConsentStatus>? status,
      Wrapped<String>? requestId}) {
    return PaymentInitiationConsentCreateResponse(
        consentId: (consentId != null ? consentId.value : this.consentId),
        status: (status != null ? status.value : this.status),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentInitiationConsentGetRequest {
  PaymentInitiationConsentGetRequest({
    this.clientId,
    this.secret,
    required this.consentId,
  });

  factory PaymentInitiationConsentGetRequest.fromJson(
          Map<String, dynamic> json) =>
      _$PaymentInitiationConsentGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'consent_id')
  final String consentId;
  static const fromJsonFactory = _$PaymentInitiationConsentGetRequestFromJson;
  static const toJsonFactory = _$PaymentInitiationConsentGetRequestToJson;
  Map<String, dynamic> toJson() =>
      _$PaymentInitiationConsentGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentInitiationConsentGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.consentId, consentId) ||
                const DeepCollectionEquality()
                    .equals(other.consentId, consentId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(consentId) ^
      runtimeType.hashCode;
}

extension $PaymentInitiationConsentGetRequestExtension
    on PaymentInitiationConsentGetRequest {
  PaymentInitiationConsentGetRequest copyWith(
      {String? clientId, String? secret, String? consentId}) {
    return PaymentInitiationConsentGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        consentId: consentId ?? this.consentId);
  }

  PaymentInitiationConsentGetRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? consentId}) {
    return PaymentInitiationConsentGetRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        consentId: (consentId != null ? consentId.value : this.consentId));
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentInitiationConsentGetResponse {
  PaymentInitiationConsentGetResponse({
    required this.requestId,
    required this.consentId,
    required this.status,
    required this.createdAt,
    required this.recipientId,
    required this.reference,
    required this.constraints,
    required this.scopes,
  });

  factory PaymentInitiationConsentGetResponse.fromJson(
          Map<String, dynamic> json) =>
      _$PaymentInitiationConsentGetResponseFromJson(json);

  @JsonKey(name: 'request_id')
  final String requestId;
  @JsonKey(name: 'consent_id')
  final String consentId;
  @JsonKey(
    name: 'status',
    toJson: paymentInitiationConsentStatusToJson,
    fromJson: paymentInitiationConsentStatusFromJson,
  )
  final enums.PaymentInitiationConsentStatus status;
  @JsonKey(name: 'created_at')
  final DateTime createdAt;
  @JsonKey(name: 'recipient_id')
  final String recipientId;
  @JsonKey(name: 'reference')
  final String reference;
  @JsonKey(name: 'constraints')
  final PaymentInitiationConsentConstraints constraints;
  @JsonKey(
    name: 'scopes',
    toJson: paymentInitiationConsentScopeListToJson,
    fromJson: paymentInitiationConsentScopeListFromJson,
  )
  final List<enums.PaymentInitiationConsentScope> scopes;
  static const fromJsonFactory = _$PaymentInitiationConsentGetResponseFromJson;
  static const toJsonFactory = _$PaymentInitiationConsentGetResponseToJson;
  Map<String, dynamic> toJson() =>
      _$PaymentInitiationConsentGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentInitiationConsentGetResponse &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)) &&
            (identical(other.consentId, consentId) ||
                const DeepCollectionEquality()
                    .equals(other.consentId, consentId)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.createdAt, createdAt) ||
                const DeepCollectionEquality()
                    .equals(other.createdAt, createdAt)) &&
            (identical(other.recipientId, recipientId) ||
                const DeepCollectionEquality()
                    .equals(other.recipientId, recipientId)) &&
            (identical(other.reference, reference) ||
                const DeepCollectionEquality()
                    .equals(other.reference, reference)) &&
            (identical(other.constraints, constraints) ||
                const DeepCollectionEquality()
                    .equals(other.constraints, constraints)) &&
            (identical(other.scopes, scopes) ||
                const DeepCollectionEquality().equals(other.scopes, scopes)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(requestId) ^
      const DeepCollectionEquality().hash(consentId) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(createdAt) ^
      const DeepCollectionEquality().hash(recipientId) ^
      const DeepCollectionEquality().hash(reference) ^
      const DeepCollectionEquality().hash(constraints) ^
      const DeepCollectionEquality().hash(scopes) ^
      runtimeType.hashCode;
}

extension $PaymentInitiationConsentGetResponseExtension
    on PaymentInitiationConsentGetResponse {
  PaymentInitiationConsentGetResponse copyWith(
      {String? requestId,
      String? consentId,
      enums.PaymentInitiationConsentStatus? status,
      DateTime? createdAt,
      String? recipientId,
      String? reference,
      PaymentInitiationConsentConstraints? constraints,
      List<enums.PaymentInitiationConsentScope>? scopes}) {
    return PaymentInitiationConsentGetResponse(
        requestId: requestId ?? this.requestId,
        consentId: consentId ?? this.consentId,
        status: status ?? this.status,
        createdAt: createdAt ?? this.createdAt,
        recipientId: recipientId ?? this.recipientId,
        reference: reference ?? this.reference,
        constraints: constraints ?? this.constraints,
        scopes: scopes ?? this.scopes);
  }

  PaymentInitiationConsentGetResponse copyWithWrapped(
      {Wrapped<String>? requestId,
      Wrapped<String>? consentId,
      Wrapped<enums.PaymentInitiationConsentStatus>? status,
      Wrapped<DateTime>? createdAt,
      Wrapped<String>? recipientId,
      Wrapped<String>? reference,
      Wrapped<PaymentInitiationConsentConstraints>? constraints,
      Wrapped<List<enums.PaymentInitiationConsentScope>>? scopes}) {
    return PaymentInitiationConsentGetResponse(
        requestId: (requestId != null ? requestId.value : this.requestId),
        consentId: (consentId != null ? consentId.value : this.consentId),
        status: (status != null ? status.value : this.status),
        createdAt: (createdAt != null ? createdAt.value : this.createdAt),
        recipientId:
            (recipientId != null ? recipientId.value : this.recipientId),
        reference: (reference != null ? reference.value : this.reference),
        constraints:
            (constraints != null ? constraints.value : this.constraints),
        scopes: (scopes != null ? scopes.value : this.scopes));
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentInitiationConsent {
  PaymentInitiationConsent({
    required this.consentId,
    required this.status,
    required this.createdAt,
    required this.recipientId,
    required this.reference,
    required this.constraints,
    required this.scopes,
  });

  factory PaymentInitiationConsent.fromJson(Map<String, dynamic> json) =>
      _$PaymentInitiationConsentFromJson(json);

  @JsonKey(name: 'consent_id')
  final String consentId;
  @JsonKey(
    name: 'status',
    toJson: paymentInitiationConsentStatusToJson,
    fromJson: paymentInitiationConsentStatusFromJson,
  )
  final enums.PaymentInitiationConsentStatus status;
  @JsonKey(name: 'created_at')
  final DateTime createdAt;
  @JsonKey(name: 'recipient_id')
  final String recipientId;
  @JsonKey(name: 'reference')
  final String reference;
  @JsonKey(name: 'constraints')
  final PaymentInitiationConsentConstraints constraints;
  @JsonKey(
    name: 'scopes',
    toJson: paymentInitiationConsentScopeListToJson,
    fromJson: paymentInitiationConsentScopeListFromJson,
  )
  final List<enums.PaymentInitiationConsentScope> scopes;
  static const fromJsonFactory = _$PaymentInitiationConsentFromJson;
  static const toJsonFactory = _$PaymentInitiationConsentToJson;
  Map<String, dynamic> toJson() => _$PaymentInitiationConsentToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentInitiationConsent &&
            (identical(other.consentId, consentId) ||
                const DeepCollectionEquality()
                    .equals(other.consentId, consentId)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.createdAt, createdAt) ||
                const DeepCollectionEquality()
                    .equals(other.createdAt, createdAt)) &&
            (identical(other.recipientId, recipientId) ||
                const DeepCollectionEquality()
                    .equals(other.recipientId, recipientId)) &&
            (identical(other.reference, reference) ||
                const DeepCollectionEquality()
                    .equals(other.reference, reference)) &&
            (identical(other.constraints, constraints) ||
                const DeepCollectionEquality()
                    .equals(other.constraints, constraints)) &&
            (identical(other.scopes, scopes) ||
                const DeepCollectionEquality().equals(other.scopes, scopes)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(consentId) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(createdAt) ^
      const DeepCollectionEquality().hash(recipientId) ^
      const DeepCollectionEquality().hash(reference) ^
      const DeepCollectionEquality().hash(constraints) ^
      const DeepCollectionEquality().hash(scopes) ^
      runtimeType.hashCode;
}

extension $PaymentInitiationConsentExtension on PaymentInitiationConsent {
  PaymentInitiationConsent copyWith(
      {String? consentId,
      enums.PaymentInitiationConsentStatus? status,
      DateTime? createdAt,
      String? recipientId,
      String? reference,
      PaymentInitiationConsentConstraints? constraints,
      List<enums.PaymentInitiationConsentScope>? scopes}) {
    return PaymentInitiationConsent(
        consentId: consentId ?? this.consentId,
        status: status ?? this.status,
        createdAt: createdAt ?? this.createdAt,
        recipientId: recipientId ?? this.recipientId,
        reference: reference ?? this.reference,
        constraints: constraints ?? this.constraints,
        scopes: scopes ?? this.scopes);
  }

  PaymentInitiationConsent copyWithWrapped(
      {Wrapped<String>? consentId,
      Wrapped<enums.PaymentInitiationConsentStatus>? status,
      Wrapped<DateTime>? createdAt,
      Wrapped<String>? recipientId,
      Wrapped<String>? reference,
      Wrapped<PaymentInitiationConsentConstraints>? constraints,
      Wrapped<List<enums.PaymentInitiationConsentScope>>? scopes}) {
    return PaymentInitiationConsent(
        consentId: (consentId != null ? consentId.value : this.consentId),
        status: (status != null ? status.value : this.status),
        createdAt: (createdAt != null ? createdAt.value : this.createdAt),
        recipientId:
            (recipientId != null ? recipientId.value : this.recipientId),
        reference: (reference != null ? reference.value : this.reference),
        constraints:
            (constraints != null ? constraints.value : this.constraints),
        scopes: (scopes != null ? scopes.value : this.scopes));
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentInitiationConsentRevokeRequest {
  PaymentInitiationConsentRevokeRequest({
    this.clientId,
    this.secret,
    required this.consentId,
  });

  factory PaymentInitiationConsentRevokeRequest.fromJson(
          Map<String, dynamic> json) =>
      _$PaymentInitiationConsentRevokeRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'consent_id')
  final String consentId;
  static const fromJsonFactory =
      _$PaymentInitiationConsentRevokeRequestFromJson;
  static const toJsonFactory = _$PaymentInitiationConsentRevokeRequestToJson;
  Map<String, dynamic> toJson() =>
      _$PaymentInitiationConsentRevokeRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentInitiationConsentRevokeRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.consentId, consentId) ||
                const DeepCollectionEquality()
                    .equals(other.consentId, consentId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(consentId) ^
      runtimeType.hashCode;
}

extension $PaymentInitiationConsentRevokeRequestExtension
    on PaymentInitiationConsentRevokeRequest {
  PaymentInitiationConsentRevokeRequest copyWith(
      {String? clientId, String? secret, String? consentId}) {
    return PaymentInitiationConsentRevokeRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        consentId: consentId ?? this.consentId);
  }

  PaymentInitiationConsentRevokeRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? consentId}) {
    return PaymentInitiationConsentRevokeRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        consentId: (consentId != null ? consentId.value : this.consentId));
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentInitiationConsentRevokeResponse {
  PaymentInitiationConsentRevokeResponse({
    this.requestId,
  });

  factory PaymentInitiationConsentRevokeResponse.fromJson(
          Map<String, dynamic> json) =>
      _$PaymentInitiationConsentRevokeResponseFromJson(json);

  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory =
      _$PaymentInitiationConsentRevokeResponseFromJson;
  static const toJsonFactory = _$PaymentInitiationConsentRevokeResponseToJson;
  Map<String, dynamic> toJson() =>
      _$PaymentInitiationConsentRevokeResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentInitiationConsentRevokeResponse &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(requestId) ^ runtimeType.hashCode;
}

extension $PaymentInitiationConsentRevokeResponseExtension
    on PaymentInitiationConsentRevokeResponse {
  PaymentInitiationConsentRevokeResponse copyWith({String? requestId}) {
    return PaymentInitiationConsentRevokeResponse(
        requestId: requestId ?? this.requestId);
  }

  PaymentInitiationConsentRevokeResponse copyWithWrapped(
      {Wrapped<String?>? requestId}) {
    return PaymentInitiationConsentRevokeResponse(
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentInitiationConsentPaymentExecuteRequest {
  PaymentInitiationConsentPaymentExecuteRequest({
    this.clientId,
    this.secret,
    required this.consentId,
    required this.amount,
    required this.idempotencyKey,
  });

  factory PaymentInitiationConsentPaymentExecuteRequest.fromJson(
          Map<String, dynamic> json) =>
      _$PaymentInitiationConsentPaymentExecuteRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'consent_id')
  final String consentId;
  @JsonKey(name: 'amount')
  final PaymentAmount amount;
  @JsonKey(name: 'idempotency_key')
  final String idempotencyKey;
  static const fromJsonFactory =
      _$PaymentInitiationConsentPaymentExecuteRequestFromJson;
  static const toJsonFactory =
      _$PaymentInitiationConsentPaymentExecuteRequestToJson;
  Map<String, dynamic> toJson() =>
      _$PaymentInitiationConsentPaymentExecuteRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentInitiationConsentPaymentExecuteRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.consentId, consentId) ||
                const DeepCollectionEquality()
                    .equals(other.consentId, consentId)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.idempotencyKey, idempotencyKey) ||
                const DeepCollectionEquality()
                    .equals(other.idempotencyKey, idempotencyKey)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(consentId) ^
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(idempotencyKey) ^
      runtimeType.hashCode;
}

extension $PaymentInitiationConsentPaymentExecuteRequestExtension
    on PaymentInitiationConsentPaymentExecuteRequest {
  PaymentInitiationConsentPaymentExecuteRequest copyWith(
      {String? clientId,
      String? secret,
      String? consentId,
      PaymentAmount? amount,
      String? idempotencyKey}) {
    return PaymentInitiationConsentPaymentExecuteRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        consentId: consentId ?? this.consentId,
        amount: amount ?? this.amount,
        idempotencyKey: idempotencyKey ?? this.idempotencyKey);
  }

  PaymentInitiationConsentPaymentExecuteRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? consentId,
      Wrapped<PaymentAmount>? amount,
      Wrapped<String>? idempotencyKey}) {
    return PaymentInitiationConsentPaymentExecuteRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        consentId: (consentId != null ? consentId.value : this.consentId),
        amount: (amount != null ? amount.value : this.amount),
        idempotencyKey: (idempotencyKey != null
            ? idempotencyKey.value
            : this.idempotencyKey));
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentInitiationConsentPaymentExecuteResponse {
  PaymentInitiationConsentPaymentExecuteResponse({
    required this.paymentId,
    required this.status,
    required this.requestId,
  });

  factory PaymentInitiationConsentPaymentExecuteResponse.fromJson(
          Map<String, dynamic> json) =>
      _$PaymentInitiationConsentPaymentExecuteResponseFromJson(json);

  @JsonKey(name: 'payment_id')
  final String paymentId;
  @JsonKey(
    name: 'status',
    toJson: paymentInitiationPaymentStatusToJson,
    fromJson: paymentInitiationPaymentStatusFromJson,
  )
  final enums.PaymentInitiationPaymentStatus status;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory =
      _$PaymentInitiationConsentPaymentExecuteResponseFromJson;
  static const toJsonFactory =
      _$PaymentInitiationConsentPaymentExecuteResponseToJson;
  Map<String, dynamic> toJson() =>
      _$PaymentInitiationConsentPaymentExecuteResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentInitiationConsentPaymentExecuteResponse &&
            (identical(other.paymentId, paymentId) ||
                const DeepCollectionEquality()
                    .equals(other.paymentId, paymentId)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(paymentId) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $PaymentInitiationConsentPaymentExecuteResponseExtension
    on PaymentInitiationConsentPaymentExecuteResponse {
  PaymentInitiationConsentPaymentExecuteResponse copyWith(
      {String? paymentId,
      enums.PaymentInitiationPaymentStatus? status,
      String? requestId}) {
    return PaymentInitiationConsentPaymentExecuteResponse(
        paymentId: paymentId ?? this.paymentId,
        status: status ?? this.status,
        requestId: requestId ?? this.requestId);
  }

  PaymentInitiationConsentPaymentExecuteResponse copyWithWrapped(
      {Wrapped<String>? paymentId,
      Wrapped<enums.PaymentInitiationPaymentStatus>? status,
      Wrapped<String>? requestId}) {
    return PaymentInitiationConsentPaymentExecuteResponse(
        paymentId: (paymentId != null ? paymentId.value : this.paymentId),
        status: (status != null ? status.value : this.status),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentInitiationPaymentListRequest {
  PaymentInitiationPaymentListRequest({
    this.clientId,
    this.secret,
    this.count,
    this.cursor,
    this.consentId,
  });

  factory PaymentInitiationPaymentListRequest.fromJson(
          Map<String, dynamic> json) =>
      _$PaymentInitiationPaymentListRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'count')
  final int? count;
  @JsonKey(name: 'cursor')
  final DateTime? cursor;
  @JsonKey(name: 'consent_id')
  final String? consentId;
  static const fromJsonFactory = _$PaymentInitiationPaymentListRequestFromJson;
  static const toJsonFactory = _$PaymentInitiationPaymentListRequestToJson;
  Map<String, dynamic> toJson() =>
      _$PaymentInitiationPaymentListRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentInitiationPaymentListRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)) &&
            (identical(other.cursor, cursor) ||
                const DeepCollectionEquality().equals(other.cursor, cursor)) &&
            (identical(other.consentId, consentId) ||
                const DeepCollectionEquality()
                    .equals(other.consentId, consentId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(count) ^
      const DeepCollectionEquality().hash(cursor) ^
      const DeepCollectionEquality().hash(consentId) ^
      runtimeType.hashCode;
}

extension $PaymentInitiationPaymentListRequestExtension
    on PaymentInitiationPaymentListRequest {
  PaymentInitiationPaymentListRequest copyWith(
      {String? clientId,
      String? secret,
      int? count,
      DateTime? cursor,
      String? consentId}) {
    return PaymentInitiationPaymentListRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        count: count ?? this.count,
        cursor: cursor ?? this.cursor,
        consentId: consentId ?? this.consentId);
  }

  PaymentInitiationPaymentListRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<int?>? count,
      Wrapped<DateTime?>? cursor,
      Wrapped<String?>? consentId}) {
    return PaymentInitiationPaymentListRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        count: (count != null ? count.value : this.count),
        cursor: (cursor != null ? cursor.value : this.cursor),
        consentId: (consentId != null ? consentId.value : this.consentId));
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentInitiationPaymentListResponse {
  PaymentInitiationPaymentListResponse({
    required this.payments,
    required this.nextCursor,
    required this.requestId,
  });

  factory PaymentInitiationPaymentListResponse.fromJson(
          Map<String, dynamic> json) =>
      _$PaymentInitiationPaymentListResponseFromJson(json);

  @JsonKey(name: 'payments', defaultValue: <PaymentInitiationPayment>[])
  final List<PaymentInitiationPayment> payments;
  @JsonKey(name: 'next_cursor')
  final DateTime? nextCursor;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$PaymentInitiationPaymentListResponseFromJson;
  static const toJsonFactory = _$PaymentInitiationPaymentListResponseToJson;
  Map<String, dynamic> toJson() =>
      _$PaymentInitiationPaymentListResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentInitiationPaymentListResponse &&
            (identical(other.payments, payments) ||
                const DeepCollectionEquality()
                    .equals(other.payments, payments)) &&
            (identical(other.nextCursor, nextCursor) ||
                const DeepCollectionEquality()
                    .equals(other.nextCursor, nextCursor)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(payments) ^
      const DeepCollectionEquality().hash(nextCursor) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $PaymentInitiationPaymentListResponseExtension
    on PaymentInitiationPaymentListResponse {
  PaymentInitiationPaymentListResponse copyWith(
      {List<PaymentInitiationPayment>? payments,
      DateTime? nextCursor,
      String? requestId}) {
    return PaymentInitiationPaymentListResponse(
        payments: payments ?? this.payments,
        nextCursor: nextCursor ?? this.nextCursor,
        requestId: requestId ?? this.requestId);
  }

  PaymentInitiationPaymentListResponse copyWithWrapped(
      {Wrapped<List<PaymentInitiationPayment>>? payments,
      Wrapped<DateTime?>? nextCursor,
      Wrapped<String>? requestId}) {
    return PaymentInitiationPaymentListResponse(
        payments: (payments != null ? payments.value : this.payments),
        nextCursor: (nextCursor != null ? nextCursor.value : this.nextCursor),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class InvestmentsHoldingsGetRequest {
  InvestmentsHoldingsGetRequest({
    this.clientId,
    this.secret,
    required this.accessToken,
    this.options,
  });

  factory InvestmentsHoldingsGetRequest.fromJson(Map<String, dynamic> json) =>
      _$InvestmentsHoldingsGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'access_token')
  final String accessToken;
  @JsonKey(name: 'options')
  final InvestmentHoldingsGetRequestOptions? options;
  static const fromJsonFactory = _$InvestmentsHoldingsGetRequestFromJson;
  static const toJsonFactory = _$InvestmentsHoldingsGetRequestToJson;
  Map<String, dynamic> toJson() => _$InvestmentsHoldingsGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvestmentsHoldingsGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)) &&
            (identical(other.options, options) ||
                const DeepCollectionEquality().equals(other.options, options)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(accessToken) ^
      const DeepCollectionEquality().hash(options) ^
      runtimeType.hashCode;
}

extension $InvestmentsHoldingsGetRequestExtension
    on InvestmentsHoldingsGetRequest {
  InvestmentsHoldingsGetRequest copyWith(
      {String? clientId,
      String? secret,
      String? accessToken,
      InvestmentHoldingsGetRequestOptions? options}) {
    return InvestmentsHoldingsGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        accessToken: accessToken ?? this.accessToken,
        options: options ?? this.options);
  }

  InvestmentsHoldingsGetRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? accessToken,
      Wrapped<InvestmentHoldingsGetRequestOptions?>? options}) {
    return InvestmentsHoldingsGetRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        accessToken:
            (accessToken != null ? accessToken.value : this.accessToken),
        options: (options != null ? options.value : this.options));
  }
}

@JsonSerializable(explicitToJson: true)
class InvestmentHoldingsGetRequestOptions {
  InvestmentHoldingsGetRequestOptions({
    this.accountIds,
  });

  factory InvestmentHoldingsGetRequestOptions.fromJson(
          Map<String, dynamic> json) =>
      _$InvestmentHoldingsGetRequestOptionsFromJson(json);

  @JsonKey(name: 'account_ids', defaultValue: <String>[])
  final List<String>? accountIds;
  static const fromJsonFactory = _$InvestmentHoldingsGetRequestOptionsFromJson;
  static const toJsonFactory = _$InvestmentHoldingsGetRequestOptionsToJson;
  Map<String, dynamic> toJson() =>
      _$InvestmentHoldingsGetRequestOptionsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvestmentHoldingsGetRequestOptions &&
            (identical(other.accountIds, accountIds) ||
                const DeepCollectionEquality()
                    .equals(other.accountIds, accountIds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountIds) ^ runtimeType.hashCode;
}

extension $InvestmentHoldingsGetRequestOptionsExtension
    on InvestmentHoldingsGetRequestOptions {
  InvestmentHoldingsGetRequestOptions copyWith({List<String>? accountIds}) {
    return InvestmentHoldingsGetRequestOptions(
        accountIds: accountIds ?? this.accountIds);
  }

  InvestmentHoldingsGetRequestOptions copyWithWrapped(
      {Wrapped<List<String>?>? accountIds}) {
    return InvestmentHoldingsGetRequestOptions(
        accountIds: (accountIds != null ? accountIds.value : this.accountIds));
  }
}

@JsonSerializable(explicitToJson: true)
class InvestmentsHoldingsGetResponse {
  InvestmentsHoldingsGetResponse({
    required this.accounts,
    required this.holdings,
    required this.securities,
    required this.item,
    required this.requestId,
  });

  factory InvestmentsHoldingsGetResponse.fromJson(Map<String, dynamic> json) =>
      _$InvestmentsHoldingsGetResponseFromJson(json);

  @JsonKey(name: 'accounts', defaultValue: <AccountBase>[])
  final List<AccountBase> accounts;
  @JsonKey(name: 'holdings', defaultValue: <Holding>[])
  final List<Holding> holdings;
  @JsonKey(name: 'securities', defaultValue: <Security>[])
  final List<Security> securities;
  @JsonKey(name: 'item')
  final Item item;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$InvestmentsHoldingsGetResponseFromJson;
  static const toJsonFactory = _$InvestmentsHoldingsGetResponseToJson;
  Map<String, dynamic> toJson() => _$InvestmentsHoldingsGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvestmentsHoldingsGetResponse &&
            (identical(other.accounts, accounts) ||
                const DeepCollectionEquality()
                    .equals(other.accounts, accounts)) &&
            (identical(other.holdings, holdings) ||
                const DeepCollectionEquality()
                    .equals(other.holdings, holdings)) &&
            (identical(other.securities, securities) ||
                const DeepCollectionEquality()
                    .equals(other.securities, securities)) &&
            (identical(other.item, item) ||
                const DeepCollectionEquality().equals(other.item, item)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accounts) ^
      const DeepCollectionEquality().hash(holdings) ^
      const DeepCollectionEquality().hash(securities) ^
      const DeepCollectionEquality().hash(item) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $InvestmentsHoldingsGetResponseExtension
    on InvestmentsHoldingsGetResponse {
  InvestmentsHoldingsGetResponse copyWith(
      {List<AccountBase>? accounts,
      List<Holding>? holdings,
      List<Security>? securities,
      Item? item,
      String? requestId}) {
    return InvestmentsHoldingsGetResponse(
        accounts: accounts ?? this.accounts,
        holdings: holdings ?? this.holdings,
        securities: securities ?? this.securities,
        item: item ?? this.item,
        requestId: requestId ?? this.requestId);
  }

  InvestmentsHoldingsGetResponse copyWithWrapped(
      {Wrapped<List<AccountBase>>? accounts,
      Wrapped<List<Holding>>? holdings,
      Wrapped<List<Security>>? securities,
      Wrapped<Item>? item,
      Wrapped<String>? requestId}) {
    return InvestmentsHoldingsGetResponse(
        accounts: (accounts != null ? accounts.value : this.accounts),
        holdings: (holdings != null ? holdings.value : this.holdings),
        securities: (securities != null ? securities.value : this.securities),
        item: (item != null ? item.value : this.item),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class InvestmentsTransactionsGetRequest {
  InvestmentsTransactionsGetRequest({
    this.clientId,
    this.secret,
    required this.accessToken,
    required this.startDate,
    required this.endDate,
    this.options,
  });

  factory InvestmentsTransactionsGetRequest.fromJson(
          Map<String, dynamic> json) =>
      _$InvestmentsTransactionsGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'access_token')
  final String accessToken;
  @JsonKey(name: 'start_date', toJson: _dateToJson)
  final DateTime startDate;
  @JsonKey(name: 'end_date', toJson: _dateToJson)
  final DateTime endDate;
  @JsonKey(name: 'options')
  final InvestmentsTransactionsGetRequestOptions? options;
  static const fromJsonFactory = _$InvestmentsTransactionsGetRequestFromJson;
  static const toJsonFactory = _$InvestmentsTransactionsGetRequestToJson;
  Map<String, dynamic> toJson() =>
      _$InvestmentsTransactionsGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvestmentsTransactionsGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)) &&
            (identical(other.startDate, startDate) ||
                const DeepCollectionEquality()
                    .equals(other.startDate, startDate)) &&
            (identical(other.endDate, endDate) ||
                const DeepCollectionEquality()
                    .equals(other.endDate, endDate)) &&
            (identical(other.options, options) ||
                const DeepCollectionEquality().equals(other.options, options)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(accessToken) ^
      const DeepCollectionEquality().hash(startDate) ^
      const DeepCollectionEquality().hash(endDate) ^
      const DeepCollectionEquality().hash(options) ^
      runtimeType.hashCode;
}

extension $InvestmentsTransactionsGetRequestExtension
    on InvestmentsTransactionsGetRequest {
  InvestmentsTransactionsGetRequest copyWith(
      {String? clientId,
      String? secret,
      String? accessToken,
      DateTime? startDate,
      DateTime? endDate,
      InvestmentsTransactionsGetRequestOptions? options}) {
    return InvestmentsTransactionsGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        accessToken: accessToken ?? this.accessToken,
        startDate: startDate ?? this.startDate,
        endDate: endDate ?? this.endDate,
        options: options ?? this.options);
  }

  InvestmentsTransactionsGetRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? accessToken,
      Wrapped<DateTime>? startDate,
      Wrapped<DateTime>? endDate,
      Wrapped<InvestmentsTransactionsGetRequestOptions?>? options}) {
    return InvestmentsTransactionsGetRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        accessToken:
            (accessToken != null ? accessToken.value : this.accessToken),
        startDate: (startDate != null ? startDate.value : this.startDate),
        endDate: (endDate != null ? endDate.value : this.endDate),
        options: (options != null ? options.value : this.options));
  }
}

@JsonSerializable(explicitToJson: true)
class InvestmentsTransactionsGetRequestOptions {
  InvestmentsTransactionsGetRequestOptions({
    this.accountIds,
    this.count,
    this.offset,
  });

  factory InvestmentsTransactionsGetRequestOptions.fromJson(
          Map<String, dynamic> json) =>
      _$InvestmentsTransactionsGetRequestOptionsFromJson(json);

  @JsonKey(name: 'account_ids', defaultValue: <String>[])
  final List<String>? accountIds;
  @JsonKey(name: 'count')
  final int? count;
  @JsonKey(name: 'offset')
  final int? offset;
  static const fromJsonFactory =
      _$InvestmentsTransactionsGetRequestOptionsFromJson;
  static const toJsonFactory = _$InvestmentsTransactionsGetRequestOptionsToJson;
  Map<String, dynamic> toJson() =>
      _$InvestmentsTransactionsGetRequestOptionsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvestmentsTransactionsGetRequestOptions &&
            (identical(other.accountIds, accountIds) ||
                const DeepCollectionEquality()
                    .equals(other.accountIds, accountIds)) &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)) &&
            (identical(other.offset, offset) ||
                const DeepCollectionEquality().equals(other.offset, offset)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountIds) ^
      const DeepCollectionEquality().hash(count) ^
      const DeepCollectionEquality().hash(offset) ^
      runtimeType.hashCode;
}

extension $InvestmentsTransactionsGetRequestOptionsExtension
    on InvestmentsTransactionsGetRequestOptions {
  InvestmentsTransactionsGetRequestOptions copyWith(
      {List<String>? accountIds, int? count, int? offset}) {
    return InvestmentsTransactionsGetRequestOptions(
        accountIds: accountIds ?? this.accountIds,
        count: count ?? this.count,
        offset: offset ?? this.offset);
  }

  InvestmentsTransactionsGetRequestOptions copyWithWrapped(
      {Wrapped<List<String>?>? accountIds,
      Wrapped<int?>? count,
      Wrapped<int?>? offset}) {
    return InvestmentsTransactionsGetRequestOptions(
        accountIds: (accountIds != null ? accountIds.value : this.accountIds),
        count: (count != null ? count.value : this.count),
        offset: (offset != null ? offset.value : this.offset));
  }
}

@JsonSerializable(explicitToJson: true)
class InvestmentsTransactionsGetResponse {
  InvestmentsTransactionsGetResponse({
    required this.item,
    required this.accounts,
    required this.securities,
    required this.investmentTransactions,
    required this.totalInvestmentTransactions,
    required this.requestId,
  });

  factory InvestmentsTransactionsGetResponse.fromJson(
          Map<String, dynamic> json) =>
      _$InvestmentsTransactionsGetResponseFromJson(json);

  @JsonKey(name: 'item')
  final Item item;
  @JsonKey(name: 'accounts', defaultValue: <AccountBase>[])
  final List<AccountBase> accounts;
  @JsonKey(name: 'securities', defaultValue: <Security>[])
  final List<Security> securities;
  @JsonKey(
      name: 'investment_transactions', defaultValue: <InvestmentTransaction>[])
  final List<InvestmentTransaction> investmentTransactions;
  @JsonKey(name: 'total_investment_transactions')
  final int totalInvestmentTransactions;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$InvestmentsTransactionsGetResponseFromJson;
  static const toJsonFactory = _$InvestmentsTransactionsGetResponseToJson;
  Map<String, dynamic> toJson() =>
      _$InvestmentsTransactionsGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvestmentsTransactionsGetResponse &&
            (identical(other.item, item) ||
                const DeepCollectionEquality().equals(other.item, item)) &&
            (identical(other.accounts, accounts) ||
                const DeepCollectionEquality()
                    .equals(other.accounts, accounts)) &&
            (identical(other.securities, securities) ||
                const DeepCollectionEquality()
                    .equals(other.securities, securities)) &&
            (identical(other.investmentTransactions, investmentTransactions) ||
                const DeepCollectionEquality().equals(
                    other.investmentTransactions, investmentTransactions)) &&
            (identical(other.totalInvestmentTransactions,
                    totalInvestmentTransactions) ||
                const DeepCollectionEquality().equals(
                    other.totalInvestmentTransactions,
                    totalInvestmentTransactions)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(item) ^
      const DeepCollectionEquality().hash(accounts) ^
      const DeepCollectionEquality().hash(securities) ^
      const DeepCollectionEquality().hash(investmentTransactions) ^
      const DeepCollectionEquality().hash(totalInvestmentTransactions) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $InvestmentsTransactionsGetResponseExtension
    on InvestmentsTransactionsGetResponse {
  InvestmentsTransactionsGetResponse copyWith(
      {Item? item,
      List<AccountBase>? accounts,
      List<Security>? securities,
      List<InvestmentTransaction>? investmentTransactions,
      int? totalInvestmentTransactions,
      String? requestId}) {
    return InvestmentsTransactionsGetResponse(
        item: item ?? this.item,
        accounts: accounts ?? this.accounts,
        securities: securities ?? this.securities,
        investmentTransactions:
            investmentTransactions ?? this.investmentTransactions,
        totalInvestmentTransactions:
            totalInvestmentTransactions ?? this.totalInvestmentTransactions,
        requestId: requestId ?? this.requestId);
  }

  InvestmentsTransactionsGetResponse copyWithWrapped(
      {Wrapped<Item>? item,
      Wrapped<List<AccountBase>>? accounts,
      Wrapped<List<Security>>? securities,
      Wrapped<List<InvestmentTransaction>>? investmentTransactions,
      Wrapped<int>? totalInvestmentTransactions,
      Wrapped<String>? requestId}) {
    return InvestmentsTransactionsGetResponse(
        item: (item != null ? item.value : this.item),
        accounts: (accounts != null ? accounts.value : this.accounts),
        securities: (securities != null ? securities.value : this.securities),
        investmentTransactions: (investmentTransactions != null
            ? investmentTransactions.value
            : this.investmentTransactions),
        totalInvestmentTransactions: (totalInvestmentTransactions != null
            ? totalInvestmentTransactions.value
            : this.totalInvestmentTransactions),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class ProcessorTokenCreateRequest {
  ProcessorTokenCreateRequest({
    this.clientId,
    this.secret,
    required this.accessToken,
    required this.accountId,
    required this.processor,
  });

  factory ProcessorTokenCreateRequest.fromJson(Map<String, dynamic> json) =>
      _$ProcessorTokenCreateRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'access_token')
  final String accessToken;
  @JsonKey(name: 'account_id')
  final String accountId;
  @JsonKey(
    name: 'processor',
    toJson: processorTokenCreateRequestProcessorToJson,
    fromJson: processorTokenCreateRequestProcessorFromJson,
  )
  final enums.ProcessorTokenCreateRequestProcessor processor;
  static const fromJsonFactory = _$ProcessorTokenCreateRequestFromJson;
  static const toJsonFactory = _$ProcessorTokenCreateRequestToJson;
  Map<String, dynamic> toJson() => _$ProcessorTokenCreateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ProcessorTokenCreateRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)) &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.processor, processor) ||
                const DeepCollectionEquality()
                    .equals(other.processor, processor)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(accessToken) ^
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(processor) ^
      runtimeType.hashCode;
}

extension $ProcessorTokenCreateRequestExtension on ProcessorTokenCreateRequest {
  ProcessorTokenCreateRequest copyWith(
      {String? clientId,
      String? secret,
      String? accessToken,
      String? accountId,
      enums.ProcessorTokenCreateRequestProcessor? processor}) {
    return ProcessorTokenCreateRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        accessToken: accessToken ?? this.accessToken,
        accountId: accountId ?? this.accountId,
        processor: processor ?? this.processor);
  }

  ProcessorTokenCreateRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? accessToken,
      Wrapped<String>? accountId,
      Wrapped<enums.ProcessorTokenCreateRequestProcessor>? processor}) {
    return ProcessorTokenCreateRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        accessToken:
            (accessToken != null ? accessToken.value : this.accessToken),
        accountId: (accountId != null ? accountId.value : this.accountId),
        processor: (processor != null ? processor.value : this.processor));
  }
}

@JsonSerializable(explicitToJson: true)
class ProcessorTokenCreateResponse {
  ProcessorTokenCreateResponse({
    required this.processorToken,
    required this.requestId,
  });

  factory ProcessorTokenCreateResponse.fromJson(Map<String, dynamic> json) =>
      _$ProcessorTokenCreateResponseFromJson(json);

  @JsonKey(name: 'processor_token')
  final String processorToken;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$ProcessorTokenCreateResponseFromJson;
  static const toJsonFactory = _$ProcessorTokenCreateResponseToJson;
  Map<String, dynamic> toJson() => _$ProcessorTokenCreateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ProcessorTokenCreateResponse &&
            (identical(other.processorToken, processorToken) ||
                const DeepCollectionEquality()
                    .equals(other.processorToken, processorToken)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(processorToken) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $ProcessorTokenCreateResponseExtension
    on ProcessorTokenCreateResponse {
  ProcessorTokenCreateResponse copyWith(
      {String? processorToken, String? requestId}) {
    return ProcessorTokenCreateResponse(
        processorToken: processorToken ?? this.processorToken,
        requestId: requestId ?? this.requestId);
  }

  ProcessorTokenCreateResponse copyWithWrapped(
      {Wrapped<String>? processorToken, Wrapped<String>? requestId}) {
    return ProcessorTokenCreateResponse(
        processorToken: (processorToken != null
            ? processorToken.value
            : this.processorToken),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class ProcessorStripeBankAccountTokenCreateRequest {
  ProcessorStripeBankAccountTokenCreateRequest({
    this.clientId,
    this.secret,
    required this.accessToken,
    required this.accountId,
  });

  factory ProcessorStripeBankAccountTokenCreateRequest.fromJson(
          Map<String, dynamic> json) =>
      _$ProcessorStripeBankAccountTokenCreateRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'access_token')
  final String accessToken;
  @JsonKey(name: 'account_id')
  final String accountId;
  static const fromJsonFactory =
      _$ProcessorStripeBankAccountTokenCreateRequestFromJson;
  static const toJsonFactory =
      _$ProcessorStripeBankAccountTokenCreateRequestToJson;
  Map<String, dynamic> toJson() =>
      _$ProcessorStripeBankAccountTokenCreateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ProcessorStripeBankAccountTokenCreateRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)) &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(accessToken) ^
      const DeepCollectionEquality().hash(accountId) ^
      runtimeType.hashCode;
}

extension $ProcessorStripeBankAccountTokenCreateRequestExtension
    on ProcessorStripeBankAccountTokenCreateRequest {
  ProcessorStripeBankAccountTokenCreateRequest copyWith(
      {String? clientId,
      String? secret,
      String? accessToken,
      String? accountId}) {
    return ProcessorStripeBankAccountTokenCreateRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        accessToken: accessToken ?? this.accessToken,
        accountId: accountId ?? this.accountId);
  }

  ProcessorStripeBankAccountTokenCreateRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? accessToken,
      Wrapped<String>? accountId}) {
    return ProcessorStripeBankAccountTokenCreateRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        accessToken:
            (accessToken != null ? accessToken.value : this.accessToken),
        accountId: (accountId != null ? accountId.value : this.accountId));
  }
}

@JsonSerializable(explicitToJson: true)
class ProcessorStripeBankAccountTokenCreateResponse {
  ProcessorStripeBankAccountTokenCreateResponse({
    required this.stripeBankAccountToken,
    required this.requestId,
  });

  factory ProcessorStripeBankAccountTokenCreateResponse.fromJson(
          Map<String, dynamic> json) =>
      _$ProcessorStripeBankAccountTokenCreateResponseFromJson(json);

  @JsonKey(name: 'stripe_bank_account_token')
  final String stripeBankAccountToken;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory =
      _$ProcessorStripeBankAccountTokenCreateResponseFromJson;
  static const toJsonFactory =
      _$ProcessorStripeBankAccountTokenCreateResponseToJson;
  Map<String, dynamic> toJson() =>
      _$ProcessorStripeBankAccountTokenCreateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ProcessorStripeBankAccountTokenCreateResponse &&
            (identical(other.stripeBankAccountToken, stripeBankAccountToken) ||
                const DeepCollectionEquality().equals(
                    other.stripeBankAccountToken, stripeBankAccountToken)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(stripeBankAccountToken) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $ProcessorStripeBankAccountTokenCreateResponseExtension
    on ProcessorStripeBankAccountTokenCreateResponse {
  ProcessorStripeBankAccountTokenCreateResponse copyWith(
      {String? stripeBankAccountToken, String? requestId}) {
    return ProcessorStripeBankAccountTokenCreateResponse(
        stripeBankAccountToken:
            stripeBankAccountToken ?? this.stripeBankAccountToken,
        requestId: requestId ?? this.requestId);
  }

  ProcessorStripeBankAccountTokenCreateResponse copyWithWrapped(
      {Wrapped<String>? stripeBankAccountToken, Wrapped<String>? requestId}) {
    return ProcessorStripeBankAccountTokenCreateResponse(
        stripeBankAccountToken: (stripeBankAccountToken != null
            ? stripeBankAccountToken.value
            : this.stripeBankAccountToken),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class ProcessorApexProcessorTokenCreateRequest {
  ProcessorApexProcessorTokenCreateRequest({
    this.clientId,
    this.secret,
    required this.accessToken,
    required this.accountId,
  });

  factory ProcessorApexProcessorTokenCreateRequest.fromJson(
          Map<String, dynamic> json) =>
      _$ProcessorApexProcessorTokenCreateRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'access_token')
  final String accessToken;
  @JsonKey(name: 'account_id')
  final String accountId;
  static const fromJsonFactory =
      _$ProcessorApexProcessorTokenCreateRequestFromJson;
  static const toJsonFactory = _$ProcessorApexProcessorTokenCreateRequestToJson;
  Map<String, dynamic> toJson() =>
      _$ProcessorApexProcessorTokenCreateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ProcessorApexProcessorTokenCreateRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)) &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(accessToken) ^
      const DeepCollectionEquality().hash(accountId) ^
      runtimeType.hashCode;
}

extension $ProcessorApexProcessorTokenCreateRequestExtension
    on ProcessorApexProcessorTokenCreateRequest {
  ProcessorApexProcessorTokenCreateRequest copyWith(
      {String? clientId,
      String? secret,
      String? accessToken,
      String? accountId}) {
    return ProcessorApexProcessorTokenCreateRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        accessToken: accessToken ?? this.accessToken,
        accountId: accountId ?? this.accountId);
  }

  ProcessorApexProcessorTokenCreateRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? accessToken,
      Wrapped<String>? accountId}) {
    return ProcessorApexProcessorTokenCreateRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        accessToken:
            (accessToken != null ? accessToken.value : this.accessToken),
        accountId: (accountId != null ? accountId.value : this.accountId));
  }
}

@JsonSerializable(explicitToJson: true)
class DepositSwitchCreateRequest {
  DepositSwitchCreateRequest({
    this.clientId,
    this.secret,
    required this.targetAccessToken,
    required this.targetAccountId,
    this.countryCode,
    this.options,
  });

  factory DepositSwitchCreateRequest.fromJson(Map<String, dynamic> json) =>
      _$DepositSwitchCreateRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'target_access_token')
  final String targetAccessToken;
  @JsonKey(name: 'target_account_id')
  final String targetAccountId;
  @JsonKey(
    name: 'country_code',
    toJson: depositSwitchCreateRequestCountryCodeToJson,
    fromJson: depositSwitchCreateRequestCountryCodeFromJson,
  )
  final enums.DepositSwitchCreateRequestCountryCode? countryCode;
  @JsonKey(name: 'options')
  final DepositSwitchCreateRequestOptions? options;
  static const fromJsonFactory = _$DepositSwitchCreateRequestFromJson;
  static const toJsonFactory = _$DepositSwitchCreateRequestToJson;
  Map<String, dynamic> toJson() => _$DepositSwitchCreateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is DepositSwitchCreateRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.targetAccessToken, targetAccessToken) ||
                const DeepCollectionEquality()
                    .equals(other.targetAccessToken, targetAccessToken)) &&
            (identical(other.targetAccountId, targetAccountId) ||
                const DeepCollectionEquality()
                    .equals(other.targetAccountId, targetAccountId)) &&
            (identical(other.countryCode, countryCode) ||
                const DeepCollectionEquality()
                    .equals(other.countryCode, countryCode)) &&
            (identical(other.options, options) ||
                const DeepCollectionEquality().equals(other.options, options)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(targetAccessToken) ^
      const DeepCollectionEquality().hash(targetAccountId) ^
      const DeepCollectionEquality().hash(countryCode) ^
      const DeepCollectionEquality().hash(options) ^
      runtimeType.hashCode;
}

extension $DepositSwitchCreateRequestExtension on DepositSwitchCreateRequest {
  DepositSwitchCreateRequest copyWith(
      {String? clientId,
      String? secret,
      String? targetAccessToken,
      String? targetAccountId,
      enums.DepositSwitchCreateRequestCountryCode? countryCode,
      DepositSwitchCreateRequestOptions? options}) {
    return DepositSwitchCreateRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        targetAccessToken: targetAccessToken ?? this.targetAccessToken,
        targetAccountId: targetAccountId ?? this.targetAccountId,
        countryCode: countryCode ?? this.countryCode,
        options: options ?? this.options);
  }

  DepositSwitchCreateRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? targetAccessToken,
      Wrapped<String>? targetAccountId,
      Wrapped<enums.DepositSwitchCreateRequestCountryCode?>? countryCode,
      Wrapped<DepositSwitchCreateRequestOptions?>? options}) {
    return DepositSwitchCreateRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        targetAccessToken: (targetAccessToken != null
            ? targetAccessToken.value
            : this.targetAccessToken),
        targetAccountId: (targetAccountId != null
            ? targetAccountId.value
            : this.targetAccountId),
        countryCode:
            (countryCode != null ? countryCode.value : this.countryCode),
        options: (options != null ? options.value : this.options));
  }
}

@JsonSerializable(explicitToJson: true)
class DepositSwitchCreateRequestOptions {
  DepositSwitchCreateRequestOptions({
    this.webhook,
    this.transactionItemAccessTokens,
  });

  factory DepositSwitchCreateRequestOptions.fromJson(
          Map<String, dynamic> json) =>
      _$DepositSwitchCreateRequestOptionsFromJson(json);

  @JsonKey(name: 'webhook')
  final String? webhook;
  @JsonKey(name: 'transaction_item_access_tokens', defaultValue: <String>[])
  final List<String>? transactionItemAccessTokens;
  static const fromJsonFactory = _$DepositSwitchCreateRequestOptionsFromJson;
  static const toJsonFactory = _$DepositSwitchCreateRequestOptionsToJson;
  Map<String, dynamic> toJson() =>
      _$DepositSwitchCreateRequestOptionsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is DepositSwitchCreateRequestOptions &&
            (identical(other.webhook, webhook) ||
                const DeepCollectionEquality()
                    .equals(other.webhook, webhook)) &&
            (identical(other.transactionItemAccessTokens,
                    transactionItemAccessTokens) ||
                const DeepCollectionEquality().equals(
                    other.transactionItemAccessTokens,
                    transactionItemAccessTokens)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(webhook) ^
      const DeepCollectionEquality().hash(transactionItemAccessTokens) ^
      runtimeType.hashCode;
}

extension $DepositSwitchCreateRequestOptionsExtension
    on DepositSwitchCreateRequestOptions {
  DepositSwitchCreateRequestOptions copyWith(
      {String? webhook, List<String>? transactionItemAccessTokens}) {
    return DepositSwitchCreateRequestOptions(
        webhook: webhook ?? this.webhook,
        transactionItemAccessTokens:
            transactionItemAccessTokens ?? this.transactionItemAccessTokens);
  }

  DepositSwitchCreateRequestOptions copyWithWrapped(
      {Wrapped<String?>? webhook,
      Wrapped<List<String>?>? transactionItemAccessTokens}) {
    return DepositSwitchCreateRequestOptions(
        webhook: (webhook != null ? webhook.value : this.webhook),
        transactionItemAccessTokens: (transactionItemAccessTokens != null
            ? transactionItemAccessTokens.value
            : this.transactionItemAccessTokens));
  }
}

@JsonSerializable(explicitToJson: true)
class DepositSwitchCreateResponse {
  DepositSwitchCreateResponse({
    required this.depositSwitchId,
    required this.requestId,
  });

  factory DepositSwitchCreateResponse.fromJson(Map<String, dynamic> json) =>
      _$DepositSwitchCreateResponseFromJson(json);

  @JsonKey(name: 'deposit_switch_id')
  final String depositSwitchId;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$DepositSwitchCreateResponseFromJson;
  static const toJsonFactory = _$DepositSwitchCreateResponseToJson;
  Map<String, dynamic> toJson() => _$DepositSwitchCreateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is DepositSwitchCreateResponse &&
            (identical(other.depositSwitchId, depositSwitchId) ||
                const DeepCollectionEquality()
                    .equals(other.depositSwitchId, depositSwitchId)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(depositSwitchId) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $DepositSwitchCreateResponseExtension on DepositSwitchCreateResponse {
  DepositSwitchCreateResponse copyWith(
      {String? depositSwitchId, String? requestId}) {
    return DepositSwitchCreateResponse(
        depositSwitchId: depositSwitchId ?? this.depositSwitchId,
        requestId: requestId ?? this.requestId);
  }

  DepositSwitchCreateResponse copyWithWrapped(
      {Wrapped<String>? depositSwitchId, Wrapped<String>? requestId}) {
    return DepositSwitchCreateResponse(
        depositSwitchId: (depositSwitchId != null
            ? depositSwitchId.value
            : this.depositSwitchId),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class DepositSwitchTokenCreateRequest {
  DepositSwitchTokenCreateRequest({
    this.clientId,
    this.secret,
    required this.depositSwitchId,
  });

  factory DepositSwitchTokenCreateRequest.fromJson(Map<String, dynamic> json) =>
      _$DepositSwitchTokenCreateRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'deposit_switch_id')
  final String depositSwitchId;
  static const fromJsonFactory = _$DepositSwitchTokenCreateRequestFromJson;
  static const toJsonFactory = _$DepositSwitchTokenCreateRequestToJson;
  Map<String, dynamic> toJson() =>
      _$DepositSwitchTokenCreateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is DepositSwitchTokenCreateRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.depositSwitchId, depositSwitchId) ||
                const DeepCollectionEquality()
                    .equals(other.depositSwitchId, depositSwitchId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(depositSwitchId) ^
      runtimeType.hashCode;
}

extension $DepositSwitchTokenCreateRequestExtension
    on DepositSwitchTokenCreateRequest {
  DepositSwitchTokenCreateRequest copyWith(
      {String? clientId, String? secret, String? depositSwitchId}) {
    return DepositSwitchTokenCreateRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        depositSwitchId: depositSwitchId ?? this.depositSwitchId);
  }

  DepositSwitchTokenCreateRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? depositSwitchId}) {
    return DepositSwitchTokenCreateRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        depositSwitchId: (depositSwitchId != null
            ? depositSwitchId.value
            : this.depositSwitchId));
  }
}

@JsonSerializable(explicitToJson: true)
class DepositSwitchTokenCreateResponse {
  DepositSwitchTokenCreateResponse({
    required this.depositSwitchToken,
    required this.depositSwitchTokenExpirationTime,
    required this.requestId,
  });

  factory DepositSwitchTokenCreateResponse.fromJson(
          Map<String, dynamic> json) =>
      _$DepositSwitchTokenCreateResponseFromJson(json);

  @JsonKey(name: 'deposit_switch_token')
  final String depositSwitchToken;
  @JsonKey(name: 'deposit_switch_token_expiration_time')
  final String depositSwitchTokenExpirationTime;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$DepositSwitchTokenCreateResponseFromJson;
  static const toJsonFactory = _$DepositSwitchTokenCreateResponseToJson;
  Map<String, dynamic> toJson() =>
      _$DepositSwitchTokenCreateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is DepositSwitchTokenCreateResponse &&
            (identical(other.depositSwitchToken, depositSwitchToken) ||
                const DeepCollectionEquality()
                    .equals(other.depositSwitchToken, depositSwitchToken)) &&
            (identical(other.depositSwitchTokenExpirationTime,
                    depositSwitchTokenExpirationTime) ||
                const DeepCollectionEquality().equals(
                    other.depositSwitchTokenExpirationTime,
                    depositSwitchTokenExpirationTime)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(depositSwitchToken) ^
      const DeepCollectionEquality().hash(depositSwitchTokenExpirationTime) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $DepositSwitchTokenCreateResponseExtension
    on DepositSwitchTokenCreateResponse {
  DepositSwitchTokenCreateResponse copyWith(
      {String? depositSwitchToken,
      String? depositSwitchTokenExpirationTime,
      String? requestId}) {
    return DepositSwitchTokenCreateResponse(
        depositSwitchToken: depositSwitchToken ?? this.depositSwitchToken,
        depositSwitchTokenExpirationTime: depositSwitchTokenExpirationTime ??
            this.depositSwitchTokenExpirationTime,
        requestId: requestId ?? this.requestId);
  }

  DepositSwitchTokenCreateResponse copyWithWrapped(
      {Wrapped<String>? depositSwitchToken,
      Wrapped<String>? depositSwitchTokenExpirationTime,
      Wrapped<String>? requestId}) {
    return DepositSwitchTokenCreateResponse(
        depositSwitchToken: (depositSwitchToken != null
            ? depositSwitchToken.value
            : this.depositSwitchToken),
        depositSwitchTokenExpirationTime:
            (depositSwitchTokenExpirationTime != null
                ? depositSwitchTokenExpirationTime.value
                : this.depositSwitchTokenExpirationTime),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class LinkTokenGetRequest {
  LinkTokenGetRequest({
    this.clientId,
    this.secret,
    required this.linkToken,
  });

  factory LinkTokenGetRequest.fromJson(Map<String, dynamic> json) =>
      _$LinkTokenGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'link_token')
  final String linkToken;
  static const fromJsonFactory = _$LinkTokenGetRequestFromJson;
  static const toJsonFactory = _$LinkTokenGetRequestToJson;
  Map<String, dynamic> toJson() => _$LinkTokenGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LinkTokenGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.linkToken, linkToken) ||
                const DeepCollectionEquality()
                    .equals(other.linkToken, linkToken)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(linkToken) ^
      runtimeType.hashCode;
}

extension $LinkTokenGetRequestExtension on LinkTokenGetRequest {
  LinkTokenGetRequest copyWith(
      {String? clientId, String? secret, String? linkToken}) {
    return LinkTokenGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        linkToken: linkToken ?? this.linkToken);
  }

  LinkTokenGetRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? linkToken}) {
    return LinkTokenGetRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        linkToken: (linkToken != null ? linkToken.value : this.linkToken));
  }
}

@JsonSerializable(explicitToJson: true)
class LinkTokenCreateRequest {
  LinkTokenCreateRequest({
    this.clientId,
    this.secret,
    required this.clientName,
    required this.language,
    required this.countryCodes,
    required this.user,
    this.products,
    this.additionalConsentedProducts,
    this.webhook,
    this.accessToken,
    this.linkCustomizationName,
    this.redirectUri,
    this.androidPackageName,
    this.institutionData,
    this.accountFilters,
    this.euConfig,
    this.institutionId,
    this.paymentInitiation,
    this.depositSwitch,
    this.incomeVerification,
    this.auth,
    this.transfer,
    this.update,
    this.identityVerification,
    this.userToken,
    this.investments,
  });

  factory LinkTokenCreateRequest.fromJson(Map<String, dynamic> json) =>
      _$LinkTokenCreateRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'client_name')
  final String clientName;
  @JsonKey(name: 'language')
  final String language;
  @JsonKey(
    name: 'country_codes',
    toJson: countryCodeListToJson,
    fromJson: countryCodeListFromJson,
  )
  final List<enums.CountryCode> countryCodes;
  @JsonKey(name: 'user')
  final LinkTokenCreateRequestUser user;
  @JsonKey(
    name: 'products',
    toJson: productsListToJson,
    fromJson: productsListFromJson,
  )
  final List<enums.Products>? products;
  @JsonKey(
    name: 'additional_consented_products',
    toJson: productsListToJson,
    fromJson: productsListFromJson,
  )
  final List<enums.Products>? additionalConsentedProducts;
  @JsonKey(name: 'webhook')
  final String? webhook;
  @JsonKey(name: 'access_token')
  final String? accessToken;
  @JsonKey(name: 'link_customization_name')
  final String? linkCustomizationName;
  @JsonKey(name: 'redirect_uri')
  final String? redirectUri;
  @JsonKey(name: 'android_package_name')
  final String? androidPackageName;
  @JsonKey(name: 'institution_data')
  final LinkTokenCreateInstitutionData? institutionData;
  @JsonKey(name: 'account_filters')
  final LinkTokenAccountFilters? accountFilters;
  @JsonKey(name: 'eu_config')
  final LinkTokenEUConfig? euConfig;
  @JsonKey(name: 'institution_id')
  final String? institutionId;
  @JsonKey(name: 'payment_initiation')
  final LinkTokenCreateRequestPaymentInitiation? paymentInitiation;
  @JsonKey(name: 'deposit_switch')
  final LinkTokenCreateRequestDepositSwitch? depositSwitch;
  @JsonKey(name: 'income_verification')
  final LinkTokenCreateRequestIncomeVerification? incomeVerification;
  @JsonKey(name: 'auth')
  final LinkTokenCreateRequestAuth? auth;
  @JsonKey(name: 'transfer')
  final LinkTokenCreateRequestTransfer? transfer;
  @JsonKey(name: 'update')
  final LinkTokenCreateRequestUpdate? update;
  @JsonKey(name: 'identity_verification')
  final LinkTokenCreateRequestIdentityVerification? identityVerification;
  @JsonKey(name: 'user_token')
  final String? userToken;
  @JsonKey(name: 'investments')
  final LinkTokenInvestments? investments;
  static const fromJsonFactory = _$LinkTokenCreateRequestFromJson;
  static const toJsonFactory = _$LinkTokenCreateRequestToJson;
  Map<String, dynamic> toJson() => _$LinkTokenCreateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LinkTokenCreateRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.clientName, clientName) ||
                const DeepCollectionEquality()
                    .equals(other.clientName, clientName)) &&
            (identical(other.language, language) ||
                const DeepCollectionEquality()
                    .equals(other.language, language)) &&
            (identical(other.countryCodes, countryCodes) ||
                const DeepCollectionEquality()
                    .equals(other.countryCodes, countryCodes)) &&
            (identical(other.user, user) ||
                const DeepCollectionEquality().equals(other.user, user)) &&
            (identical(other.products, products) ||
                const DeepCollectionEquality()
                    .equals(other.products, products)) &&
            (identical(other.additionalConsentedProducts, additionalConsentedProducts) ||
                const DeepCollectionEquality().equals(
                    other.additionalConsentedProducts,
                    additionalConsentedProducts)) &&
            (identical(other.webhook, webhook) ||
                const DeepCollectionEquality()
                    .equals(other.webhook, webhook)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)) &&
            (identical(other.linkCustomizationName, linkCustomizationName) ||
                const DeepCollectionEquality().equals(
                    other.linkCustomizationName, linkCustomizationName)) &&
            (identical(other.redirectUri, redirectUri) ||
                const DeepCollectionEquality()
                    .equals(other.redirectUri, redirectUri)) &&
            (identical(other.androidPackageName, androidPackageName) ||
                const DeepCollectionEquality()
                    .equals(other.androidPackageName, androidPackageName)) &&
            (identical(other.institutionData, institutionData) ||
                const DeepCollectionEquality()
                    .equals(other.institutionData, institutionData)) &&
            (identical(other.accountFilters, accountFilters) ||
                const DeepCollectionEquality()
                    .equals(other.accountFilters, accountFilters)) &&
            (identical(other.euConfig, euConfig) ||
                const DeepCollectionEquality()
                    .equals(other.euConfig, euConfig)) &&
            (identical(other.institutionId, institutionId) ||
                const DeepCollectionEquality()
                    .equals(other.institutionId, institutionId)) &&
            (identical(other.paymentInitiation, paymentInitiation) ||
                const DeepCollectionEquality()
                    .equals(other.paymentInitiation, paymentInitiation)) &&
            (identical(other.depositSwitch, depositSwitch) ||
                const DeepCollectionEquality().equals(other.depositSwitch, depositSwitch)) &&
            (identical(other.incomeVerification, incomeVerification) || const DeepCollectionEquality().equals(other.incomeVerification, incomeVerification)) &&
            (identical(other.auth, auth) || const DeepCollectionEquality().equals(other.auth, auth)) &&
            (identical(other.transfer, transfer) || const DeepCollectionEquality().equals(other.transfer, transfer)) &&
            (identical(other.update, update) || const DeepCollectionEquality().equals(other.update, update)) &&
            (identical(other.identityVerification, identityVerification) || const DeepCollectionEquality().equals(other.identityVerification, identityVerification)) &&
            (identical(other.userToken, userToken) || const DeepCollectionEquality().equals(other.userToken, userToken)) &&
            (identical(other.investments, investments) || const DeepCollectionEquality().equals(other.investments, investments)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(clientName) ^
      const DeepCollectionEquality().hash(language) ^
      const DeepCollectionEquality().hash(countryCodes) ^
      const DeepCollectionEquality().hash(user) ^
      const DeepCollectionEquality().hash(products) ^
      const DeepCollectionEquality().hash(additionalConsentedProducts) ^
      const DeepCollectionEquality().hash(webhook) ^
      const DeepCollectionEquality().hash(accessToken) ^
      const DeepCollectionEquality().hash(linkCustomizationName) ^
      const DeepCollectionEquality().hash(redirectUri) ^
      const DeepCollectionEquality().hash(androidPackageName) ^
      const DeepCollectionEquality().hash(institutionData) ^
      const DeepCollectionEquality().hash(accountFilters) ^
      const DeepCollectionEquality().hash(euConfig) ^
      const DeepCollectionEquality().hash(institutionId) ^
      const DeepCollectionEquality().hash(paymentInitiation) ^
      const DeepCollectionEquality().hash(depositSwitch) ^
      const DeepCollectionEquality().hash(incomeVerification) ^
      const DeepCollectionEquality().hash(auth) ^
      const DeepCollectionEquality().hash(transfer) ^
      const DeepCollectionEquality().hash(update) ^
      const DeepCollectionEquality().hash(identityVerification) ^
      const DeepCollectionEquality().hash(userToken) ^
      const DeepCollectionEquality().hash(investments) ^
      runtimeType.hashCode;
}

extension $LinkTokenCreateRequestExtension on LinkTokenCreateRequest {
  LinkTokenCreateRequest copyWith(
      {String? clientId,
      String? secret,
      String? clientName,
      String? language,
      List<enums.CountryCode>? countryCodes,
      LinkTokenCreateRequestUser? user,
      List<enums.Products>? products,
      List<enums.Products>? additionalConsentedProducts,
      String? webhook,
      String? accessToken,
      String? linkCustomizationName,
      String? redirectUri,
      String? androidPackageName,
      LinkTokenCreateInstitutionData? institutionData,
      LinkTokenAccountFilters? accountFilters,
      LinkTokenEUConfig? euConfig,
      String? institutionId,
      LinkTokenCreateRequestPaymentInitiation? paymentInitiation,
      LinkTokenCreateRequestDepositSwitch? depositSwitch,
      LinkTokenCreateRequestIncomeVerification? incomeVerification,
      LinkTokenCreateRequestAuth? auth,
      LinkTokenCreateRequestTransfer? transfer,
      LinkTokenCreateRequestUpdate? update,
      LinkTokenCreateRequestIdentityVerification? identityVerification,
      String? userToken,
      LinkTokenInvestments? investments}) {
    return LinkTokenCreateRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        clientName: clientName ?? this.clientName,
        language: language ?? this.language,
        countryCodes: countryCodes ?? this.countryCodes,
        user: user ?? this.user,
        products: products ?? this.products,
        additionalConsentedProducts:
            additionalConsentedProducts ?? this.additionalConsentedProducts,
        webhook: webhook ?? this.webhook,
        accessToken: accessToken ?? this.accessToken,
        linkCustomizationName:
            linkCustomizationName ?? this.linkCustomizationName,
        redirectUri: redirectUri ?? this.redirectUri,
        androidPackageName: androidPackageName ?? this.androidPackageName,
        institutionData: institutionData ?? this.institutionData,
        accountFilters: accountFilters ?? this.accountFilters,
        euConfig: euConfig ?? this.euConfig,
        institutionId: institutionId ?? this.institutionId,
        paymentInitiation: paymentInitiation ?? this.paymentInitiation,
        depositSwitch: depositSwitch ?? this.depositSwitch,
        incomeVerification: incomeVerification ?? this.incomeVerification,
        auth: auth ?? this.auth,
        transfer: transfer ?? this.transfer,
        update: update ?? this.update,
        identityVerification: identityVerification ?? this.identityVerification,
        userToken: userToken ?? this.userToken,
        investments: investments ?? this.investments);
  }

  LinkTokenCreateRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? clientName,
      Wrapped<String>? language,
      Wrapped<List<enums.CountryCode>>? countryCodes,
      Wrapped<LinkTokenCreateRequestUser>? user,
      Wrapped<List<enums.Products>?>? products,
      Wrapped<List<enums.Products>?>? additionalConsentedProducts,
      Wrapped<String?>? webhook,
      Wrapped<String?>? accessToken,
      Wrapped<String?>? linkCustomizationName,
      Wrapped<String?>? redirectUri,
      Wrapped<String?>? androidPackageName,
      Wrapped<LinkTokenCreateInstitutionData?>? institutionData,
      Wrapped<LinkTokenAccountFilters?>? accountFilters,
      Wrapped<LinkTokenEUConfig?>? euConfig,
      Wrapped<String?>? institutionId,
      Wrapped<LinkTokenCreateRequestPaymentInitiation?>? paymentInitiation,
      Wrapped<LinkTokenCreateRequestDepositSwitch?>? depositSwitch,
      Wrapped<LinkTokenCreateRequestIncomeVerification?>? incomeVerification,
      Wrapped<LinkTokenCreateRequestAuth?>? auth,
      Wrapped<LinkTokenCreateRequestTransfer?>? transfer,
      Wrapped<LinkTokenCreateRequestUpdate?>? update,
      Wrapped<LinkTokenCreateRequestIdentityVerification?>?
          identityVerification,
      Wrapped<String?>? userToken,
      Wrapped<LinkTokenInvestments?>? investments}) {
    return LinkTokenCreateRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        clientName: (clientName != null ? clientName.value : this.clientName),
        language: (language != null ? language.value : this.language),
        countryCodes:
            (countryCodes != null ? countryCodes.value : this.countryCodes),
        user: (user != null ? user.value : this.user),
        products: (products != null ? products.value : this.products),
        additionalConsentedProducts: (additionalConsentedProducts != null
            ? additionalConsentedProducts.value
            : this.additionalConsentedProducts),
        webhook: (webhook != null ? webhook.value : this.webhook),
        accessToken:
            (accessToken != null ? accessToken.value : this.accessToken),
        linkCustomizationName: (linkCustomizationName != null
            ? linkCustomizationName.value
            : this.linkCustomizationName),
        redirectUri:
            (redirectUri != null ? redirectUri.value : this.redirectUri),
        androidPackageName: (androidPackageName != null
            ? androidPackageName.value
            : this.androidPackageName),
        institutionData: (institutionData != null
            ? institutionData.value
            : this.institutionData),
        accountFilters: (accountFilters != null
            ? accountFilters.value
            : this.accountFilters),
        euConfig: (euConfig != null ? euConfig.value : this.euConfig),
        institutionId:
            (institutionId != null ? institutionId.value : this.institutionId),
        paymentInitiation: (paymentInitiation != null
            ? paymentInitiation.value
            : this.paymentInitiation),
        depositSwitch:
            (depositSwitch != null ? depositSwitch.value : this.depositSwitch),
        incomeVerification: (incomeVerification != null
            ? incomeVerification.value
            : this.incomeVerification),
        auth: (auth != null ? auth.value : this.auth),
        transfer: (transfer != null ? transfer.value : this.transfer),
        update: (update != null ? update.value : this.update),
        identityVerification: (identityVerification != null
            ? identityVerification.value
            : this.identityVerification),
        userToken: (userToken != null ? userToken.value : this.userToken),
        investments:
            (investments != null ? investments.value : this.investments));
  }
}

@JsonSerializable(explicitToJson: true)
class LinkTokenAccountFilters {
  LinkTokenAccountFilters({
    this.depository,
    this.credit,
    this.loan,
    this.investment,
  });

  factory LinkTokenAccountFilters.fromJson(Map<String, dynamic> json) =>
      _$LinkTokenAccountFiltersFromJson(json);

  @JsonKey(name: 'depository')
  final DepositoryFilter? depository;
  @JsonKey(name: 'credit')
  final CreditFilter? credit;
  @JsonKey(name: 'loan')
  final LoanFilter? loan;
  @JsonKey(name: 'investment')
  final InvestmentFilter? investment;
  static const fromJsonFactory = _$LinkTokenAccountFiltersFromJson;
  static const toJsonFactory = _$LinkTokenAccountFiltersToJson;
  Map<String, dynamic> toJson() => _$LinkTokenAccountFiltersToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LinkTokenAccountFilters &&
            (identical(other.depository, depository) ||
                const DeepCollectionEquality()
                    .equals(other.depository, depository)) &&
            (identical(other.credit, credit) ||
                const DeepCollectionEquality().equals(other.credit, credit)) &&
            (identical(other.loan, loan) ||
                const DeepCollectionEquality().equals(other.loan, loan)) &&
            (identical(other.investment, investment) ||
                const DeepCollectionEquality()
                    .equals(other.investment, investment)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(depository) ^
      const DeepCollectionEquality().hash(credit) ^
      const DeepCollectionEquality().hash(loan) ^
      const DeepCollectionEquality().hash(investment) ^
      runtimeType.hashCode;
}

extension $LinkTokenAccountFiltersExtension on LinkTokenAccountFilters {
  LinkTokenAccountFilters copyWith(
      {DepositoryFilter? depository,
      CreditFilter? credit,
      LoanFilter? loan,
      InvestmentFilter? investment}) {
    return LinkTokenAccountFilters(
        depository: depository ?? this.depository,
        credit: credit ?? this.credit,
        loan: loan ?? this.loan,
        investment: investment ?? this.investment);
  }

  LinkTokenAccountFilters copyWithWrapped(
      {Wrapped<DepositoryFilter?>? depository,
      Wrapped<CreditFilter?>? credit,
      Wrapped<LoanFilter?>? loan,
      Wrapped<InvestmentFilter?>? investment}) {
    return LinkTokenAccountFilters(
        depository: (depository != null ? depository.value : this.depository),
        credit: (credit != null ? credit.value : this.credit),
        loan: (loan != null ? loan.value : this.loan),
        investment: (investment != null ? investment.value : this.investment));
  }
}

@JsonSerializable(explicitToJson: true)
class LinkTokenEUConfig {
  LinkTokenEUConfig({
    this.headless,
  });

  factory LinkTokenEUConfig.fromJson(Map<String, dynamic> json) =>
      _$LinkTokenEUConfigFromJson(json);

  @JsonKey(name: 'headless')
  final bool? headless;
  static const fromJsonFactory = _$LinkTokenEUConfigFromJson;
  static const toJsonFactory = _$LinkTokenEUConfigToJson;
  Map<String, dynamic> toJson() => _$LinkTokenEUConfigToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LinkTokenEUConfig &&
            (identical(other.headless, headless) ||
                const DeepCollectionEquality()
                    .equals(other.headless, headless)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(headless) ^ runtimeType.hashCode;
}

extension $LinkTokenEUConfigExtension on LinkTokenEUConfig {
  LinkTokenEUConfig copyWith({bool? headless}) {
    return LinkTokenEUConfig(headless: headless ?? this.headless);
  }

  LinkTokenEUConfig copyWithWrapped({Wrapped<bool?>? headless}) {
    return LinkTokenEUConfig(
        headless: (headless != null ? headless.value : this.headless));
  }
}

@JsonSerializable(explicitToJson: true)
class LinkTokenInvestments {
  LinkTokenInvestments({
    this.allowUnverifiedCryptoWallets,
  });

  factory LinkTokenInvestments.fromJson(Map<String, dynamic> json) =>
      _$LinkTokenInvestmentsFromJson(json);

  @JsonKey(name: 'allow_unverified_crypto_wallets')
  final bool? allowUnverifiedCryptoWallets;
  static const fromJsonFactory = _$LinkTokenInvestmentsFromJson;
  static const toJsonFactory = _$LinkTokenInvestmentsToJson;
  Map<String, dynamic> toJson() => _$LinkTokenInvestmentsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LinkTokenInvestments &&
            (identical(other.allowUnverifiedCryptoWallets,
                    allowUnverifiedCryptoWallets) ||
                const DeepCollectionEquality().equals(
                    other.allowUnverifiedCryptoWallets,
                    allowUnverifiedCryptoWallets)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(allowUnverifiedCryptoWallets) ^
      runtimeType.hashCode;
}

extension $LinkTokenInvestmentsExtension on LinkTokenInvestments {
  LinkTokenInvestments copyWith({bool? allowUnverifiedCryptoWallets}) {
    return LinkTokenInvestments(
        allowUnverifiedCryptoWallets:
            allowUnverifiedCryptoWallets ?? this.allowUnverifiedCryptoWallets);
  }

  LinkTokenInvestments copyWithWrapped(
      {Wrapped<bool?>? allowUnverifiedCryptoWallets}) {
    return LinkTokenInvestments(
        allowUnverifiedCryptoWallets: (allowUnverifiedCryptoWallets != null
            ? allowUnverifiedCryptoWallets.value
            : this.allowUnverifiedCryptoWallets));
  }
}

@JsonSerializable(explicitToJson: true)
class LinkTokenCreateRequestPaymentInitiation {
  LinkTokenCreateRequestPaymentInitiation({
    this.paymentId,
    this.consentId,
  });

  factory LinkTokenCreateRequestPaymentInitiation.fromJson(
          Map<String, dynamic> json) =>
      _$LinkTokenCreateRequestPaymentInitiationFromJson(json);

  @JsonKey(name: 'payment_id')
  final String? paymentId;
  @JsonKey(name: 'consent_id')
  final String? consentId;
  static const fromJsonFactory =
      _$LinkTokenCreateRequestPaymentInitiationFromJson;
  static const toJsonFactory = _$LinkTokenCreateRequestPaymentInitiationToJson;
  Map<String, dynamic> toJson() =>
      _$LinkTokenCreateRequestPaymentInitiationToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LinkTokenCreateRequestPaymentInitiation &&
            (identical(other.paymentId, paymentId) ||
                const DeepCollectionEquality()
                    .equals(other.paymentId, paymentId)) &&
            (identical(other.consentId, consentId) ||
                const DeepCollectionEquality()
                    .equals(other.consentId, consentId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(paymentId) ^
      const DeepCollectionEquality().hash(consentId) ^
      runtimeType.hashCode;
}

extension $LinkTokenCreateRequestPaymentInitiationExtension
    on LinkTokenCreateRequestPaymentInitiation {
  LinkTokenCreateRequestPaymentInitiation copyWith(
      {String? paymentId, String? consentId}) {
    return LinkTokenCreateRequestPaymentInitiation(
        paymentId: paymentId ?? this.paymentId,
        consentId: consentId ?? this.consentId);
  }

  LinkTokenCreateRequestPaymentInitiation copyWithWrapped(
      {Wrapped<String?>? paymentId, Wrapped<String?>? consentId}) {
    return LinkTokenCreateRequestPaymentInitiation(
        paymentId: (paymentId != null ? paymentId.value : this.paymentId),
        consentId: (consentId != null ? consentId.value : this.consentId));
  }
}

@JsonSerializable(explicitToJson: true)
class LinkTokenCreateRequestDepositSwitch {
  LinkTokenCreateRequestDepositSwitch({
    required this.depositSwitchId,
  });

  factory LinkTokenCreateRequestDepositSwitch.fromJson(
          Map<String, dynamic> json) =>
      _$LinkTokenCreateRequestDepositSwitchFromJson(json);

  @JsonKey(name: 'deposit_switch_id')
  final String depositSwitchId;
  static const fromJsonFactory = _$LinkTokenCreateRequestDepositSwitchFromJson;
  static const toJsonFactory = _$LinkTokenCreateRequestDepositSwitchToJson;
  Map<String, dynamic> toJson() =>
      _$LinkTokenCreateRequestDepositSwitchToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LinkTokenCreateRequestDepositSwitch &&
            (identical(other.depositSwitchId, depositSwitchId) ||
                const DeepCollectionEquality()
                    .equals(other.depositSwitchId, depositSwitchId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(depositSwitchId) ^
      runtimeType.hashCode;
}

extension $LinkTokenCreateRequestDepositSwitchExtension
    on LinkTokenCreateRequestDepositSwitch {
  LinkTokenCreateRequestDepositSwitch copyWith({String? depositSwitchId}) {
    return LinkTokenCreateRequestDepositSwitch(
        depositSwitchId: depositSwitchId ?? this.depositSwitchId);
  }

  LinkTokenCreateRequestDepositSwitch copyWithWrapped(
      {Wrapped<String>? depositSwitchId}) {
    return LinkTokenCreateRequestDepositSwitch(
        depositSwitchId: (depositSwitchId != null
            ? depositSwitchId.value
            : this.depositSwitchId));
  }
}

@JsonSerializable(explicitToJson: true)
class LinkTokenCreateRequestTransfer {
  LinkTokenCreateRequestTransfer({
    this.intentId,
    this.paymentProfileToken,
  });

  factory LinkTokenCreateRequestTransfer.fromJson(Map<String, dynamic> json) =>
      _$LinkTokenCreateRequestTransferFromJson(json);

  @JsonKey(name: 'intent_id')
  final String? intentId;
  @JsonKey(name: 'payment_profile_token')
  final String? paymentProfileToken;
  static const fromJsonFactory = _$LinkTokenCreateRequestTransferFromJson;
  static const toJsonFactory = _$LinkTokenCreateRequestTransferToJson;
  Map<String, dynamic> toJson() => _$LinkTokenCreateRequestTransferToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LinkTokenCreateRequestTransfer &&
            (identical(other.intentId, intentId) ||
                const DeepCollectionEquality()
                    .equals(other.intentId, intentId)) &&
            (identical(other.paymentProfileToken, paymentProfileToken) ||
                const DeepCollectionEquality()
                    .equals(other.paymentProfileToken, paymentProfileToken)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(intentId) ^
      const DeepCollectionEquality().hash(paymentProfileToken) ^
      runtimeType.hashCode;
}

extension $LinkTokenCreateRequestTransferExtension
    on LinkTokenCreateRequestTransfer {
  LinkTokenCreateRequestTransfer copyWith(
      {String? intentId, String? paymentProfileToken}) {
    return LinkTokenCreateRequestTransfer(
        intentId: intentId ?? this.intentId,
        paymentProfileToken: paymentProfileToken ?? this.paymentProfileToken);
  }

  LinkTokenCreateRequestTransfer copyWithWrapped(
      {Wrapped<String?>? intentId, Wrapped<String?>? paymentProfileToken}) {
    return LinkTokenCreateRequestTransfer(
        intentId: (intentId != null ? intentId.value : this.intentId),
        paymentProfileToken: (paymentProfileToken != null
            ? paymentProfileToken.value
            : this.paymentProfileToken));
  }
}

@JsonSerializable(explicitToJson: true)
class LinkTokenCreateRequestUserStatedIncomeSource {
  LinkTokenCreateRequestUserStatedIncomeSource({
    this.employer,
    this.category,
    this.payPerCycle,
    this.payAnnual,
    this.payType,
    this.payFrequency,
  });

  factory LinkTokenCreateRequestUserStatedIncomeSource.fromJson(
          Map<String, dynamic> json) =>
      _$LinkTokenCreateRequestUserStatedIncomeSourceFromJson(json);

  @JsonKey(name: 'employer')
  final String? employer;
  @JsonKey(
    name: 'category',
    toJson: userStatedIncomeSourceCategoryToJson,
    fromJson: userStatedIncomeSourceCategoryFromJson,
  )
  final enums.UserStatedIncomeSourceCategory? category;
  @JsonKey(name: 'pay_per_cycle')
  final double? payPerCycle;
  @JsonKey(name: 'pay_annual')
  final double? payAnnual;
  @JsonKey(
    name: 'pay_type',
    toJson: userStatedIncomeSourcePayTypeToJson,
    fromJson: userStatedIncomeSourcePayTypeFromJson,
  )
  final enums.UserStatedIncomeSourcePayType? payType;
  @JsonKey(
    name: 'pay_frequency',
    toJson: userStatedIncomeSourceFrequencyToJson,
    fromJson: userStatedIncomeSourceFrequencyFromJson,
  )
  final enums.UserStatedIncomeSourceFrequency? payFrequency;
  static const fromJsonFactory =
      _$LinkTokenCreateRequestUserStatedIncomeSourceFromJson;
  static const toJsonFactory =
      _$LinkTokenCreateRequestUserStatedIncomeSourceToJson;
  Map<String, dynamic> toJson() =>
      _$LinkTokenCreateRequestUserStatedIncomeSourceToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LinkTokenCreateRequestUserStatedIncomeSource &&
            (identical(other.employer, employer) ||
                const DeepCollectionEquality()
                    .equals(other.employer, employer)) &&
            (identical(other.category, category) ||
                const DeepCollectionEquality()
                    .equals(other.category, category)) &&
            (identical(other.payPerCycle, payPerCycle) ||
                const DeepCollectionEquality()
                    .equals(other.payPerCycle, payPerCycle)) &&
            (identical(other.payAnnual, payAnnual) ||
                const DeepCollectionEquality()
                    .equals(other.payAnnual, payAnnual)) &&
            (identical(other.payType, payType) ||
                const DeepCollectionEquality()
                    .equals(other.payType, payType)) &&
            (identical(other.payFrequency, payFrequency) ||
                const DeepCollectionEquality()
                    .equals(other.payFrequency, payFrequency)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(employer) ^
      const DeepCollectionEquality().hash(category) ^
      const DeepCollectionEquality().hash(payPerCycle) ^
      const DeepCollectionEquality().hash(payAnnual) ^
      const DeepCollectionEquality().hash(payType) ^
      const DeepCollectionEquality().hash(payFrequency) ^
      runtimeType.hashCode;
}

extension $LinkTokenCreateRequestUserStatedIncomeSourceExtension
    on LinkTokenCreateRequestUserStatedIncomeSource {
  LinkTokenCreateRequestUserStatedIncomeSource copyWith(
      {String? employer,
      enums.UserStatedIncomeSourceCategory? category,
      double? payPerCycle,
      double? payAnnual,
      enums.UserStatedIncomeSourcePayType? payType,
      enums.UserStatedIncomeSourceFrequency? payFrequency}) {
    return LinkTokenCreateRequestUserStatedIncomeSource(
        employer: employer ?? this.employer,
        category: category ?? this.category,
        payPerCycle: payPerCycle ?? this.payPerCycle,
        payAnnual: payAnnual ?? this.payAnnual,
        payType: payType ?? this.payType,
        payFrequency: payFrequency ?? this.payFrequency);
  }

  LinkTokenCreateRequestUserStatedIncomeSource copyWithWrapped(
      {Wrapped<String?>? employer,
      Wrapped<enums.UserStatedIncomeSourceCategory?>? category,
      Wrapped<double?>? payPerCycle,
      Wrapped<double?>? payAnnual,
      Wrapped<enums.UserStatedIncomeSourcePayType?>? payType,
      Wrapped<enums.UserStatedIncomeSourceFrequency?>? payFrequency}) {
    return LinkTokenCreateRequestUserStatedIncomeSource(
        employer: (employer != null ? employer.value : this.employer),
        category: (category != null ? category.value : this.category),
        payPerCycle:
            (payPerCycle != null ? payPerCycle.value : this.payPerCycle),
        payAnnual: (payAnnual != null ? payAnnual.value : this.payAnnual),
        payType: (payType != null ? payType.value : this.payType),
        payFrequency:
            (payFrequency != null ? payFrequency.value : this.payFrequency));
  }
}

@JsonSerializable(explicitToJson: true)
class LinkTokenCreateRequestAuth {
  LinkTokenCreateRequestAuth({
    this.authTypeSelectEnabled,
    this.automatedMicrodepositsEnabled,
    this.instantMatchEnabled,
    this.sameDayMicrodepositsEnabled,
    this.flowType,
  });

  factory LinkTokenCreateRequestAuth.fromJson(Map<String, dynamic> json) =>
      _$LinkTokenCreateRequestAuthFromJson(json);

  @JsonKey(name: 'auth_type_select_enabled', defaultValue: false)
  final bool? authTypeSelectEnabled;
  @JsonKey(name: 'automated_microdeposits_enabled')
  final bool? automatedMicrodepositsEnabled;
  @JsonKey(name: 'instant_match_enabled')
  final bool? instantMatchEnabled;
  @JsonKey(name: 'same_day_microdeposits_enabled')
  final bool? sameDayMicrodepositsEnabled;
  @JsonKey(
    name: 'flow_type',
    toJson: linkTokenCreateRequestAuthFlowTypeToJson,
    fromJson: linkTokenCreateRequestAuthFlowTypeFromJson,
  )
  final enums.LinkTokenCreateRequestAuthFlowType? flowType;
  static const fromJsonFactory = _$LinkTokenCreateRequestAuthFromJson;
  static const toJsonFactory = _$LinkTokenCreateRequestAuthToJson;
  Map<String, dynamic> toJson() => _$LinkTokenCreateRequestAuthToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LinkTokenCreateRequestAuth &&
            (identical(other.authTypeSelectEnabled, authTypeSelectEnabled) ||
                const DeepCollectionEquality().equals(
                    other.authTypeSelectEnabled, authTypeSelectEnabled)) &&
            (identical(other.automatedMicrodepositsEnabled,
                    automatedMicrodepositsEnabled) ||
                const DeepCollectionEquality().equals(
                    other.automatedMicrodepositsEnabled,
                    automatedMicrodepositsEnabled)) &&
            (identical(other.instantMatchEnabled, instantMatchEnabled) ||
                const DeepCollectionEquality()
                    .equals(other.instantMatchEnabled, instantMatchEnabled)) &&
            (identical(other.sameDayMicrodepositsEnabled,
                    sameDayMicrodepositsEnabled) ||
                const DeepCollectionEquality().equals(
                    other.sameDayMicrodepositsEnabled,
                    sameDayMicrodepositsEnabled)) &&
            (identical(other.flowType, flowType) ||
                const DeepCollectionEquality()
                    .equals(other.flowType, flowType)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(authTypeSelectEnabled) ^
      const DeepCollectionEquality().hash(automatedMicrodepositsEnabled) ^
      const DeepCollectionEquality().hash(instantMatchEnabled) ^
      const DeepCollectionEquality().hash(sameDayMicrodepositsEnabled) ^
      const DeepCollectionEquality().hash(flowType) ^
      runtimeType.hashCode;
}

extension $LinkTokenCreateRequestAuthExtension on LinkTokenCreateRequestAuth {
  LinkTokenCreateRequestAuth copyWith(
      {bool? authTypeSelectEnabled,
      bool? automatedMicrodepositsEnabled,
      bool? instantMatchEnabled,
      bool? sameDayMicrodepositsEnabled,
      enums.LinkTokenCreateRequestAuthFlowType? flowType}) {
    return LinkTokenCreateRequestAuth(
        authTypeSelectEnabled:
            authTypeSelectEnabled ?? this.authTypeSelectEnabled,
        automatedMicrodepositsEnabled:
            automatedMicrodepositsEnabled ?? this.automatedMicrodepositsEnabled,
        instantMatchEnabled: instantMatchEnabled ?? this.instantMatchEnabled,
        sameDayMicrodepositsEnabled:
            sameDayMicrodepositsEnabled ?? this.sameDayMicrodepositsEnabled,
        flowType: flowType ?? this.flowType);
  }

  LinkTokenCreateRequestAuth copyWithWrapped(
      {Wrapped<bool?>? authTypeSelectEnabled,
      Wrapped<bool?>? automatedMicrodepositsEnabled,
      Wrapped<bool?>? instantMatchEnabled,
      Wrapped<bool?>? sameDayMicrodepositsEnabled,
      Wrapped<enums.LinkTokenCreateRequestAuthFlowType?>? flowType}) {
    return LinkTokenCreateRequestAuth(
        authTypeSelectEnabled: (authTypeSelectEnabled != null
            ? authTypeSelectEnabled.value
            : this.authTypeSelectEnabled),
        automatedMicrodepositsEnabled: (automatedMicrodepositsEnabled != null
            ? automatedMicrodepositsEnabled.value
            : this.automatedMicrodepositsEnabled),
        instantMatchEnabled: (instantMatchEnabled != null
            ? instantMatchEnabled.value
            : this.instantMatchEnabled),
        sameDayMicrodepositsEnabled: (sameDayMicrodepositsEnabled != null
            ? sameDayMicrodepositsEnabled.value
            : this.sameDayMicrodepositsEnabled),
        flowType: (flowType != null ? flowType.value : this.flowType));
  }
}

@JsonSerializable(explicitToJson: true)
class LinkTokenCreateRequestIdentityVerification {
  LinkTokenCreateRequestIdentityVerification({
    required this.templateId,
    this.consent,
    this.gaveConsent,
  });

  factory LinkTokenCreateRequestIdentityVerification.fromJson(
          Map<String, dynamic> json) =>
      _$LinkTokenCreateRequestIdentityVerificationFromJson(json);

  @JsonKey(name: 'template_id')
  final String templateId;
  @JsonKey(name: 'consent')
  final bool? consent;
  @JsonKey(name: 'gave_consent')
  final bool? gaveConsent;
  static const fromJsonFactory =
      _$LinkTokenCreateRequestIdentityVerificationFromJson;
  static const toJsonFactory =
      _$LinkTokenCreateRequestIdentityVerificationToJson;
  Map<String, dynamic> toJson() =>
      _$LinkTokenCreateRequestIdentityVerificationToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LinkTokenCreateRequestIdentityVerification &&
            (identical(other.templateId, templateId) ||
                const DeepCollectionEquality()
                    .equals(other.templateId, templateId)) &&
            (identical(other.consent, consent) ||
                const DeepCollectionEquality()
                    .equals(other.consent, consent)) &&
            (identical(other.gaveConsent, gaveConsent) ||
                const DeepCollectionEquality()
                    .equals(other.gaveConsent, gaveConsent)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(templateId) ^
      const DeepCollectionEquality().hash(consent) ^
      const DeepCollectionEquality().hash(gaveConsent) ^
      runtimeType.hashCode;
}

extension $LinkTokenCreateRequestIdentityVerificationExtension
    on LinkTokenCreateRequestIdentityVerification {
  LinkTokenCreateRequestIdentityVerification copyWith(
      {String? templateId, bool? consent, bool? gaveConsent}) {
    return LinkTokenCreateRequestIdentityVerification(
        templateId: templateId ?? this.templateId,
        consent: consent ?? this.consent,
        gaveConsent: gaveConsent ?? this.gaveConsent);
  }

  LinkTokenCreateRequestIdentityVerification copyWithWrapped(
      {Wrapped<String>? templateId,
      Wrapped<bool?>? consent,
      Wrapped<bool?>? gaveConsent}) {
    return LinkTokenCreateRequestIdentityVerification(
        templateId: (templateId != null ? templateId.value : this.templateId),
        consent: (consent != null ? consent.value : this.consent),
        gaveConsent:
            (gaveConsent != null ? gaveConsent.value : this.gaveConsent));
  }
}

@JsonSerializable(explicitToJson: true)
class LinkTokenCreateInstitutionData {
  LinkTokenCreateInstitutionData({
    this.routingNumber,
  });

  factory LinkTokenCreateInstitutionData.fromJson(Map<String, dynamic> json) =>
      _$LinkTokenCreateInstitutionDataFromJson(json);

  @JsonKey(name: 'routing_number')
  final String? routingNumber;
  static const fromJsonFactory = _$LinkTokenCreateInstitutionDataFromJson;
  static const toJsonFactory = _$LinkTokenCreateInstitutionDataToJson;
  Map<String, dynamic> toJson() => _$LinkTokenCreateInstitutionDataToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LinkTokenCreateInstitutionData &&
            (identical(other.routingNumber, routingNumber) ||
                const DeepCollectionEquality()
                    .equals(other.routingNumber, routingNumber)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(routingNumber) ^ runtimeType.hashCode;
}

extension $LinkTokenCreateInstitutionDataExtension
    on LinkTokenCreateInstitutionData {
  LinkTokenCreateInstitutionData copyWith({String? routingNumber}) {
    return LinkTokenCreateInstitutionData(
        routingNumber: routingNumber ?? this.routingNumber);
  }

  LinkTokenCreateInstitutionData copyWithWrapped(
      {Wrapped<String?>? routingNumber}) {
    return LinkTokenCreateInstitutionData(
        routingNumber:
            (routingNumber != null ? routingNumber.value : this.routingNumber));
  }
}

@JsonSerializable(explicitToJson: true)
class LinkTokenCreateRequestUser {
  LinkTokenCreateRequestUser({
    required this.clientUserId,
    this.legalName,
    this.name,
    this.phoneNumber,
    this.phoneNumberVerifiedTime,
    this.emailAddress,
    this.emailAddressVerifiedTime,
    this.ssn,
    this.dateOfBirth,
    this.address,
    this.idNumber,
  });

  factory LinkTokenCreateRequestUser.fromJson(Map<String, dynamic> json) =>
      _$LinkTokenCreateRequestUserFromJson(json);

  @JsonKey(name: 'client_user_id')
  final String clientUserId;
  @JsonKey(name: 'legal_name')
  final String? legalName;
  @JsonKey(name: 'name')
  final dynamic? name;
  @JsonKey(name: 'phone_number')
  final String? phoneNumber;
  @JsonKey(name: 'phone_number_verified_time')
  final DateTime? phoneNumberVerifiedTime;
  @JsonKey(name: 'email_address')
  final String? emailAddress;
  @JsonKey(name: 'email_address_verified_time')
  final DateTime? emailAddressVerifiedTime;
  @JsonKey(name: 'ssn')
  final String? ssn;
  @JsonKey(name: 'date_of_birth', toJson: _dateToJson)
  final DateTime? dateOfBirth;
  @JsonKey(name: 'address')
  final UserAddress? address;
  @JsonKey(name: 'id_number')
  final UserIDNumber? idNumber;
  static const fromJsonFactory = _$LinkTokenCreateRequestUserFromJson;
  static const toJsonFactory = _$LinkTokenCreateRequestUserToJson;
  Map<String, dynamic> toJson() => _$LinkTokenCreateRequestUserToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LinkTokenCreateRequestUser &&
            (identical(other.clientUserId, clientUserId) ||
                const DeepCollectionEquality()
                    .equals(other.clientUserId, clientUserId)) &&
            (identical(other.legalName, legalName) ||
                const DeepCollectionEquality()
                    .equals(other.legalName, legalName)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.phoneNumber, phoneNumber) ||
                const DeepCollectionEquality()
                    .equals(other.phoneNumber, phoneNumber)) &&
            (identical(
                    other.phoneNumberVerifiedTime, phoneNumberVerifiedTime) ||
                const DeepCollectionEquality().equals(
                    other.phoneNumberVerifiedTime, phoneNumberVerifiedTime)) &&
            (identical(other.emailAddress, emailAddress) ||
                const DeepCollectionEquality()
                    .equals(other.emailAddress, emailAddress)) &&
            (identical(
                    other.emailAddressVerifiedTime, emailAddressVerifiedTime) ||
                const DeepCollectionEquality().equals(
                    other.emailAddressVerifiedTime,
                    emailAddressVerifiedTime)) &&
            (identical(other.ssn, ssn) ||
                const DeepCollectionEquality().equals(other.ssn, ssn)) &&
            (identical(other.dateOfBirth, dateOfBirth) ||
                const DeepCollectionEquality()
                    .equals(other.dateOfBirth, dateOfBirth)) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality()
                    .equals(other.address, address)) &&
            (identical(other.idNumber, idNumber) ||
                const DeepCollectionEquality()
                    .equals(other.idNumber, idNumber)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientUserId) ^
      const DeepCollectionEquality().hash(legalName) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(phoneNumber) ^
      const DeepCollectionEquality().hash(phoneNumberVerifiedTime) ^
      const DeepCollectionEquality().hash(emailAddress) ^
      const DeepCollectionEquality().hash(emailAddressVerifiedTime) ^
      const DeepCollectionEquality().hash(ssn) ^
      const DeepCollectionEquality().hash(dateOfBirth) ^
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(idNumber) ^
      runtimeType.hashCode;
}

extension $LinkTokenCreateRequestUserExtension on LinkTokenCreateRequestUser {
  LinkTokenCreateRequestUser copyWith(
      {String? clientUserId,
      String? legalName,
      dynamic? name,
      String? phoneNumber,
      DateTime? phoneNumberVerifiedTime,
      String? emailAddress,
      DateTime? emailAddressVerifiedTime,
      String? ssn,
      DateTime? dateOfBirth,
      UserAddress? address,
      UserIDNumber? idNumber}) {
    return LinkTokenCreateRequestUser(
        clientUserId: clientUserId ?? this.clientUserId,
        legalName: legalName ?? this.legalName,
        name: name ?? this.name,
        phoneNumber: phoneNumber ?? this.phoneNumber,
        phoneNumberVerifiedTime:
            phoneNumberVerifiedTime ?? this.phoneNumberVerifiedTime,
        emailAddress: emailAddress ?? this.emailAddress,
        emailAddressVerifiedTime:
            emailAddressVerifiedTime ?? this.emailAddressVerifiedTime,
        ssn: ssn ?? this.ssn,
        dateOfBirth: dateOfBirth ?? this.dateOfBirth,
        address: address ?? this.address,
        idNumber: idNumber ?? this.idNumber);
  }

  LinkTokenCreateRequestUser copyWithWrapped(
      {Wrapped<String>? clientUserId,
      Wrapped<String?>? legalName,
      Wrapped<dynamic?>? name,
      Wrapped<String?>? phoneNumber,
      Wrapped<DateTime?>? phoneNumberVerifiedTime,
      Wrapped<String?>? emailAddress,
      Wrapped<DateTime?>? emailAddressVerifiedTime,
      Wrapped<String?>? ssn,
      Wrapped<DateTime?>? dateOfBirth,
      Wrapped<UserAddress?>? address,
      Wrapped<UserIDNumber?>? idNumber}) {
    return LinkTokenCreateRequestUser(
        clientUserId:
            (clientUserId != null ? clientUserId.value : this.clientUserId),
        legalName: (legalName != null ? legalName.value : this.legalName),
        name: (name != null ? name.value : this.name),
        phoneNumber:
            (phoneNumber != null ? phoneNumber.value : this.phoneNumber),
        phoneNumberVerifiedTime: (phoneNumberVerifiedTime != null
            ? phoneNumberVerifiedTime.value
            : this.phoneNumberVerifiedTime),
        emailAddress:
            (emailAddress != null ? emailAddress.value : this.emailAddress),
        emailAddressVerifiedTime: (emailAddressVerifiedTime != null
            ? emailAddressVerifiedTime.value
            : this.emailAddressVerifiedTime),
        ssn: (ssn != null ? ssn.value : this.ssn),
        dateOfBirth:
            (dateOfBirth != null ? dateOfBirth.value : this.dateOfBirth),
        address: (address != null ? address.value : this.address),
        idNumber: (idNumber != null ? idNumber.value : this.idNumber));
  }
}

@JsonSerializable(explicitToJson: true)
class LinkTokenCreateRequestUpdate {
  LinkTokenCreateRequestUpdate({
    this.accountSelectionEnabled,
  });

  factory LinkTokenCreateRequestUpdate.fromJson(Map<String, dynamic> json) =>
      _$LinkTokenCreateRequestUpdateFromJson(json);

  @JsonKey(name: 'account_selection_enabled', defaultValue: false)
  final bool? accountSelectionEnabled;
  static const fromJsonFactory = _$LinkTokenCreateRequestUpdateFromJson;
  static const toJsonFactory = _$LinkTokenCreateRequestUpdateToJson;
  Map<String, dynamic> toJson() => _$LinkTokenCreateRequestUpdateToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LinkTokenCreateRequestUpdate &&
            (identical(
                    other.accountSelectionEnabled, accountSelectionEnabled) ||
                const DeepCollectionEquality().equals(
                    other.accountSelectionEnabled, accountSelectionEnabled)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountSelectionEnabled) ^
      runtimeType.hashCode;
}

extension $LinkTokenCreateRequestUpdateExtension
    on LinkTokenCreateRequestUpdate {
  LinkTokenCreateRequestUpdate copyWith({bool? accountSelectionEnabled}) {
    return LinkTokenCreateRequestUpdate(
        accountSelectionEnabled:
            accountSelectionEnabled ?? this.accountSelectionEnabled);
  }

  LinkTokenCreateRequestUpdate copyWithWrapped(
      {Wrapped<bool?>? accountSelectionEnabled}) {
    return LinkTokenCreateRequestUpdate(
        accountSelectionEnabled: (accountSelectionEnabled != null
            ? accountSelectionEnabled.value
            : this.accountSelectionEnabled));
  }
}

@JsonSerializable(explicitToJson: true)
class LinkTokenCreateRequestAccountSubtypes {
  LinkTokenCreateRequestAccountSubtypes({
    this.depository,
    this.credit,
    this.loan,
    this.investment,
  });

  factory LinkTokenCreateRequestAccountSubtypes.fromJson(
          Map<String, dynamic> json) =>
      _$LinkTokenCreateRequestAccountSubtypesFromJson(json);

  @JsonKey(name: 'depository')
  final LinkTokenCreateDepositoryFilter? depository;
  @JsonKey(name: 'credit')
  final LinkTokenCreateCreditFilter? credit;
  @JsonKey(name: 'loan')
  final LinkTokenCreateLoanFilter? loan;
  @JsonKey(name: 'investment')
  final LinkTokenCreateInvestmentFilter? investment;
  static const fromJsonFactory =
      _$LinkTokenCreateRequestAccountSubtypesFromJson;
  static const toJsonFactory = _$LinkTokenCreateRequestAccountSubtypesToJson;
  Map<String, dynamic> toJson() =>
      _$LinkTokenCreateRequestAccountSubtypesToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LinkTokenCreateRequestAccountSubtypes &&
            (identical(other.depository, depository) ||
                const DeepCollectionEquality()
                    .equals(other.depository, depository)) &&
            (identical(other.credit, credit) ||
                const DeepCollectionEquality().equals(other.credit, credit)) &&
            (identical(other.loan, loan) ||
                const DeepCollectionEquality().equals(other.loan, loan)) &&
            (identical(other.investment, investment) ||
                const DeepCollectionEquality()
                    .equals(other.investment, investment)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(depository) ^
      const DeepCollectionEquality().hash(credit) ^
      const DeepCollectionEquality().hash(loan) ^
      const DeepCollectionEquality().hash(investment) ^
      runtimeType.hashCode;
}

extension $LinkTokenCreateRequestAccountSubtypesExtension
    on LinkTokenCreateRequestAccountSubtypes {
  LinkTokenCreateRequestAccountSubtypes copyWith(
      {LinkTokenCreateDepositoryFilter? depository,
      LinkTokenCreateCreditFilter? credit,
      LinkTokenCreateLoanFilter? loan,
      LinkTokenCreateInvestmentFilter? investment}) {
    return LinkTokenCreateRequestAccountSubtypes(
        depository: depository ?? this.depository,
        credit: credit ?? this.credit,
        loan: loan ?? this.loan,
        investment: investment ?? this.investment);
  }

  LinkTokenCreateRequestAccountSubtypes copyWithWrapped(
      {Wrapped<LinkTokenCreateDepositoryFilter?>? depository,
      Wrapped<LinkTokenCreateCreditFilter?>? credit,
      Wrapped<LinkTokenCreateLoanFilter?>? loan,
      Wrapped<LinkTokenCreateInvestmentFilter?>? investment}) {
    return LinkTokenCreateRequestAccountSubtypes(
        depository: (depository != null ? depository.value : this.depository),
        credit: (credit != null ? credit.value : this.credit),
        loan: (loan != null ? loan.value : this.loan),
        investment: (investment != null ? investment.value : this.investment));
  }
}

@JsonSerializable(explicitToJson: true)
class LinkTokenCreateDepositoryFilter {
  LinkTokenCreateDepositoryFilter({
    this.accountSubtypes,
  });

  factory LinkTokenCreateDepositoryFilter.fromJson(Map<String, dynamic> json) =>
      _$LinkTokenCreateDepositoryFilterFromJson(json);

  @JsonKey(name: 'account_subtypes')
  final List<String>? accountSubtypes;
  static const fromJsonFactory = _$LinkTokenCreateDepositoryFilterFromJson;
  static const toJsonFactory = _$LinkTokenCreateDepositoryFilterToJson;
  Map<String, dynamic> toJson() =>
      _$LinkTokenCreateDepositoryFilterToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LinkTokenCreateDepositoryFilter &&
            (identical(other.accountSubtypes, accountSubtypes) ||
                const DeepCollectionEquality()
                    .equals(other.accountSubtypes, accountSubtypes)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountSubtypes) ^
      runtimeType.hashCode;
}

extension $LinkTokenCreateDepositoryFilterExtension
    on LinkTokenCreateDepositoryFilter {
  LinkTokenCreateDepositoryFilter copyWith({List<String>? accountSubtypes}) {
    return LinkTokenCreateDepositoryFilter(
        accountSubtypes: accountSubtypes ?? this.accountSubtypes);
  }

  LinkTokenCreateDepositoryFilter copyWithWrapped(
      {Wrapped<List<String>?>? accountSubtypes}) {
    return LinkTokenCreateDepositoryFilter(
        accountSubtypes: (accountSubtypes != null
            ? accountSubtypes.value
            : this.accountSubtypes));
  }
}

@JsonSerializable(explicitToJson: true)
class LinkTokenCreateCreditFilter {
  LinkTokenCreateCreditFilter({
    this.accountSubtypes,
  });

  factory LinkTokenCreateCreditFilter.fromJson(Map<String, dynamic> json) =>
      _$LinkTokenCreateCreditFilterFromJson(json);

  @JsonKey(name: 'account_subtypes')
  final List<String>? accountSubtypes;
  static const fromJsonFactory = _$LinkTokenCreateCreditFilterFromJson;
  static const toJsonFactory = _$LinkTokenCreateCreditFilterToJson;
  Map<String, dynamic> toJson() => _$LinkTokenCreateCreditFilterToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LinkTokenCreateCreditFilter &&
            (identical(other.accountSubtypes, accountSubtypes) ||
                const DeepCollectionEquality()
                    .equals(other.accountSubtypes, accountSubtypes)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountSubtypes) ^
      runtimeType.hashCode;
}

extension $LinkTokenCreateCreditFilterExtension on LinkTokenCreateCreditFilter {
  LinkTokenCreateCreditFilter copyWith({List<String>? accountSubtypes}) {
    return LinkTokenCreateCreditFilter(
        accountSubtypes: accountSubtypes ?? this.accountSubtypes);
  }

  LinkTokenCreateCreditFilter copyWithWrapped(
      {Wrapped<List<String>?>? accountSubtypes}) {
    return LinkTokenCreateCreditFilter(
        accountSubtypes: (accountSubtypes != null
            ? accountSubtypes.value
            : this.accountSubtypes));
  }
}

@JsonSerializable(explicitToJson: true)
class LinkTokenCreateLoanFilter {
  LinkTokenCreateLoanFilter({
    this.accountSubtypes,
  });

  factory LinkTokenCreateLoanFilter.fromJson(Map<String, dynamic> json) =>
      _$LinkTokenCreateLoanFilterFromJson(json);

  @JsonKey(name: 'account_subtypes')
  final List<String>? accountSubtypes;
  static const fromJsonFactory = _$LinkTokenCreateLoanFilterFromJson;
  static const toJsonFactory = _$LinkTokenCreateLoanFilterToJson;
  Map<String, dynamic> toJson() => _$LinkTokenCreateLoanFilterToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LinkTokenCreateLoanFilter &&
            (identical(other.accountSubtypes, accountSubtypes) ||
                const DeepCollectionEquality()
                    .equals(other.accountSubtypes, accountSubtypes)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountSubtypes) ^
      runtimeType.hashCode;
}

extension $LinkTokenCreateLoanFilterExtension on LinkTokenCreateLoanFilter {
  LinkTokenCreateLoanFilter copyWith({List<String>? accountSubtypes}) {
    return LinkTokenCreateLoanFilter(
        accountSubtypes: accountSubtypes ?? this.accountSubtypes);
  }

  LinkTokenCreateLoanFilter copyWithWrapped(
      {Wrapped<List<String>?>? accountSubtypes}) {
    return LinkTokenCreateLoanFilter(
        accountSubtypes: (accountSubtypes != null
            ? accountSubtypes.value
            : this.accountSubtypes));
  }
}

@JsonSerializable(explicitToJson: true)
class LinkTokenCreateInvestmentFilter {
  LinkTokenCreateInvestmentFilter({
    this.accountSubtypes,
  });

  factory LinkTokenCreateInvestmentFilter.fromJson(Map<String, dynamic> json) =>
      _$LinkTokenCreateInvestmentFilterFromJson(json);

  @JsonKey(name: 'account_subtypes')
  final List<String>? accountSubtypes;
  static const fromJsonFactory = _$LinkTokenCreateInvestmentFilterFromJson;
  static const toJsonFactory = _$LinkTokenCreateInvestmentFilterToJson;
  Map<String, dynamic> toJson() =>
      _$LinkTokenCreateInvestmentFilterToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LinkTokenCreateInvestmentFilter &&
            (identical(other.accountSubtypes, accountSubtypes) ||
                const DeepCollectionEquality()
                    .equals(other.accountSubtypes, accountSubtypes)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountSubtypes) ^
      runtimeType.hashCode;
}

extension $LinkTokenCreateInvestmentFilterExtension
    on LinkTokenCreateInvestmentFilter {
  LinkTokenCreateInvestmentFilter copyWith({List<String>? accountSubtypes}) {
    return LinkTokenCreateInvestmentFilter(
        accountSubtypes: accountSubtypes ?? this.accountSubtypes);
  }

  LinkTokenCreateInvestmentFilter copyWithWrapped(
      {Wrapped<List<String>?>? accountSubtypes}) {
    return LinkTokenCreateInvestmentFilter(
        accountSubtypes: (accountSubtypes != null
            ? accountSubtypes.value
            : this.accountSubtypes));
  }
}

@JsonSerializable(explicitToJson: true)
class LinkOAuthCorrelationIdExchangeRequest {
  LinkOAuthCorrelationIdExchangeRequest({
    this.clientId,
    this.secret,
    required this.linkCorrelationId,
  });

  factory LinkOAuthCorrelationIdExchangeRequest.fromJson(
          Map<String, dynamic> json) =>
      _$LinkOAuthCorrelationIdExchangeRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'link_correlation_id')
  final String linkCorrelationId;
  static const fromJsonFactory =
      _$LinkOAuthCorrelationIdExchangeRequestFromJson;
  static const toJsonFactory = _$LinkOAuthCorrelationIdExchangeRequestToJson;
  Map<String, dynamic> toJson() =>
      _$LinkOAuthCorrelationIdExchangeRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LinkOAuthCorrelationIdExchangeRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.linkCorrelationId, linkCorrelationId) ||
                const DeepCollectionEquality()
                    .equals(other.linkCorrelationId, linkCorrelationId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(linkCorrelationId) ^
      runtimeType.hashCode;
}

extension $LinkOAuthCorrelationIdExchangeRequestExtension
    on LinkOAuthCorrelationIdExchangeRequest {
  LinkOAuthCorrelationIdExchangeRequest copyWith(
      {String? clientId, String? secret, String? linkCorrelationId}) {
    return LinkOAuthCorrelationIdExchangeRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        linkCorrelationId: linkCorrelationId ?? this.linkCorrelationId);
  }

  LinkOAuthCorrelationIdExchangeRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? linkCorrelationId}) {
    return LinkOAuthCorrelationIdExchangeRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        linkCorrelationId: (linkCorrelationId != null
            ? linkCorrelationId.value
            : this.linkCorrelationId));
  }
}

@JsonSerializable(explicitToJson: true)
class LinkOAuthCorrelationIdExchangeResponse {
  LinkOAuthCorrelationIdExchangeResponse({
    required this.linkToken,
    required this.requestId,
  });

  factory LinkOAuthCorrelationIdExchangeResponse.fromJson(
          Map<String, dynamic> json) =>
      _$LinkOAuthCorrelationIdExchangeResponseFromJson(json);

  @JsonKey(name: 'link_token')
  final String linkToken;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory =
      _$LinkOAuthCorrelationIdExchangeResponseFromJson;
  static const toJsonFactory = _$LinkOAuthCorrelationIdExchangeResponseToJson;
  Map<String, dynamic> toJson() =>
      _$LinkOAuthCorrelationIdExchangeResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LinkOAuthCorrelationIdExchangeResponse &&
            (identical(other.linkToken, linkToken) ||
                const DeepCollectionEquality()
                    .equals(other.linkToken, linkToken)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(linkToken) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $LinkOAuthCorrelationIdExchangeResponseExtension
    on LinkOAuthCorrelationIdExchangeResponse {
  LinkOAuthCorrelationIdExchangeResponse copyWith(
      {String? linkToken, String? requestId}) {
    return LinkOAuthCorrelationIdExchangeResponse(
        linkToken: linkToken ?? this.linkToken,
        requestId: requestId ?? this.requestId);
  }

  LinkOAuthCorrelationIdExchangeResponse copyWithWrapped(
      {Wrapped<String>? linkToken, Wrapped<String>? requestId}) {
    return LinkOAuthCorrelationIdExchangeResponse(
        linkToken: (linkToken != null ? linkToken.value : this.linkToken),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class LinkTokenGetResponse {
  LinkTokenGetResponse({
    required this.linkToken,
    required this.createdAt,
    required this.expiration,
    required this.metadata,
    required this.requestId,
  });

  factory LinkTokenGetResponse.fromJson(Map<String, dynamic> json) =>
      _$LinkTokenGetResponseFromJson(json);

  @JsonKey(name: 'link_token')
  final String linkToken;
  @JsonKey(name: 'created_at')
  final DateTime? createdAt;
  @JsonKey(name: 'expiration')
  final DateTime? expiration;
  @JsonKey(name: 'metadata')
  final LinkTokenGetMetadataResponse metadata;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$LinkTokenGetResponseFromJson;
  static const toJsonFactory = _$LinkTokenGetResponseToJson;
  Map<String, dynamic> toJson() => _$LinkTokenGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LinkTokenGetResponse &&
            (identical(other.linkToken, linkToken) ||
                const DeepCollectionEquality()
                    .equals(other.linkToken, linkToken)) &&
            (identical(other.createdAt, createdAt) ||
                const DeepCollectionEquality()
                    .equals(other.createdAt, createdAt)) &&
            (identical(other.expiration, expiration) ||
                const DeepCollectionEquality()
                    .equals(other.expiration, expiration)) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality()
                    .equals(other.metadata, metadata)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(linkToken) ^
      const DeepCollectionEquality().hash(createdAt) ^
      const DeepCollectionEquality().hash(expiration) ^
      const DeepCollectionEquality().hash(metadata) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $LinkTokenGetResponseExtension on LinkTokenGetResponse {
  LinkTokenGetResponse copyWith(
      {String? linkToken,
      DateTime? createdAt,
      DateTime? expiration,
      LinkTokenGetMetadataResponse? metadata,
      String? requestId}) {
    return LinkTokenGetResponse(
        linkToken: linkToken ?? this.linkToken,
        createdAt: createdAt ?? this.createdAt,
        expiration: expiration ?? this.expiration,
        metadata: metadata ?? this.metadata,
        requestId: requestId ?? this.requestId);
  }

  LinkTokenGetResponse copyWithWrapped(
      {Wrapped<String>? linkToken,
      Wrapped<DateTime?>? createdAt,
      Wrapped<DateTime?>? expiration,
      Wrapped<LinkTokenGetMetadataResponse>? metadata,
      Wrapped<String>? requestId}) {
    return LinkTokenGetResponse(
        linkToken: (linkToken != null ? linkToken.value : this.linkToken),
        createdAt: (createdAt != null ? createdAt.value : this.createdAt),
        expiration: (expiration != null ? expiration.value : this.expiration),
        metadata: (metadata != null ? metadata.value : this.metadata),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class LinkTokenGetMetadataResponse {
  LinkTokenGetMetadataResponse({
    required this.initialProducts,
    required this.webhook,
    required this.countryCodes,
    required this.language,
    this.institutionData,
    this.accountFilters,
    required this.redirectUri,
    required this.clientName,
  });

  factory LinkTokenGetMetadataResponse.fromJson(Map<String, dynamic> json) =>
      _$LinkTokenGetMetadataResponseFromJson(json);

  @JsonKey(
    name: 'initial_products',
    toJson: productsListToJson,
    fromJson: productsListFromJson,
  )
  final List<enums.Products> initialProducts;
  @JsonKey(name: 'webhook')
  final String? webhook;
  @JsonKey(
    name: 'country_codes',
    toJson: countryCodeListToJson,
    fromJson: countryCodeListFromJson,
  )
  final List<enums.CountryCode> countryCodes;
  @JsonKey(name: 'language')
  final String? language;
  @JsonKey(name: 'institution_data')
  final LinkTokenCreateInstitutionData? institutionData;
  @JsonKey(name: 'account_filters')
  final AccountFiltersResponse? accountFilters;
  @JsonKey(name: 'redirect_uri')
  final String? redirectUri;
  @JsonKey(name: 'client_name')
  final String? clientName;
  static const fromJsonFactory = _$LinkTokenGetMetadataResponseFromJson;
  static const toJsonFactory = _$LinkTokenGetMetadataResponseToJson;
  Map<String, dynamic> toJson() => _$LinkTokenGetMetadataResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LinkTokenGetMetadataResponse &&
            (identical(other.initialProducts, initialProducts) ||
                const DeepCollectionEquality()
                    .equals(other.initialProducts, initialProducts)) &&
            (identical(other.webhook, webhook) ||
                const DeepCollectionEquality()
                    .equals(other.webhook, webhook)) &&
            (identical(other.countryCodes, countryCodes) ||
                const DeepCollectionEquality()
                    .equals(other.countryCodes, countryCodes)) &&
            (identical(other.language, language) ||
                const DeepCollectionEquality()
                    .equals(other.language, language)) &&
            (identical(other.institutionData, institutionData) ||
                const DeepCollectionEquality()
                    .equals(other.institutionData, institutionData)) &&
            (identical(other.accountFilters, accountFilters) ||
                const DeepCollectionEquality()
                    .equals(other.accountFilters, accountFilters)) &&
            (identical(other.redirectUri, redirectUri) ||
                const DeepCollectionEquality()
                    .equals(other.redirectUri, redirectUri)) &&
            (identical(other.clientName, clientName) ||
                const DeepCollectionEquality()
                    .equals(other.clientName, clientName)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(initialProducts) ^
      const DeepCollectionEquality().hash(webhook) ^
      const DeepCollectionEquality().hash(countryCodes) ^
      const DeepCollectionEquality().hash(language) ^
      const DeepCollectionEquality().hash(institutionData) ^
      const DeepCollectionEquality().hash(accountFilters) ^
      const DeepCollectionEquality().hash(redirectUri) ^
      const DeepCollectionEquality().hash(clientName) ^
      runtimeType.hashCode;
}

extension $LinkTokenGetMetadataResponseExtension
    on LinkTokenGetMetadataResponse {
  LinkTokenGetMetadataResponse copyWith(
      {List<enums.Products>? initialProducts,
      String? webhook,
      List<enums.CountryCode>? countryCodes,
      String? language,
      LinkTokenCreateInstitutionData? institutionData,
      AccountFiltersResponse? accountFilters,
      String? redirectUri,
      String? clientName}) {
    return LinkTokenGetMetadataResponse(
        initialProducts: initialProducts ?? this.initialProducts,
        webhook: webhook ?? this.webhook,
        countryCodes: countryCodes ?? this.countryCodes,
        language: language ?? this.language,
        institutionData: institutionData ?? this.institutionData,
        accountFilters: accountFilters ?? this.accountFilters,
        redirectUri: redirectUri ?? this.redirectUri,
        clientName: clientName ?? this.clientName);
  }

  LinkTokenGetMetadataResponse copyWithWrapped(
      {Wrapped<List<enums.Products>>? initialProducts,
      Wrapped<String?>? webhook,
      Wrapped<List<enums.CountryCode>>? countryCodes,
      Wrapped<String?>? language,
      Wrapped<LinkTokenCreateInstitutionData?>? institutionData,
      Wrapped<AccountFiltersResponse?>? accountFilters,
      Wrapped<String?>? redirectUri,
      Wrapped<String?>? clientName}) {
    return LinkTokenGetMetadataResponse(
        initialProducts: (initialProducts != null
            ? initialProducts.value
            : this.initialProducts),
        webhook: (webhook != null ? webhook.value : this.webhook),
        countryCodes:
            (countryCodes != null ? countryCodes.value : this.countryCodes),
        language: (language != null ? language.value : this.language),
        institutionData: (institutionData != null
            ? institutionData.value
            : this.institutionData),
        accountFilters: (accountFilters != null
            ? accountFilters.value
            : this.accountFilters),
        redirectUri:
            (redirectUri != null ? redirectUri.value : this.redirectUri),
        clientName: (clientName != null ? clientName.value : this.clientName));
  }
}

@JsonSerializable(explicitToJson: true)
class LinkTokenCreateResponse {
  LinkTokenCreateResponse({
    required this.linkToken,
    required this.expiration,
    required this.requestId,
  });

  factory LinkTokenCreateResponse.fromJson(Map<String, dynamic> json) =>
      _$LinkTokenCreateResponseFromJson(json);

  @JsonKey(name: 'link_token')
  final String linkToken;
  @JsonKey(name: 'expiration')
  final DateTime expiration;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$LinkTokenCreateResponseFromJson;
  static const toJsonFactory = _$LinkTokenCreateResponseToJson;
  Map<String, dynamic> toJson() => _$LinkTokenCreateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LinkTokenCreateResponse &&
            (identical(other.linkToken, linkToken) ||
                const DeepCollectionEquality()
                    .equals(other.linkToken, linkToken)) &&
            (identical(other.expiration, expiration) ||
                const DeepCollectionEquality()
                    .equals(other.expiration, expiration)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(linkToken) ^
      const DeepCollectionEquality().hash(expiration) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $LinkTokenCreateResponseExtension on LinkTokenCreateResponse {
  LinkTokenCreateResponse copyWith(
      {String? linkToken, DateTime? expiration, String? requestId}) {
    return LinkTokenCreateResponse(
        linkToken: linkToken ?? this.linkToken,
        expiration: expiration ?? this.expiration,
        requestId: requestId ?? this.requestId);
  }

  LinkTokenCreateResponse copyWithWrapped(
      {Wrapped<String>? linkToken,
      Wrapped<DateTime>? expiration,
      Wrapped<String>? requestId}) {
    return LinkTokenCreateResponse(
        linkToken: (linkToken != null ? linkToken.value : this.linkToken),
        expiration: (expiration != null ? expiration.value : this.expiration),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class PlaidError {
  PlaidError({
    required this.errorType,
    required this.errorCode,
    required this.errorMessage,
    required this.displayMessage,
    this.requestId,
    this.causes,
    this.status,
    this.documentationUrl,
    this.suggestedAction,
  });

  factory PlaidError.fromJson(Map<String, dynamic> json) =>
      _$PlaidErrorFromJson(json);

  @JsonKey(
    name: 'error_type',
    toJson: plaidErrorTypeToJson,
    fromJson: plaidErrorTypeFromJson,
  )
  final enums.PlaidErrorType errorType;
  @JsonKey(name: 'error_code')
  final String errorCode;
  @JsonKey(name: 'error_message')
  final String errorMessage;
  @JsonKey(name: 'display_message')
  final String? displayMessage;
  @JsonKey(name: 'request_id')
  final String? requestId;
  @JsonKey(name: 'causes', defaultValue: <Object>[])
  final List<Object>? causes;
  @JsonKey(name: 'status')
  final double? status;
  @JsonKey(name: 'documentation_url')
  final String? documentationUrl;
  @JsonKey(name: 'suggested_action')
  final String? suggestedAction;
  static const fromJsonFactory = _$PlaidErrorFromJson;
  static const toJsonFactory = _$PlaidErrorToJson;
  Map<String, dynamic> toJson() => _$PlaidErrorToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PlaidError &&
            (identical(other.errorType, errorType) ||
                const DeepCollectionEquality()
                    .equals(other.errorType, errorType)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.errorMessage, errorMessage) ||
                const DeepCollectionEquality()
                    .equals(other.errorMessage, errorMessage)) &&
            (identical(other.displayMessage, displayMessage) ||
                const DeepCollectionEquality()
                    .equals(other.displayMessage, displayMessage)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)) &&
            (identical(other.causes, causes) ||
                const DeepCollectionEquality().equals(other.causes, causes)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.documentationUrl, documentationUrl) ||
                const DeepCollectionEquality()
                    .equals(other.documentationUrl, documentationUrl)) &&
            (identical(other.suggestedAction, suggestedAction) ||
                const DeepCollectionEquality()
                    .equals(other.suggestedAction, suggestedAction)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(errorType) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(errorMessage) ^
      const DeepCollectionEquality().hash(displayMessage) ^
      const DeepCollectionEquality().hash(requestId) ^
      const DeepCollectionEquality().hash(causes) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(documentationUrl) ^
      const DeepCollectionEquality().hash(suggestedAction) ^
      runtimeType.hashCode;
}

extension $PlaidErrorExtension on PlaidError {
  PlaidError copyWith(
      {enums.PlaidErrorType? errorType,
      String? errorCode,
      String? errorMessage,
      String? displayMessage,
      String? requestId,
      List<Object>? causes,
      double? status,
      String? documentationUrl,
      String? suggestedAction}) {
    return PlaidError(
        errorType: errorType ?? this.errorType,
        errorCode: errorCode ?? this.errorCode,
        errorMessage: errorMessage ?? this.errorMessage,
        displayMessage: displayMessage ?? this.displayMessage,
        requestId: requestId ?? this.requestId,
        causes: causes ?? this.causes,
        status: status ?? this.status,
        documentationUrl: documentationUrl ?? this.documentationUrl,
        suggestedAction: suggestedAction ?? this.suggestedAction);
  }

  PlaidError copyWithWrapped(
      {Wrapped<enums.PlaidErrorType>? errorType,
      Wrapped<String>? errorCode,
      Wrapped<String>? errorMessage,
      Wrapped<String?>? displayMessage,
      Wrapped<String?>? requestId,
      Wrapped<List<Object>?>? causes,
      Wrapped<double?>? status,
      Wrapped<String?>? documentationUrl,
      Wrapped<String?>? suggestedAction}) {
    return PlaidError(
        errorType: (errorType != null ? errorType.value : this.errorType),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        errorMessage:
            (errorMessage != null ? errorMessage.value : this.errorMessage),
        displayMessage: (displayMessage != null
            ? displayMessage.value
            : this.displayMessage),
        requestId: (requestId != null ? requestId.value : this.requestId),
        causes: (causes != null ? causes.value : this.causes),
        status: (status != null ? status.value : this.status),
        documentationUrl: (documentationUrl != null
            ? documentationUrl.value
            : this.documentationUrl),
        suggestedAction: (suggestedAction != null
            ? suggestedAction.value
            : this.suggestedAction));
  }
}

@JsonSerializable(explicitToJson: true)
class AccountBase {
  AccountBase({
    required this.accountId,
    required this.balances,
    required this.mask,
    required this.name,
    required this.officialName,
    required this.type,
    required this.subtype,
    this.verificationStatus,
  });

  factory AccountBase.fromJson(Map<String, dynamic> json) =>
      _$AccountBaseFromJson(json);

  @JsonKey(name: 'account_id')
  final String accountId;
  @JsonKey(name: 'balances')
  final AccountBalance balances;
  @JsonKey(name: 'mask')
  final String? mask;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'official_name')
  final String? officialName;
  @JsonKey(
    name: 'type',
    toJson: accountTypeToJson,
    fromJson: accountTypeFromJson,
  )
  final enums.AccountType type;
  @JsonKey(
    name: 'subtype',
    toJson: accountSubtypeToJson,
    fromJson: accountSubtypeFromJson,
  )
  final enums.AccountSubtype? subtype;
  @JsonKey(
    name: 'verification_status',
    toJson: accountBaseVerificationStatusToJson,
    fromJson: accountBaseVerificationStatusFromJson,
  )
  final enums.AccountBaseVerificationStatus? verificationStatus;
  static const fromJsonFactory = _$AccountBaseFromJson;
  static const toJsonFactory = _$AccountBaseToJson;
  Map<String, dynamic> toJson() => _$AccountBaseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AccountBase &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.balances, balances) ||
                const DeepCollectionEquality()
                    .equals(other.balances, balances)) &&
            (identical(other.mask, mask) ||
                const DeepCollectionEquality().equals(other.mask, mask)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.officialName, officialName) ||
                const DeepCollectionEquality()
                    .equals(other.officialName, officialName)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.subtype, subtype) ||
                const DeepCollectionEquality()
                    .equals(other.subtype, subtype)) &&
            (identical(other.verificationStatus, verificationStatus) ||
                const DeepCollectionEquality()
                    .equals(other.verificationStatus, verificationStatus)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(balances) ^
      const DeepCollectionEquality().hash(mask) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(officialName) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(subtype) ^
      const DeepCollectionEquality().hash(verificationStatus) ^
      runtimeType.hashCode;
}

extension $AccountBaseExtension on AccountBase {
  AccountBase copyWith(
      {String? accountId,
      AccountBalance? balances,
      String? mask,
      String? name,
      String? officialName,
      enums.AccountType? type,
      enums.AccountSubtype? subtype,
      enums.AccountBaseVerificationStatus? verificationStatus}) {
    return AccountBase(
        accountId: accountId ?? this.accountId,
        balances: balances ?? this.balances,
        mask: mask ?? this.mask,
        name: name ?? this.name,
        officialName: officialName ?? this.officialName,
        type: type ?? this.type,
        subtype: subtype ?? this.subtype,
        verificationStatus: verificationStatus ?? this.verificationStatus);
  }

  AccountBase copyWithWrapped(
      {Wrapped<String>? accountId,
      Wrapped<AccountBalance>? balances,
      Wrapped<String?>? mask,
      Wrapped<String>? name,
      Wrapped<String?>? officialName,
      Wrapped<enums.AccountType>? type,
      Wrapped<enums.AccountSubtype?>? subtype,
      Wrapped<enums.AccountBaseVerificationStatus?>? verificationStatus}) {
    return AccountBase(
        accountId: (accountId != null ? accountId.value : this.accountId),
        balances: (balances != null ? balances.value : this.balances),
        mask: (mask != null ? mask.value : this.mask),
        name: (name != null ? name.value : this.name),
        officialName:
            (officialName != null ? officialName.value : this.officialName),
        type: (type != null ? type.value : this.type),
        subtype: (subtype != null ? subtype.value : this.subtype),
        verificationStatus: (verificationStatus != null
            ? verificationStatus.value
            : this.verificationStatus));
  }
}

@JsonSerializable(explicitToJson: true)
class AccountBalance {
  AccountBalance({
    required this.available,
    required this.current,
    required this.limit,
    required this.isoCurrencyCode,
    required this.unofficialCurrencyCode,
    this.lastUpdatedDatetime,
  });

  factory AccountBalance.fromJson(Map<String, dynamic> json) =>
      _$AccountBalanceFromJson(json);

  @JsonKey(name: 'available')
  final double? available;
  @JsonKey(name: 'current')
  final double? current;
  @JsonKey(name: 'limit')
  final double? limit;
  @JsonKey(name: 'iso_currency_code')
  final String? isoCurrencyCode;
  @JsonKey(name: 'unofficial_currency_code')
  final String? unofficialCurrencyCode;
  @JsonKey(name: 'last_updated_datetime')
  final DateTime? lastUpdatedDatetime;
  static const fromJsonFactory = _$AccountBalanceFromJson;
  static const toJsonFactory = _$AccountBalanceToJson;
  Map<String, dynamic> toJson() => _$AccountBalanceToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AccountBalance &&
            (identical(other.available, available) ||
                const DeepCollectionEquality()
                    .equals(other.available, available)) &&
            (identical(other.current, current) ||
                const DeepCollectionEquality()
                    .equals(other.current, current)) &&
            (identical(other.limit, limit) ||
                const DeepCollectionEquality().equals(other.limit, limit)) &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)) &&
            (identical(other.unofficialCurrencyCode, unofficialCurrencyCode) ||
                const DeepCollectionEquality().equals(
                    other.unofficialCurrencyCode, unofficialCurrencyCode)) &&
            (identical(other.lastUpdatedDatetime, lastUpdatedDatetime) ||
                const DeepCollectionEquality()
                    .equals(other.lastUpdatedDatetime, lastUpdatedDatetime)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(available) ^
      const DeepCollectionEquality().hash(current) ^
      const DeepCollectionEquality().hash(limit) ^
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      const DeepCollectionEquality().hash(unofficialCurrencyCode) ^
      const DeepCollectionEquality().hash(lastUpdatedDatetime) ^
      runtimeType.hashCode;
}

extension $AccountBalanceExtension on AccountBalance {
  AccountBalance copyWith(
      {double? available,
      double? current,
      double? limit,
      String? isoCurrencyCode,
      String? unofficialCurrencyCode,
      DateTime? lastUpdatedDatetime}) {
    return AccountBalance(
        available: available ?? this.available,
        current: current ?? this.current,
        limit: limit ?? this.limit,
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode,
        unofficialCurrencyCode:
            unofficialCurrencyCode ?? this.unofficialCurrencyCode,
        lastUpdatedDatetime: lastUpdatedDatetime ?? this.lastUpdatedDatetime);
  }

  AccountBalance copyWithWrapped(
      {Wrapped<double?>? available,
      Wrapped<double?>? current,
      Wrapped<double?>? limit,
      Wrapped<String?>? isoCurrencyCode,
      Wrapped<String?>? unofficialCurrencyCode,
      Wrapped<DateTime?>? lastUpdatedDatetime}) {
    return AccountBalance(
        available: (available != null ? available.value : this.available),
        current: (current != null ? current.value : this.current),
        limit: (limit != null ? limit.value : this.limit),
        isoCurrencyCode: (isoCurrencyCode != null
            ? isoCurrencyCode.value
            : this.isoCurrencyCode),
        unofficialCurrencyCode: (unofficialCurrencyCode != null
            ? unofficialCurrencyCode.value
            : this.unofficialCurrencyCode),
        lastUpdatedDatetime: (lastUpdatedDatetime != null
            ? lastUpdatedDatetime.value
            : this.lastUpdatedDatetime));
  }
}

@JsonSerializable(explicitToJson: true)
class NumbersACH {
  NumbersACH({
    required this.accountId,
    required this.account,
    required this.routing,
    required this.wireRouting,
    this.canTransferIn,
    this.canTransferOut,
  });

  factory NumbersACH.fromJson(Map<String, dynamic> json) =>
      _$NumbersACHFromJson(json);

  @JsonKey(name: 'account_id')
  final String accountId;
  @JsonKey(name: 'account')
  final String account;
  @JsonKey(name: 'routing')
  final String routing;
  @JsonKey(name: 'wire_routing')
  final String? wireRouting;
  @JsonKey(name: 'can_transfer_in')
  final bool? canTransferIn;
  @JsonKey(name: 'can_transfer_out')
  final bool? canTransferOut;
  static const fromJsonFactory = _$NumbersACHFromJson;
  static const toJsonFactory = _$NumbersACHToJson;
  Map<String, dynamic> toJson() => _$NumbersACHToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is NumbersACH &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.account, account) ||
                const DeepCollectionEquality()
                    .equals(other.account, account)) &&
            (identical(other.routing, routing) ||
                const DeepCollectionEquality()
                    .equals(other.routing, routing)) &&
            (identical(other.wireRouting, wireRouting) ||
                const DeepCollectionEquality()
                    .equals(other.wireRouting, wireRouting)) &&
            (identical(other.canTransferIn, canTransferIn) ||
                const DeepCollectionEquality()
                    .equals(other.canTransferIn, canTransferIn)) &&
            (identical(other.canTransferOut, canTransferOut) ||
                const DeepCollectionEquality()
                    .equals(other.canTransferOut, canTransferOut)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(account) ^
      const DeepCollectionEquality().hash(routing) ^
      const DeepCollectionEquality().hash(wireRouting) ^
      const DeepCollectionEquality().hash(canTransferIn) ^
      const DeepCollectionEquality().hash(canTransferOut) ^
      runtimeType.hashCode;
}

extension $NumbersACHExtension on NumbersACH {
  NumbersACH copyWith(
      {String? accountId,
      String? account,
      String? routing,
      String? wireRouting,
      bool? canTransferIn,
      bool? canTransferOut}) {
    return NumbersACH(
        accountId: accountId ?? this.accountId,
        account: account ?? this.account,
        routing: routing ?? this.routing,
        wireRouting: wireRouting ?? this.wireRouting,
        canTransferIn: canTransferIn ?? this.canTransferIn,
        canTransferOut: canTransferOut ?? this.canTransferOut);
  }

  NumbersACH copyWithWrapped(
      {Wrapped<String>? accountId,
      Wrapped<String>? account,
      Wrapped<String>? routing,
      Wrapped<String?>? wireRouting,
      Wrapped<bool?>? canTransferIn,
      Wrapped<bool?>? canTransferOut}) {
    return NumbersACH(
        accountId: (accountId != null ? accountId.value : this.accountId),
        account: (account != null ? account.value : this.account),
        routing: (routing != null ? routing.value : this.routing),
        wireRouting:
            (wireRouting != null ? wireRouting.value : this.wireRouting),
        canTransferIn:
            (canTransferIn != null ? canTransferIn.value : this.canTransferIn),
        canTransferOut: (canTransferOut != null
            ? canTransferOut.value
            : this.canTransferOut));
  }
}

@JsonSerializable(explicitToJson: true)
class NumbersACHNullable {
  NumbersACHNullable({
    required this.accountId,
    required this.account,
    required this.routing,
    required this.wireRouting,
    this.canTransferIn,
    this.canTransferOut,
  });

  factory NumbersACHNullable.fromJson(Map<String, dynamic> json) =>
      _$NumbersACHNullableFromJson(json);

  @JsonKey(name: 'account_id')
  final String accountId;
  @JsonKey(name: 'account')
  final String account;
  @JsonKey(name: 'routing')
  final String routing;
  @JsonKey(name: 'wire_routing')
  final String? wireRouting;
  @JsonKey(name: 'can_transfer_in')
  final bool? canTransferIn;
  @JsonKey(name: 'can_transfer_out')
  final bool? canTransferOut;
  static const fromJsonFactory = _$NumbersACHNullableFromJson;
  static const toJsonFactory = _$NumbersACHNullableToJson;
  Map<String, dynamic> toJson() => _$NumbersACHNullableToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is NumbersACHNullable &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.account, account) ||
                const DeepCollectionEquality()
                    .equals(other.account, account)) &&
            (identical(other.routing, routing) ||
                const DeepCollectionEquality()
                    .equals(other.routing, routing)) &&
            (identical(other.wireRouting, wireRouting) ||
                const DeepCollectionEquality()
                    .equals(other.wireRouting, wireRouting)) &&
            (identical(other.canTransferIn, canTransferIn) ||
                const DeepCollectionEquality()
                    .equals(other.canTransferIn, canTransferIn)) &&
            (identical(other.canTransferOut, canTransferOut) ||
                const DeepCollectionEquality()
                    .equals(other.canTransferOut, canTransferOut)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(account) ^
      const DeepCollectionEquality().hash(routing) ^
      const DeepCollectionEquality().hash(wireRouting) ^
      const DeepCollectionEquality().hash(canTransferIn) ^
      const DeepCollectionEquality().hash(canTransferOut) ^
      runtimeType.hashCode;
}

extension $NumbersACHNullableExtension on NumbersACHNullable {
  NumbersACHNullable copyWith(
      {String? accountId,
      String? account,
      String? routing,
      String? wireRouting,
      bool? canTransferIn,
      bool? canTransferOut}) {
    return NumbersACHNullable(
        accountId: accountId ?? this.accountId,
        account: account ?? this.account,
        routing: routing ?? this.routing,
        wireRouting: wireRouting ?? this.wireRouting,
        canTransferIn: canTransferIn ?? this.canTransferIn,
        canTransferOut: canTransferOut ?? this.canTransferOut);
  }

  NumbersACHNullable copyWithWrapped(
      {Wrapped<String>? accountId,
      Wrapped<String>? account,
      Wrapped<String>? routing,
      Wrapped<String?>? wireRouting,
      Wrapped<bool?>? canTransferIn,
      Wrapped<bool?>? canTransferOut}) {
    return NumbersACHNullable(
        accountId: (accountId != null ? accountId.value : this.accountId),
        account: (account != null ? account.value : this.account),
        routing: (routing != null ? routing.value : this.routing),
        wireRouting:
            (wireRouting != null ? wireRouting.value : this.wireRouting),
        canTransferIn:
            (canTransferIn != null ? canTransferIn.value : this.canTransferIn),
        canTransferOut: (canTransferOut != null
            ? canTransferOut.value
            : this.canTransferOut));
  }
}

@JsonSerializable(explicitToJson: true)
class NumbersEFT {
  NumbersEFT({
    required this.accountId,
    required this.account,
    required this.institution,
    required this.branch,
  });

  factory NumbersEFT.fromJson(Map<String, dynamic> json) =>
      _$NumbersEFTFromJson(json);

  @JsonKey(name: 'account_id')
  final String accountId;
  @JsonKey(name: 'account')
  final String account;
  @JsonKey(name: 'institution')
  final String institution;
  @JsonKey(name: 'branch')
  final String branch;
  static const fromJsonFactory = _$NumbersEFTFromJson;
  static const toJsonFactory = _$NumbersEFTToJson;
  Map<String, dynamic> toJson() => _$NumbersEFTToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is NumbersEFT &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.account, account) ||
                const DeepCollectionEquality()
                    .equals(other.account, account)) &&
            (identical(other.institution, institution) ||
                const DeepCollectionEquality()
                    .equals(other.institution, institution)) &&
            (identical(other.branch, branch) ||
                const DeepCollectionEquality().equals(other.branch, branch)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(account) ^
      const DeepCollectionEquality().hash(institution) ^
      const DeepCollectionEquality().hash(branch) ^
      runtimeType.hashCode;
}

extension $NumbersEFTExtension on NumbersEFT {
  NumbersEFT copyWith(
      {String? accountId,
      String? account,
      String? institution,
      String? branch}) {
    return NumbersEFT(
        accountId: accountId ?? this.accountId,
        account: account ?? this.account,
        institution: institution ?? this.institution,
        branch: branch ?? this.branch);
  }

  NumbersEFT copyWithWrapped(
      {Wrapped<String>? accountId,
      Wrapped<String>? account,
      Wrapped<String>? institution,
      Wrapped<String>? branch}) {
    return NumbersEFT(
        accountId: (accountId != null ? accountId.value : this.accountId),
        account: (account != null ? account.value : this.account),
        institution:
            (institution != null ? institution.value : this.institution),
        branch: (branch != null ? branch.value : this.branch));
  }
}

@JsonSerializable(explicitToJson: true)
class NumbersEFTNullable {
  NumbersEFTNullable({
    required this.accountId,
    required this.account,
    required this.institution,
    required this.branch,
  });

  factory NumbersEFTNullable.fromJson(Map<String, dynamic> json) =>
      _$NumbersEFTNullableFromJson(json);

  @JsonKey(name: 'account_id')
  final String accountId;
  @JsonKey(name: 'account')
  final String account;
  @JsonKey(name: 'institution')
  final String institution;
  @JsonKey(name: 'branch')
  final String branch;
  static const fromJsonFactory = _$NumbersEFTNullableFromJson;
  static const toJsonFactory = _$NumbersEFTNullableToJson;
  Map<String, dynamic> toJson() => _$NumbersEFTNullableToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is NumbersEFTNullable &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.account, account) ||
                const DeepCollectionEquality()
                    .equals(other.account, account)) &&
            (identical(other.institution, institution) ||
                const DeepCollectionEquality()
                    .equals(other.institution, institution)) &&
            (identical(other.branch, branch) ||
                const DeepCollectionEquality().equals(other.branch, branch)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(account) ^
      const DeepCollectionEquality().hash(institution) ^
      const DeepCollectionEquality().hash(branch) ^
      runtimeType.hashCode;
}

extension $NumbersEFTNullableExtension on NumbersEFTNullable {
  NumbersEFTNullable copyWith(
      {String? accountId,
      String? account,
      String? institution,
      String? branch}) {
    return NumbersEFTNullable(
        accountId: accountId ?? this.accountId,
        account: account ?? this.account,
        institution: institution ?? this.institution,
        branch: branch ?? this.branch);
  }

  NumbersEFTNullable copyWithWrapped(
      {Wrapped<String>? accountId,
      Wrapped<String>? account,
      Wrapped<String>? institution,
      Wrapped<String>? branch}) {
    return NumbersEFTNullable(
        accountId: (accountId != null ? accountId.value : this.accountId),
        account: (account != null ? account.value : this.account),
        institution:
            (institution != null ? institution.value : this.institution),
        branch: (branch != null ? branch.value : this.branch));
  }
}

@JsonSerializable(explicitToJson: true)
class NumbersInternational {
  NumbersInternational({
    required this.accountId,
    required this.iban,
    required this.bic,
  });

  factory NumbersInternational.fromJson(Map<String, dynamic> json) =>
      _$NumbersInternationalFromJson(json);

  @JsonKey(name: 'account_id')
  final String accountId;
  @JsonKey(name: 'iban')
  final String iban;
  @JsonKey(name: 'bic')
  final String bic;
  static const fromJsonFactory = _$NumbersInternationalFromJson;
  static const toJsonFactory = _$NumbersInternationalToJson;
  Map<String, dynamic> toJson() => _$NumbersInternationalToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is NumbersInternational &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.iban, iban) ||
                const DeepCollectionEquality().equals(other.iban, iban)) &&
            (identical(other.bic, bic) ||
                const DeepCollectionEquality().equals(other.bic, bic)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(iban) ^
      const DeepCollectionEquality().hash(bic) ^
      runtimeType.hashCode;
}

extension $NumbersInternationalExtension on NumbersInternational {
  NumbersInternational copyWith(
      {String? accountId, String? iban, String? bic}) {
    return NumbersInternational(
        accountId: accountId ?? this.accountId,
        iban: iban ?? this.iban,
        bic: bic ?? this.bic);
  }

  NumbersInternational copyWithWrapped(
      {Wrapped<String>? accountId,
      Wrapped<String>? iban,
      Wrapped<String>? bic}) {
    return NumbersInternational(
        accountId: (accountId != null ? accountId.value : this.accountId),
        iban: (iban != null ? iban.value : this.iban),
        bic: (bic != null ? bic.value : this.bic));
  }
}

@JsonSerializable(explicitToJson: true)
class NumbersInternationalNullable {
  NumbersInternationalNullable({
    required this.accountId,
    required this.iban,
    required this.bic,
  });

  factory NumbersInternationalNullable.fromJson(Map<String, dynamic> json) =>
      _$NumbersInternationalNullableFromJson(json);

  @JsonKey(name: 'account_id')
  final String accountId;
  @JsonKey(name: 'iban')
  final String iban;
  @JsonKey(name: 'bic')
  final String bic;
  static const fromJsonFactory = _$NumbersInternationalNullableFromJson;
  static const toJsonFactory = _$NumbersInternationalNullableToJson;
  Map<String, dynamic> toJson() => _$NumbersInternationalNullableToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is NumbersInternationalNullable &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.iban, iban) ||
                const DeepCollectionEquality().equals(other.iban, iban)) &&
            (identical(other.bic, bic) ||
                const DeepCollectionEquality().equals(other.bic, bic)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(iban) ^
      const DeepCollectionEquality().hash(bic) ^
      runtimeType.hashCode;
}

extension $NumbersInternationalNullableExtension
    on NumbersInternationalNullable {
  NumbersInternationalNullable copyWith(
      {String? accountId, String? iban, String? bic}) {
    return NumbersInternationalNullable(
        accountId: accountId ?? this.accountId,
        iban: iban ?? this.iban,
        bic: bic ?? this.bic);
  }

  NumbersInternationalNullable copyWithWrapped(
      {Wrapped<String>? accountId,
      Wrapped<String>? iban,
      Wrapped<String>? bic}) {
    return NumbersInternationalNullable(
        accountId: (accountId != null ? accountId.value : this.accountId),
        iban: (iban != null ? iban.value : this.iban),
        bic: (bic != null ? bic.value : this.bic));
  }
}

@JsonSerializable(explicitToJson: true)
class NumbersBACS {
  NumbersBACS({
    required this.accountId,
    required this.account,
    required this.sortCode,
  });

  factory NumbersBACS.fromJson(Map<String, dynamic> json) =>
      _$NumbersBACSFromJson(json);

  @JsonKey(name: 'account_id')
  final String accountId;
  @JsonKey(name: 'account')
  final String account;
  @JsonKey(name: 'sort_code')
  final String sortCode;
  static const fromJsonFactory = _$NumbersBACSFromJson;
  static const toJsonFactory = _$NumbersBACSToJson;
  Map<String, dynamic> toJson() => _$NumbersBACSToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is NumbersBACS &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.account, account) ||
                const DeepCollectionEquality()
                    .equals(other.account, account)) &&
            (identical(other.sortCode, sortCode) ||
                const DeepCollectionEquality()
                    .equals(other.sortCode, sortCode)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(account) ^
      const DeepCollectionEquality().hash(sortCode) ^
      runtimeType.hashCode;
}

extension $NumbersBACSExtension on NumbersBACS {
  NumbersBACS copyWith({String? accountId, String? account, String? sortCode}) {
    return NumbersBACS(
        accountId: accountId ?? this.accountId,
        account: account ?? this.account,
        sortCode: sortCode ?? this.sortCode);
  }

  NumbersBACS copyWithWrapped(
      {Wrapped<String>? accountId,
      Wrapped<String>? account,
      Wrapped<String>? sortCode}) {
    return NumbersBACS(
        accountId: (accountId != null ? accountId.value : this.accountId),
        account: (account != null ? account.value : this.account),
        sortCode: (sortCode != null ? sortCode.value : this.sortCode));
  }
}

@JsonSerializable(explicitToJson: true)
class NumbersBACSNullable {
  NumbersBACSNullable({
    required this.accountId,
    required this.account,
    required this.sortCode,
  });

  factory NumbersBACSNullable.fromJson(Map<String, dynamic> json) =>
      _$NumbersBACSNullableFromJson(json);

  @JsonKey(name: 'account_id')
  final String accountId;
  @JsonKey(name: 'account')
  final String account;
  @JsonKey(name: 'sort_code')
  final String sortCode;
  static const fromJsonFactory = _$NumbersBACSNullableFromJson;
  static const toJsonFactory = _$NumbersBACSNullableToJson;
  Map<String, dynamic> toJson() => _$NumbersBACSNullableToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is NumbersBACSNullable &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.account, account) ||
                const DeepCollectionEquality()
                    .equals(other.account, account)) &&
            (identical(other.sortCode, sortCode) ||
                const DeepCollectionEquality()
                    .equals(other.sortCode, sortCode)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(account) ^
      const DeepCollectionEquality().hash(sortCode) ^
      runtimeType.hashCode;
}

extension $NumbersBACSNullableExtension on NumbersBACSNullable {
  NumbersBACSNullable copyWith(
      {String? accountId, String? account, String? sortCode}) {
    return NumbersBACSNullable(
        accountId: accountId ?? this.accountId,
        account: account ?? this.account,
        sortCode: sortCode ?? this.sortCode);
  }

  NumbersBACSNullable copyWithWrapped(
      {Wrapped<String>? accountId,
      Wrapped<String>? account,
      Wrapped<String>? sortCode}) {
    return NumbersBACSNullable(
        accountId: (accountId != null ? accountId.value : this.accountId),
        account: (account != null ? account.value : this.account),
        sortCode: (sortCode != null ? sortCode.value : this.sortCode));
  }
}

@JsonSerializable(explicitToJson: true)
class NumbersInternationalIBAN {
  NumbersInternationalIBAN({
    required this.iban,
    required this.bic,
  });

  factory NumbersInternationalIBAN.fromJson(Map<String, dynamic> json) =>
      _$NumbersInternationalIBANFromJson(json);

  @JsonKey(name: 'iban')
  final String iban;
  @JsonKey(name: 'bic')
  final String bic;
  static const fromJsonFactory = _$NumbersInternationalIBANFromJson;
  static const toJsonFactory = _$NumbersInternationalIBANToJson;
  Map<String, dynamic> toJson() => _$NumbersInternationalIBANToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is NumbersInternationalIBAN &&
            (identical(other.iban, iban) ||
                const DeepCollectionEquality().equals(other.iban, iban)) &&
            (identical(other.bic, bic) ||
                const DeepCollectionEquality().equals(other.bic, bic)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(iban) ^
      const DeepCollectionEquality().hash(bic) ^
      runtimeType.hashCode;
}

extension $NumbersInternationalIBANExtension on NumbersInternationalIBAN {
  NumbersInternationalIBAN copyWith({String? iban, String? bic}) {
    return NumbersInternationalIBAN(
        iban: iban ?? this.iban, bic: bic ?? this.bic);
  }

  NumbersInternationalIBAN copyWithWrapped(
      {Wrapped<String>? iban, Wrapped<String>? bic}) {
    return NumbersInternationalIBAN(
        iban: (iban != null ? iban.value : this.iban),
        bic: (bic != null ? bic.value : this.bic));
  }
}

@JsonSerializable(explicitToJson: true)
class RecipientBACS {
  RecipientBACS({
    this.account,
    this.sortCode,
  });

  factory RecipientBACS.fromJson(Map<String, dynamic> json) =>
      _$RecipientBACSFromJson(json);

  @JsonKey(name: 'account')
  final String? account;
  @JsonKey(name: 'sort_code')
  final String? sortCode;
  static const fromJsonFactory = _$RecipientBACSFromJson;
  static const toJsonFactory = _$RecipientBACSToJson;
  Map<String, dynamic> toJson() => _$RecipientBACSToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is RecipientBACS &&
            (identical(other.account, account) ||
                const DeepCollectionEquality()
                    .equals(other.account, account)) &&
            (identical(other.sortCode, sortCode) ||
                const DeepCollectionEquality()
                    .equals(other.sortCode, sortCode)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(account) ^
      const DeepCollectionEquality().hash(sortCode) ^
      runtimeType.hashCode;
}

extension $RecipientBACSExtension on RecipientBACS {
  RecipientBACS copyWith({String? account, String? sortCode}) {
    return RecipientBACS(
        account: account ?? this.account, sortCode: sortCode ?? this.sortCode);
  }

  RecipientBACS copyWithWrapped(
      {Wrapped<String?>? account, Wrapped<String?>? sortCode}) {
    return RecipientBACS(
        account: (account != null ? account.value : this.account),
        sortCode: (sortCode != null ? sortCode.value : this.sortCode));
  }
}

@JsonSerializable(explicitToJson: true)
class RecipientBACSNullable {
  RecipientBACSNullable({
    this.account,
    this.sortCode,
  });

  factory RecipientBACSNullable.fromJson(Map<String, dynamic> json) =>
      _$RecipientBACSNullableFromJson(json);

  @JsonKey(name: 'account')
  final String? account;
  @JsonKey(name: 'sort_code')
  final String? sortCode;
  static const fromJsonFactory = _$RecipientBACSNullableFromJson;
  static const toJsonFactory = _$RecipientBACSNullableToJson;
  Map<String, dynamic> toJson() => _$RecipientBACSNullableToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is RecipientBACSNullable &&
            (identical(other.account, account) ||
                const DeepCollectionEquality()
                    .equals(other.account, account)) &&
            (identical(other.sortCode, sortCode) ||
                const DeepCollectionEquality()
                    .equals(other.sortCode, sortCode)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(account) ^
      const DeepCollectionEquality().hash(sortCode) ^
      runtimeType.hashCode;
}

extension $RecipientBACSNullableExtension on RecipientBACSNullable {
  RecipientBACSNullable copyWith({String? account, String? sortCode}) {
    return RecipientBACSNullable(
        account: account ?? this.account, sortCode: sortCode ?? this.sortCode);
  }

  RecipientBACSNullable copyWithWrapped(
      {Wrapped<String?>? account, Wrapped<String?>? sortCode}) {
    return RecipientBACSNullable(
        account: (account != null ? account.value : this.account),
        sortCode: (sortCode != null ? sortCode.value : this.sortCode));
  }
}

@JsonSerializable(explicitToJson: true)
class SenderBACSNullable {
  SenderBACSNullable({
    this.account,
    this.sortCode,
  });

  factory SenderBACSNullable.fromJson(Map<String, dynamic> json) =>
      _$SenderBACSNullableFromJson(json);

  @JsonKey(name: 'account')
  final String? account;
  @JsonKey(name: 'sort_code')
  final String? sortCode;
  static const fromJsonFactory = _$SenderBACSNullableFromJson;
  static const toJsonFactory = _$SenderBACSNullableToJson;
  Map<String, dynamic> toJson() => _$SenderBACSNullableToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SenderBACSNullable &&
            (identical(other.account, account) ||
                const DeepCollectionEquality()
                    .equals(other.account, account)) &&
            (identical(other.sortCode, sortCode) ||
                const DeepCollectionEquality()
                    .equals(other.sortCode, sortCode)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(account) ^
      const DeepCollectionEquality().hash(sortCode) ^
      runtimeType.hashCode;
}

extension $SenderBACSNullableExtension on SenderBACSNullable {
  SenderBACSNullable copyWith({String? account, String? sortCode}) {
    return SenderBACSNullable(
        account: account ?? this.account, sortCode: sortCode ?? this.sortCode);
  }

  SenderBACSNullable copyWithWrapped(
      {Wrapped<String?>? account, Wrapped<String?>? sortCode}) {
    return SenderBACSNullable(
        account: (account != null ? account.value : this.account),
        sortCode: (sortCode != null ? sortCode.value : this.sortCode));
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentInitiationOptionalRestrictionBacs {
  PaymentInitiationOptionalRestrictionBacs({
    this.account,
    this.sortCode,
  });

  factory PaymentInitiationOptionalRestrictionBacs.fromJson(
          Map<String, dynamic> json) =>
      _$PaymentInitiationOptionalRestrictionBacsFromJson(json);

  @JsonKey(name: 'account')
  final String? account;
  @JsonKey(name: 'sort_code')
  final String? sortCode;
  static const fromJsonFactory =
      _$PaymentInitiationOptionalRestrictionBacsFromJson;
  static const toJsonFactory = _$PaymentInitiationOptionalRestrictionBacsToJson;
  Map<String, dynamic> toJson() =>
      _$PaymentInitiationOptionalRestrictionBacsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentInitiationOptionalRestrictionBacs &&
            (identical(other.account, account) ||
                const DeepCollectionEquality()
                    .equals(other.account, account)) &&
            (identical(other.sortCode, sortCode) ||
                const DeepCollectionEquality()
                    .equals(other.sortCode, sortCode)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(account) ^
      const DeepCollectionEquality().hash(sortCode) ^
      runtimeType.hashCode;
}

extension $PaymentInitiationOptionalRestrictionBacsExtension
    on PaymentInitiationOptionalRestrictionBacs {
  PaymentInitiationOptionalRestrictionBacs copyWith(
      {String? account, String? sortCode}) {
    return PaymentInitiationOptionalRestrictionBacs(
        account: account ?? this.account, sortCode: sortCode ?? this.sortCode);
  }

  PaymentInitiationOptionalRestrictionBacs copyWithWrapped(
      {Wrapped<String?>? account, Wrapped<String?>? sortCode}) {
    return PaymentInitiationOptionalRestrictionBacs(
        account: (account != null ? account.value : this.account),
        sortCode: (sortCode != null ? sortCode.value : this.sortCode));
  }
}

@JsonSerializable(explicitToJson: true)
class RemovedTransaction {
  RemovedTransaction({
    this.transactionId,
  });

  factory RemovedTransaction.fromJson(Map<String, dynamic> json) =>
      _$RemovedTransactionFromJson(json);

  @JsonKey(name: 'transaction_id')
  final String? transactionId;
  static const fromJsonFactory = _$RemovedTransactionFromJson;
  static const toJsonFactory = _$RemovedTransactionToJson;
  Map<String, dynamic> toJson() => _$RemovedTransactionToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is RemovedTransaction &&
            (identical(other.transactionId, transactionId) ||
                const DeepCollectionEquality()
                    .equals(other.transactionId, transactionId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(transactionId) ^ runtimeType.hashCode;
}

extension $RemovedTransactionExtension on RemovedTransaction {
  RemovedTransaction copyWith({String? transactionId}) {
    return RemovedTransaction(
        transactionId: transactionId ?? this.transactionId);
  }

  RemovedTransaction copyWithWrapped({Wrapped<String?>? transactionId}) {
    return RemovedTransaction(
        transactionId:
            (transactionId != null ? transactionId.value : this.transactionId));
  }
}

@JsonSerializable(explicitToJson: true)
class TransactionsRuleDetails {
  TransactionsRuleDetails({
    required this.field,
    required this.type,
    required this.query,
  });

  factory TransactionsRuleDetails.fromJson(Map<String, dynamic> json) =>
      _$TransactionsRuleDetailsFromJson(json);

  @JsonKey(
    name: 'field',
    toJson: transactionsRuleFieldToJson,
    fromJson: transactionsRuleFieldFromJson,
  )
  final enums.TransactionsRuleField field;
  @JsonKey(
    name: 'type',
    toJson: transactionsRuleTypeToJson,
    fromJson: transactionsRuleTypeFromJson,
  )
  final enums.TransactionsRuleType type;
  @JsonKey(name: 'query')
  final String query;
  static const fromJsonFactory = _$TransactionsRuleDetailsFromJson;
  static const toJsonFactory = _$TransactionsRuleDetailsToJson;
  Map<String, dynamic> toJson() => _$TransactionsRuleDetailsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransactionsRuleDetails &&
            (identical(other.field, field) ||
                const DeepCollectionEquality().equals(other.field, field)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.query, query) ||
                const DeepCollectionEquality().equals(other.query, query)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(field) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(query) ^
      runtimeType.hashCode;
}

extension $TransactionsRuleDetailsExtension on TransactionsRuleDetails {
  TransactionsRuleDetails copyWith(
      {enums.TransactionsRuleField? field,
      enums.TransactionsRuleType? type,
      String? query}) {
    return TransactionsRuleDetails(
        field: field ?? this.field,
        type: type ?? this.type,
        query: query ?? this.query);
  }

  TransactionsRuleDetails copyWithWrapped(
      {Wrapped<enums.TransactionsRuleField>? field,
      Wrapped<enums.TransactionsRuleType>? type,
      Wrapped<String>? query}) {
    return TransactionsRuleDetails(
        field: (field != null ? field.value : this.field),
        type: (type != null ? type.value : this.type),
        query: (query != null ? query.value : this.query));
  }
}

@JsonSerializable(explicitToJson: true)
class TransactionsCategoryRule {
  TransactionsCategoryRule({
    this.id,
    this.itemId,
    this.createdAt,
    this.personalFinanceCategory,
    this.ruleDetails,
  });

  factory TransactionsCategoryRule.fromJson(Map<String, dynamic> json) =>
      _$TransactionsCategoryRuleFromJson(json);

  @JsonKey(name: 'id')
  final String? id;
  @JsonKey(name: 'item_id')
  final String? itemId;
  @JsonKey(name: 'created_at')
  final DateTime? createdAt;
  @JsonKey(name: 'personal_finance_category')
  final String? personalFinanceCategory;
  @JsonKey(name: 'rule_details')
  final TransactionsRuleDetails? ruleDetails;
  static const fromJsonFactory = _$TransactionsCategoryRuleFromJson;
  static const toJsonFactory = _$TransactionsCategoryRuleToJson;
  Map<String, dynamic> toJson() => _$TransactionsCategoryRuleToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransactionsCategoryRule &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)) &&
            (identical(other.createdAt, createdAt) ||
                const DeepCollectionEquality()
                    .equals(other.createdAt, createdAt)) &&
            (identical(
                    other.personalFinanceCategory, personalFinanceCategory) ||
                const DeepCollectionEquality().equals(
                    other.personalFinanceCategory, personalFinanceCategory)) &&
            (identical(other.ruleDetails, ruleDetails) ||
                const DeepCollectionEquality()
                    .equals(other.ruleDetails, ruleDetails)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(itemId) ^
      const DeepCollectionEquality().hash(createdAt) ^
      const DeepCollectionEquality().hash(personalFinanceCategory) ^
      const DeepCollectionEquality().hash(ruleDetails) ^
      runtimeType.hashCode;
}

extension $TransactionsCategoryRuleExtension on TransactionsCategoryRule {
  TransactionsCategoryRule copyWith(
      {String? id,
      String? itemId,
      DateTime? createdAt,
      String? personalFinanceCategory,
      TransactionsRuleDetails? ruleDetails}) {
    return TransactionsCategoryRule(
        id: id ?? this.id,
        itemId: itemId ?? this.itemId,
        createdAt: createdAt ?? this.createdAt,
        personalFinanceCategory:
            personalFinanceCategory ?? this.personalFinanceCategory,
        ruleDetails: ruleDetails ?? this.ruleDetails);
  }

  TransactionsCategoryRule copyWithWrapped(
      {Wrapped<String?>? id,
      Wrapped<String?>? itemId,
      Wrapped<DateTime?>? createdAt,
      Wrapped<String?>? personalFinanceCategory,
      Wrapped<TransactionsRuleDetails?>? ruleDetails}) {
    return TransactionsCategoryRule(
        id: (id != null ? id.value : this.id),
        itemId: (itemId != null ? itemId.value : this.itemId),
        createdAt: (createdAt != null ? createdAt.value : this.createdAt),
        personalFinanceCategory: (personalFinanceCategory != null
            ? personalFinanceCategory.value
            : this.personalFinanceCategory),
        ruleDetails:
            (ruleDetails != null ? ruleDetails.value : this.ruleDetails));
  }
}

@JsonSerializable(explicitToJson: true)
class TransactionBase {
  TransactionBase({
    this.transactionType,
    this.pendingTransactionId,
    this.categoryId,
    this.category,
    this.location,
    this.paymentMeta,
    this.accountOwner,
    this.name,
    this.originalDescription,
    required this.accountId,
    required this.amount,
    required this.isoCurrencyCode,
    required this.unofficialCurrencyCode,
    required this.date,
    required this.pending,
    required this.transactionId,
    this.merchantName,
    this.checkNumber,
  });

  factory TransactionBase.fromJson(Map<String, dynamic> json) =>
      _$TransactionBaseFromJson(json);

  @JsonKey(
    name: 'transaction_type',
    toJson: transactionBaseTransactionTypeToJson,
    fromJson: transactionBaseTransactionTypeFromJson,
  )
  final enums.TransactionBaseTransactionType? transactionType;
  @JsonKey(name: 'pending_transaction_id')
  final String? pendingTransactionId;
  @JsonKey(name: 'category_id')
  final String? categoryId;
  @JsonKey(name: 'category', defaultValue: <String>[])
  final List<String>? category;
  @JsonKey(name: 'location')
  final Location? location;
  @JsonKey(name: 'payment_meta')
  final PaymentMeta? paymentMeta;
  @JsonKey(name: 'account_owner')
  final String? accountOwner;
  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'original_description')
  final String? originalDescription;
  @JsonKey(name: 'account_id')
  final String accountId;
  @JsonKey(name: 'amount')
  final double amount;
  @JsonKey(name: 'iso_currency_code')
  final String? isoCurrencyCode;
  @JsonKey(name: 'unofficial_currency_code')
  final String? unofficialCurrencyCode;
  @JsonKey(name: 'date', toJson: _dateToJson)
  final DateTime date;
  @JsonKey(name: 'pending')
  final bool pending;
  @JsonKey(name: 'transaction_id')
  final String transactionId;
  @JsonKey(name: 'merchant_name')
  final String? merchantName;
  @JsonKey(name: 'check_number')
  final String? checkNumber;
  static const fromJsonFactory = _$TransactionBaseFromJson;
  static const toJsonFactory = _$TransactionBaseToJson;
  Map<String, dynamic> toJson() => _$TransactionBaseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransactionBase &&
            (identical(other.transactionType, transactionType) ||
                const DeepCollectionEquality()
                    .equals(other.transactionType, transactionType)) &&
            (identical(other.pendingTransactionId, pendingTransactionId) ||
                const DeepCollectionEquality().equals(
                    other.pendingTransactionId, pendingTransactionId)) &&
            (identical(other.categoryId, categoryId) ||
                const DeepCollectionEquality()
                    .equals(other.categoryId, categoryId)) &&
            (identical(other.category, category) ||
                const DeepCollectionEquality()
                    .equals(other.category, category)) &&
            (identical(other.location, location) ||
                const DeepCollectionEquality()
                    .equals(other.location, location)) &&
            (identical(other.paymentMeta, paymentMeta) ||
                const DeepCollectionEquality()
                    .equals(other.paymentMeta, paymentMeta)) &&
            (identical(other.accountOwner, accountOwner) ||
                const DeepCollectionEquality()
                    .equals(other.accountOwner, accountOwner)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.originalDescription, originalDescription) ||
                const DeepCollectionEquality()
                    .equals(other.originalDescription, originalDescription)) &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)) &&
            (identical(other.unofficialCurrencyCode, unofficialCurrencyCode) ||
                const DeepCollectionEquality().equals(
                    other.unofficialCurrencyCode, unofficialCurrencyCode)) &&
            (identical(other.date, date) ||
                const DeepCollectionEquality().equals(other.date, date)) &&
            (identical(other.pending, pending) ||
                const DeepCollectionEquality()
                    .equals(other.pending, pending)) &&
            (identical(other.transactionId, transactionId) ||
                const DeepCollectionEquality()
                    .equals(other.transactionId, transactionId)) &&
            (identical(other.merchantName, merchantName) ||
                const DeepCollectionEquality()
                    .equals(other.merchantName, merchantName)) &&
            (identical(other.checkNumber, checkNumber) ||
                const DeepCollectionEquality()
                    .equals(other.checkNumber, checkNumber)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(transactionType) ^
      const DeepCollectionEquality().hash(pendingTransactionId) ^
      const DeepCollectionEquality().hash(categoryId) ^
      const DeepCollectionEquality().hash(category) ^
      const DeepCollectionEquality().hash(location) ^
      const DeepCollectionEquality().hash(paymentMeta) ^
      const DeepCollectionEquality().hash(accountOwner) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(originalDescription) ^
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      const DeepCollectionEquality().hash(unofficialCurrencyCode) ^
      const DeepCollectionEquality().hash(date) ^
      const DeepCollectionEquality().hash(pending) ^
      const DeepCollectionEquality().hash(transactionId) ^
      const DeepCollectionEquality().hash(merchantName) ^
      const DeepCollectionEquality().hash(checkNumber) ^
      runtimeType.hashCode;
}

extension $TransactionBaseExtension on TransactionBase {
  TransactionBase copyWith(
      {enums.TransactionBaseTransactionType? transactionType,
      String? pendingTransactionId,
      String? categoryId,
      List<String>? category,
      Location? location,
      PaymentMeta? paymentMeta,
      String? accountOwner,
      String? name,
      String? originalDescription,
      String? accountId,
      double? amount,
      String? isoCurrencyCode,
      String? unofficialCurrencyCode,
      DateTime? date,
      bool? pending,
      String? transactionId,
      String? merchantName,
      String? checkNumber}) {
    return TransactionBase(
        transactionType: transactionType ?? this.transactionType,
        pendingTransactionId: pendingTransactionId ?? this.pendingTransactionId,
        categoryId: categoryId ?? this.categoryId,
        category: category ?? this.category,
        location: location ?? this.location,
        paymentMeta: paymentMeta ?? this.paymentMeta,
        accountOwner: accountOwner ?? this.accountOwner,
        name: name ?? this.name,
        originalDescription: originalDescription ?? this.originalDescription,
        accountId: accountId ?? this.accountId,
        amount: amount ?? this.amount,
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode,
        unofficialCurrencyCode:
            unofficialCurrencyCode ?? this.unofficialCurrencyCode,
        date: date ?? this.date,
        pending: pending ?? this.pending,
        transactionId: transactionId ?? this.transactionId,
        merchantName: merchantName ?? this.merchantName,
        checkNumber: checkNumber ?? this.checkNumber);
  }

  TransactionBase copyWithWrapped(
      {Wrapped<enums.TransactionBaseTransactionType?>? transactionType,
      Wrapped<String?>? pendingTransactionId,
      Wrapped<String?>? categoryId,
      Wrapped<List<String>?>? category,
      Wrapped<Location?>? location,
      Wrapped<PaymentMeta?>? paymentMeta,
      Wrapped<String?>? accountOwner,
      Wrapped<String?>? name,
      Wrapped<String?>? originalDescription,
      Wrapped<String>? accountId,
      Wrapped<double>? amount,
      Wrapped<String?>? isoCurrencyCode,
      Wrapped<String?>? unofficialCurrencyCode,
      Wrapped<DateTime>? date,
      Wrapped<bool>? pending,
      Wrapped<String>? transactionId,
      Wrapped<String?>? merchantName,
      Wrapped<String?>? checkNumber}) {
    return TransactionBase(
        transactionType: (transactionType != null
            ? transactionType.value
            : this.transactionType),
        pendingTransactionId: (pendingTransactionId != null
            ? pendingTransactionId.value
            : this.pendingTransactionId),
        categoryId: (categoryId != null ? categoryId.value : this.categoryId),
        category: (category != null ? category.value : this.category),
        location: (location != null ? location.value : this.location),
        paymentMeta:
            (paymentMeta != null ? paymentMeta.value : this.paymentMeta),
        accountOwner:
            (accountOwner != null ? accountOwner.value : this.accountOwner),
        name: (name != null ? name.value : this.name),
        originalDescription: (originalDescription != null
            ? originalDescription.value
            : this.originalDescription),
        accountId: (accountId != null ? accountId.value : this.accountId),
        amount: (amount != null ? amount.value : this.amount),
        isoCurrencyCode: (isoCurrencyCode != null
            ? isoCurrencyCode.value
            : this.isoCurrencyCode),
        unofficialCurrencyCode: (unofficialCurrencyCode != null
            ? unofficialCurrencyCode.value
            : this.unofficialCurrencyCode),
        date: (date != null ? date.value : this.date),
        pending: (pending != null ? pending.value : this.pending),
        transactionId:
            (transactionId != null ? transactionId.value : this.transactionId),
        merchantName:
            (merchantName != null ? merchantName.value : this.merchantName),
        checkNumber:
            (checkNumber != null ? checkNumber.value : this.checkNumber));
  }
}

@JsonSerializable(explicitToJson: true)
class Transaction {
  Transaction({
    required this.paymentChannel,
    required this.authorizedDate,
    required this.authorizedDatetime,
    required this.datetime,
    required this.transactionCode,
    this.personalFinanceCategory,
    this.transactionType,
    required this.pendingTransactionId,
    required this.categoryId,
    required this.category,
    required this.location,
    required this.paymentMeta,
    required this.accountOwner,
    required this.name,
    this.originalDescription,
    required this.accountId,
    required this.amount,
    required this.isoCurrencyCode,
    required this.unofficialCurrencyCode,
    required this.date,
    required this.pending,
    required this.transactionId,
    this.merchantName,
    this.checkNumber,
  });

  factory Transaction.fromJson(Map<String, dynamic> json) =>
      _$TransactionFromJson(json);

  @JsonKey(
    name: 'payment_channel',
    toJson: transactionPaymentChannelToJson,
    fromJson: transactionPaymentChannelFromJson,
  )
  final enums.TransactionPaymentChannel paymentChannel;
  @JsonKey(name: 'authorized_date', toJson: _dateToJson)
  final DateTime? authorizedDate;
  @JsonKey(name: 'authorized_datetime')
  final DateTime? authorizedDatetime;
  @JsonKey(name: 'datetime')
  final DateTime? datetime;
  @JsonKey(
    name: 'transaction_code',
    toJson: transactionCodeToJson,
    fromJson: transactionCodeFromJson,
  )
  final enums.TransactionCode? transactionCode;
  @JsonKey(name: 'personal_finance_category')
  final PersonalFinanceCategory? personalFinanceCategory;
  @JsonKey(
    name: 'transaction_type',
    toJson: transactionTransactionTypeToJson,
    fromJson: transactionTransactionTypeFromJson,
  )
  final enums.TransactionTransactionType? transactionType;
  @JsonKey(name: 'pending_transaction_id')
  final String? pendingTransactionId;
  @JsonKey(name: 'category_id')
  final String? categoryId;
  @JsonKey(name: 'category', defaultValue: <String>[])
  final List<String>? category;
  @JsonKey(name: 'location')
  final Location location;
  @JsonKey(name: 'payment_meta')
  final PaymentMeta paymentMeta;
  @JsonKey(name: 'account_owner')
  final String? accountOwner;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'original_description')
  final String? originalDescription;
  @JsonKey(name: 'account_id')
  final String accountId;
  @JsonKey(name: 'amount')
  final double amount;
  @JsonKey(name: 'iso_currency_code')
  final String? isoCurrencyCode;
  @JsonKey(name: 'unofficial_currency_code')
  final String? unofficialCurrencyCode;
  @JsonKey(name: 'date', toJson: _dateToJson)
  final DateTime date;
  @JsonKey(name: 'pending')
  final bool pending;
  @JsonKey(name: 'transaction_id')
  final String transactionId;
  @JsonKey(name: 'merchant_name')
  final String? merchantName;
  @JsonKey(name: 'check_number')
  final String? checkNumber;
  static const fromJsonFactory = _$TransactionFromJson;
  static const toJsonFactory = _$TransactionToJson;
  Map<String, dynamic> toJson() => _$TransactionToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Transaction &&
            (identical(other.paymentChannel, paymentChannel) ||
                const DeepCollectionEquality()
                    .equals(other.paymentChannel, paymentChannel)) &&
            (identical(other.authorizedDate, authorizedDate) ||
                const DeepCollectionEquality()
                    .equals(other.authorizedDate, authorizedDate)) &&
            (identical(other.authorizedDatetime, authorizedDatetime) ||
                const DeepCollectionEquality()
                    .equals(other.authorizedDatetime, authorizedDatetime)) &&
            (identical(other.datetime, datetime) ||
                const DeepCollectionEquality()
                    .equals(other.datetime, datetime)) &&
            (identical(other.transactionCode, transactionCode) ||
                const DeepCollectionEquality()
                    .equals(other.transactionCode, transactionCode)) &&
            (identical(other.personalFinanceCategory, personalFinanceCategory) ||
                const DeepCollectionEquality().equals(
                    other.personalFinanceCategory, personalFinanceCategory)) &&
            (identical(other.transactionType, transactionType) ||
                const DeepCollectionEquality()
                    .equals(other.transactionType, transactionType)) &&
            (identical(other.pendingTransactionId, pendingTransactionId) ||
                const DeepCollectionEquality().equals(
                    other.pendingTransactionId, pendingTransactionId)) &&
            (identical(other.categoryId, categoryId) ||
                const DeepCollectionEquality()
                    .equals(other.categoryId, categoryId)) &&
            (identical(other.category, category) ||
                const DeepCollectionEquality()
                    .equals(other.category, category)) &&
            (identical(other.location, location) ||
                const DeepCollectionEquality()
                    .equals(other.location, location)) &&
            (identical(other.paymentMeta, paymentMeta) ||
                const DeepCollectionEquality()
                    .equals(other.paymentMeta, paymentMeta)) &&
            (identical(other.accountOwner, accountOwner) ||
                const DeepCollectionEquality()
                    .equals(other.accountOwner, accountOwner)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.originalDescription, originalDescription) ||
                const DeepCollectionEquality()
                    .equals(other.originalDescription, originalDescription)) &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)) &&
            (identical(other.unofficialCurrencyCode, unofficialCurrencyCode) || const DeepCollectionEquality().equals(other.unofficialCurrencyCode, unofficialCurrencyCode)) &&
            (identical(other.date, date) || const DeepCollectionEquality().equals(other.date, date)) &&
            (identical(other.pending, pending) || const DeepCollectionEquality().equals(other.pending, pending)) &&
            (identical(other.transactionId, transactionId) || const DeepCollectionEquality().equals(other.transactionId, transactionId)) &&
            (identical(other.merchantName, merchantName) || const DeepCollectionEquality().equals(other.merchantName, merchantName)) &&
            (identical(other.checkNumber, checkNumber) || const DeepCollectionEquality().equals(other.checkNumber, checkNumber)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(paymentChannel) ^
      const DeepCollectionEquality().hash(authorizedDate) ^
      const DeepCollectionEquality().hash(authorizedDatetime) ^
      const DeepCollectionEquality().hash(datetime) ^
      const DeepCollectionEquality().hash(transactionCode) ^
      const DeepCollectionEquality().hash(personalFinanceCategory) ^
      const DeepCollectionEquality().hash(transactionType) ^
      const DeepCollectionEquality().hash(pendingTransactionId) ^
      const DeepCollectionEquality().hash(categoryId) ^
      const DeepCollectionEquality().hash(category) ^
      const DeepCollectionEquality().hash(location) ^
      const DeepCollectionEquality().hash(paymentMeta) ^
      const DeepCollectionEquality().hash(accountOwner) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(originalDescription) ^
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      const DeepCollectionEquality().hash(unofficialCurrencyCode) ^
      const DeepCollectionEquality().hash(date) ^
      const DeepCollectionEquality().hash(pending) ^
      const DeepCollectionEquality().hash(transactionId) ^
      const DeepCollectionEquality().hash(merchantName) ^
      const DeepCollectionEquality().hash(checkNumber) ^
      runtimeType.hashCode;
}

extension $TransactionExtension on Transaction {
  Transaction copyWith(
      {enums.TransactionPaymentChannel? paymentChannel,
      DateTime? authorizedDate,
      DateTime? authorizedDatetime,
      DateTime? datetime,
      enums.TransactionCode? transactionCode,
      PersonalFinanceCategory? personalFinanceCategory,
      enums.TransactionTransactionType? transactionType,
      String? pendingTransactionId,
      String? categoryId,
      List<String>? category,
      Location? location,
      PaymentMeta? paymentMeta,
      String? accountOwner,
      String? name,
      String? originalDescription,
      String? accountId,
      double? amount,
      String? isoCurrencyCode,
      String? unofficialCurrencyCode,
      DateTime? date,
      bool? pending,
      String? transactionId,
      String? merchantName,
      String? checkNumber}) {
    return Transaction(
        paymentChannel: paymentChannel ?? this.paymentChannel,
        authorizedDate: authorizedDate ?? this.authorizedDate,
        authorizedDatetime: authorizedDatetime ?? this.authorizedDatetime,
        datetime: datetime ?? this.datetime,
        transactionCode: transactionCode ?? this.transactionCode,
        personalFinanceCategory:
            personalFinanceCategory ?? this.personalFinanceCategory,
        transactionType: transactionType ?? this.transactionType,
        pendingTransactionId: pendingTransactionId ?? this.pendingTransactionId,
        categoryId: categoryId ?? this.categoryId,
        category: category ?? this.category,
        location: location ?? this.location,
        paymentMeta: paymentMeta ?? this.paymentMeta,
        accountOwner: accountOwner ?? this.accountOwner,
        name: name ?? this.name,
        originalDescription: originalDescription ?? this.originalDescription,
        accountId: accountId ?? this.accountId,
        amount: amount ?? this.amount,
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode,
        unofficialCurrencyCode:
            unofficialCurrencyCode ?? this.unofficialCurrencyCode,
        date: date ?? this.date,
        pending: pending ?? this.pending,
        transactionId: transactionId ?? this.transactionId,
        merchantName: merchantName ?? this.merchantName,
        checkNumber: checkNumber ?? this.checkNumber);
  }

  Transaction copyWithWrapped(
      {Wrapped<enums.TransactionPaymentChannel>? paymentChannel,
      Wrapped<DateTime?>? authorizedDate,
      Wrapped<DateTime?>? authorizedDatetime,
      Wrapped<DateTime?>? datetime,
      Wrapped<enums.TransactionCode?>? transactionCode,
      Wrapped<PersonalFinanceCategory?>? personalFinanceCategory,
      Wrapped<enums.TransactionTransactionType?>? transactionType,
      Wrapped<String?>? pendingTransactionId,
      Wrapped<String?>? categoryId,
      Wrapped<List<String>?>? category,
      Wrapped<Location>? location,
      Wrapped<PaymentMeta>? paymentMeta,
      Wrapped<String?>? accountOwner,
      Wrapped<String>? name,
      Wrapped<String?>? originalDescription,
      Wrapped<String>? accountId,
      Wrapped<double>? amount,
      Wrapped<String?>? isoCurrencyCode,
      Wrapped<String?>? unofficialCurrencyCode,
      Wrapped<DateTime>? date,
      Wrapped<bool>? pending,
      Wrapped<String>? transactionId,
      Wrapped<String?>? merchantName,
      Wrapped<String?>? checkNumber}) {
    return Transaction(
        paymentChannel: (paymentChannel != null
            ? paymentChannel.value
            : this.paymentChannel),
        authorizedDate: (authorizedDate != null
            ? authorizedDate.value
            : this.authorizedDate),
        authorizedDatetime: (authorizedDatetime != null
            ? authorizedDatetime.value
            : this.authorizedDatetime),
        datetime: (datetime != null ? datetime.value : this.datetime),
        transactionCode: (transactionCode != null
            ? transactionCode.value
            : this.transactionCode),
        personalFinanceCategory: (personalFinanceCategory != null
            ? personalFinanceCategory.value
            : this.personalFinanceCategory),
        transactionType: (transactionType != null
            ? transactionType.value
            : this.transactionType),
        pendingTransactionId: (pendingTransactionId != null
            ? pendingTransactionId.value
            : this.pendingTransactionId),
        categoryId: (categoryId != null ? categoryId.value : this.categoryId),
        category: (category != null ? category.value : this.category),
        location: (location != null ? location.value : this.location),
        paymentMeta:
            (paymentMeta != null ? paymentMeta.value : this.paymentMeta),
        accountOwner:
            (accountOwner != null ? accountOwner.value : this.accountOwner),
        name: (name != null ? name.value : this.name),
        originalDescription: (originalDescription != null
            ? originalDescription.value
            : this.originalDescription),
        accountId: (accountId != null ? accountId.value : this.accountId),
        amount: (amount != null ? amount.value : this.amount),
        isoCurrencyCode: (isoCurrencyCode != null
            ? isoCurrencyCode.value
            : this.isoCurrencyCode),
        unofficialCurrencyCode: (unofficialCurrencyCode != null
            ? unofficialCurrencyCode.value
            : this.unofficialCurrencyCode),
        date: (date != null ? date.value : this.date),
        pending: (pending != null ? pending.value : this.pending),
        transactionId:
            (transactionId != null ? transactionId.value : this.transactionId),
        merchantName:
            (merchantName != null ? merchantName.value : this.merchantName),
        checkNumber:
            (checkNumber != null ? checkNumber.value : this.checkNumber));
  }
}

@JsonSerializable(explicitToJson: true)
class Location {
  Location({
    required this.address,
    required this.city,
    required this.region,
    required this.postalCode,
    required this.country,
    required this.lat,
    required this.lon,
    required this.storeNumber,
  });

  factory Location.fromJson(Map<String, dynamic> json) =>
      _$LocationFromJson(json);

  @JsonKey(name: 'address')
  final String? address;
  @JsonKey(name: 'city')
  final String? city;
  @JsonKey(name: 'region')
  final String? region;
  @JsonKey(name: 'postal_code')
  final String? postalCode;
  @JsonKey(name: 'country')
  final String? country;
  @JsonKey(name: 'lat')
  final double? lat;
  @JsonKey(name: 'lon')
  final double? lon;
  @JsonKey(name: 'store_number')
  final String? storeNumber;
  static const fromJsonFactory = _$LocationFromJson;
  static const toJsonFactory = _$LocationToJson;
  Map<String, dynamic> toJson() => _$LocationToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Location &&
            (identical(other.address, address) ||
                const DeepCollectionEquality()
                    .equals(other.address, address)) &&
            (identical(other.city, city) ||
                const DeepCollectionEquality().equals(other.city, city)) &&
            (identical(other.region, region) ||
                const DeepCollectionEquality().equals(other.region, region)) &&
            (identical(other.postalCode, postalCode) ||
                const DeepCollectionEquality()
                    .equals(other.postalCode, postalCode)) &&
            (identical(other.country, country) ||
                const DeepCollectionEquality()
                    .equals(other.country, country)) &&
            (identical(other.lat, lat) ||
                const DeepCollectionEquality().equals(other.lat, lat)) &&
            (identical(other.lon, lon) ||
                const DeepCollectionEquality().equals(other.lon, lon)) &&
            (identical(other.storeNumber, storeNumber) ||
                const DeepCollectionEquality()
                    .equals(other.storeNumber, storeNumber)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(city) ^
      const DeepCollectionEquality().hash(region) ^
      const DeepCollectionEquality().hash(postalCode) ^
      const DeepCollectionEquality().hash(country) ^
      const DeepCollectionEquality().hash(lat) ^
      const DeepCollectionEquality().hash(lon) ^
      const DeepCollectionEquality().hash(storeNumber) ^
      runtimeType.hashCode;
}

extension $LocationExtension on Location {
  Location copyWith(
      {String? address,
      String? city,
      String? region,
      String? postalCode,
      String? country,
      double? lat,
      double? lon,
      String? storeNumber}) {
    return Location(
        address: address ?? this.address,
        city: city ?? this.city,
        region: region ?? this.region,
        postalCode: postalCode ?? this.postalCode,
        country: country ?? this.country,
        lat: lat ?? this.lat,
        lon: lon ?? this.lon,
        storeNumber: storeNumber ?? this.storeNumber);
  }

  Location copyWithWrapped(
      {Wrapped<String?>? address,
      Wrapped<String?>? city,
      Wrapped<String?>? region,
      Wrapped<String?>? postalCode,
      Wrapped<String?>? country,
      Wrapped<double?>? lat,
      Wrapped<double?>? lon,
      Wrapped<String?>? storeNumber}) {
    return Location(
        address: (address != null ? address.value : this.address),
        city: (city != null ? city.value : this.city),
        region: (region != null ? region.value : this.region),
        postalCode: (postalCode != null ? postalCode.value : this.postalCode),
        country: (country != null ? country.value : this.country),
        lat: (lat != null ? lat.value : this.lat),
        lon: (lon != null ? lon.value : this.lon),
        storeNumber:
            (storeNumber != null ? storeNumber.value : this.storeNumber));
  }
}

@JsonSerializable(explicitToJson: true)
class TransactionStream {
  TransactionStream({
    required this.accountId,
    required this.streamId,
    required this.categoryId,
    required this.category,
    required this.description,
    required this.merchantName,
    required this.firstDate,
    required this.lastDate,
    required this.frequency,
    required this.transactionIds,
    required this.averageAmount,
    required this.lastAmount,
    required this.isActive,
    required this.status,
    this.personalFinanceCategory,
  });

  factory TransactionStream.fromJson(Map<String, dynamic> json) =>
      _$TransactionStreamFromJson(json);

  @JsonKey(name: 'account_id')
  final String accountId;
  @JsonKey(name: 'stream_id')
  final String streamId;
  @JsonKey(name: 'category_id')
  final String categoryId;
  @JsonKey(name: 'category', defaultValue: <String>[])
  final List<String> category;
  @JsonKey(name: 'description')
  final String description;
  @JsonKey(name: 'merchant_name')
  final String? merchantName;
  @JsonKey(name: 'first_date', toJson: _dateToJson)
  final DateTime firstDate;
  @JsonKey(name: 'last_date', toJson: _dateToJson)
  final DateTime lastDate;
  @JsonKey(
    name: 'frequency',
    toJson: recurringTransactionFrequencyToJson,
    fromJson: recurringTransactionFrequencyFromJson,
  )
  final enums.RecurringTransactionFrequency frequency;
  @JsonKey(name: 'transaction_ids', defaultValue: <String>[])
  final List<String> transactionIds;
  @JsonKey(name: 'average_amount')
  final TransactionStreamAmount averageAmount;
  @JsonKey(name: 'last_amount')
  final TransactionStreamAmount lastAmount;
  @JsonKey(name: 'is_active')
  final bool isActive;
  @JsonKey(
    name: 'status',
    toJson: transactionStreamStatusToJson,
    fromJson: transactionStreamStatusFromJson,
  )
  final enums.TransactionStreamStatus status;
  @JsonKey(name: 'personal_finance_category')
  final PersonalFinanceCategory? personalFinanceCategory;
  static const fromJsonFactory = _$TransactionStreamFromJson;
  static const toJsonFactory = _$TransactionStreamToJson;
  Map<String, dynamic> toJson() => _$TransactionStreamToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransactionStream &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.streamId, streamId) ||
                const DeepCollectionEquality()
                    .equals(other.streamId, streamId)) &&
            (identical(other.categoryId, categoryId) ||
                const DeepCollectionEquality()
                    .equals(other.categoryId, categoryId)) &&
            (identical(other.category, category) ||
                const DeepCollectionEquality()
                    .equals(other.category, category)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.merchantName, merchantName) ||
                const DeepCollectionEquality()
                    .equals(other.merchantName, merchantName)) &&
            (identical(other.firstDate, firstDate) ||
                const DeepCollectionEquality()
                    .equals(other.firstDate, firstDate)) &&
            (identical(other.lastDate, lastDate) ||
                const DeepCollectionEquality()
                    .equals(other.lastDate, lastDate)) &&
            (identical(other.frequency, frequency) ||
                const DeepCollectionEquality()
                    .equals(other.frequency, frequency)) &&
            (identical(other.transactionIds, transactionIds) ||
                const DeepCollectionEquality()
                    .equals(other.transactionIds, transactionIds)) &&
            (identical(other.averageAmount, averageAmount) ||
                const DeepCollectionEquality()
                    .equals(other.averageAmount, averageAmount)) &&
            (identical(other.lastAmount, lastAmount) ||
                const DeepCollectionEquality()
                    .equals(other.lastAmount, lastAmount)) &&
            (identical(other.isActive, isActive) ||
                const DeepCollectionEquality()
                    .equals(other.isActive, isActive)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(
                    other.personalFinanceCategory, personalFinanceCategory) ||
                const DeepCollectionEquality().equals(
                    other.personalFinanceCategory, personalFinanceCategory)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(streamId) ^
      const DeepCollectionEquality().hash(categoryId) ^
      const DeepCollectionEquality().hash(category) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(merchantName) ^
      const DeepCollectionEquality().hash(firstDate) ^
      const DeepCollectionEquality().hash(lastDate) ^
      const DeepCollectionEquality().hash(frequency) ^
      const DeepCollectionEquality().hash(transactionIds) ^
      const DeepCollectionEquality().hash(averageAmount) ^
      const DeepCollectionEquality().hash(lastAmount) ^
      const DeepCollectionEquality().hash(isActive) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(personalFinanceCategory) ^
      runtimeType.hashCode;
}

extension $TransactionStreamExtension on TransactionStream {
  TransactionStream copyWith(
      {String? accountId,
      String? streamId,
      String? categoryId,
      List<String>? category,
      String? description,
      String? merchantName,
      DateTime? firstDate,
      DateTime? lastDate,
      enums.RecurringTransactionFrequency? frequency,
      List<String>? transactionIds,
      TransactionStreamAmount? averageAmount,
      TransactionStreamAmount? lastAmount,
      bool? isActive,
      enums.TransactionStreamStatus? status,
      PersonalFinanceCategory? personalFinanceCategory}) {
    return TransactionStream(
        accountId: accountId ?? this.accountId,
        streamId: streamId ?? this.streamId,
        categoryId: categoryId ?? this.categoryId,
        category: category ?? this.category,
        description: description ?? this.description,
        merchantName: merchantName ?? this.merchantName,
        firstDate: firstDate ?? this.firstDate,
        lastDate: lastDate ?? this.lastDate,
        frequency: frequency ?? this.frequency,
        transactionIds: transactionIds ?? this.transactionIds,
        averageAmount: averageAmount ?? this.averageAmount,
        lastAmount: lastAmount ?? this.lastAmount,
        isActive: isActive ?? this.isActive,
        status: status ?? this.status,
        personalFinanceCategory:
            personalFinanceCategory ?? this.personalFinanceCategory);
  }

  TransactionStream copyWithWrapped(
      {Wrapped<String>? accountId,
      Wrapped<String>? streamId,
      Wrapped<String>? categoryId,
      Wrapped<List<String>>? category,
      Wrapped<String>? description,
      Wrapped<String?>? merchantName,
      Wrapped<DateTime>? firstDate,
      Wrapped<DateTime>? lastDate,
      Wrapped<enums.RecurringTransactionFrequency>? frequency,
      Wrapped<List<String>>? transactionIds,
      Wrapped<TransactionStreamAmount>? averageAmount,
      Wrapped<TransactionStreamAmount>? lastAmount,
      Wrapped<bool>? isActive,
      Wrapped<enums.TransactionStreamStatus>? status,
      Wrapped<PersonalFinanceCategory?>? personalFinanceCategory}) {
    return TransactionStream(
        accountId: (accountId != null ? accountId.value : this.accountId),
        streamId: (streamId != null ? streamId.value : this.streamId),
        categoryId: (categoryId != null ? categoryId.value : this.categoryId),
        category: (category != null ? category.value : this.category),
        description:
            (description != null ? description.value : this.description),
        merchantName:
            (merchantName != null ? merchantName.value : this.merchantName),
        firstDate: (firstDate != null ? firstDate.value : this.firstDate),
        lastDate: (lastDate != null ? lastDate.value : this.lastDate),
        frequency: (frequency != null ? frequency.value : this.frequency),
        transactionIds: (transactionIds != null
            ? transactionIds.value
            : this.transactionIds),
        averageAmount:
            (averageAmount != null ? averageAmount.value : this.averageAmount),
        lastAmount: (lastAmount != null ? lastAmount.value : this.lastAmount),
        isActive: (isActive != null ? isActive.value : this.isActive),
        status: (status != null ? status.value : this.status),
        personalFinanceCategory: (personalFinanceCategory != null
            ? personalFinanceCategory.value
            : this.personalFinanceCategory));
  }
}

@JsonSerializable(explicitToJson: true)
class TransactionStreamAmount {
  TransactionStreamAmount({
    this.amount,
    this.isoCurrencyCode,
    this.unofficialCurrencyCode,
  });

  factory TransactionStreamAmount.fromJson(Map<String, dynamic> json) =>
      _$TransactionStreamAmountFromJson(json);

  @JsonKey(name: 'amount')
  final double? amount;
  @JsonKey(name: 'iso_currency_code')
  final String? isoCurrencyCode;
  @JsonKey(name: 'unofficial_currency_code')
  final String? unofficialCurrencyCode;
  static const fromJsonFactory = _$TransactionStreamAmountFromJson;
  static const toJsonFactory = _$TransactionStreamAmountToJson;
  Map<String, dynamic> toJson() => _$TransactionStreamAmountToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransactionStreamAmount &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)) &&
            (identical(other.unofficialCurrencyCode, unofficialCurrencyCode) ||
                const DeepCollectionEquality().equals(
                    other.unofficialCurrencyCode, unofficialCurrencyCode)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      const DeepCollectionEquality().hash(unofficialCurrencyCode) ^
      runtimeType.hashCode;
}

extension $TransactionStreamAmountExtension on TransactionStreamAmount {
  TransactionStreamAmount copyWith(
      {double? amount,
      String? isoCurrencyCode,
      String? unofficialCurrencyCode}) {
    return TransactionStreamAmount(
        amount: amount ?? this.amount,
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode,
        unofficialCurrencyCode:
            unofficialCurrencyCode ?? this.unofficialCurrencyCode);
  }

  TransactionStreamAmount copyWithWrapped(
      {Wrapped<double?>? amount,
      Wrapped<String?>? isoCurrencyCode,
      Wrapped<String?>? unofficialCurrencyCode}) {
    return TransactionStreamAmount(
        amount: (amount != null ? amount.value : this.amount),
        isoCurrencyCode: (isoCurrencyCode != null
            ? isoCurrencyCode.value
            : this.isoCurrencyCode),
        unofficialCurrencyCode: (unofficialCurrencyCode != null
            ? unofficialCurrencyCode.value
            : this.unofficialCurrencyCode));
  }
}

@JsonSerializable(explicitToJson: true)
class Institution {
  Institution({
    required this.institutionId,
    required this.name,
    required this.products,
    required this.countryCodes,
    this.url,
    this.primaryColor,
    this.logo,
    required this.routingNumbers,
    required this.oauth,
    this.status,
    this.paymentInitiationMetadata,
    this.authMetadata,
  });

  factory Institution.fromJson(Map<String, dynamic> json) =>
      _$InstitutionFromJson(json);

  @JsonKey(name: 'institution_id')
  final String institutionId;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(
    name: 'products',
    toJson: productsListToJson,
    fromJson: productsListFromJson,
  )
  final List<enums.Products> products;
  @JsonKey(
    name: 'country_codes',
    toJson: countryCodeListToJson,
    fromJson: countryCodeListFromJson,
  )
  final List<enums.CountryCode> countryCodes;
  @JsonKey(name: 'url')
  final String? url;
  @JsonKey(name: 'primary_color')
  final String? primaryColor;
  @JsonKey(name: 'logo')
  final String? logo;
  @JsonKey(name: 'routing_numbers', defaultValue: <String>[])
  final List<String> routingNumbers;
  @JsonKey(name: 'oauth')
  final bool oauth;
  @JsonKey(name: 'status')
  final InstitutionStatus? status;
  @JsonKey(name: 'payment_initiation_metadata')
  final PaymentInitiationMetadata? paymentInitiationMetadata;
  @JsonKey(name: 'auth_metadata')
  final AuthMetadata? authMetadata;
  static const fromJsonFactory = _$InstitutionFromJson;
  static const toJsonFactory = _$InstitutionToJson;
  Map<String, dynamic> toJson() => _$InstitutionToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Institution &&
            (identical(other.institutionId, institutionId) ||
                const DeepCollectionEquality()
                    .equals(other.institutionId, institutionId)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.products, products) ||
                const DeepCollectionEquality()
                    .equals(other.products, products)) &&
            (identical(other.countryCodes, countryCodes) ||
                const DeepCollectionEquality()
                    .equals(other.countryCodes, countryCodes)) &&
            (identical(other.url, url) ||
                const DeepCollectionEquality().equals(other.url, url)) &&
            (identical(other.primaryColor, primaryColor) ||
                const DeepCollectionEquality()
                    .equals(other.primaryColor, primaryColor)) &&
            (identical(other.logo, logo) ||
                const DeepCollectionEquality().equals(other.logo, logo)) &&
            (identical(other.routingNumbers, routingNumbers) ||
                const DeepCollectionEquality()
                    .equals(other.routingNumbers, routingNumbers)) &&
            (identical(other.oauth, oauth) ||
                const DeepCollectionEquality().equals(other.oauth, oauth)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.paymentInitiationMetadata,
                    paymentInitiationMetadata) ||
                const DeepCollectionEquality().equals(
                    other.paymentInitiationMetadata,
                    paymentInitiationMetadata)) &&
            (identical(other.authMetadata, authMetadata) ||
                const DeepCollectionEquality()
                    .equals(other.authMetadata, authMetadata)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(institutionId) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(products) ^
      const DeepCollectionEquality().hash(countryCodes) ^
      const DeepCollectionEquality().hash(url) ^
      const DeepCollectionEquality().hash(primaryColor) ^
      const DeepCollectionEquality().hash(logo) ^
      const DeepCollectionEquality().hash(routingNumbers) ^
      const DeepCollectionEquality().hash(oauth) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(paymentInitiationMetadata) ^
      const DeepCollectionEquality().hash(authMetadata) ^
      runtimeType.hashCode;
}

extension $InstitutionExtension on Institution {
  Institution copyWith(
      {String? institutionId,
      String? name,
      List<enums.Products>? products,
      List<enums.CountryCode>? countryCodes,
      String? url,
      String? primaryColor,
      String? logo,
      List<String>? routingNumbers,
      bool? oauth,
      InstitutionStatus? status,
      PaymentInitiationMetadata? paymentInitiationMetadata,
      AuthMetadata? authMetadata}) {
    return Institution(
        institutionId: institutionId ?? this.institutionId,
        name: name ?? this.name,
        products: products ?? this.products,
        countryCodes: countryCodes ?? this.countryCodes,
        url: url ?? this.url,
        primaryColor: primaryColor ?? this.primaryColor,
        logo: logo ?? this.logo,
        routingNumbers: routingNumbers ?? this.routingNumbers,
        oauth: oauth ?? this.oauth,
        status: status ?? this.status,
        paymentInitiationMetadata:
            paymentInitiationMetadata ?? this.paymentInitiationMetadata,
        authMetadata: authMetadata ?? this.authMetadata);
  }

  Institution copyWithWrapped(
      {Wrapped<String>? institutionId,
      Wrapped<String>? name,
      Wrapped<List<enums.Products>>? products,
      Wrapped<List<enums.CountryCode>>? countryCodes,
      Wrapped<String?>? url,
      Wrapped<String?>? primaryColor,
      Wrapped<String?>? logo,
      Wrapped<List<String>>? routingNumbers,
      Wrapped<bool>? oauth,
      Wrapped<InstitutionStatus?>? status,
      Wrapped<PaymentInitiationMetadata?>? paymentInitiationMetadata,
      Wrapped<AuthMetadata?>? authMetadata}) {
    return Institution(
        institutionId:
            (institutionId != null ? institutionId.value : this.institutionId),
        name: (name != null ? name.value : this.name),
        products: (products != null ? products.value : this.products),
        countryCodes:
            (countryCodes != null ? countryCodes.value : this.countryCodes),
        url: (url != null ? url.value : this.url),
        primaryColor:
            (primaryColor != null ? primaryColor.value : this.primaryColor),
        logo: (logo != null ? logo.value : this.logo),
        routingNumbers: (routingNumbers != null
            ? routingNumbers.value
            : this.routingNumbers),
        oauth: (oauth != null ? oauth.value : this.oauth),
        status: (status != null ? status.value : this.status),
        paymentInitiationMetadata: (paymentInitiationMetadata != null
            ? paymentInitiationMetadata.value
            : this.paymentInitiationMetadata),
        authMetadata:
            (authMetadata != null ? authMetadata.value : this.authMetadata));
  }
}

@JsonSerializable(explicitToJson: true)
class InstitutionStatus {
  InstitutionStatus({
    this.itemLogins,
    this.transactionsUpdates,
    this.auth,
    this.identity,
    this.investmentsUpdates,
    this.liabilitiesUpdates,
    this.liabilities,
    this.investments,
    this.healthIncidents,
  });

  factory InstitutionStatus.fromJson(Map<String, dynamic> json) =>
      _$InstitutionStatusFromJson(json);

  @JsonKey(name: 'item_logins')
  final ProductStatus? itemLogins;
  @JsonKey(name: 'transactions_updates')
  final ProductStatus? transactionsUpdates;
  @JsonKey(name: 'auth')
  final ProductStatus? auth;
  @JsonKey(name: 'identity')
  final ProductStatus? identity;
  @JsonKey(name: 'investments_updates')
  final ProductStatus? investmentsUpdates;
  @JsonKey(name: 'liabilities_updates')
  final ProductStatus? liabilitiesUpdates;
  @JsonKey(name: 'liabilities')
  final ProductStatus? liabilities;
  @JsonKey(name: 'investments')
  final ProductStatus? investments;
  @JsonKey(name: 'health_incidents', defaultValue: <HealthIncident>[])
  final List<HealthIncident>? healthIncidents;
  static const fromJsonFactory = _$InstitutionStatusFromJson;
  static const toJsonFactory = _$InstitutionStatusToJson;
  Map<String, dynamic> toJson() => _$InstitutionStatusToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InstitutionStatus &&
            (identical(other.itemLogins, itemLogins) ||
                const DeepCollectionEquality()
                    .equals(other.itemLogins, itemLogins)) &&
            (identical(other.transactionsUpdates, transactionsUpdates) ||
                const DeepCollectionEquality()
                    .equals(other.transactionsUpdates, transactionsUpdates)) &&
            (identical(other.auth, auth) ||
                const DeepCollectionEquality().equals(other.auth, auth)) &&
            (identical(other.identity, identity) ||
                const DeepCollectionEquality()
                    .equals(other.identity, identity)) &&
            (identical(other.investmentsUpdates, investmentsUpdates) ||
                const DeepCollectionEquality()
                    .equals(other.investmentsUpdates, investmentsUpdates)) &&
            (identical(other.liabilitiesUpdates, liabilitiesUpdates) ||
                const DeepCollectionEquality()
                    .equals(other.liabilitiesUpdates, liabilitiesUpdates)) &&
            (identical(other.liabilities, liabilities) ||
                const DeepCollectionEquality()
                    .equals(other.liabilities, liabilities)) &&
            (identical(other.investments, investments) ||
                const DeepCollectionEquality()
                    .equals(other.investments, investments)) &&
            (identical(other.healthIncidents, healthIncidents) ||
                const DeepCollectionEquality()
                    .equals(other.healthIncidents, healthIncidents)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(itemLogins) ^
      const DeepCollectionEquality().hash(transactionsUpdates) ^
      const DeepCollectionEquality().hash(auth) ^
      const DeepCollectionEquality().hash(identity) ^
      const DeepCollectionEquality().hash(investmentsUpdates) ^
      const DeepCollectionEquality().hash(liabilitiesUpdates) ^
      const DeepCollectionEquality().hash(liabilities) ^
      const DeepCollectionEquality().hash(investments) ^
      const DeepCollectionEquality().hash(healthIncidents) ^
      runtimeType.hashCode;
}

extension $InstitutionStatusExtension on InstitutionStatus {
  InstitutionStatus copyWith(
      {ProductStatus? itemLogins,
      ProductStatus? transactionsUpdates,
      ProductStatus? auth,
      ProductStatus? identity,
      ProductStatus? investmentsUpdates,
      ProductStatus? liabilitiesUpdates,
      ProductStatus? liabilities,
      ProductStatus? investments,
      List<HealthIncident>? healthIncidents}) {
    return InstitutionStatus(
        itemLogins: itemLogins ?? this.itemLogins,
        transactionsUpdates: transactionsUpdates ?? this.transactionsUpdates,
        auth: auth ?? this.auth,
        identity: identity ?? this.identity,
        investmentsUpdates: investmentsUpdates ?? this.investmentsUpdates,
        liabilitiesUpdates: liabilitiesUpdates ?? this.liabilitiesUpdates,
        liabilities: liabilities ?? this.liabilities,
        investments: investments ?? this.investments,
        healthIncidents: healthIncidents ?? this.healthIncidents);
  }

  InstitutionStatus copyWithWrapped(
      {Wrapped<ProductStatus?>? itemLogins,
      Wrapped<ProductStatus?>? transactionsUpdates,
      Wrapped<ProductStatus?>? auth,
      Wrapped<ProductStatus?>? identity,
      Wrapped<ProductStatus?>? investmentsUpdates,
      Wrapped<ProductStatus?>? liabilitiesUpdates,
      Wrapped<ProductStatus?>? liabilities,
      Wrapped<ProductStatus?>? investments,
      Wrapped<List<HealthIncident>?>? healthIncidents}) {
    return InstitutionStatus(
        itemLogins: (itemLogins != null ? itemLogins.value : this.itemLogins),
        transactionsUpdates: (transactionsUpdates != null
            ? transactionsUpdates.value
            : this.transactionsUpdates),
        auth: (auth != null ? auth.value : this.auth),
        identity: (identity != null ? identity.value : this.identity),
        investmentsUpdates: (investmentsUpdates != null
            ? investmentsUpdates.value
            : this.investmentsUpdates),
        liabilitiesUpdates: (liabilitiesUpdates != null
            ? liabilitiesUpdates.value
            : this.liabilitiesUpdates),
        liabilities:
            (liabilities != null ? liabilities.value : this.liabilities),
        investments:
            (investments != null ? investments.value : this.investments),
        healthIncidents: (healthIncidents != null
            ? healthIncidents.value
            : this.healthIncidents));
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentMeta {
  PaymentMeta({
    required this.referenceNumber,
    required this.ppdId,
    required this.payee,
    required this.byOrderOf,
    required this.payer,
    required this.paymentMethod,
    required this.paymentProcessor,
    required this.reason,
  });

  factory PaymentMeta.fromJson(Map<String, dynamic> json) =>
      _$PaymentMetaFromJson(json);

  @JsonKey(name: 'reference_number')
  final String? referenceNumber;
  @JsonKey(name: 'ppd_id')
  final String? ppdId;
  @JsonKey(name: 'payee')
  final String? payee;
  @JsonKey(name: 'by_order_of')
  final String? byOrderOf;
  @JsonKey(name: 'payer')
  final String? payer;
  @JsonKey(name: 'payment_method')
  final String? paymentMethod;
  @JsonKey(name: 'payment_processor')
  final String? paymentProcessor;
  @JsonKey(name: 'reason')
  final String? reason;
  static const fromJsonFactory = _$PaymentMetaFromJson;
  static const toJsonFactory = _$PaymentMetaToJson;
  Map<String, dynamic> toJson() => _$PaymentMetaToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentMeta &&
            (identical(other.referenceNumber, referenceNumber) ||
                const DeepCollectionEquality()
                    .equals(other.referenceNumber, referenceNumber)) &&
            (identical(other.ppdId, ppdId) ||
                const DeepCollectionEquality().equals(other.ppdId, ppdId)) &&
            (identical(other.payee, payee) ||
                const DeepCollectionEquality().equals(other.payee, payee)) &&
            (identical(other.byOrderOf, byOrderOf) ||
                const DeepCollectionEquality()
                    .equals(other.byOrderOf, byOrderOf)) &&
            (identical(other.payer, payer) ||
                const DeepCollectionEquality().equals(other.payer, payer)) &&
            (identical(other.paymentMethod, paymentMethod) ||
                const DeepCollectionEquality()
                    .equals(other.paymentMethod, paymentMethod)) &&
            (identical(other.paymentProcessor, paymentProcessor) ||
                const DeepCollectionEquality()
                    .equals(other.paymentProcessor, paymentProcessor)) &&
            (identical(other.reason, reason) ||
                const DeepCollectionEquality().equals(other.reason, reason)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(referenceNumber) ^
      const DeepCollectionEquality().hash(ppdId) ^
      const DeepCollectionEquality().hash(payee) ^
      const DeepCollectionEquality().hash(byOrderOf) ^
      const DeepCollectionEquality().hash(payer) ^
      const DeepCollectionEquality().hash(paymentMethod) ^
      const DeepCollectionEquality().hash(paymentProcessor) ^
      const DeepCollectionEquality().hash(reason) ^
      runtimeType.hashCode;
}

extension $PaymentMetaExtension on PaymentMeta {
  PaymentMeta copyWith(
      {String? referenceNumber,
      String? ppdId,
      String? payee,
      String? byOrderOf,
      String? payer,
      String? paymentMethod,
      String? paymentProcessor,
      String? reason}) {
    return PaymentMeta(
        referenceNumber: referenceNumber ?? this.referenceNumber,
        ppdId: ppdId ?? this.ppdId,
        payee: payee ?? this.payee,
        byOrderOf: byOrderOf ?? this.byOrderOf,
        payer: payer ?? this.payer,
        paymentMethod: paymentMethod ?? this.paymentMethod,
        paymentProcessor: paymentProcessor ?? this.paymentProcessor,
        reason: reason ?? this.reason);
  }

  PaymentMeta copyWithWrapped(
      {Wrapped<String?>? referenceNumber,
      Wrapped<String?>? ppdId,
      Wrapped<String?>? payee,
      Wrapped<String?>? byOrderOf,
      Wrapped<String?>? payer,
      Wrapped<String?>? paymentMethod,
      Wrapped<String?>? paymentProcessor,
      Wrapped<String?>? reason}) {
    return PaymentMeta(
        referenceNumber: (referenceNumber != null
            ? referenceNumber.value
            : this.referenceNumber),
        ppdId: (ppdId != null ? ppdId.value : this.ppdId),
        payee: (payee != null ? payee.value : this.payee),
        byOrderOf: (byOrderOf != null ? byOrderOf.value : this.byOrderOf),
        payer: (payer != null ? payer.value : this.payer),
        paymentMethod:
            (paymentMethod != null ? paymentMethod.value : this.paymentMethod),
        paymentProcessor: (paymentProcessor != null
            ? paymentProcessor.value
            : this.paymentProcessor),
        reason: (reason != null ? reason.value : this.reason));
  }
}

@JsonSerializable(explicitToJson: true)
class Category {
  Category({
    required this.categoryId,
    required this.group,
    required this.hierarchy,
  });

  factory Category.fromJson(Map<String, dynamic> json) =>
      _$CategoryFromJson(json);

  @JsonKey(name: 'category_id')
  final String categoryId;
  @JsonKey(name: 'group')
  final String group;
  @JsonKey(name: 'hierarchy', defaultValue: <String>[])
  final List<String> hierarchy;
  static const fromJsonFactory = _$CategoryFromJson;
  static const toJsonFactory = _$CategoryToJson;
  Map<String, dynamic> toJson() => _$CategoryToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Category &&
            (identical(other.categoryId, categoryId) ||
                const DeepCollectionEquality()
                    .equals(other.categoryId, categoryId)) &&
            (identical(other.group, group) ||
                const DeepCollectionEquality().equals(other.group, group)) &&
            (identical(other.hierarchy, hierarchy) ||
                const DeepCollectionEquality()
                    .equals(other.hierarchy, hierarchy)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(categoryId) ^
      const DeepCollectionEquality().hash(group) ^
      const DeepCollectionEquality().hash(hierarchy) ^
      runtimeType.hashCode;
}

extension $CategoryExtension on Category {
  Category copyWith(
      {String? categoryId, String? group, List<String>? hierarchy}) {
    return Category(
        categoryId: categoryId ?? this.categoryId,
        group: group ?? this.group,
        hierarchy: hierarchy ?? this.hierarchy);
  }

  Category copyWithWrapped(
      {Wrapped<String>? categoryId,
      Wrapped<String>? group,
      Wrapped<List<String>>? hierarchy}) {
    return Category(
        categoryId: (categoryId != null ? categoryId.value : this.categoryId),
        group: (group != null ? group.value : this.group),
        hierarchy: (hierarchy != null ? hierarchy.value : this.hierarchy));
  }
}

@JsonSerializable(explicitToJson: true)
class Counterparty {
  Counterparty({
    required this.name,
    required this.type,
  });

  factory Counterparty.fromJson(Map<String, dynamic> json) =>
      _$CounterpartyFromJson(json);

  @JsonKey(name: 'name')
  final String name;
  @JsonKey(
    name: 'type',
    toJson: counterpartyTypeToJson,
    fromJson: counterpartyTypeFromJson,
  )
  final enums.CounterpartyType type;
  static const fromJsonFactory = _$CounterpartyFromJson;
  static const toJsonFactory = _$CounterpartyToJson;
  Map<String, dynamic> toJson() => _$CounterpartyToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Counterparty &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(type) ^
      runtimeType.hashCode;
}

extension $CounterpartyExtension on Counterparty {
  Counterparty copyWith({String? name, enums.CounterpartyType? type}) {
    return Counterparty(name: name ?? this.name, type: type ?? this.type);
  }

  Counterparty copyWithWrapped(
      {Wrapped<String>? name, Wrapped<enums.CounterpartyType>? type}) {
    return Counterparty(
        name: (name != null ? name.value : this.name),
        type: (type != null ? type.value : this.type));
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalFinanceCategory {
  PersonalFinanceCategory({
    required this.primary,
    required this.detailed,
  });

  factory PersonalFinanceCategory.fromJson(Map<String, dynamic> json) =>
      _$PersonalFinanceCategoryFromJson(json);

  @JsonKey(name: 'primary')
  final String primary;
  @JsonKey(name: 'detailed')
  final String detailed;
  static const fromJsonFactory = _$PersonalFinanceCategoryFromJson;
  static const toJsonFactory = _$PersonalFinanceCategoryToJson;
  Map<String, dynamic> toJson() => _$PersonalFinanceCategoryToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PersonalFinanceCategory &&
            (identical(other.primary, primary) ||
                const DeepCollectionEquality()
                    .equals(other.primary, primary)) &&
            (identical(other.detailed, detailed) ||
                const DeepCollectionEquality()
                    .equals(other.detailed, detailed)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(primary) ^
      const DeepCollectionEquality().hash(detailed) ^
      runtimeType.hashCode;
}

extension $PersonalFinanceCategoryExtension on PersonalFinanceCategory {
  PersonalFinanceCategory copyWith({String? primary, String? detailed}) {
    return PersonalFinanceCategory(
        primary: primary ?? this.primary, detailed: detailed ?? this.detailed);
  }

  PersonalFinanceCategory copyWithWrapped(
      {Wrapped<String>? primary, Wrapped<String>? detailed}) {
    return PersonalFinanceCategory(
        primary: (primary != null ? primary.value : this.primary),
        detailed: (detailed != null ? detailed.value : this.detailed));
  }
}

@JsonSerializable(explicitToJson: true)
class ScreeningStatusUpdatedWebhook {
  ScreeningStatusUpdatedWebhook({
    required this.webhookType,
    required this.webhookCode,
    required this.screeningId,
    required this.environment,
  });

  factory ScreeningStatusUpdatedWebhook.fromJson(Map<String, dynamic> json) =>
      _$ScreeningStatusUpdatedWebhookFromJson(json);

  @JsonKey(name: 'webhook_type')
  final String webhookType;
  @JsonKey(name: 'webhook_code')
  final String webhookCode;
  @JsonKey(name: 'screeningId')
  final dynamic screeningId;
  @JsonKey(
    name: 'environment',
    toJson: webhookEnvironmentValuesToJson,
    fromJson: webhookEnvironmentValuesFromJson,
  )
  final enums.WebhookEnvironmentValues environment;
  static const fromJsonFactory = _$ScreeningStatusUpdatedWebhookFromJson;
  static const toJsonFactory = _$ScreeningStatusUpdatedWebhookToJson;
  Map<String, dynamic> toJson() => _$ScreeningStatusUpdatedWebhookToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ScreeningStatusUpdatedWebhook &&
            (identical(other.webhookType, webhookType) ||
                const DeepCollectionEquality()
                    .equals(other.webhookType, webhookType)) &&
            (identical(other.webhookCode, webhookCode) ||
                const DeepCollectionEquality()
                    .equals(other.webhookCode, webhookCode)) &&
            (identical(other.screeningId, screeningId) ||
                const DeepCollectionEquality()
                    .equals(other.screeningId, screeningId)) &&
            (identical(other.environment, environment) ||
                const DeepCollectionEquality()
                    .equals(other.environment, environment)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(webhookType) ^
      const DeepCollectionEquality().hash(webhookCode) ^
      const DeepCollectionEquality().hash(screeningId) ^
      const DeepCollectionEquality().hash(environment) ^
      runtimeType.hashCode;
}

extension $ScreeningStatusUpdatedWebhookExtension
    on ScreeningStatusUpdatedWebhook {
  ScreeningStatusUpdatedWebhook copyWith(
      {String? webhookType,
      String? webhookCode,
      dynamic screeningId,
      enums.WebhookEnvironmentValues? environment}) {
    return ScreeningStatusUpdatedWebhook(
        webhookType: webhookType ?? this.webhookType,
        webhookCode: webhookCode ?? this.webhookCode,
        screeningId: screeningId ?? this.screeningId,
        environment: environment ?? this.environment);
  }

  ScreeningStatusUpdatedWebhook copyWithWrapped(
      {Wrapped<String>? webhookType,
      Wrapped<String>? webhookCode,
      Wrapped<dynamic>? screeningId,
      Wrapped<enums.WebhookEnvironmentValues>? environment}) {
    return ScreeningStatusUpdatedWebhook(
        webhookType:
            (webhookType != null ? webhookType.value : this.webhookType),
        webhookCode:
            (webhookCode != null ? webhookCode.value : this.webhookCode),
        screeningId:
            (screeningId != null ? screeningId.value : this.screeningId),
        environment:
            (environment != null ? environment.value : this.environment));
  }
}

@JsonSerializable(explicitToJson: true)
class EntityScreeningStatusUpdatedWebhook {
  EntityScreeningStatusUpdatedWebhook({
    required this.webhookType,
    required this.webhookCode,
    required this.screeningId,
    required this.environment,
  });

  factory EntityScreeningStatusUpdatedWebhook.fromJson(
          Map<String, dynamic> json) =>
      _$EntityScreeningStatusUpdatedWebhookFromJson(json);

  @JsonKey(name: 'webhook_type')
  final String webhookType;
  @JsonKey(name: 'webhook_code')
  final String webhookCode;
  @JsonKey(name: 'screeningId')
  final dynamic screeningId;
  @JsonKey(
    name: 'environment',
    toJson: webhookEnvironmentValuesToJson,
    fromJson: webhookEnvironmentValuesFromJson,
  )
  final enums.WebhookEnvironmentValues environment;
  static const fromJsonFactory = _$EntityScreeningStatusUpdatedWebhookFromJson;
  static const toJsonFactory = _$EntityScreeningStatusUpdatedWebhookToJson;
  Map<String, dynamic> toJson() =>
      _$EntityScreeningStatusUpdatedWebhookToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is EntityScreeningStatusUpdatedWebhook &&
            (identical(other.webhookType, webhookType) ||
                const DeepCollectionEquality()
                    .equals(other.webhookType, webhookType)) &&
            (identical(other.webhookCode, webhookCode) ||
                const DeepCollectionEquality()
                    .equals(other.webhookCode, webhookCode)) &&
            (identical(other.screeningId, screeningId) ||
                const DeepCollectionEquality()
                    .equals(other.screeningId, screeningId)) &&
            (identical(other.environment, environment) ||
                const DeepCollectionEquality()
                    .equals(other.environment, environment)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(webhookType) ^
      const DeepCollectionEquality().hash(webhookCode) ^
      const DeepCollectionEquality().hash(screeningId) ^
      const DeepCollectionEquality().hash(environment) ^
      runtimeType.hashCode;
}

extension $EntityScreeningStatusUpdatedWebhookExtension
    on EntityScreeningStatusUpdatedWebhook {
  EntityScreeningStatusUpdatedWebhook copyWith(
      {String? webhookType,
      String? webhookCode,
      dynamic screeningId,
      enums.WebhookEnvironmentValues? environment}) {
    return EntityScreeningStatusUpdatedWebhook(
        webhookType: webhookType ?? this.webhookType,
        webhookCode: webhookCode ?? this.webhookCode,
        screeningId: screeningId ?? this.screeningId,
        environment: environment ?? this.environment);
  }

  EntityScreeningStatusUpdatedWebhook copyWithWrapped(
      {Wrapped<String>? webhookType,
      Wrapped<String>? webhookCode,
      Wrapped<dynamic>? screeningId,
      Wrapped<enums.WebhookEnvironmentValues>? environment}) {
    return EntityScreeningStatusUpdatedWebhook(
        webhookType:
            (webhookType != null ? webhookType.value : this.webhookType),
        webhookCode:
            (webhookCode != null ? webhookCode.value : this.webhookCode),
        screeningId:
            (screeningId != null ? screeningId.value : this.screeningId),
        environment:
            (environment != null ? environment.value : this.environment));
  }
}

@JsonSerializable(explicitToJson: true)
class IdentityVerificationStepUpdatedWebhook {
  IdentityVerificationStepUpdatedWebhook({
    required this.webhookType,
    required this.webhookCode,
    required this.identityVerificationId,
    required this.environment,
  });

  factory IdentityVerificationStepUpdatedWebhook.fromJson(
          Map<String, dynamic> json) =>
      _$IdentityVerificationStepUpdatedWebhookFromJson(json);

  @JsonKey(name: 'webhook_type')
  final String webhookType;
  @JsonKey(name: 'webhook_code')
  final String webhookCode;
  @JsonKey(name: 'identityVerificationId')
  final dynamic identityVerificationId;
  @JsonKey(
    name: 'environment',
    toJson: webhookEnvironmentValuesToJson,
    fromJson: webhookEnvironmentValuesFromJson,
  )
  final enums.WebhookEnvironmentValues environment;
  static const fromJsonFactory =
      _$IdentityVerificationStepUpdatedWebhookFromJson;
  static const toJsonFactory = _$IdentityVerificationStepUpdatedWebhookToJson;
  Map<String, dynamic> toJson() =>
      _$IdentityVerificationStepUpdatedWebhookToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IdentityVerificationStepUpdatedWebhook &&
            (identical(other.webhookType, webhookType) ||
                const DeepCollectionEquality()
                    .equals(other.webhookType, webhookType)) &&
            (identical(other.webhookCode, webhookCode) ||
                const DeepCollectionEquality()
                    .equals(other.webhookCode, webhookCode)) &&
            (identical(other.identityVerificationId, identityVerificationId) ||
                const DeepCollectionEquality().equals(
                    other.identityVerificationId, identityVerificationId)) &&
            (identical(other.environment, environment) ||
                const DeepCollectionEquality()
                    .equals(other.environment, environment)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(webhookType) ^
      const DeepCollectionEquality().hash(webhookCode) ^
      const DeepCollectionEquality().hash(identityVerificationId) ^
      const DeepCollectionEquality().hash(environment) ^
      runtimeType.hashCode;
}

extension $IdentityVerificationStepUpdatedWebhookExtension
    on IdentityVerificationStepUpdatedWebhook {
  IdentityVerificationStepUpdatedWebhook copyWith(
      {String? webhookType,
      String? webhookCode,
      dynamic identityVerificationId,
      enums.WebhookEnvironmentValues? environment}) {
    return IdentityVerificationStepUpdatedWebhook(
        webhookType: webhookType ?? this.webhookType,
        webhookCode: webhookCode ?? this.webhookCode,
        identityVerificationId:
            identityVerificationId ?? this.identityVerificationId,
        environment: environment ?? this.environment);
  }

  IdentityVerificationStepUpdatedWebhook copyWithWrapped(
      {Wrapped<String>? webhookType,
      Wrapped<String>? webhookCode,
      Wrapped<dynamic>? identityVerificationId,
      Wrapped<enums.WebhookEnvironmentValues>? environment}) {
    return IdentityVerificationStepUpdatedWebhook(
        webhookType:
            (webhookType != null ? webhookType.value : this.webhookType),
        webhookCode:
            (webhookCode != null ? webhookCode.value : this.webhookCode),
        identityVerificationId: (identityVerificationId != null
            ? identityVerificationId.value
            : this.identityVerificationId),
        environment:
            (environment != null ? environment.value : this.environment));
  }
}

@JsonSerializable(explicitToJson: true)
class IdentityVerificationRetriedWebhook {
  IdentityVerificationRetriedWebhook({
    required this.webhookType,
    required this.webhookCode,
    required this.identityVerificationId,
    required this.environment,
  });

  factory IdentityVerificationRetriedWebhook.fromJson(
          Map<String, dynamic> json) =>
      _$IdentityVerificationRetriedWebhookFromJson(json);

  @JsonKey(name: 'webhook_type')
  final String webhookType;
  @JsonKey(name: 'webhook_code')
  final String webhookCode;
  @JsonKey(name: 'identityVerificationId')
  final dynamic identityVerificationId;
  @JsonKey(
    name: 'environment',
    toJson: webhookEnvironmentValuesToJson,
    fromJson: webhookEnvironmentValuesFromJson,
  )
  final enums.WebhookEnvironmentValues environment;
  static const fromJsonFactory = _$IdentityVerificationRetriedWebhookFromJson;
  static const toJsonFactory = _$IdentityVerificationRetriedWebhookToJson;
  Map<String, dynamic> toJson() =>
      _$IdentityVerificationRetriedWebhookToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IdentityVerificationRetriedWebhook &&
            (identical(other.webhookType, webhookType) ||
                const DeepCollectionEquality()
                    .equals(other.webhookType, webhookType)) &&
            (identical(other.webhookCode, webhookCode) ||
                const DeepCollectionEquality()
                    .equals(other.webhookCode, webhookCode)) &&
            (identical(other.identityVerificationId, identityVerificationId) ||
                const DeepCollectionEquality().equals(
                    other.identityVerificationId, identityVerificationId)) &&
            (identical(other.environment, environment) ||
                const DeepCollectionEquality()
                    .equals(other.environment, environment)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(webhookType) ^
      const DeepCollectionEquality().hash(webhookCode) ^
      const DeepCollectionEquality().hash(identityVerificationId) ^
      const DeepCollectionEquality().hash(environment) ^
      runtimeType.hashCode;
}

extension $IdentityVerificationRetriedWebhookExtension
    on IdentityVerificationRetriedWebhook {
  IdentityVerificationRetriedWebhook copyWith(
      {String? webhookType,
      String? webhookCode,
      dynamic identityVerificationId,
      enums.WebhookEnvironmentValues? environment}) {
    return IdentityVerificationRetriedWebhook(
        webhookType: webhookType ?? this.webhookType,
        webhookCode: webhookCode ?? this.webhookCode,
        identityVerificationId:
            identityVerificationId ?? this.identityVerificationId,
        environment: environment ?? this.environment);
  }

  IdentityVerificationRetriedWebhook copyWithWrapped(
      {Wrapped<String>? webhookType,
      Wrapped<String>? webhookCode,
      Wrapped<dynamic>? identityVerificationId,
      Wrapped<enums.WebhookEnvironmentValues>? environment}) {
    return IdentityVerificationRetriedWebhook(
        webhookType:
            (webhookType != null ? webhookType.value : this.webhookType),
        webhookCode:
            (webhookCode != null ? webhookCode.value : this.webhookCode),
        identityVerificationId: (identityVerificationId != null
            ? identityVerificationId.value
            : this.identityVerificationId),
        environment:
            (environment != null ? environment.value : this.environment));
  }
}

@JsonSerializable(explicitToJson: true)
class IdentityVerificationStatusUpdatedWebhook {
  IdentityVerificationStatusUpdatedWebhook({
    required this.webhookType,
    required this.webhookCode,
    required this.identityVerificationId,
    required this.environment,
  });

  factory IdentityVerificationStatusUpdatedWebhook.fromJson(
          Map<String, dynamic> json) =>
      _$IdentityVerificationStatusUpdatedWebhookFromJson(json);

  @JsonKey(name: 'webhook_type')
  final String webhookType;
  @JsonKey(name: 'webhook_code')
  final String webhookCode;
  @JsonKey(name: 'identityVerificationId')
  final dynamic identityVerificationId;
  @JsonKey(
    name: 'environment',
    toJson: webhookEnvironmentValuesToJson,
    fromJson: webhookEnvironmentValuesFromJson,
  )
  final enums.WebhookEnvironmentValues environment;
  static const fromJsonFactory =
      _$IdentityVerificationStatusUpdatedWebhookFromJson;
  static const toJsonFactory = _$IdentityVerificationStatusUpdatedWebhookToJson;
  Map<String, dynamic> toJson() =>
      _$IdentityVerificationStatusUpdatedWebhookToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IdentityVerificationStatusUpdatedWebhook &&
            (identical(other.webhookType, webhookType) ||
                const DeepCollectionEquality()
                    .equals(other.webhookType, webhookType)) &&
            (identical(other.webhookCode, webhookCode) ||
                const DeepCollectionEquality()
                    .equals(other.webhookCode, webhookCode)) &&
            (identical(other.identityVerificationId, identityVerificationId) ||
                const DeepCollectionEquality().equals(
                    other.identityVerificationId, identityVerificationId)) &&
            (identical(other.environment, environment) ||
                const DeepCollectionEquality()
                    .equals(other.environment, environment)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(webhookType) ^
      const DeepCollectionEquality().hash(webhookCode) ^
      const DeepCollectionEquality().hash(identityVerificationId) ^
      const DeepCollectionEquality().hash(environment) ^
      runtimeType.hashCode;
}

extension $IdentityVerificationStatusUpdatedWebhookExtension
    on IdentityVerificationStatusUpdatedWebhook {
  IdentityVerificationStatusUpdatedWebhook copyWith(
      {String? webhookType,
      String? webhookCode,
      dynamic identityVerificationId,
      enums.WebhookEnvironmentValues? environment}) {
    return IdentityVerificationStatusUpdatedWebhook(
        webhookType: webhookType ?? this.webhookType,
        webhookCode: webhookCode ?? this.webhookCode,
        identityVerificationId:
            identityVerificationId ?? this.identityVerificationId,
        environment: environment ?? this.environment);
  }

  IdentityVerificationStatusUpdatedWebhook copyWithWrapped(
      {Wrapped<String>? webhookType,
      Wrapped<String>? webhookCode,
      Wrapped<dynamic>? identityVerificationId,
      Wrapped<enums.WebhookEnvironmentValues>? environment}) {
    return IdentityVerificationStatusUpdatedWebhook(
        webhookType:
            (webhookType != null ? webhookType.value : this.webhookType),
        webhookCode:
            (webhookCode != null ? webhookCode.value : this.webhookCode),
        identityVerificationId: (identityVerificationId != null
            ? identityVerificationId.value
            : this.identityVerificationId),
        environment:
            (environment != null ? environment.value : this.environment));
  }
}

@JsonSerializable(explicitToJson: true)
class TransactionsRemovedWebhook {
  TransactionsRemovedWebhook({
    required this.webhookType,
    required this.webhookCode,
    this.error,
    required this.removedTransactions,
    required this.itemId,
    required this.environment,
  });

  factory TransactionsRemovedWebhook.fromJson(Map<String, dynamic> json) =>
      _$TransactionsRemovedWebhookFromJson(json);

  @JsonKey(name: 'webhook_type')
  final String webhookType;
  @JsonKey(name: 'webhook_code')
  final String webhookCode;
  @JsonKey(name: 'error')
  final PlaidError? error;
  @JsonKey(name: 'removed_transactions', defaultValue: <String>[])
  final List<String> removedTransactions;
  @JsonKey(name: 'item_id')
  final String itemId;
  @JsonKey(
    name: 'environment',
    toJson: webhookEnvironmentValuesToJson,
    fromJson: webhookEnvironmentValuesFromJson,
  )
  final enums.WebhookEnvironmentValues environment;
  static const fromJsonFactory = _$TransactionsRemovedWebhookFromJson;
  static const toJsonFactory = _$TransactionsRemovedWebhookToJson;
  Map<String, dynamic> toJson() => _$TransactionsRemovedWebhookToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransactionsRemovedWebhook &&
            (identical(other.webhookType, webhookType) ||
                const DeepCollectionEquality()
                    .equals(other.webhookType, webhookType)) &&
            (identical(other.webhookCode, webhookCode) ||
                const DeepCollectionEquality()
                    .equals(other.webhookCode, webhookCode)) &&
            (identical(other.error, error) ||
                const DeepCollectionEquality().equals(other.error, error)) &&
            (identical(other.removedTransactions, removedTransactions) ||
                const DeepCollectionEquality()
                    .equals(other.removedTransactions, removedTransactions)) &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)) &&
            (identical(other.environment, environment) ||
                const DeepCollectionEquality()
                    .equals(other.environment, environment)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(webhookType) ^
      const DeepCollectionEquality().hash(webhookCode) ^
      const DeepCollectionEquality().hash(error) ^
      const DeepCollectionEquality().hash(removedTransactions) ^
      const DeepCollectionEquality().hash(itemId) ^
      const DeepCollectionEquality().hash(environment) ^
      runtimeType.hashCode;
}

extension $TransactionsRemovedWebhookExtension on TransactionsRemovedWebhook {
  TransactionsRemovedWebhook copyWith(
      {String? webhookType,
      String? webhookCode,
      PlaidError? error,
      List<String>? removedTransactions,
      String? itemId,
      enums.WebhookEnvironmentValues? environment}) {
    return TransactionsRemovedWebhook(
        webhookType: webhookType ?? this.webhookType,
        webhookCode: webhookCode ?? this.webhookCode,
        error: error ?? this.error,
        removedTransactions: removedTransactions ?? this.removedTransactions,
        itemId: itemId ?? this.itemId,
        environment: environment ?? this.environment);
  }

  TransactionsRemovedWebhook copyWithWrapped(
      {Wrapped<String>? webhookType,
      Wrapped<String>? webhookCode,
      Wrapped<PlaidError?>? error,
      Wrapped<List<String>>? removedTransactions,
      Wrapped<String>? itemId,
      Wrapped<enums.WebhookEnvironmentValues>? environment}) {
    return TransactionsRemovedWebhook(
        webhookType:
            (webhookType != null ? webhookType.value : this.webhookType),
        webhookCode:
            (webhookCode != null ? webhookCode.value : this.webhookCode),
        error: (error != null ? error.value : this.error),
        removedTransactions: (removedTransactions != null
            ? removedTransactions.value
            : this.removedTransactions),
        itemId: (itemId != null ? itemId.value : this.itemId),
        environment:
            (environment != null ? environment.value : this.environment));
  }
}

@JsonSerializable(explicitToJson: true)
class DefaultUpdateWebhook {
  DefaultUpdateWebhook({
    required this.webhookType,
    required this.webhookCode,
    this.error,
    required this.newTransactions,
    required this.itemId,
    required this.environment,
  });

  factory DefaultUpdateWebhook.fromJson(Map<String, dynamic> json) =>
      _$DefaultUpdateWebhookFromJson(json);

  @JsonKey(name: 'webhook_type')
  final String webhookType;
  @JsonKey(name: 'webhook_code')
  final String webhookCode;
  @JsonKey(name: 'error')
  final PlaidError? error;
  @JsonKey(name: 'new_transactions')
  final double newTransactions;
  @JsonKey(name: 'item_id')
  final String itemId;
  @JsonKey(
    name: 'environment',
    toJson: webhookEnvironmentValuesToJson,
    fromJson: webhookEnvironmentValuesFromJson,
  )
  final enums.WebhookEnvironmentValues environment;
  static const fromJsonFactory = _$DefaultUpdateWebhookFromJson;
  static const toJsonFactory = _$DefaultUpdateWebhookToJson;
  Map<String, dynamic> toJson() => _$DefaultUpdateWebhookToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is DefaultUpdateWebhook &&
            (identical(other.webhookType, webhookType) ||
                const DeepCollectionEquality()
                    .equals(other.webhookType, webhookType)) &&
            (identical(other.webhookCode, webhookCode) ||
                const DeepCollectionEquality()
                    .equals(other.webhookCode, webhookCode)) &&
            (identical(other.error, error) ||
                const DeepCollectionEquality().equals(other.error, error)) &&
            (identical(other.newTransactions, newTransactions) ||
                const DeepCollectionEquality()
                    .equals(other.newTransactions, newTransactions)) &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)) &&
            (identical(other.environment, environment) ||
                const DeepCollectionEquality()
                    .equals(other.environment, environment)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(webhookType) ^
      const DeepCollectionEquality().hash(webhookCode) ^
      const DeepCollectionEquality().hash(error) ^
      const DeepCollectionEquality().hash(newTransactions) ^
      const DeepCollectionEquality().hash(itemId) ^
      const DeepCollectionEquality().hash(environment) ^
      runtimeType.hashCode;
}

extension $DefaultUpdateWebhookExtension on DefaultUpdateWebhook {
  DefaultUpdateWebhook copyWith(
      {String? webhookType,
      String? webhookCode,
      PlaidError? error,
      double? newTransactions,
      String? itemId,
      enums.WebhookEnvironmentValues? environment}) {
    return DefaultUpdateWebhook(
        webhookType: webhookType ?? this.webhookType,
        webhookCode: webhookCode ?? this.webhookCode,
        error: error ?? this.error,
        newTransactions: newTransactions ?? this.newTransactions,
        itemId: itemId ?? this.itemId,
        environment: environment ?? this.environment);
  }

  DefaultUpdateWebhook copyWithWrapped(
      {Wrapped<String>? webhookType,
      Wrapped<String>? webhookCode,
      Wrapped<PlaidError?>? error,
      Wrapped<double>? newTransactions,
      Wrapped<String>? itemId,
      Wrapped<enums.WebhookEnvironmentValues>? environment}) {
    return DefaultUpdateWebhook(
        webhookType:
            (webhookType != null ? webhookType.value : this.webhookType),
        webhookCode:
            (webhookCode != null ? webhookCode.value : this.webhookCode),
        error: (error != null ? error.value : this.error),
        newTransactions: (newTransactions != null
            ? newTransactions.value
            : this.newTransactions),
        itemId: (itemId != null ? itemId.value : this.itemId),
        environment:
            (environment != null ? environment.value : this.environment));
  }
}

@JsonSerializable(explicitToJson: true)
class SyncUpdatesAvailableWebhook {
  SyncUpdatesAvailableWebhook({
    required this.webhookType,
    required this.webhookCode,
    required this.itemId,
    required this.initialUpdateComplete,
    required this.historicalUpdateComplete,
    required this.environment,
  });

  factory SyncUpdatesAvailableWebhook.fromJson(Map<String, dynamic> json) =>
      _$SyncUpdatesAvailableWebhookFromJson(json);

  @JsonKey(name: 'webhook_type')
  final String webhookType;
  @JsonKey(name: 'webhook_code')
  final String webhookCode;
  @JsonKey(name: 'item_id')
  final String itemId;
  @JsonKey(name: 'initial_update_complete')
  final bool initialUpdateComplete;
  @JsonKey(name: 'historical_update_complete')
  final bool historicalUpdateComplete;
  @JsonKey(
    name: 'environment',
    toJson: webhookEnvironmentValuesToJson,
    fromJson: webhookEnvironmentValuesFromJson,
  )
  final enums.WebhookEnvironmentValues environment;
  static const fromJsonFactory = _$SyncUpdatesAvailableWebhookFromJson;
  static const toJsonFactory = _$SyncUpdatesAvailableWebhookToJson;
  Map<String, dynamic> toJson() => _$SyncUpdatesAvailableWebhookToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SyncUpdatesAvailableWebhook &&
            (identical(other.webhookType, webhookType) ||
                const DeepCollectionEquality()
                    .equals(other.webhookType, webhookType)) &&
            (identical(other.webhookCode, webhookCode) ||
                const DeepCollectionEquality()
                    .equals(other.webhookCode, webhookCode)) &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)) &&
            (identical(other.initialUpdateComplete, initialUpdateComplete) ||
                const DeepCollectionEquality().equals(
                    other.initialUpdateComplete, initialUpdateComplete)) &&
            (identical(
                    other.historicalUpdateComplete, historicalUpdateComplete) ||
                const DeepCollectionEquality().equals(
                    other.historicalUpdateComplete,
                    historicalUpdateComplete)) &&
            (identical(other.environment, environment) ||
                const DeepCollectionEquality()
                    .equals(other.environment, environment)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(webhookType) ^
      const DeepCollectionEquality().hash(webhookCode) ^
      const DeepCollectionEquality().hash(itemId) ^
      const DeepCollectionEquality().hash(initialUpdateComplete) ^
      const DeepCollectionEquality().hash(historicalUpdateComplete) ^
      const DeepCollectionEquality().hash(environment) ^
      runtimeType.hashCode;
}

extension $SyncUpdatesAvailableWebhookExtension on SyncUpdatesAvailableWebhook {
  SyncUpdatesAvailableWebhook copyWith(
      {String? webhookType,
      String? webhookCode,
      String? itemId,
      bool? initialUpdateComplete,
      bool? historicalUpdateComplete,
      enums.WebhookEnvironmentValues? environment}) {
    return SyncUpdatesAvailableWebhook(
        webhookType: webhookType ?? this.webhookType,
        webhookCode: webhookCode ?? this.webhookCode,
        itemId: itemId ?? this.itemId,
        initialUpdateComplete:
            initialUpdateComplete ?? this.initialUpdateComplete,
        historicalUpdateComplete:
            historicalUpdateComplete ?? this.historicalUpdateComplete,
        environment: environment ?? this.environment);
  }

  SyncUpdatesAvailableWebhook copyWithWrapped(
      {Wrapped<String>? webhookType,
      Wrapped<String>? webhookCode,
      Wrapped<String>? itemId,
      Wrapped<bool>? initialUpdateComplete,
      Wrapped<bool>? historicalUpdateComplete,
      Wrapped<enums.WebhookEnvironmentValues>? environment}) {
    return SyncUpdatesAvailableWebhook(
        webhookType:
            (webhookType != null ? webhookType.value : this.webhookType),
        webhookCode:
            (webhookCode != null ? webhookCode.value : this.webhookCode),
        itemId: (itemId != null ? itemId.value : this.itemId),
        initialUpdateComplete: (initialUpdateComplete != null
            ? initialUpdateComplete.value
            : this.initialUpdateComplete),
        historicalUpdateComplete: (historicalUpdateComplete != null
            ? historicalUpdateComplete.value
            : this.historicalUpdateComplete),
        environment:
            (environment != null ? environment.value : this.environment));
  }
}

@JsonSerializable(explicitToJson: true)
class RecurringTransactionsUpdateWebhook {
  RecurringTransactionsUpdateWebhook({
    required this.webhookType,
    required this.webhookCode,
    required this.itemId,
    required this.accountIds,
    required this.environment,
  });

  factory RecurringTransactionsUpdateWebhook.fromJson(
          Map<String, dynamic> json) =>
      _$RecurringTransactionsUpdateWebhookFromJson(json);

  @JsonKey(name: 'webhook_type')
  final String webhookType;
  @JsonKey(name: 'webhook_code')
  final String webhookCode;
  @JsonKey(name: 'item_id')
  final String itemId;
  @JsonKey(name: 'account_ids', defaultValue: <String>[])
  final List<String> accountIds;
  @JsonKey(
    name: 'environment',
    toJson: webhookEnvironmentValuesToJson,
    fromJson: webhookEnvironmentValuesFromJson,
  )
  final enums.WebhookEnvironmentValues environment;
  static const fromJsonFactory = _$RecurringTransactionsUpdateWebhookFromJson;
  static const toJsonFactory = _$RecurringTransactionsUpdateWebhookToJson;
  Map<String, dynamic> toJson() =>
      _$RecurringTransactionsUpdateWebhookToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is RecurringTransactionsUpdateWebhook &&
            (identical(other.webhookType, webhookType) ||
                const DeepCollectionEquality()
                    .equals(other.webhookType, webhookType)) &&
            (identical(other.webhookCode, webhookCode) ||
                const DeepCollectionEquality()
                    .equals(other.webhookCode, webhookCode)) &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)) &&
            (identical(other.accountIds, accountIds) ||
                const DeepCollectionEquality()
                    .equals(other.accountIds, accountIds)) &&
            (identical(other.environment, environment) ||
                const DeepCollectionEquality()
                    .equals(other.environment, environment)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(webhookType) ^
      const DeepCollectionEquality().hash(webhookCode) ^
      const DeepCollectionEquality().hash(itemId) ^
      const DeepCollectionEquality().hash(accountIds) ^
      const DeepCollectionEquality().hash(environment) ^
      runtimeType.hashCode;
}

extension $RecurringTransactionsUpdateWebhookExtension
    on RecurringTransactionsUpdateWebhook {
  RecurringTransactionsUpdateWebhook copyWith(
      {String? webhookType,
      String? webhookCode,
      String? itemId,
      List<String>? accountIds,
      enums.WebhookEnvironmentValues? environment}) {
    return RecurringTransactionsUpdateWebhook(
        webhookType: webhookType ?? this.webhookType,
        webhookCode: webhookCode ?? this.webhookCode,
        itemId: itemId ?? this.itemId,
        accountIds: accountIds ?? this.accountIds,
        environment: environment ?? this.environment);
  }

  RecurringTransactionsUpdateWebhook copyWithWrapped(
      {Wrapped<String>? webhookType,
      Wrapped<String>? webhookCode,
      Wrapped<String>? itemId,
      Wrapped<List<String>>? accountIds,
      Wrapped<enums.WebhookEnvironmentValues>? environment}) {
    return RecurringTransactionsUpdateWebhook(
        webhookType:
            (webhookType != null ? webhookType.value : this.webhookType),
        webhookCode:
            (webhookCode != null ? webhookCode.value : this.webhookCode),
        itemId: (itemId != null ? itemId.value : this.itemId),
        accountIds: (accountIds != null ? accountIds.value : this.accountIds),
        environment:
            (environment != null ? environment.value : this.environment));
  }
}

@JsonSerializable(explicitToJson: true)
class IdentityDefaultUpdateWebhook {
  IdentityDefaultUpdateWebhook({
    required this.webhookType,
    required this.webhookCode,
    required this.itemId,
    required this.accountIdsWithUpdatedIdentity,
    required this.error,
    required this.environment,
  });

  factory IdentityDefaultUpdateWebhook.fromJson(Map<String, dynamic> json) =>
      _$IdentityDefaultUpdateWebhookFromJson(json);

  @JsonKey(name: 'webhook_type')
  final String webhookType;
  @JsonKey(name: 'webhook_code')
  final String webhookCode;
  @JsonKey(name: 'item_id')
  final String itemId;
  @JsonKey(name: 'account_ids_with_updated_identity')
  final AccountIdsWithUpdatedIdentity accountIdsWithUpdatedIdentity;
  @JsonKey(name: 'error')
  final PlaidError? error;
  @JsonKey(
    name: 'environment',
    toJson: webhookEnvironmentValuesToJson,
    fromJson: webhookEnvironmentValuesFromJson,
  )
  final enums.WebhookEnvironmentValues environment;
  static const fromJsonFactory = _$IdentityDefaultUpdateWebhookFromJson;
  static const toJsonFactory = _$IdentityDefaultUpdateWebhookToJson;
  Map<String, dynamic> toJson() => _$IdentityDefaultUpdateWebhookToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IdentityDefaultUpdateWebhook &&
            (identical(other.webhookType, webhookType) ||
                const DeepCollectionEquality()
                    .equals(other.webhookType, webhookType)) &&
            (identical(other.webhookCode, webhookCode) ||
                const DeepCollectionEquality()
                    .equals(other.webhookCode, webhookCode)) &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)) &&
            (identical(other.accountIdsWithUpdatedIdentity,
                    accountIdsWithUpdatedIdentity) ||
                const DeepCollectionEquality().equals(
                    other.accountIdsWithUpdatedIdentity,
                    accountIdsWithUpdatedIdentity)) &&
            (identical(other.error, error) ||
                const DeepCollectionEquality().equals(other.error, error)) &&
            (identical(other.environment, environment) ||
                const DeepCollectionEquality()
                    .equals(other.environment, environment)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(webhookType) ^
      const DeepCollectionEquality().hash(webhookCode) ^
      const DeepCollectionEquality().hash(itemId) ^
      const DeepCollectionEquality().hash(accountIdsWithUpdatedIdentity) ^
      const DeepCollectionEquality().hash(error) ^
      const DeepCollectionEquality().hash(environment) ^
      runtimeType.hashCode;
}

extension $IdentityDefaultUpdateWebhookExtension
    on IdentityDefaultUpdateWebhook {
  IdentityDefaultUpdateWebhook copyWith(
      {String? webhookType,
      String? webhookCode,
      String? itemId,
      AccountIdsWithUpdatedIdentity? accountIdsWithUpdatedIdentity,
      PlaidError? error,
      enums.WebhookEnvironmentValues? environment}) {
    return IdentityDefaultUpdateWebhook(
        webhookType: webhookType ?? this.webhookType,
        webhookCode: webhookCode ?? this.webhookCode,
        itemId: itemId ?? this.itemId,
        accountIdsWithUpdatedIdentity:
            accountIdsWithUpdatedIdentity ?? this.accountIdsWithUpdatedIdentity,
        error: error ?? this.error,
        environment: environment ?? this.environment);
  }

  IdentityDefaultUpdateWebhook copyWithWrapped(
      {Wrapped<String>? webhookType,
      Wrapped<String>? webhookCode,
      Wrapped<String>? itemId,
      Wrapped<AccountIdsWithUpdatedIdentity>? accountIdsWithUpdatedIdentity,
      Wrapped<PlaidError?>? error,
      Wrapped<enums.WebhookEnvironmentValues>? environment}) {
    return IdentityDefaultUpdateWebhook(
        webhookType:
            (webhookType != null ? webhookType.value : this.webhookType),
        webhookCode:
            (webhookCode != null ? webhookCode.value : this.webhookCode),
        itemId: (itemId != null ? itemId.value : this.itemId),
        accountIdsWithUpdatedIdentity: (accountIdsWithUpdatedIdentity != null
            ? accountIdsWithUpdatedIdentity.value
            : this.accountIdsWithUpdatedIdentity),
        error: (error != null ? error.value : this.error),
        environment:
            (environment != null ? environment.value : this.environment));
  }
}

@JsonSerializable(explicitToJson: true)
class AccountIdsWithUpdatedIdentity {
  AccountIdsWithUpdatedIdentity();

  factory AccountIdsWithUpdatedIdentity.fromJson(Map<String, dynamic> json) =>
      _$AccountIdsWithUpdatedIdentityFromJson(json);

  static const fromJsonFactory = _$AccountIdsWithUpdatedIdentityFromJson;
  static const toJsonFactory = _$AccountIdsWithUpdatedIdentityToJson;
  Map<String, dynamic> toJson() => _$AccountIdsWithUpdatedIdentityToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => runtimeType.hashCode;
}

@JsonSerializable(explicitToJson: true)
class HistoricalUpdateWebhook {
  HistoricalUpdateWebhook({
    required this.webhookType,
    required this.webhookCode,
    this.error,
    required this.newTransactions,
    required this.itemId,
    required this.environment,
  });

  factory HistoricalUpdateWebhook.fromJson(Map<String, dynamic> json) =>
      _$HistoricalUpdateWebhookFromJson(json);

  @JsonKey(name: 'webhook_type')
  final String webhookType;
  @JsonKey(name: 'webhook_code')
  final String webhookCode;
  @JsonKey(name: 'error')
  final PlaidError? error;
  @JsonKey(name: 'new_transactions')
  final double newTransactions;
  @JsonKey(name: 'item_id')
  final String itemId;
  @JsonKey(
    name: 'environment',
    toJson: webhookEnvironmentValuesToJson,
    fromJson: webhookEnvironmentValuesFromJson,
  )
  final enums.WebhookEnvironmentValues environment;
  static const fromJsonFactory = _$HistoricalUpdateWebhookFromJson;
  static const toJsonFactory = _$HistoricalUpdateWebhookToJson;
  Map<String, dynamic> toJson() => _$HistoricalUpdateWebhookToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is HistoricalUpdateWebhook &&
            (identical(other.webhookType, webhookType) ||
                const DeepCollectionEquality()
                    .equals(other.webhookType, webhookType)) &&
            (identical(other.webhookCode, webhookCode) ||
                const DeepCollectionEquality()
                    .equals(other.webhookCode, webhookCode)) &&
            (identical(other.error, error) ||
                const DeepCollectionEquality().equals(other.error, error)) &&
            (identical(other.newTransactions, newTransactions) ||
                const DeepCollectionEquality()
                    .equals(other.newTransactions, newTransactions)) &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)) &&
            (identical(other.environment, environment) ||
                const DeepCollectionEquality()
                    .equals(other.environment, environment)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(webhookType) ^
      const DeepCollectionEquality().hash(webhookCode) ^
      const DeepCollectionEquality().hash(error) ^
      const DeepCollectionEquality().hash(newTransactions) ^
      const DeepCollectionEquality().hash(itemId) ^
      const DeepCollectionEquality().hash(environment) ^
      runtimeType.hashCode;
}

extension $HistoricalUpdateWebhookExtension on HistoricalUpdateWebhook {
  HistoricalUpdateWebhook copyWith(
      {String? webhookType,
      String? webhookCode,
      PlaidError? error,
      double? newTransactions,
      String? itemId,
      enums.WebhookEnvironmentValues? environment}) {
    return HistoricalUpdateWebhook(
        webhookType: webhookType ?? this.webhookType,
        webhookCode: webhookCode ?? this.webhookCode,
        error: error ?? this.error,
        newTransactions: newTransactions ?? this.newTransactions,
        itemId: itemId ?? this.itemId,
        environment: environment ?? this.environment);
  }

  HistoricalUpdateWebhook copyWithWrapped(
      {Wrapped<String>? webhookType,
      Wrapped<String>? webhookCode,
      Wrapped<PlaidError?>? error,
      Wrapped<double>? newTransactions,
      Wrapped<String>? itemId,
      Wrapped<enums.WebhookEnvironmentValues>? environment}) {
    return HistoricalUpdateWebhook(
        webhookType:
            (webhookType != null ? webhookType.value : this.webhookType),
        webhookCode:
            (webhookCode != null ? webhookCode.value : this.webhookCode),
        error: (error != null ? error.value : this.error),
        newTransactions: (newTransactions != null
            ? newTransactions.value
            : this.newTransactions),
        itemId: (itemId != null ? itemId.value : this.itemId),
        environment:
            (environment != null ? environment.value : this.environment));
  }
}

@JsonSerializable(explicitToJson: true)
class InitialUpdateWebhook {
  InitialUpdateWebhook({
    required this.webhookType,
    required this.webhookCode,
    this.error,
    required this.newTransactions,
    required this.itemId,
    required this.environment,
  });

  factory InitialUpdateWebhook.fromJson(Map<String, dynamic> json) =>
      _$InitialUpdateWebhookFromJson(json);

  @JsonKey(name: 'webhook_type')
  final String webhookType;
  @JsonKey(name: 'webhook_code')
  final String webhookCode;
  @JsonKey(name: 'error')
  final String? error;
  @JsonKey(name: 'new_transactions')
  final double newTransactions;
  @JsonKey(name: 'item_id')
  final String itemId;
  @JsonKey(
    name: 'environment',
    toJson: webhookEnvironmentValuesToJson,
    fromJson: webhookEnvironmentValuesFromJson,
  )
  final enums.WebhookEnvironmentValues environment;
  static const fromJsonFactory = _$InitialUpdateWebhookFromJson;
  static const toJsonFactory = _$InitialUpdateWebhookToJson;
  Map<String, dynamic> toJson() => _$InitialUpdateWebhookToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InitialUpdateWebhook &&
            (identical(other.webhookType, webhookType) ||
                const DeepCollectionEquality()
                    .equals(other.webhookType, webhookType)) &&
            (identical(other.webhookCode, webhookCode) ||
                const DeepCollectionEquality()
                    .equals(other.webhookCode, webhookCode)) &&
            (identical(other.error, error) ||
                const DeepCollectionEquality().equals(other.error, error)) &&
            (identical(other.newTransactions, newTransactions) ||
                const DeepCollectionEquality()
                    .equals(other.newTransactions, newTransactions)) &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)) &&
            (identical(other.environment, environment) ||
                const DeepCollectionEquality()
                    .equals(other.environment, environment)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(webhookType) ^
      const DeepCollectionEquality().hash(webhookCode) ^
      const DeepCollectionEquality().hash(error) ^
      const DeepCollectionEquality().hash(newTransactions) ^
      const DeepCollectionEquality().hash(itemId) ^
      const DeepCollectionEquality().hash(environment) ^
      runtimeType.hashCode;
}

extension $InitialUpdateWebhookExtension on InitialUpdateWebhook {
  InitialUpdateWebhook copyWith(
      {String? webhookType,
      String? webhookCode,
      String? error,
      double? newTransactions,
      String? itemId,
      enums.WebhookEnvironmentValues? environment}) {
    return InitialUpdateWebhook(
        webhookType: webhookType ?? this.webhookType,
        webhookCode: webhookCode ?? this.webhookCode,
        error: error ?? this.error,
        newTransactions: newTransactions ?? this.newTransactions,
        itemId: itemId ?? this.itemId,
        environment: environment ?? this.environment);
  }

  InitialUpdateWebhook copyWithWrapped(
      {Wrapped<String>? webhookType,
      Wrapped<String>? webhookCode,
      Wrapped<String?>? error,
      Wrapped<double>? newTransactions,
      Wrapped<String>? itemId,
      Wrapped<enums.WebhookEnvironmentValues>? environment}) {
    return InitialUpdateWebhook(
        webhookType:
            (webhookType != null ? webhookType.value : this.webhookType),
        webhookCode:
            (webhookCode != null ? webhookCode.value : this.webhookCode),
        error: (error != null ? error.value : this.error),
        newTransactions: (newTransactions != null
            ? newTransactions.value
            : this.newTransactions),
        itemId: (itemId != null ? itemId.value : this.itemId),
        environment:
            (environment != null ? environment.value : this.environment));
  }
}

@JsonSerializable(explicitToJson: true)
class PhoneNumber {
  PhoneNumber({
    required this.data,
    required this.primary,
    required this.type,
  });

  factory PhoneNumber.fromJson(Map<String, dynamic> json) =>
      _$PhoneNumberFromJson(json);

  @JsonKey(name: 'data')
  final String data;
  @JsonKey(name: 'primary')
  final bool primary;
  @JsonKey(
    name: 'type',
    toJson: phoneNumberTypeToJson,
    fromJson: phoneNumberTypeFromJson,
  )
  final enums.PhoneNumberType type;
  static const fromJsonFactory = _$PhoneNumberFromJson;
  static const toJsonFactory = _$PhoneNumberToJson;
  Map<String, dynamic> toJson() => _$PhoneNumberToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PhoneNumber &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)) &&
            (identical(other.primary, primary) ||
                const DeepCollectionEquality()
                    .equals(other.primary, primary)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(data) ^
      const DeepCollectionEquality().hash(primary) ^
      const DeepCollectionEquality().hash(type) ^
      runtimeType.hashCode;
}

extension $PhoneNumberExtension on PhoneNumber {
  PhoneNumber copyWith(
      {String? data, bool? primary, enums.PhoneNumberType? type}) {
    return PhoneNumber(
        data: data ?? this.data,
        primary: primary ?? this.primary,
        type: type ?? this.type);
  }

  PhoneNumber copyWithWrapped(
      {Wrapped<String>? data,
      Wrapped<bool>? primary,
      Wrapped<enums.PhoneNumberType>? type}) {
    return PhoneNumber(
        data: (data != null ? data.value : this.data),
        primary: (primary != null ? primary.value : this.primary),
        type: (type != null ? type.value : this.type));
  }
}

@JsonSerializable(explicitToJson: true)
class Email {
  Email({
    required this.data,
    required this.primary,
    required this.type,
  });

  factory Email.fromJson(Map<String, dynamic> json) => _$EmailFromJson(json);

  @JsonKey(name: 'data')
  final String data;
  @JsonKey(name: 'primary')
  final bool primary;
  @JsonKey(
    name: 'type',
    toJson: emailTypeToJson,
    fromJson: emailTypeFromJson,
  )
  final enums.EmailType type;
  static const fromJsonFactory = _$EmailFromJson;
  static const toJsonFactory = _$EmailToJson;
  Map<String, dynamic> toJson() => _$EmailToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Email &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)) &&
            (identical(other.primary, primary) ||
                const DeepCollectionEquality()
                    .equals(other.primary, primary)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(data) ^
      const DeepCollectionEquality().hash(primary) ^
      const DeepCollectionEquality().hash(type) ^
      runtimeType.hashCode;
}

extension $EmailExtension on Email {
  Email copyWith({String? data, bool? primary, enums.EmailType? type}) {
    return Email(
        data: data ?? this.data,
        primary: primary ?? this.primary,
        type: type ?? this.type);
  }

  Email copyWithWrapped(
      {Wrapped<String>? data,
      Wrapped<bool>? primary,
      Wrapped<enums.EmailType>? type}) {
    return Email(
        data: (data != null ? data.value : this.data),
        primary: (primary != null ? primary.value : this.primary),
        type: (type != null ? type.value : this.type));
  }
}

@JsonSerializable(explicitToJson: true)
class Address {
  Address({
    required this.data,
    this.primary,
  });

  factory Address.fromJson(Map<String, dynamic> json) =>
      _$AddressFromJson(json);

  @JsonKey(name: 'data')
  final AddressData data;
  @JsonKey(name: 'primary')
  final bool? primary;
  static const fromJsonFactory = _$AddressFromJson;
  static const toJsonFactory = _$AddressToJson;
  Map<String, dynamic> toJson() => _$AddressToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Address &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)) &&
            (identical(other.primary, primary) ||
                const DeepCollectionEquality().equals(other.primary, primary)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(data) ^
      const DeepCollectionEquality().hash(primary) ^
      runtimeType.hashCode;
}

extension $AddressExtension on Address {
  Address copyWith({AddressData? data, bool? primary}) {
    return Address(data: data ?? this.data, primary: primary ?? this.primary);
  }

  Address copyWithWrapped(
      {Wrapped<AddressData>? data, Wrapped<bool?>? primary}) {
    return Address(
        data: (data != null ? data.value : this.data),
        primary: (primary != null ? primary.value : this.primary));
  }
}

@JsonSerializable(explicitToJson: true)
class AddressNullable {
  AddressNullable({
    required this.data,
    this.primary,
  });

  factory AddressNullable.fromJson(Map<String, dynamic> json) =>
      _$AddressNullableFromJson(json);

  @JsonKey(name: 'data')
  final AddressData data;
  @JsonKey(name: 'primary')
  final bool? primary;
  static const fromJsonFactory = _$AddressNullableFromJson;
  static const toJsonFactory = _$AddressNullableToJson;
  Map<String, dynamic> toJson() => _$AddressNullableToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AddressNullable &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)) &&
            (identical(other.primary, primary) ||
                const DeepCollectionEquality().equals(other.primary, primary)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(data) ^
      const DeepCollectionEquality().hash(primary) ^
      runtimeType.hashCode;
}

extension $AddressNullableExtension on AddressNullable {
  AddressNullable copyWith({AddressData? data, bool? primary}) {
    return AddressNullable(
        data: data ?? this.data, primary: primary ?? this.primary);
  }

  AddressNullable copyWithWrapped(
      {Wrapped<AddressData>? data, Wrapped<bool?>? primary}) {
    return AddressNullable(
        data: (data != null ? data.value : this.data),
        primary: (primary != null ? primary.value : this.primary));
  }
}

@JsonSerializable(explicitToJson: true)
class AddressDataNullable {
  AddressDataNullable({
    required this.city,
    required this.region,
    required this.street,
    required this.postalCode,
    required this.country,
  });

  factory AddressDataNullable.fromJson(Map<String, dynamic> json) =>
      _$AddressDataNullableFromJson(json);

  @JsonKey(name: 'city')
  final String city;
  @JsonKey(name: 'region')
  final String? region;
  @JsonKey(name: 'street')
  final String street;
  @JsonKey(name: 'postal_code')
  final String? postalCode;
  @JsonKey(name: 'country')
  final String? country;
  static const fromJsonFactory = _$AddressDataNullableFromJson;
  static const toJsonFactory = _$AddressDataNullableToJson;
  Map<String, dynamic> toJson() => _$AddressDataNullableToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AddressDataNullable &&
            (identical(other.city, city) ||
                const DeepCollectionEquality().equals(other.city, city)) &&
            (identical(other.region, region) ||
                const DeepCollectionEquality().equals(other.region, region)) &&
            (identical(other.street, street) ||
                const DeepCollectionEquality().equals(other.street, street)) &&
            (identical(other.postalCode, postalCode) ||
                const DeepCollectionEquality()
                    .equals(other.postalCode, postalCode)) &&
            (identical(other.country, country) ||
                const DeepCollectionEquality().equals(other.country, country)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(city) ^
      const DeepCollectionEquality().hash(region) ^
      const DeepCollectionEquality().hash(street) ^
      const DeepCollectionEquality().hash(postalCode) ^
      const DeepCollectionEquality().hash(country) ^
      runtimeType.hashCode;
}

extension $AddressDataNullableExtension on AddressDataNullable {
  AddressDataNullable copyWith(
      {String? city,
      String? region,
      String? street,
      String? postalCode,
      String? country}) {
    return AddressDataNullable(
        city: city ?? this.city,
        region: region ?? this.region,
        street: street ?? this.street,
        postalCode: postalCode ?? this.postalCode,
        country: country ?? this.country);
  }

  AddressDataNullable copyWithWrapped(
      {Wrapped<String>? city,
      Wrapped<String?>? region,
      Wrapped<String>? street,
      Wrapped<String?>? postalCode,
      Wrapped<String?>? country}) {
    return AddressDataNullable(
        city: (city != null ? city.value : this.city),
        region: (region != null ? region.value : this.region),
        street: (street != null ? street.value : this.street),
        postalCode: (postalCode != null ? postalCode.value : this.postalCode),
        country: (country != null ? country.value : this.country));
  }
}

@JsonSerializable(explicitToJson: true)
class AddressData {
  AddressData({
    required this.city,
    required this.region,
    required this.street,
    required this.postalCode,
    required this.country,
  });

  factory AddressData.fromJson(Map<String, dynamic> json) =>
      _$AddressDataFromJson(json);

  @JsonKey(name: 'city')
  final String city;
  @JsonKey(name: 'region')
  final String? region;
  @JsonKey(name: 'street')
  final String street;
  @JsonKey(name: 'postal_code')
  final String? postalCode;
  @JsonKey(name: 'country')
  final String? country;
  static const fromJsonFactory = _$AddressDataFromJson;
  static const toJsonFactory = _$AddressDataToJson;
  Map<String, dynamic> toJson() => _$AddressDataToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AddressData &&
            (identical(other.city, city) ||
                const DeepCollectionEquality().equals(other.city, city)) &&
            (identical(other.region, region) ||
                const DeepCollectionEquality().equals(other.region, region)) &&
            (identical(other.street, street) ||
                const DeepCollectionEquality().equals(other.street, street)) &&
            (identical(other.postalCode, postalCode) ||
                const DeepCollectionEquality()
                    .equals(other.postalCode, postalCode)) &&
            (identical(other.country, country) ||
                const DeepCollectionEquality().equals(other.country, country)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(city) ^
      const DeepCollectionEquality().hash(region) ^
      const DeepCollectionEquality().hash(street) ^
      const DeepCollectionEquality().hash(postalCode) ^
      const DeepCollectionEquality().hash(country) ^
      runtimeType.hashCode;
}

extension $AddressDataExtension on AddressData {
  AddressData copyWith(
      {String? city,
      String? region,
      String? street,
      String? postalCode,
      String? country}) {
    return AddressData(
        city: city ?? this.city,
        region: region ?? this.region,
        street: street ?? this.street,
        postalCode: postalCode ?? this.postalCode,
        country: country ?? this.country);
  }

  AddressData copyWithWrapped(
      {Wrapped<String>? city,
      Wrapped<String?>? region,
      Wrapped<String>? street,
      Wrapped<String?>? postalCode,
      Wrapped<String?>? country}) {
    return AddressData(
        city: (city != null ? city.value : this.city),
        region: (region != null ? region.value : this.region),
        street: (street != null ? street.value : this.street),
        postalCode: (postalCode != null ? postalCode.value : this.postalCode),
        country: (country != null ? country.value : this.country));
  }
}

@JsonSerializable(explicitToJson: true)
class Owner {
  Owner({
    required this.names,
    required this.phoneNumbers,
    required this.emails,
    required this.addresses,
  });

  factory Owner.fromJson(Map<String, dynamic> json) => _$OwnerFromJson(json);

  @JsonKey(name: 'names', defaultValue: <String>[])
  final List<String> names;
  @JsonKey(name: 'phone_numbers', defaultValue: <PhoneNumber>[])
  final List<PhoneNumber> phoneNumbers;
  @JsonKey(name: 'emails', defaultValue: <Email>[])
  final List<Email> emails;
  @JsonKey(name: 'addresses', defaultValue: <Address>[])
  final List<Address> addresses;
  static const fromJsonFactory = _$OwnerFromJson;
  static const toJsonFactory = _$OwnerToJson;
  Map<String, dynamic> toJson() => _$OwnerToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Owner &&
            (identical(other.names, names) ||
                const DeepCollectionEquality().equals(other.names, names)) &&
            (identical(other.phoneNumbers, phoneNumbers) ||
                const DeepCollectionEquality()
                    .equals(other.phoneNumbers, phoneNumbers)) &&
            (identical(other.emails, emails) ||
                const DeepCollectionEquality().equals(other.emails, emails)) &&
            (identical(other.addresses, addresses) ||
                const DeepCollectionEquality()
                    .equals(other.addresses, addresses)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(names) ^
      const DeepCollectionEquality().hash(phoneNumbers) ^
      const DeepCollectionEquality().hash(emails) ^
      const DeepCollectionEquality().hash(addresses) ^
      runtimeType.hashCode;
}

extension $OwnerExtension on Owner {
  Owner copyWith(
      {List<String>? names,
      List<PhoneNumber>? phoneNumbers,
      List<Email>? emails,
      List<Address>? addresses}) {
    return Owner(
        names: names ?? this.names,
        phoneNumbers: phoneNumbers ?? this.phoneNumbers,
        emails: emails ?? this.emails,
        addresses: addresses ?? this.addresses);
  }

  Owner copyWithWrapped(
      {Wrapped<List<String>>? names,
      Wrapped<List<PhoneNumber>>? phoneNumbers,
      Wrapped<List<Email>>? emails,
      Wrapped<List<Address>>? addresses}) {
    return Owner(
        names: (names != null ? names.value : this.names),
        phoneNumbers:
            (phoneNumbers != null ? phoneNumbers.value : this.phoneNumbers),
        emails: (emails != null ? emails.value : this.emails),
        addresses: (addresses != null ? addresses.value : this.addresses));
  }
}

@JsonSerializable(explicitToJson: true)
class OwnerOverride {
  OwnerOverride({
    required this.names,
    required this.phoneNumbers,
    required this.emails,
    required this.addresses,
  });

  factory OwnerOverride.fromJson(Map<String, dynamic> json) =>
      _$OwnerOverrideFromJson(json);

  @JsonKey(name: 'names', defaultValue: <String>[])
  final List<String> names;
  @JsonKey(name: 'phone_numbers', defaultValue: <PhoneNumber>[])
  final List<PhoneNumber> phoneNumbers;
  @JsonKey(name: 'emails', defaultValue: <Email>[])
  final List<Email> emails;
  @JsonKey(name: 'addresses', defaultValue: <Address>[])
  final List<Address> addresses;
  static const fromJsonFactory = _$OwnerOverrideFromJson;
  static const toJsonFactory = _$OwnerOverrideToJson;
  Map<String, dynamic> toJson() => _$OwnerOverrideToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is OwnerOverride &&
            (identical(other.names, names) ||
                const DeepCollectionEquality().equals(other.names, names)) &&
            (identical(other.phoneNumbers, phoneNumbers) ||
                const DeepCollectionEquality()
                    .equals(other.phoneNumbers, phoneNumbers)) &&
            (identical(other.emails, emails) ||
                const DeepCollectionEquality().equals(other.emails, emails)) &&
            (identical(other.addresses, addresses) ||
                const DeepCollectionEquality()
                    .equals(other.addresses, addresses)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(names) ^
      const DeepCollectionEquality().hash(phoneNumbers) ^
      const DeepCollectionEquality().hash(emails) ^
      const DeepCollectionEquality().hash(addresses) ^
      runtimeType.hashCode;
}

extension $OwnerOverrideExtension on OwnerOverride {
  OwnerOverride copyWith(
      {List<String>? names,
      List<PhoneNumber>? phoneNumbers,
      List<Email>? emails,
      List<Address>? addresses}) {
    return OwnerOverride(
        names: names ?? this.names,
        phoneNumbers: phoneNumbers ?? this.phoneNumbers,
        emails: emails ?? this.emails,
        addresses: addresses ?? this.addresses);
  }

  OwnerOverride copyWithWrapped(
      {Wrapped<List<String>>? names,
      Wrapped<List<PhoneNumber>>? phoneNumbers,
      Wrapped<List<Email>>? emails,
      Wrapped<List<Address>>? addresses}) {
    return OwnerOverride(
        names: (names != null ? names.value : this.names),
        phoneNumbers:
            (phoneNumbers != null ? phoneNumbers.value : this.phoneNumbers),
        emails: (emails != null ? emails.value : this.emails),
        addresses: (addresses != null ? addresses.value : this.addresses));
  }
}

@JsonSerializable(explicitToJson: true)
class LiabilitiesObject {
  LiabilitiesObject({
    required this.credit,
    required this.mortgage,
    required this.student,
  });

  factory LiabilitiesObject.fromJson(Map<String, dynamic> json) =>
      _$LiabilitiesObjectFromJson(json);

  @JsonKey(name: 'credit', defaultValue: <CreditCardLiability>[])
  final List<CreditCardLiability>? credit;
  @JsonKey(name: 'mortgage', defaultValue: <MortgageLiability>[])
  final List<MortgageLiability>? mortgage;
  @JsonKey(name: 'student', defaultValue: <StudentLoan>[])
  final List<StudentLoan>? student;
  static const fromJsonFactory = _$LiabilitiesObjectFromJson;
  static const toJsonFactory = _$LiabilitiesObjectToJson;
  Map<String, dynamic> toJson() => _$LiabilitiesObjectToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LiabilitiesObject &&
            (identical(other.credit, credit) ||
                const DeepCollectionEquality().equals(other.credit, credit)) &&
            (identical(other.mortgage, mortgage) ||
                const DeepCollectionEquality()
                    .equals(other.mortgage, mortgage)) &&
            (identical(other.student, student) ||
                const DeepCollectionEquality().equals(other.student, student)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(credit) ^
      const DeepCollectionEquality().hash(mortgage) ^
      const DeepCollectionEquality().hash(student) ^
      runtimeType.hashCode;
}

extension $LiabilitiesObjectExtension on LiabilitiesObject {
  LiabilitiesObject copyWith(
      {List<CreditCardLiability>? credit,
      List<MortgageLiability>? mortgage,
      List<StudentLoan>? student}) {
    return LiabilitiesObject(
        credit: credit ?? this.credit,
        mortgage: mortgage ?? this.mortgage,
        student: student ?? this.student);
  }

  LiabilitiesObject copyWithWrapped(
      {Wrapped<List<CreditCardLiability>?>? credit,
      Wrapped<List<MortgageLiability>?>? mortgage,
      Wrapped<List<StudentLoan>?>? student}) {
    return LiabilitiesObject(
        credit: (credit != null ? credit.value : this.credit),
        mortgage: (mortgage != null ? mortgage.value : this.mortgage),
        student: (student != null ? student.value : this.student));
  }
}

@JsonSerializable(explicitToJson: true)
class StudentLoan {
  StudentLoan({
    required this.accountId,
    required this.accountNumber,
    required this.disbursementDates,
    required this.expectedPayoffDate,
    required this.guarantor,
    required this.interestRatePercentage,
    required this.isOverdue,
    required this.lastPaymentAmount,
    required this.lastPaymentDate,
    required this.lastStatementIssueDate,
    required this.loanName,
    required this.loanStatus,
    required this.minimumPaymentAmount,
    required this.nextPaymentDueDate,
    required this.originationDate,
    required this.originationPrincipalAmount,
    required this.outstandingInterestAmount,
    required this.paymentReferenceNumber,
    required this.pslfStatus,
    required this.repaymentPlan,
    required this.sequenceNumber,
    required this.servicerAddress,
    required this.ytdInterestPaid,
    required this.ytdPrincipalPaid,
  });

  factory StudentLoan.fromJson(Map<String, dynamic> json) =>
      _$StudentLoanFromJson(json);

  @JsonKey(name: 'account_id')
  final String? accountId;
  @JsonKey(name: 'account_number')
  final String? accountNumber;
  @JsonKey(name: 'disbursement_dates', defaultValue: <DateTime>[])
  final List<DateTime>? disbursementDates;
  @JsonKey(name: 'expected_payoff_date', toJson: _dateToJson)
  final DateTime? expectedPayoffDate;
  @JsonKey(name: 'guarantor')
  final String? guarantor;
  @JsonKey(name: 'interest_rate_percentage')
  final double interestRatePercentage;
  @JsonKey(name: 'is_overdue')
  final bool? isOverdue;
  @JsonKey(name: 'last_payment_amount')
  final double? lastPaymentAmount;
  @JsonKey(name: 'last_payment_date', toJson: _dateToJson)
  final DateTime? lastPaymentDate;
  @JsonKey(name: 'last_statement_issue_date', toJson: _dateToJson)
  final DateTime? lastStatementIssueDate;
  @JsonKey(name: 'loan_name')
  final String? loanName;
  @JsonKey(name: 'loan_status')
  final StudentLoanStatus loanStatus;
  @JsonKey(name: 'minimum_payment_amount')
  final double? minimumPaymentAmount;
  @JsonKey(name: 'next_payment_due_date', toJson: _dateToJson)
  final DateTime? nextPaymentDueDate;
  @JsonKey(name: 'origination_date', toJson: _dateToJson)
  final DateTime? originationDate;
  @JsonKey(name: 'origination_principal_amount')
  final double? originationPrincipalAmount;
  @JsonKey(name: 'outstanding_interest_amount')
  final double? outstandingInterestAmount;
  @JsonKey(name: 'payment_reference_number')
  final String? paymentReferenceNumber;
  @JsonKey(name: 'pslf_status')
  final PSLFStatus pslfStatus;
  @JsonKey(name: 'repayment_plan')
  final StudentRepaymentPlan repaymentPlan;
  @JsonKey(name: 'sequence_number')
  final String? sequenceNumber;
  @JsonKey(name: 'servicer_address')
  final ServicerAddressData servicerAddress;
  @JsonKey(name: 'ytd_interest_paid')
  final double? ytdInterestPaid;
  @JsonKey(name: 'ytd_principal_paid')
  final double? ytdPrincipalPaid;
  static const fromJsonFactory = _$StudentLoanFromJson;
  static const toJsonFactory = _$StudentLoanToJson;
  Map<String, dynamic> toJson() => _$StudentLoanToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is StudentLoan &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.accountNumber, accountNumber) ||
                const DeepCollectionEquality()
                    .equals(other.accountNumber, accountNumber)) &&
            (identical(other.disbursementDates, disbursementDates) ||
                const DeepCollectionEquality()
                    .equals(other.disbursementDates, disbursementDates)) &&
            (identical(other.expectedPayoffDate, expectedPayoffDate) ||
                const DeepCollectionEquality()
                    .equals(other.expectedPayoffDate, expectedPayoffDate)) &&
            (identical(other.guarantor, guarantor) ||
                const DeepCollectionEquality()
                    .equals(other.guarantor, guarantor)) &&
            (identical(other.interestRatePercentage, interestRatePercentage) ||
                const DeepCollectionEquality().equals(
                    other.interestRatePercentage, interestRatePercentage)) &&
            (identical(other.isOverdue, isOverdue) ||
                const DeepCollectionEquality()
                    .equals(other.isOverdue, isOverdue)) &&
            (identical(other.lastPaymentAmount, lastPaymentAmount) ||
                const DeepCollectionEquality()
                    .equals(other.lastPaymentAmount, lastPaymentAmount)) &&
            (identical(other.lastPaymentDate, lastPaymentDate) ||
                const DeepCollectionEquality()
                    .equals(other.lastPaymentDate, lastPaymentDate)) &&
            (identical(other.lastStatementIssueDate, lastStatementIssueDate) ||
                const DeepCollectionEquality().equals(
                    other.lastStatementIssueDate, lastStatementIssueDate)) &&
            (identical(other.loanName, loanName) ||
                const DeepCollectionEquality()
                    .equals(other.loanName, loanName)) &&
            (identical(other.loanStatus, loanStatus) ||
                const DeepCollectionEquality()
                    .equals(other.loanStatus, loanStatus)) &&
            (identical(other.minimumPaymentAmount, minimumPaymentAmount) ||
                const DeepCollectionEquality().equals(
                    other.minimumPaymentAmount, minimumPaymentAmount)) &&
            (identical(other.nextPaymentDueDate, nextPaymentDueDate) ||
                const DeepCollectionEquality()
                    .equals(other.nextPaymentDueDate, nextPaymentDueDate)) &&
            (identical(other.originationDate, originationDate) ||
                const DeepCollectionEquality()
                    .equals(other.originationDate, originationDate)) &&
            (identical(other.originationPrincipalAmount, originationPrincipalAmount) ||
                const DeepCollectionEquality().equals(
                    other.originationPrincipalAmount,
                    originationPrincipalAmount)) &&
            (identical(other.outstandingInterestAmount, outstandingInterestAmount) ||
                const DeepCollectionEquality().equals(
                    other.outstandingInterestAmount,
                    outstandingInterestAmount)) &&
            (identical(other.paymentReferenceNumber, paymentReferenceNumber) ||
                const DeepCollectionEquality().equals(
                    other.paymentReferenceNumber, paymentReferenceNumber)) &&
            (identical(other.pslfStatus, pslfStatus) ||
                const DeepCollectionEquality()
                    .equals(other.pslfStatus, pslfStatus)) &&
            (identical(other.repaymentPlan, repaymentPlan) || const DeepCollectionEquality().equals(other.repaymentPlan, repaymentPlan)) &&
            (identical(other.sequenceNumber, sequenceNumber) || const DeepCollectionEquality().equals(other.sequenceNumber, sequenceNumber)) &&
            (identical(other.servicerAddress, servicerAddress) || const DeepCollectionEquality().equals(other.servicerAddress, servicerAddress)) &&
            (identical(other.ytdInterestPaid, ytdInterestPaid) || const DeepCollectionEquality().equals(other.ytdInterestPaid, ytdInterestPaid)) &&
            (identical(other.ytdPrincipalPaid, ytdPrincipalPaid) || const DeepCollectionEquality().equals(other.ytdPrincipalPaid, ytdPrincipalPaid)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(accountNumber) ^
      const DeepCollectionEquality().hash(disbursementDates) ^
      const DeepCollectionEquality().hash(expectedPayoffDate) ^
      const DeepCollectionEquality().hash(guarantor) ^
      const DeepCollectionEquality().hash(interestRatePercentage) ^
      const DeepCollectionEquality().hash(isOverdue) ^
      const DeepCollectionEquality().hash(lastPaymentAmount) ^
      const DeepCollectionEquality().hash(lastPaymentDate) ^
      const DeepCollectionEquality().hash(lastStatementIssueDate) ^
      const DeepCollectionEquality().hash(loanName) ^
      const DeepCollectionEquality().hash(loanStatus) ^
      const DeepCollectionEquality().hash(minimumPaymentAmount) ^
      const DeepCollectionEquality().hash(nextPaymentDueDate) ^
      const DeepCollectionEquality().hash(originationDate) ^
      const DeepCollectionEquality().hash(originationPrincipalAmount) ^
      const DeepCollectionEquality().hash(outstandingInterestAmount) ^
      const DeepCollectionEquality().hash(paymentReferenceNumber) ^
      const DeepCollectionEquality().hash(pslfStatus) ^
      const DeepCollectionEquality().hash(repaymentPlan) ^
      const DeepCollectionEquality().hash(sequenceNumber) ^
      const DeepCollectionEquality().hash(servicerAddress) ^
      const DeepCollectionEquality().hash(ytdInterestPaid) ^
      const DeepCollectionEquality().hash(ytdPrincipalPaid) ^
      runtimeType.hashCode;
}

extension $StudentLoanExtension on StudentLoan {
  StudentLoan copyWith(
      {String? accountId,
      String? accountNumber,
      List<DateTime>? disbursementDates,
      DateTime? expectedPayoffDate,
      String? guarantor,
      double? interestRatePercentage,
      bool? isOverdue,
      double? lastPaymentAmount,
      DateTime? lastPaymentDate,
      DateTime? lastStatementIssueDate,
      String? loanName,
      StudentLoanStatus? loanStatus,
      double? minimumPaymentAmount,
      DateTime? nextPaymentDueDate,
      DateTime? originationDate,
      double? originationPrincipalAmount,
      double? outstandingInterestAmount,
      String? paymentReferenceNumber,
      PSLFStatus? pslfStatus,
      StudentRepaymentPlan? repaymentPlan,
      String? sequenceNumber,
      ServicerAddressData? servicerAddress,
      double? ytdInterestPaid,
      double? ytdPrincipalPaid}) {
    return StudentLoan(
        accountId: accountId ?? this.accountId,
        accountNumber: accountNumber ?? this.accountNumber,
        disbursementDates: disbursementDates ?? this.disbursementDates,
        expectedPayoffDate: expectedPayoffDate ?? this.expectedPayoffDate,
        guarantor: guarantor ?? this.guarantor,
        interestRatePercentage:
            interestRatePercentage ?? this.interestRatePercentage,
        isOverdue: isOverdue ?? this.isOverdue,
        lastPaymentAmount: lastPaymentAmount ?? this.lastPaymentAmount,
        lastPaymentDate: lastPaymentDate ?? this.lastPaymentDate,
        lastStatementIssueDate:
            lastStatementIssueDate ?? this.lastStatementIssueDate,
        loanName: loanName ?? this.loanName,
        loanStatus: loanStatus ?? this.loanStatus,
        minimumPaymentAmount: minimumPaymentAmount ?? this.minimumPaymentAmount,
        nextPaymentDueDate: nextPaymentDueDate ?? this.nextPaymentDueDate,
        originationDate: originationDate ?? this.originationDate,
        originationPrincipalAmount:
            originationPrincipalAmount ?? this.originationPrincipalAmount,
        outstandingInterestAmount:
            outstandingInterestAmount ?? this.outstandingInterestAmount,
        paymentReferenceNumber:
            paymentReferenceNumber ?? this.paymentReferenceNumber,
        pslfStatus: pslfStatus ?? this.pslfStatus,
        repaymentPlan: repaymentPlan ?? this.repaymentPlan,
        sequenceNumber: sequenceNumber ?? this.sequenceNumber,
        servicerAddress: servicerAddress ?? this.servicerAddress,
        ytdInterestPaid: ytdInterestPaid ?? this.ytdInterestPaid,
        ytdPrincipalPaid: ytdPrincipalPaid ?? this.ytdPrincipalPaid);
  }

  StudentLoan copyWithWrapped(
      {Wrapped<String?>? accountId,
      Wrapped<String?>? accountNumber,
      Wrapped<List<DateTime>?>? disbursementDates,
      Wrapped<DateTime?>? expectedPayoffDate,
      Wrapped<String?>? guarantor,
      Wrapped<double>? interestRatePercentage,
      Wrapped<bool?>? isOverdue,
      Wrapped<double?>? lastPaymentAmount,
      Wrapped<DateTime?>? lastPaymentDate,
      Wrapped<DateTime?>? lastStatementIssueDate,
      Wrapped<String?>? loanName,
      Wrapped<StudentLoanStatus>? loanStatus,
      Wrapped<double?>? minimumPaymentAmount,
      Wrapped<DateTime?>? nextPaymentDueDate,
      Wrapped<DateTime?>? originationDate,
      Wrapped<double?>? originationPrincipalAmount,
      Wrapped<double?>? outstandingInterestAmount,
      Wrapped<String?>? paymentReferenceNumber,
      Wrapped<PSLFStatus>? pslfStatus,
      Wrapped<StudentRepaymentPlan>? repaymentPlan,
      Wrapped<String?>? sequenceNumber,
      Wrapped<ServicerAddressData>? servicerAddress,
      Wrapped<double?>? ytdInterestPaid,
      Wrapped<double?>? ytdPrincipalPaid}) {
    return StudentLoan(
        accountId: (accountId != null ? accountId.value : this.accountId),
        accountNumber:
            (accountNumber != null ? accountNumber.value : this.accountNumber),
        disbursementDates: (disbursementDates != null
            ? disbursementDates.value
            : this.disbursementDates),
        expectedPayoffDate: (expectedPayoffDate != null
            ? expectedPayoffDate.value
            : this.expectedPayoffDate),
        guarantor: (guarantor != null ? guarantor.value : this.guarantor),
        interestRatePercentage: (interestRatePercentage != null
            ? interestRatePercentage.value
            : this.interestRatePercentage),
        isOverdue: (isOverdue != null ? isOverdue.value : this.isOverdue),
        lastPaymentAmount: (lastPaymentAmount != null
            ? lastPaymentAmount.value
            : this.lastPaymentAmount),
        lastPaymentDate: (lastPaymentDate != null
            ? lastPaymentDate.value
            : this.lastPaymentDate),
        lastStatementIssueDate: (lastStatementIssueDate != null
            ? lastStatementIssueDate.value
            : this.lastStatementIssueDate),
        loanName: (loanName != null ? loanName.value : this.loanName),
        loanStatus: (loanStatus != null ? loanStatus.value : this.loanStatus),
        minimumPaymentAmount: (minimumPaymentAmount != null
            ? minimumPaymentAmount.value
            : this.minimumPaymentAmount),
        nextPaymentDueDate: (nextPaymentDueDate != null
            ? nextPaymentDueDate.value
            : this.nextPaymentDueDate),
        originationDate: (originationDate != null
            ? originationDate.value
            : this.originationDate),
        originationPrincipalAmount: (originationPrincipalAmount != null
            ? originationPrincipalAmount.value
            : this.originationPrincipalAmount),
        outstandingInterestAmount: (outstandingInterestAmount != null
            ? outstandingInterestAmount.value
            : this.outstandingInterestAmount),
        paymentReferenceNumber: (paymentReferenceNumber != null
            ? paymentReferenceNumber.value
            : this.paymentReferenceNumber),
        pslfStatus: (pslfStatus != null ? pslfStatus.value : this.pslfStatus),
        repaymentPlan:
            (repaymentPlan != null ? repaymentPlan.value : this.repaymentPlan),
        sequenceNumber: (sequenceNumber != null
            ? sequenceNumber.value
            : this.sequenceNumber),
        servicerAddress: (servicerAddress != null
            ? servicerAddress.value
            : this.servicerAddress),
        ytdInterestPaid: (ytdInterestPaid != null
            ? ytdInterestPaid.value
            : this.ytdInterestPaid),
        ytdPrincipalPaid: (ytdPrincipalPaid != null
            ? ytdPrincipalPaid.value
            : this.ytdPrincipalPaid));
  }
}

@JsonSerializable(explicitToJson: true)
class CreditCardLiability {
  CreditCardLiability({
    required this.accountId,
    required this.aprs,
    required this.isOverdue,
    required this.lastPaymentAmount,
    required this.lastPaymentDate,
    required this.lastStatementIssueDate,
    required this.lastStatementBalance,
    required this.minimumPaymentAmount,
    required this.nextPaymentDueDate,
  });

  factory CreditCardLiability.fromJson(Map<String, dynamic> json) =>
      _$CreditCardLiabilityFromJson(json);

  @JsonKey(name: 'account_id')
  final String? accountId;
  @JsonKey(name: 'aprs', defaultValue: <Apr>[])
  final List<Apr> aprs;
  @JsonKey(name: 'is_overdue')
  final bool? isOverdue;
  @JsonKey(name: 'last_payment_amount')
  final double? lastPaymentAmount;
  @JsonKey(name: 'last_payment_date', toJson: _dateToJson)
  final DateTime? lastPaymentDate;
  @JsonKey(name: 'last_statement_issue_date', toJson: _dateToJson)
  final DateTime? lastStatementIssueDate;
  @JsonKey(name: 'last_statement_balance')
  final double? lastStatementBalance;
  @JsonKey(name: 'minimum_payment_amount')
  final double? minimumPaymentAmount;
  @JsonKey(name: 'next_payment_due_date', toJson: _dateToJson)
  final DateTime? nextPaymentDueDate;
  static const fromJsonFactory = _$CreditCardLiabilityFromJson;
  static const toJsonFactory = _$CreditCardLiabilityToJson;
  Map<String, dynamic> toJson() => _$CreditCardLiabilityToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CreditCardLiability &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.aprs, aprs) ||
                const DeepCollectionEquality().equals(other.aprs, aprs)) &&
            (identical(other.isOverdue, isOverdue) ||
                const DeepCollectionEquality()
                    .equals(other.isOverdue, isOverdue)) &&
            (identical(other.lastPaymentAmount, lastPaymentAmount) ||
                const DeepCollectionEquality()
                    .equals(other.lastPaymentAmount, lastPaymentAmount)) &&
            (identical(other.lastPaymentDate, lastPaymentDate) ||
                const DeepCollectionEquality()
                    .equals(other.lastPaymentDate, lastPaymentDate)) &&
            (identical(other.lastStatementIssueDate, lastStatementIssueDate) ||
                const DeepCollectionEquality().equals(
                    other.lastStatementIssueDate, lastStatementIssueDate)) &&
            (identical(other.lastStatementBalance, lastStatementBalance) ||
                const DeepCollectionEquality().equals(
                    other.lastStatementBalance, lastStatementBalance)) &&
            (identical(other.minimumPaymentAmount, minimumPaymentAmount) ||
                const DeepCollectionEquality().equals(
                    other.minimumPaymentAmount, minimumPaymentAmount)) &&
            (identical(other.nextPaymentDueDate, nextPaymentDueDate) ||
                const DeepCollectionEquality()
                    .equals(other.nextPaymentDueDate, nextPaymentDueDate)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(aprs) ^
      const DeepCollectionEquality().hash(isOverdue) ^
      const DeepCollectionEquality().hash(lastPaymentAmount) ^
      const DeepCollectionEquality().hash(lastPaymentDate) ^
      const DeepCollectionEquality().hash(lastStatementIssueDate) ^
      const DeepCollectionEquality().hash(lastStatementBalance) ^
      const DeepCollectionEquality().hash(minimumPaymentAmount) ^
      const DeepCollectionEquality().hash(nextPaymentDueDate) ^
      runtimeType.hashCode;
}

extension $CreditCardLiabilityExtension on CreditCardLiability {
  CreditCardLiability copyWith(
      {String? accountId,
      List<Apr>? aprs,
      bool? isOverdue,
      double? lastPaymentAmount,
      DateTime? lastPaymentDate,
      DateTime? lastStatementIssueDate,
      double? lastStatementBalance,
      double? minimumPaymentAmount,
      DateTime? nextPaymentDueDate}) {
    return CreditCardLiability(
        accountId: accountId ?? this.accountId,
        aprs: aprs ?? this.aprs,
        isOverdue: isOverdue ?? this.isOverdue,
        lastPaymentAmount: lastPaymentAmount ?? this.lastPaymentAmount,
        lastPaymentDate: lastPaymentDate ?? this.lastPaymentDate,
        lastStatementIssueDate:
            lastStatementIssueDate ?? this.lastStatementIssueDate,
        lastStatementBalance: lastStatementBalance ?? this.lastStatementBalance,
        minimumPaymentAmount: minimumPaymentAmount ?? this.minimumPaymentAmount,
        nextPaymentDueDate: nextPaymentDueDate ?? this.nextPaymentDueDate);
  }

  CreditCardLiability copyWithWrapped(
      {Wrapped<String?>? accountId,
      Wrapped<List<Apr>>? aprs,
      Wrapped<bool?>? isOverdue,
      Wrapped<double?>? lastPaymentAmount,
      Wrapped<DateTime?>? lastPaymentDate,
      Wrapped<DateTime?>? lastStatementIssueDate,
      Wrapped<double?>? lastStatementBalance,
      Wrapped<double?>? minimumPaymentAmount,
      Wrapped<DateTime?>? nextPaymentDueDate}) {
    return CreditCardLiability(
        accountId: (accountId != null ? accountId.value : this.accountId),
        aprs: (aprs != null ? aprs.value : this.aprs),
        isOverdue: (isOverdue != null ? isOverdue.value : this.isOverdue),
        lastPaymentAmount: (lastPaymentAmount != null
            ? lastPaymentAmount.value
            : this.lastPaymentAmount),
        lastPaymentDate: (lastPaymentDate != null
            ? lastPaymentDate.value
            : this.lastPaymentDate),
        lastStatementIssueDate: (lastStatementIssueDate != null
            ? lastStatementIssueDate.value
            : this.lastStatementIssueDate),
        lastStatementBalance: (lastStatementBalance != null
            ? lastStatementBalance.value
            : this.lastStatementBalance),
        minimumPaymentAmount: (minimumPaymentAmount != null
            ? minimumPaymentAmount.value
            : this.minimumPaymentAmount),
        nextPaymentDueDate: (nextPaymentDueDate != null
            ? nextPaymentDueDate.value
            : this.nextPaymentDueDate));
  }
}

@JsonSerializable(explicitToJson: true)
class MortgageLiability {
  MortgageLiability({
    required this.accountId,
    required this.accountNumber,
    required this.currentLateFee,
    required this.escrowBalance,
    required this.hasPmi,
    required this.hasPrepaymentPenalty,
    required this.interestRate,
    required this.lastPaymentAmount,
    required this.lastPaymentDate,
    required this.loanTypeDescription,
    required this.loanTerm,
    required this.maturityDate,
    required this.nextMonthlyPayment,
    required this.nextPaymentDueDate,
    required this.originationDate,
    required this.originationPrincipalAmount,
    required this.pastDueAmount,
    required this.propertyAddress,
    required this.ytdInterestPaid,
    required this.ytdPrincipalPaid,
  });

  factory MortgageLiability.fromJson(Map<String, dynamic> json) =>
      _$MortgageLiabilityFromJson(json);

  @JsonKey(name: 'account_id')
  final String accountId;
  @JsonKey(name: 'account_number')
  final String accountNumber;
  @JsonKey(name: 'current_late_fee')
  final double? currentLateFee;
  @JsonKey(name: 'escrow_balance')
  final double? escrowBalance;
  @JsonKey(name: 'has_pmi')
  final bool? hasPmi;
  @JsonKey(name: 'has_prepayment_penalty')
  final bool? hasPrepaymentPenalty;
  @JsonKey(name: 'interest_rate')
  final MortgageInterestRate interestRate;
  @JsonKey(name: 'last_payment_amount')
  final double? lastPaymentAmount;
  @JsonKey(name: 'last_payment_date', toJson: _dateToJson)
  final DateTime? lastPaymentDate;
  @JsonKey(name: 'loan_type_description')
  final String? loanTypeDescription;
  @JsonKey(name: 'loan_term')
  final String? loanTerm;
  @JsonKey(name: 'maturity_date', toJson: _dateToJson)
  final DateTime? maturityDate;
  @JsonKey(name: 'next_monthly_payment')
  final double? nextMonthlyPayment;
  @JsonKey(name: 'next_payment_due_date', toJson: _dateToJson)
  final DateTime? nextPaymentDueDate;
  @JsonKey(name: 'origination_date', toJson: _dateToJson)
  final DateTime? originationDate;
  @JsonKey(name: 'origination_principal_amount')
  final double? originationPrincipalAmount;
  @JsonKey(name: 'past_due_amount')
  final double? pastDueAmount;
  @JsonKey(name: 'property_address')
  final MortgagePropertyAddress propertyAddress;
  @JsonKey(name: 'ytd_interest_paid')
  final double? ytdInterestPaid;
  @JsonKey(name: 'ytd_principal_paid')
  final double? ytdPrincipalPaid;
  static const fromJsonFactory = _$MortgageLiabilityFromJson;
  static const toJsonFactory = _$MortgageLiabilityToJson;
  Map<String, dynamic> toJson() => _$MortgageLiabilityToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is MortgageLiability &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.accountNumber, accountNumber) ||
                const DeepCollectionEquality()
                    .equals(other.accountNumber, accountNumber)) &&
            (identical(other.currentLateFee, currentLateFee) ||
                const DeepCollectionEquality()
                    .equals(other.currentLateFee, currentLateFee)) &&
            (identical(other.escrowBalance, escrowBalance) ||
                const DeepCollectionEquality()
                    .equals(other.escrowBalance, escrowBalance)) &&
            (identical(other.hasPmi, hasPmi) ||
                const DeepCollectionEquality().equals(other.hasPmi, hasPmi)) &&
            (identical(other.hasPrepaymentPenalty, hasPrepaymentPenalty) ||
                const DeepCollectionEquality().equals(
                    other.hasPrepaymentPenalty, hasPrepaymentPenalty)) &&
            (identical(other.interestRate, interestRate) ||
                const DeepCollectionEquality()
                    .equals(other.interestRate, interestRate)) &&
            (identical(other.lastPaymentAmount, lastPaymentAmount) ||
                const DeepCollectionEquality()
                    .equals(other.lastPaymentAmount, lastPaymentAmount)) &&
            (identical(other.lastPaymentDate, lastPaymentDate) ||
                const DeepCollectionEquality()
                    .equals(other.lastPaymentDate, lastPaymentDate)) &&
            (identical(other.loanTypeDescription, loanTypeDescription) ||
                const DeepCollectionEquality()
                    .equals(other.loanTypeDescription, loanTypeDescription)) &&
            (identical(other.loanTerm, loanTerm) ||
                const DeepCollectionEquality()
                    .equals(other.loanTerm, loanTerm)) &&
            (identical(other.maturityDate, maturityDate) ||
                const DeepCollectionEquality()
                    .equals(other.maturityDate, maturityDate)) &&
            (identical(other.nextMonthlyPayment, nextMonthlyPayment) ||
                const DeepCollectionEquality()
                    .equals(other.nextMonthlyPayment, nextMonthlyPayment)) &&
            (identical(other.nextPaymentDueDate, nextPaymentDueDate) ||
                const DeepCollectionEquality()
                    .equals(other.nextPaymentDueDate, nextPaymentDueDate)) &&
            (identical(other.originationDate, originationDate) ||
                const DeepCollectionEquality()
                    .equals(other.originationDate, originationDate)) &&
            (identical(other.originationPrincipalAmount, originationPrincipalAmount) ||
                const DeepCollectionEquality().equals(
                    other.originationPrincipalAmount,
                    originationPrincipalAmount)) &&
            (identical(other.pastDueAmount, pastDueAmount) ||
                const DeepCollectionEquality()
                    .equals(other.pastDueAmount, pastDueAmount)) &&
            (identical(other.propertyAddress, propertyAddress) ||
                const DeepCollectionEquality()
                    .equals(other.propertyAddress, propertyAddress)) &&
            (identical(other.ytdInterestPaid, ytdInterestPaid) ||
                const DeepCollectionEquality()
                    .equals(other.ytdInterestPaid, ytdInterestPaid)) &&
            (identical(other.ytdPrincipalPaid, ytdPrincipalPaid) ||
                const DeepCollectionEquality()
                    .equals(other.ytdPrincipalPaid, ytdPrincipalPaid)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(accountNumber) ^
      const DeepCollectionEquality().hash(currentLateFee) ^
      const DeepCollectionEquality().hash(escrowBalance) ^
      const DeepCollectionEquality().hash(hasPmi) ^
      const DeepCollectionEquality().hash(hasPrepaymentPenalty) ^
      const DeepCollectionEquality().hash(interestRate) ^
      const DeepCollectionEquality().hash(lastPaymentAmount) ^
      const DeepCollectionEquality().hash(lastPaymentDate) ^
      const DeepCollectionEquality().hash(loanTypeDescription) ^
      const DeepCollectionEquality().hash(loanTerm) ^
      const DeepCollectionEquality().hash(maturityDate) ^
      const DeepCollectionEquality().hash(nextMonthlyPayment) ^
      const DeepCollectionEquality().hash(nextPaymentDueDate) ^
      const DeepCollectionEquality().hash(originationDate) ^
      const DeepCollectionEquality().hash(originationPrincipalAmount) ^
      const DeepCollectionEquality().hash(pastDueAmount) ^
      const DeepCollectionEquality().hash(propertyAddress) ^
      const DeepCollectionEquality().hash(ytdInterestPaid) ^
      const DeepCollectionEquality().hash(ytdPrincipalPaid) ^
      runtimeType.hashCode;
}

extension $MortgageLiabilityExtension on MortgageLiability {
  MortgageLiability copyWith(
      {String? accountId,
      String? accountNumber,
      double? currentLateFee,
      double? escrowBalance,
      bool? hasPmi,
      bool? hasPrepaymentPenalty,
      MortgageInterestRate? interestRate,
      double? lastPaymentAmount,
      DateTime? lastPaymentDate,
      String? loanTypeDescription,
      String? loanTerm,
      DateTime? maturityDate,
      double? nextMonthlyPayment,
      DateTime? nextPaymentDueDate,
      DateTime? originationDate,
      double? originationPrincipalAmount,
      double? pastDueAmount,
      MortgagePropertyAddress? propertyAddress,
      double? ytdInterestPaid,
      double? ytdPrincipalPaid}) {
    return MortgageLiability(
        accountId: accountId ?? this.accountId,
        accountNumber: accountNumber ?? this.accountNumber,
        currentLateFee: currentLateFee ?? this.currentLateFee,
        escrowBalance: escrowBalance ?? this.escrowBalance,
        hasPmi: hasPmi ?? this.hasPmi,
        hasPrepaymentPenalty: hasPrepaymentPenalty ?? this.hasPrepaymentPenalty,
        interestRate: interestRate ?? this.interestRate,
        lastPaymentAmount: lastPaymentAmount ?? this.lastPaymentAmount,
        lastPaymentDate: lastPaymentDate ?? this.lastPaymentDate,
        loanTypeDescription: loanTypeDescription ?? this.loanTypeDescription,
        loanTerm: loanTerm ?? this.loanTerm,
        maturityDate: maturityDate ?? this.maturityDate,
        nextMonthlyPayment: nextMonthlyPayment ?? this.nextMonthlyPayment,
        nextPaymentDueDate: nextPaymentDueDate ?? this.nextPaymentDueDate,
        originationDate: originationDate ?? this.originationDate,
        originationPrincipalAmount:
            originationPrincipalAmount ?? this.originationPrincipalAmount,
        pastDueAmount: pastDueAmount ?? this.pastDueAmount,
        propertyAddress: propertyAddress ?? this.propertyAddress,
        ytdInterestPaid: ytdInterestPaid ?? this.ytdInterestPaid,
        ytdPrincipalPaid: ytdPrincipalPaid ?? this.ytdPrincipalPaid);
  }

  MortgageLiability copyWithWrapped(
      {Wrapped<String>? accountId,
      Wrapped<String>? accountNumber,
      Wrapped<double?>? currentLateFee,
      Wrapped<double?>? escrowBalance,
      Wrapped<bool?>? hasPmi,
      Wrapped<bool?>? hasPrepaymentPenalty,
      Wrapped<MortgageInterestRate>? interestRate,
      Wrapped<double?>? lastPaymentAmount,
      Wrapped<DateTime?>? lastPaymentDate,
      Wrapped<String?>? loanTypeDescription,
      Wrapped<String?>? loanTerm,
      Wrapped<DateTime?>? maturityDate,
      Wrapped<double?>? nextMonthlyPayment,
      Wrapped<DateTime?>? nextPaymentDueDate,
      Wrapped<DateTime?>? originationDate,
      Wrapped<double?>? originationPrincipalAmount,
      Wrapped<double?>? pastDueAmount,
      Wrapped<MortgagePropertyAddress>? propertyAddress,
      Wrapped<double?>? ytdInterestPaid,
      Wrapped<double?>? ytdPrincipalPaid}) {
    return MortgageLiability(
        accountId: (accountId != null ? accountId.value : this.accountId),
        accountNumber:
            (accountNumber != null ? accountNumber.value : this.accountNumber),
        currentLateFee: (currentLateFee != null
            ? currentLateFee.value
            : this.currentLateFee),
        escrowBalance:
            (escrowBalance != null ? escrowBalance.value : this.escrowBalance),
        hasPmi: (hasPmi != null ? hasPmi.value : this.hasPmi),
        hasPrepaymentPenalty: (hasPrepaymentPenalty != null
            ? hasPrepaymentPenalty.value
            : this.hasPrepaymentPenalty),
        interestRate:
            (interestRate != null ? interestRate.value : this.interestRate),
        lastPaymentAmount: (lastPaymentAmount != null
            ? lastPaymentAmount.value
            : this.lastPaymentAmount),
        lastPaymentDate: (lastPaymentDate != null
            ? lastPaymentDate.value
            : this.lastPaymentDate),
        loanTypeDescription: (loanTypeDescription != null
            ? loanTypeDescription.value
            : this.loanTypeDescription),
        loanTerm: (loanTerm != null ? loanTerm.value : this.loanTerm),
        maturityDate:
            (maturityDate != null ? maturityDate.value : this.maturityDate),
        nextMonthlyPayment: (nextMonthlyPayment != null
            ? nextMonthlyPayment.value
            : this.nextMonthlyPayment),
        nextPaymentDueDate: (nextPaymentDueDate != null
            ? nextPaymentDueDate.value
            : this.nextPaymentDueDate),
        originationDate: (originationDate != null
            ? originationDate.value
            : this.originationDate),
        originationPrincipalAmount: (originationPrincipalAmount != null
            ? originationPrincipalAmount.value
            : this.originationPrincipalAmount),
        pastDueAmount:
            (pastDueAmount != null ? pastDueAmount.value : this.pastDueAmount),
        propertyAddress: (propertyAddress != null
            ? propertyAddress.value
            : this.propertyAddress),
        ytdInterestPaid: (ytdInterestPaid != null
            ? ytdInterestPaid.value
            : this.ytdInterestPaid),
        ytdPrincipalPaid: (ytdPrincipalPaid != null
            ? ytdPrincipalPaid.value
            : this.ytdPrincipalPaid));
  }
}

@JsonSerializable(explicitToJson: true)
class MortgageInterestRate {
  MortgageInterestRate({
    required this.percentage,
    required this.type,
  });

  factory MortgageInterestRate.fromJson(Map<String, dynamic> json) =>
      _$MortgageInterestRateFromJson(json);

  @JsonKey(name: 'percentage')
  final double? percentage;
  @JsonKey(name: 'type')
  final String? type;
  static const fromJsonFactory = _$MortgageInterestRateFromJson;
  static const toJsonFactory = _$MortgageInterestRateToJson;
  Map<String, dynamic> toJson() => _$MortgageInterestRateToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is MortgageInterestRate &&
            (identical(other.percentage, percentage) ||
                const DeepCollectionEquality()
                    .equals(other.percentage, percentage)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(percentage) ^
      const DeepCollectionEquality().hash(type) ^
      runtimeType.hashCode;
}

extension $MortgageInterestRateExtension on MortgageInterestRate {
  MortgageInterestRate copyWith({double? percentage, String? type}) {
    return MortgageInterestRate(
        percentage: percentage ?? this.percentage, type: type ?? this.type);
  }

  MortgageInterestRate copyWithWrapped(
      {Wrapped<double?>? percentage, Wrapped<String?>? type}) {
    return MortgageInterestRate(
        percentage: (percentage != null ? percentage.value : this.percentage),
        type: (type != null ? type.value : this.type));
  }
}

@JsonSerializable(explicitToJson: true)
class MortgagePropertyAddress {
  MortgagePropertyAddress({
    required this.city,
    required this.country,
    required this.postalCode,
    required this.region,
    required this.street,
  });

  factory MortgagePropertyAddress.fromJson(Map<String, dynamic> json) =>
      _$MortgagePropertyAddressFromJson(json);

  @JsonKey(name: 'city')
  final String? city;
  @JsonKey(name: 'country')
  final String? country;
  @JsonKey(name: 'postal_code')
  final String? postalCode;
  @JsonKey(name: 'region')
  final String? region;
  @JsonKey(name: 'street')
  final String? street;
  static const fromJsonFactory = _$MortgagePropertyAddressFromJson;
  static const toJsonFactory = _$MortgagePropertyAddressToJson;
  Map<String, dynamic> toJson() => _$MortgagePropertyAddressToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is MortgagePropertyAddress &&
            (identical(other.city, city) ||
                const DeepCollectionEquality().equals(other.city, city)) &&
            (identical(other.country, country) ||
                const DeepCollectionEquality()
                    .equals(other.country, country)) &&
            (identical(other.postalCode, postalCode) ||
                const DeepCollectionEquality()
                    .equals(other.postalCode, postalCode)) &&
            (identical(other.region, region) ||
                const DeepCollectionEquality().equals(other.region, region)) &&
            (identical(other.street, street) ||
                const DeepCollectionEquality().equals(other.street, street)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(city) ^
      const DeepCollectionEquality().hash(country) ^
      const DeepCollectionEquality().hash(postalCode) ^
      const DeepCollectionEquality().hash(region) ^
      const DeepCollectionEquality().hash(street) ^
      runtimeType.hashCode;
}

extension $MortgagePropertyAddressExtension on MortgagePropertyAddress {
  MortgagePropertyAddress copyWith(
      {String? city,
      String? country,
      String? postalCode,
      String? region,
      String? street}) {
    return MortgagePropertyAddress(
        city: city ?? this.city,
        country: country ?? this.country,
        postalCode: postalCode ?? this.postalCode,
        region: region ?? this.region,
        street: street ?? this.street);
  }

  MortgagePropertyAddress copyWithWrapped(
      {Wrapped<String?>? city,
      Wrapped<String?>? country,
      Wrapped<String?>? postalCode,
      Wrapped<String?>? region,
      Wrapped<String?>? street}) {
    return MortgagePropertyAddress(
        city: (city != null ? city.value : this.city),
        country: (country != null ? country.value : this.country),
        postalCode: (postalCode != null ? postalCode.value : this.postalCode),
        region: (region != null ? region.value : this.region),
        street: (street != null ? street.value : this.street));
  }
}

@JsonSerializable(explicitToJson: true)
class StudentLoanStatus {
  StudentLoanStatus({
    required this.endDate,
    required this.type,
  });

  factory StudentLoanStatus.fromJson(Map<String, dynamic> json) =>
      _$StudentLoanStatusFromJson(json);

  @JsonKey(name: 'end_date', toJson: _dateToJson)
  final DateTime? endDate;
  @JsonKey(
    name: 'type',
    toJson: studentLoanStatusTypeToJson,
    fromJson: studentLoanStatusTypeFromJson,
  )
  final enums.StudentLoanStatusType? type;
  static const fromJsonFactory = _$StudentLoanStatusFromJson;
  static const toJsonFactory = _$StudentLoanStatusToJson;
  Map<String, dynamic> toJson() => _$StudentLoanStatusToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is StudentLoanStatus &&
            (identical(other.endDate, endDate) ||
                const DeepCollectionEquality()
                    .equals(other.endDate, endDate)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(endDate) ^
      const DeepCollectionEquality().hash(type) ^
      runtimeType.hashCode;
}

extension $StudentLoanStatusExtension on StudentLoanStatus {
  StudentLoanStatus copyWith(
      {DateTime? endDate, enums.StudentLoanStatusType? type}) {
    return StudentLoanStatus(
        endDate: endDate ?? this.endDate, type: type ?? this.type);
  }

  StudentLoanStatus copyWithWrapped(
      {Wrapped<DateTime?>? endDate,
      Wrapped<enums.StudentLoanStatusType?>? type}) {
    return StudentLoanStatus(
        endDate: (endDate != null ? endDate.value : this.endDate),
        type: (type != null ? type.value : this.type));
  }
}

@JsonSerializable(explicitToJson: true)
class StudentRepaymentPlan {
  StudentRepaymentPlan({
    required this.description,
    required this.type,
  });

  factory StudentRepaymentPlan.fromJson(Map<String, dynamic> json) =>
      _$StudentRepaymentPlanFromJson(json);

  @JsonKey(name: 'description')
  final String? description;
  @JsonKey(
    name: 'type',
    toJson: studentRepaymentPlanTypeToJson,
    fromJson: studentRepaymentPlanTypeFromJson,
  )
  final enums.StudentRepaymentPlanType? type;
  static const fromJsonFactory = _$StudentRepaymentPlanFromJson;
  static const toJsonFactory = _$StudentRepaymentPlanToJson;
  Map<String, dynamic> toJson() => _$StudentRepaymentPlanToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is StudentRepaymentPlan &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(type) ^
      runtimeType.hashCode;
}

extension $StudentRepaymentPlanExtension on StudentRepaymentPlan {
  StudentRepaymentPlan copyWith(
      {String? description, enums.StudentRepaymentPlanType? type}) {
    return StudentRepaymentPlan(
        description: description ?? this.description, type: type ?? this.type);
  }

  StudentRepaymentPlan copyWithWrapped(
      {Wrapped<String?>? description,
      Wrapped<enums.StudentRepaymentPlanType?>? type}) {
    return StudentRepaymentPlan(
        description:
            (description != null ? description.value : this.description),
        type: (type != null ? type.value : this.type));
  }
}

@JsonSerializable(explicitToJson: true)
class PSLFStatus {
  PSLFStatus({
    required this.estimatedEligibilityDate,
    required this.paymentsMade,
    required this.paymentsRemaining,
  });

  factory PSLFStatus.fromJson(Map<String, dynamic> json) =>
      _$PSLFStatusFromJson(json);

  @JsonKey(name: 'estimated_eligibility_date', toJson: _dateToJson)
  final DateTime? estimatedEligibilityDate;
  @JsonKey(name: 'payments_made')
  final double? paymentsMade;
  @JsonKey(name: 'payments_remaining')
  final double? paymentsRemaining;
  static const fromJsonFactory = _$PSLFStatusFromJson;
  static const toJsonFactory = _$PSLFStatusToJson;
  Map<String, dynamic> toJson() => _$PSLFStatusToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PSLFStatus &&
            (identical(
                    other.estimatedEligibilityDate, estimatedEligibilityDate) ||
                const DeepCollectionEquality().equals(
                    other.estimatedEligibilityDate,
                    estimatedEligibilityDate)) &&
            (identical(other.paymentsMade, paymentsMade) ||
                const DeepCollectionEquality()
                    .equals(other.paymentsMade, paymentsMade)) &&
            (identical(other.paymentsRemaining, paymentsRemaining) ||
                const DeepCollectionEquality()
                    .equals(other.paymentsRemaining, paymentsRemaining)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(estimatedEligibilityDate) ^
      const DeepCollectionEquality().hash(paymentsMade) ^
      const DeepCollectionEquality().hash(paymentsRemaining) ^
      runtimeType.hashCode;
}

extension $PSLFStatusExtension on PSLFStatus {
  PSLFStatus copyWith(
      {DateTime? estimatedEligibilityDate,
      double? paymentsMade,
      double? paymentsRemaining}) {
    return PSLFStatus(
        estimatedEligibilityDate:
            estimatedEligibilityDate ?? this.estimatedEligibilityDate,
        paymentsMade: paymentsMade ?? this.paymentsMade,
        paymentsRemaining: paymentsRemaining ?? this.paymentsRemaining);
  }

  PSLFStatus copyWithWrapped(
      {Wrapped<DateTime?>? estimatedEligibilityDate,
      Wrapped<double?>? paymentsMade,
      Wrapped<double?>? paymentsRemaining}) {
    return PSLFStatus(
        estimatedEligibilityDate: (estimatedEligibilityDate != null
            ? estimatedEligibilityDate.value
            : this.estimatedEligibilityDate),
        paymentsMade:
            (paymentsMade != null ? paymentsMade.value : this.paymentsMade),
        paymentsRemaining: (paymentsRemaining != null
            ? paymentsRemaining.value
            : this.paymentsRemaining));
  }
}

@JsonSerializable(explicitToJson: true)
class ServicerAddressData {
  ServicerAddressData({
    required this.city,
    required this.region,
    required this.street,
    required this.postalCode,
    required this.country,
  });

  factory ServicerAddressData.fromJson(Map<String, dynamic> json) =>
      _$ServicerAddressDataFromJson(json);

  @JsonKey(name: 'city')
  final String? city;
  @JsonKey(name: 'region')
  final String? region;
  @JsonKey(name: 'street')
  final String? street;
  @JsonKey(name: 'postal_code')
  final String? postalCode;
  @JsonKey(name: 'country')
  final String? country;
  static const fromJsonFactory = _$ServicerAddressDataFromJson;
  static const toJsonFactory = _$ServicerAddressDataToJson;
  Map<String, dynamic> toJson() => _$ServicerAddressDataToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ServicerAddressData &&
            (identical(other.city, city) ||
                const DeepCollectionEquality().equals(other.city, city)) &&
            (identical(other.region, region) ||
                const DeepCollectionEquality().equals(other.region, region)) &&
            (identical(other.street, street) ||
                const DeepCollectionEquality().equals(other.street, street)) &&
            (identical(other.postalCode, postalCode) ||
                const DeepCollectionEquality()
                    .equals(other.postalCode, postalCode)) &&
            (identical(other.country, country) ||
                const DeepCollectionEquality().equals(other.country, country)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(city) ^
      const DeepCollectionEquality().hash(region) ^
      const DeepCollectionEquality().hash(street) ^
      const DeepCollectionEquality().hash(postalCode) ^
      const DeepCollectionEquality().hash(country) ^
      runtimeType.hashCode;
}

extension $ServicerAddressDataExtension on ServicerAddressData {
  ServicerAddressData copyWith(
      {String? city,
      String? region,
      String? street,
      String? postalCode,
      String? country}) {
    return ServicerAddressData(
        city: city ?? this.city,
        region: region ?? this.region,
        street: street ?? this.street,
        postalCode: postalCode ?? this.postalCode,
        country: country ?? this.country);
  }

  ServicerAddressData copyWithWrapped(
      {Wrapped<String?>? city,
      Wrapped<String?>? region,
      Wrapped<String?>? street,
      Wrapped<String?>? postalCode,
      Wrapped<String?>? country}) {
    return ServicerAddressData(
        city: (city != null ? city.value : this.city),
        region: (region != null ? region.value : this.region),
        street: (street != null ? street.value : this.street),
        postalCode: (postalCode != null ? postalCode.value : this.postalCode),
        country: (country != null ? country.value : this.country));
  }
}

@JsonSerializable(explicitToJson: true)
class Apr {
  Apr({
    required this.aprPercentage,
    required this.aprType,
    required this.balanceSubjectToApr,
    required this.interestChargeAmount,
  });

  factory Apr.fromJson(Map<String, dynamic> json) => _$AprFromJson(json);

  @JsonKey(name: 'apr_percentage')
  final double aprPercentage;
  @JsonKey(
    name: 'apr_type',
    toJson: aprAprTypeToJson,
    fromJson: aprAprTypeFromJson,
  )
  final enums.AprAprType aprType;
  @JsonKey(name: 'balance_subject_to_apr')
  final double? balanceSubjectToApr;
  @JsonKey(name: 'interest_charge_amount')
  final double? interestChargeAmount;
  static const fromJsonFactory = _$AprFromJson;
  static const toJsonFactory = _$AprToJson;
  Map<String, dynamic> toJson() => _$AprToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Apr &&
            (identical(other.aprPercentage, aprPercentage) ||
                const DeepCollectionEquality()
                    .equals(other.aprPercentage, aprPercentage)) &&
            (identical(other.aprType, aprType) ||
                const DeepCollectionEquality()
                    .equals(other.aprType, aprType)) &&
            (identical(other.balanceSubjectToApr, balanceSubjectToApr) ||
                const DeepCollectionEquality()
                    .equals(other.balanceSubjectToApr, balanceSubjectToApr)) &&
            (identical(other.interestChargeAmount, interestChargeAmount) ||
                const DeepCollectionEquality()
                    .equals(other.interestChargeAmount, interestChargeAmount)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(aprPercentage) ^
      const DeepCollectionEquality().hash(aprType) ^
      const DeepCollectionEquality().hash(balanceSubjectToApr) ^
      const DeepCollectionEquality().hash(interestChargeAmount) ^
      runtimeType.hashCode;
}

extension $AprExtension on Apr {
  Apr copyWith(
      {double? aprPercentage,
      enums.AprAprType? aprType,
      double? balanceSubjectToApr,
      double? interestChargeAmount}) {
    return Apr(
        aprPercentage: aprPercentage ?? this.aprPercentage,
        aprType: aprType ?? this.aprType,
        balanceSubjectToApr: balanceSubjectToApr ?? this.balanceSubjectToApr,
        interestChargeAmount:
            interestChargeAmount ?? this.interestChargeAmount);
  }

  Apr copyWithWrapped(
      {Wrapped<double>? aprPercentage,
      Wrapped<enums.AprAprType>? aprType,
      Wrapped<double?>? balanceSubjectToApr,
      Wrapped<double?>? interestChargeAmount}) {
    return Apr(
        aprPercentage:
            (aprPercentage != null ? aprPercentage.value : this.aprPercentage),
        aprType: (aprType != null ? aprType.value : this.aprType),
        balanceSubjectToApr: (balanceSubjectToApr != null
            ? balanceSubjectToApr.value
            : this.balanceSubjectToApr),
        interestChargeAmount: (interestChargeAmount != null
            ? interestChargeAmount.value
            : this.interestChargeAmount));
  }
}

@JsonSerializable(explicitToJson: true)
class AuthMetadata {
  AuthMetadata({
    required this.supportedMethods,
  });

  factory AuthMetadata.fromJson(Map<String, dynamic> json) =>
      _$AuthMetadataFromJson(json);

  @JsonKey(name: 'supported_methods')
  final AuthSupportedMethods? supportedMethods;
  static const fromJsonFactory = _$AuthMetadataFromJson;
  static const toJsonFactory = _$AuthMetadataToJson;
  Map<String, dynamic> toJson() => _$AuthMetadataToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AuthMetadata &&
            (identical(other.supportedMethods, supportedMethods) ||
                const DeepCollectionEquality()
                    .equals(other.supportedMethods, supportedMethods)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(supportedMethods) ^
      runtimeType.hashCode;
}

extension $AuthMetadataExtension on AuthMetadata {
  AuthMetadata copyWith({AuthSupportedMethods? supportedMethods}) {
    return AuthMetadata(
        supportedMethods: supportedMethods ?? this.supportedMethods);
  }

  AuthMetadata copyWithWrapped(
      {Wrapped<AuthSupportedMethods?>? supportedMethods}) {
    return AuthMetadata(
        supportedMethods: (supportedMethods != null
            ? supportedMethods.value
            : this.supportedMethods));
  }
}

@JsonSerializable(explicitToJson: true)
class AuthSupportedMethods {
  AuthSupportedMethods({
    required this.instantAuth,
    required this.instantMatch,
    required this.automatedMicroDeposits,
  });

  factory AuthSupportedMethods.fromJson(Map<String, dynamic> json) =>
      _$AuthSupportedMethodsFromJson(json);

  @JsonKey(name: 'instant_auth')
  final bool instantAuth;
  @JsonKey(name: 'instant_match')
  final bool instantMatch;
  @JsonKey(name: 'automated_micro_deposits')
  final bool automatedMicroDeposits;
  static const fromJsonFactory = _$AuthSupportedMethodsFromJson;
  static const toJsonFactory = _$AuthSupportedMethodsToJson;
  Map<String, dynamic> toJson() => _$AuthSupportedMethodsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AuthSupportedMethods &&
            (identical(other.instantAuth, instantAuth) ||
                const DeepCollectionEquality()
                    .equals(other.instantAuth, instantAuth)) &&
            (identical(other.instantMatch, instantMatch) ||
                const DeepCollectionEquality()
                    .equals(other.instantMatch, instantMatch)) &&
            (identical(other.automatedMicroDeposits, automatedMicroDeposits) ||
                const DeepCollectionEquality().equals(
                    other.automatedMicroDeposits, automatedMicroDeposits)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(instantAuth) ^
      const DeepCollectionEquality().hash(instantMatch) ^
      const DeepCollectionEquality().hash(automatedMicroDeposits) ^
      runtimeType.hashCode;
}

extension $AuthSupportedMethodsExtension on AuthSupportedMethods {
  AuthSupportedMethods copyWith(
      {bool? instantAuth, bool? instantMatch, bool? automatedMicroDeposits}) {
    return AuthSupportedMethods(
        instantAuth: instantAuth ?? this.instantAuth,
        instantMatch: instantMatch ?? this.instantMatch,
        automatedMicroDeposits:
            automatedMicroDeposits ?? this.automatedMicroDeposits);
  }

  AuthSupportedMethods copyWithWrapped(
      {Wrapped<bool>? instantAuth,
      Wrapped<bool>? instantMatch,
      Wrapped<bool>? automatedMicroDeposits}) {
    return AuthSupportedMethods(
        instantAuth:
            (instantAuth != null ? instantAuth.value : this.instantAuth),
        instantMatch:
            (instantMatch != null ? instantMatch.value : this.instantMatch),
        automatedMicroDeposits: (automatedMicroDeposits != null
            ? automatedMicroDeposits.value
            : this.automatedMicroDeposits));
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentInitiationMetadata {
  PaymentInitiationMetadata({
    required this.supportsInternationalPayments,
    required this.supportsSepaInstant,
    required this.maximumPaymentAmount,
    required this.supportsRefundDetails,
    required this.standingOrderMetadata,
  });

  factory PaymentInitiationMetadata.fromJson(Map<String, dynamic> json) =>
      _$PaymentInitiationMetadataFromJson(json);

  @JsonKey(name: 'supports_international_payments')
  final bool supportsInternationalPayments;
  @JsonKey(name: 'supports_sepa_instant')
  final bool supportsSepaInstant;
  @JsonKey(name: 'maximum_payment_amount')
  final PaymentInitiationMaximumPaymentAmount maximumPaymentAmount;
  @JsonKey(name: 'supports_refund_details')
  final bool supportsRefundDetails;
  @JsonKey(name: 'standing_order_metadata')
  final PaymentInitiationStandingOrderMetadata? standingOrderMetadata;
  static const fromJsonFactory = _$PaymentInitiationMetadataFromJson;
  static const toJsonFactory = _$PaymentInitiationMetadataToJson;
  Map<String, dynamic> toJson() => _$PaymentInitiationMetadataToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentInitiationMetadata &&
            (identical(other.supportsInternationalPayments,
                    supportsInternationalPayments) ||
                const DeepCollectionEquality().equals(
                    other.supportsInternationalPayments,
                    supportsInternationalPayments)) &&
            (identical(other.supportsSepaInstant, supportsSepaInstant) ||
                const DeepCollectionEquality()
                    .equals(other.supportsSepaInstant, supportsSepaInstant)) &&
            (identical(other.maximumPaymentAmount, maximumPaymentAmount) ||
                const DeepCollectionEquality().equals(
                    other.maximumPaymentAmount, maximumPaymentAmount)) &&
            (identical(other.supportsRefundDetails, supportsRefundDetails) ||
                const DeepCollectionEquality().equals(
                    other.supportsRefundDetails, supportsRefundDetails)) &&
            (identical(other.standingOrderMetadata, standingOrderMetadata) ||
                const DeepCollectionEquality().equals(
                    other.standingOrderMetadata, standingOrderMetadata)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(supportsInternationalPayments) ^
      const DeepCollectionEquality().hash(supportsSepaInstant) ^
      const DeepCollectionEquality().hash(maximumPaymentAmount) ^
      const DeepCollectionEquality().hash(supportsRefundDetails) ^
      const DeepCollectionEquality().hash(standingOrderMetadata) ^
      runtimeType.hashCode;
}

extension $PaymentInitiationMetadataExtension on PaymentInitiationMetadata {
  PaymentInitiationMetadata copyWith(
      {bool? supportsInternationalPayments,
      bool? supportsSepaInstant,
      PaymentInitiationMaximumPaymentAmount? maximumPaymentAmount,
      bool? supportsRefundDetails,
      PaymentInitiationStandingOrderMetadata? standingOrderMetadata}) {
    return PaymentInitiationMetadata(
        supportsInternationalPayments:
            supportsInternationalPayments ?? this.supportsInternationalPayments,
        supportsSepaInstant: supportsSepaInstant ?? this.supportsSepaInstant,
        maximumPaymentAmount: maximumPaymentAmount ?? this.maximumPaymentAmount,
        supportsRefundDetails:
            supportsRefundDetails ?? this.supportsRefundDetails,
        standingOrderMetadata:
            standingOrderMetadata ?? this.standingOrderMetadata);
  }

  PaymentInitiationMetadata copyWithWrapped(
      {Wrapped<bool>? supportsInternationalPayments,
      Wrapped<bool>? supportsSepaInstant,
      Wrapped<PaymentInitiationMaximumPaymentAmount>? maximumPaymentAmount,
      Wrapped<bool>? supportsRefundDetails,
      Wrapped<PaymentInitiationStandingOrderMetadata?>?
          standingOrderMetadata}) {
    return PaymentInitiationMetadata(
        supportsInternationalPayments: (supportsInternationalPayments != null
            ? supportsInternationalPayments.value
            : this.supportsInternationalPayments),
        supportsSepaInstant: (supportsSepaInstant != null
            ? supportsSepaInstant.value
            : this.supportsSepaInstant),
        maximumPaymentAmount: (maximumPaymentAmount != null
            ? maximumPaymentAmount.value
            : this.maximumPaymentAmount),
        supportsRefundDetails: (supportsRefundDetails != null
            ? supportsRefundDetails.value
            : this.supportsRefundDetails),
        standingOrderMetadata: (standingOrderMetadata != null
            ? standingOrderMetadata.value
            : this.standingOrderMetadata));
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentInitiationMaximumPaymentAmount {
  PaymentInitiationMaximumPaymentAmount();

  factory PaymentInitiationMaximumPaymentAmount.fromJson(
          Map<String, dynamic> json) =>
      _$PaymentInitiationMaximumPaymentAmountFromJson(json);

  static const fromJsonFactory =
      _$PaymentInitiationMaximumPaymentAmountFromJson;
  static const toJsonFactory = _$PaymentInitiationMaximumPaymentAmountToJson;
  Map<String, dynamic> toJson() =>
      _$PaymentInitiationMaximumPaymentAmountToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => runtimeType.hashCode;
}

@JsonSerializable(explicitToJson: true)
class PaymentInitiationStandingOrderMetadata {
  PaymentInitiationStandingOrderMetadata({
    required this.supportsStandingOrderEndDate,
    required this.supportsStandingOrderNegativeExecutionDays,
    required this.validStandingOrderIntervals,
  });

  factory PaymentInitiationStandingOrderMetadata.fromJson(
          Map<String, dynamic> json) =>
      _$PaymentInitiationStandingOrderMetadataFromJson(json);

  @JsonKey(name: 'supports_standing_order_end_date')
  final bool supportsStandingOrderEndDate;
  @JsonKey(name: 'supports_standing_order_negative_execution_days')
  final bool supportsStandingOrderNegativeExecutionDays;
  @JsonKey(
    name: 'valid_standing_order_intervals',
    toJson: paymentScheduleIntervalListToJson,
    fromJson: paymentScheduleIntervalListFromJson,
  )
  final List<enums.PaymentScheduleInterval> validStandingOrderIntervals;
  static const fromJsonFactory =
      _$PaymentInitiationStandingOrderMetadataFromJson;
  static const toJsonFactory = _$PaymentInitiationStandingOrderMetadataToJson;
  Map<String, dynamic> toJson() =>
      _$PaymentInitiationStandingOrderMetadataToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentInitiationStandingOrderMetadata &&
            (identical(other.supportsStandingOrderEndDate,
                    supportsStandingOrderEndDate) ||
                const DeepCollectionEquality().equals(
                    other.supportsStandingOrderEndDate,
                    supportsStandingOrderEndDate)) &&
            (identical(other.supportsStandingOrderNegativeExecutionDays,
                    supportsStandingOrderNegativeExecutionDays) ||
                const DeepCollectionEquality().equals(
                    other.supportsStandingOrderNegativeExecutionDays,
                    supportsStandingOrderNegativeExecutionDays)) &&
            (identical(other.validStandingOrderIntervals,
                    validStandingOrderIntervals) ||
                const DeepCollectionEquality().equals(
                    other.validStandingOrderIntervals,
                    validStandingOrderIntervals)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(supportsStandingOrderEndDate) ^
      const DeepCollectionEquality()
          .hash(supportsStandingOrderNegativeExecutionDays) ^
      const DeepCollectionEquality().hash(validStandingOrderIntervals) ^
      runtimeType.hashCode;
}

extension $PaymentInitiationStandingOrderMetadataExtension
    on PaymentInitiationStandingOrderMetadata {
  PaymentInitiationStandingOrderMetadata copyWith(
      {bool? supportsStandingOrderEndDate,
      bool? supportsStandingOrderNegativeExecutionDays,
      List<enums.PaymentScheduleInterval>? validStandingOrderIntervals}) {
    return PaymentInitiationStandingOrderMetadata(
        supportsStandingOrderEndDate:
            supportsStandingOrderEndDate ?? this.supportsStandingOrderEndDate,
        supportsStandingOrderNegativeExecutionDays:
            supportsStandingOrderNegativeExecutionDays ??
                this.supportsStandingOrderNegativeExecutionDays,
        validStandingOrderIntervals:
            validStandingOrderIntervals ?? this.validStandingOrderIntervals);
  }

  PaymentInitiationStandingOrderMetadata copyWithWrapped(
      {Wrapped<bool>? supportsStandingOrderEndDate,
      Wrapped<bool>? supportsStandingOrderNegativeExecutionDays,
      Wrapped<List<enums.PaymentScheduleInterval>>?
          validStandingOrderIntervals}) {
    return PaymentInitiationStandingOrderMetadata(
        supportsStandingOrderEndDate: (supportsStandingOrderEndDate != null
            ? supportsStandingOrderEndDate.value
            : this.supportsStandingOrderEndDate),
        supportsStandingOrderNegativeExecutionDays:
            (supportsStandingOrderNegativeExecutionDays != null
                ? supportsStandingOrderNegativeExecutionDays.value
                : this.supportsStandingOrderNegativeExecutionDays),
        validStandingOrderIntervals: (validStandingOrderIntervals != null
            ? validStandingOrderIntervals.value
            : this.validStandingOrderIntervals));
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentInitiationAddress {
  PaymentInitiationAddress({
    required this.street,
    required this.city,
    required this.postalCode,
    required this.country,
  });

  factory PaymentInitiationAddress.fromJson(Map<String, dynamic> json) =>
      _$PaymentInitiationAddressFromJson(json);

  @JsonKey(name: 'street', defaultValue: <String>[])
  final List<String> street;
  @JsonKey(name: 'city')
  final String city;
  @JsonKey(name: 'postal_code')
  final String postalCode;
  @JsonKey(name: 'country')
  final String country;
  static const fromJsonFactory = _$PaymentInitiationAddressFromJson;
  static const toJsonFactory = _$PaymentInitiationAddressToJson;
  Map<String, dynamic> toJson() => _$PaymentInitiationAddressToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentInitiationAddress &&
            (identical(other.street, street) ||
                const DeepCollectionEquality().equals(other.street, street)) &&
            (identical(other.city, city) ||
                const DeepCollectionEquality().equals(other.city, city)) &&
            (identical(other.postalCode, postalCode) ||
                const DeepCollectionEquality()
                    .equals(other.postalCode, postalCode)) &&
            (identical(other.country, country) ||
                const DeepCollectionEquality().equals(other.country, country)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(street) ^
      const DeepCollectionEquality().hash(city) ^
      const DeepCollectionEquality().hash(postalCode) ^
      const DeepCollectionEquality().hash(country) ^
      runtimeType.hashCode;
}

extension $PaymentInitiationAddressExtension on PaymentInitiationAddress {
  PaymentInitiationAddress copyWith(
      {List<String>? street,
      String? city,
      String? postalCode,
      String? country}) {
    return PaymentInitiationAddress(
        street: street ?? this.street,
        city: city ?? this.city,
        postalCode: postalCode ?? this.postalCode,
        country: country ?? this.country);
  }

  PaymentInitiationAddress copyWithWrapped(
      {Wrapped<List<String>>? street,
      Wrapped<String>? city,
      Wrapped<String>? postalCode,
      Wrapped<String>? country}) {
    return PaymentInitiationAddress(
        street: (street != null ? street.value : this.street),
        city: (city != null ? city.value : this.city),
        postalCode: (postalCode != null ? postalCode.value : this.postalCode),
        country: (country != null ? country.value : this.country));
  }
}

@JsonSerializable(explicitToJson: true)
class ExternalPaymentScheduleBase {
  ExternalPaymentScheduleBase({
    this.interval,
    this.intervalExecutionDay,
    this.startDate,
    this.endDate,
    this.adjustedStartDate,
  });

  factory ExternalPaymentScheduleBase.fromJson(Map<String, dynamic> json) =>
      _$ExternalPaymentScheduleBaseFromJson(json);

  @JsonKey(
    name: 'interval',
    toJson: paymentScheduleIntervalToJson,
    fromJson: paymentScheduleIntervalFromJson,
  )
  final enums.PaymentScheduleInterval? interval;
  @JsonKey(name: 'interval_execution_day')
  final int? intervalExecutionDay;
  @JsonKey(name: 'start_date', toJson: _dateToJson)
  final DateTime? startDate;
  @JsonKey(name: 'end_date', toJson: _dateToJson)
  final DateTime? endDate;
  @JsonKey(name: 'adjusted_start_date', toJson: _dateToJson)
  final DateTime? adjustedStartDate;
  static const fromJsonFactory = _$ExternalPaymentScheduleBaseFromJson;
  static const toJsonFactory = _$ExternalPaymentScheduleBaseToJson;
  Map<String, dynamic> toJson() => _$ExternalPaymentScheduleBaseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ExternalPaymentScheduleBase &&
            (identical(other.interval, interval) ||
                const DeepCollectionEquality()
                    .equals(other.interval, interval)) &&
            (identical(other.intervalExecutionDay, intervalExecutionDay) ||
                const DeepCollectionEquality().equals(
                    other.intervalExecutionDay, intervalExecutionDay)) &&
            (identical(other.startDate, startDate) ||
                const DeepCollectionEquality()
                    .equals(other.startDate, startDate)) &&
            (identical(other.endDate, endDate) ||
                const DeepCollectionEquality()
                    .equals(other.endDate, endDate)) &&
            (identical(other.adjustedStartDate, adjustedStartDate) ||
                const DeepCollectionEquality()
                    .equals(other.adjustedStartDate, adjustedStartDate)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(interval) ^
      const DeepCollectionEquality().hash(intervalExecutionDay) ^
      const DeepCollectionEquality().hash(startDate) ^
      const DeepCollectionEquality().hash(endDate) ^
      const DeepCollectionEquality().hash(adjustedStartDate) ^
      runtimeType.hashCode;
}

extension $ExternalPaymentScheduleBaseExtension on ExternalPaymentScheduleBase {
  ExternalPaymentScheduleBase copyWith(
      {enums.PaymentScheduleInterval? interval,
      int? intervalExecutionDay,
      DateTime? startDate,
      DateTime? endDate,
      DateTime? adjustedStartDate}) {
    return ExternalPaymentScheduleBase(
        interval: interval ?? this.interval,
        intervalExecutionDay: intervalExecutionDay ?? this.intervalExecutionDay,
        startDate: startDate ?? this.startDate,
        endDate: endDate ?? this.endDate,
        adjustedStartDate: adjustedStartDate ?? this.adjustedStartDate);
  }

  ExternalPaymentScheduleBase copyWithWrapped(
      {Wrapped<enums.PaymentScheduleInterval?>? interval,
      Wrapped<int?>? intervalExecutionDay,
      Wrapped<DateTime?>? startDate,
      Wrapped<DateTime?>? endDate,
      Wrapped<DateTime?>? adjustedStartDate}) {
    return ExternalPaymentScheduleBase(
        interval: (interval != null ? interval.value : this.interval),
        intervalExecutionDay: (intervalExecutionDay != null
            ? intervalExecutionDay.value
            : this.intervalExecutionDay),
        startDate: (startDate != null ? startDate.value : this.startDate),
        endDate: (endDate != null ? endDate.value : this.endDate),
        adjustedStartDate: (adjustedStartDate != null
            ? adjustedStartDate.value
            : this.adjustedStartDate));
  }
}

@JsonSerializable(explicitToJson: true)
class ExternalPaymentScheduleRequest {
  ExternalPaymentScheduleRequest({
    required this.interval,
    required this.intervalExecutionDay,
    required this.startDate,
    this.endDate,
    this.adjustedStartDate,
  });

  factory ExternalPaymentScheduleRequest.fromJson(Map<String, dynamic> json) =>
      _$ExternalPaymentScheduleRequestFromJson(json);

  @JsonKey(
    name: 'interval',
    toJson: paymentScheduleIntervalToJson,
    fromJson: paymentScheduleIntervalFromJson,
  )
  final enums.PaymentScheduleInterval interval;
  @JsonKey(name: 'interval_execution_day')
  final int intervalExecutionDay;
  @JsonKey(name: 'start_date', toJson: _dateToJson)
  final DateTime startDate;
  @JsonKey(name: 'end_date', toJson: _dateToJson)
  final DateTime? endDate;
  @JsonKey(name: 'adjusted_start_date', toJson: _dateToJson)
  final DateTime? adjustedStartDate;
  static const fromJsonFactory = _$ExternalPaymentScheduleRequestFromJson;
  static const toJsonFactory = _$ExternalPaymentScheduleRequestToJson;
  Map<String, dynamic> toJson() => _$ExternalPaymentScheduleRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ExternalPaymentScheduleRequest &&
            (identical(other.interval, interval) ||
                const DeepCollectionEquality()
                    .equals(other.interval, interval)) &&
            (identical(other.intervalExecutionDay, intervalExecutionDay) ||
                const DeepCollectionEquality().equals(
                    other.intervalExecutionDay, intervalExecutionDay)) &&
            (identical(other.startDate, startDate) ||
                const DeepCollectionEquality()
                    .equals(other.startDate, startDate)) &&
            (identical(other.endDate, endDate) ||
                const DeepCollectionEquality()
                    .equals(other.endDate, endDate)) &&
            (identical(other.adjustedStartDate, adjustedStartDate) ||
                const DeepCollectionEquality()
                    .equals(other.adjustedStartDate, adjustedStartDate)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(interval) ^
      const DeepCollectionEquality().hash(intervalExecutionDay) ^
      const DeepCollectionEquality().hash(startDate) ^
      const DeepCollectionEquality().hash(endDate) ^
      const DeepCollectionEquality().hash(adjustedStartDate) ^
      runtimeType.hashCode;
}

extension $ExternalPaymentScheduleRequestExtension
    on ExternalPaymentScheduleRequest {
  ExternalPaymentScheduleRequest copyWith(
      {enums.PaymentScheduleInterval? interval,
      int? intervalExecutionDay,
      DateTime? startDate,
      DateTime? endDate,
      DateTime? adjustedStartDate}) {
    return ExternalPaymentScheduleRequest(
        interval: interval ?? this.interval,
        intervalExecutionDay: intervalExecutionDay ?? this.intervalExecutionDay,
        startDate: startDate ?? this.startDate,
        endDate: endDate ?? this.endDate,
        adjustedStartDate: adjustedStartDate ?? this.adjustedStartDate);
  }

  ExternalPaymentScheduleRequest copyWithWrapped(
      {Wrapped<enums.PaymentScheduleInterval>? interval,
      Wrapped<int>? intervalExecutionDay,
      Wrapped<DateTime>? startDate,
      Wrapped<DateTime?>? endDate,
      Wrapped<DateTime?>? adjustedStartDate}) {
    return ExternalPaymentScheduleRequest(
        interval: (interval != null ? interval.value : this.interval),
        intervalExecutionDay: (intervalExecutionDay != null
            ? intervalExecutionDay.value
            : this.intervalExecutionDay),
        startDate: (startDate != null ? startDate.value : this.startDate),
        endDate: (endDate != null ? endDate.value : this.endDate),
        adjustedStartDate: (adjustedStartDate != null
            ? adjustedStartDate.value
            : this.adjustedStartDate));
  }
}

@JsonSerializable(explicitToJson: true)
class ExternalPaymentInitiationConsentOptions {
  ExternalPaymentInitiationConsentOptions({
    this.walletId,
    this.requestRefundDetails,
    this.iban,
    this.bacs,
  });

  factory ExternalPaymentInitiationConsentOptions.fromJson(
          Map<String, dynamic> json) =>
      _$ExternalPaymentInitiationConsentOptionsFromJson(json);

  @JsonKey(name: 'wallet_id')
  final String? walletId;
  @JsonKey(name: 'request_refund_details')
  final bool? requestRefundDetails;
  @JsonKey(name: 'iban')
  final String? iban;
  @JsonKey(name: 'bacs')
  final PaymentInitiationOptionalRestrictionBacs? bacs;
  static const fromJsonFactory =
      _$ExternalPaymentInitiationConsentOptionsFromJson;
  static const toJsonFactory = _$ExternalPaymentInitiationConsentOptionsToJson;
  Map<String, dynamic> toJson() =>
      _$ExternalPaymentInitiationConsentOptionsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ExternalPaymentInitiationConsentOptions &&
            (identical(other.walletId, walletId) ||
                const DeepCollectionEquality()
                    .equals(other.walletId, walletId)) &&
            (identical(other.requestRefundDetails, requestRefundDetails) ||
                const DeepCollectionEquality().equals(
                    other.requestRefundDetails, requestRefundDetails)) &&
            (identical(other.iban, iban) ||
                const DeepCollectionEquality().equals(other.iban, iban)) &&
            (identical(other.bacs, bacs) ||
                const DeepCollectionEquality().equals(other.bacs, bacs)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(walletId) ^
      const DeepCollectionEquality().hash(requestRefundDetails) ^
      const DeepCollectionEquality().hash(iban) ^
      const DeepCollectionEquality().hash(bacs) ^
      runtimeType.hashCode;
}

extension $ExternalPaymentInitiationConsentOptionsExtension
    on ExternalPaymentInitiationConsentOptions {
  ExternalPaymentInitiationConsentOptions copyWith(
      {String? walletId,
      bool? requestRefundDetails,
      String? iban,
      PaymentInitiationOptionalRestrictionBacs? bacs}) {
    return ExternalPaymentInitiationConsentOptions(
        walletId: walletId ?? this.walletId,
        requestRefundDetails: requestRefundDetails ?? this.requestRefundDetails,
        iban: iban ?? this.iban,
        bacs: bacs ?? this.bacs);
  }

  ExternalPaymentInitiationConsentOptions copyWithWrapped(
      {Wrapped<String?>? walletId,
      Wrapped<bool?>? requestRefundDetails,
      Wrapped<String?>? iban,
      Wrapped<PaymentInitiationOptionalRestrictionBacs?>? bacs}) {
    return ExternalPaymentInitiationConsentOptions(
        walletId: (walletId != null ? walletId.value : this.walletId),
        requestRefundDetails: (requestRefundDetails != null
            ? requestRefundDetails.value
            : this.requestRefundDetails),
        iban: (iban != null ? iban.value : this.iban),
        bacs: (bacs != null ? bacs.value : this.bacs));
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentInitiationConsentConstraints {
  PaymentInitiationConsentConstraints({
    this.validDateTime,
    required this.maxPaymentAmount,
    required this.periodicAmounts,
  });

  factory PaymentInitiationConsentConstraints.fromJson(
          Map<String, dynamic> json) =>
      _$PaymentInitiationConsentConstraintsFromJson(json);

  @JsonKey(name: 'valid_date_time')
  final PaymentConsentValidDateTime? validDateTime;
  @JsonKey(name: 'max_payment_amount')
  final PaymentConsentMaxPaymentAmount maxPaymentAmount;
  @JsonKey(
      name: 'periodic_amounts', defaultValue: <PaymentConsentPeriodicAmount>[])
  final List<PaymentConsentPeriodicAmount> periodicAmounts;
  static const fromJsonFactory = _$PaymentInitiationConsentConstraintsFromJson;
  static const toJsonFactory = _$PaymentInitiationConsentConstraintsToJson;
  Map<String, dynamic> toJson() =>
      _$PaymentInitiationConsentConstraintsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentInitiationConsentConstraints &&
            (identical(other.validDateTime, validDateTime) ||
                const DeepCollectionEquality()
                    .equals(other.validDateTime, validDateTime)) &&
            (identical(other.maxPaymentAmount, maxPaymentAmount) ||
                const DeepCollectionEquality()
                    .equals(other.maxPaymentAmount, maxPaymentAmount)) &&
            (identical(other.periodicAmounts, periodicAmounts) ||
                const DeepCollectionEquality()
                    .equals(other.periodicAmounts, periodicAmounts)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(validDateTime) ^
      const DeepCollectionEquality().hash(maxPaymentAmount) ^
      const DeepCollectionEquality().hash(periodicAmounts) ^
      runtimeType.hashCode;
}

extension $PaymentInitiationConsentConstraintsExtension
    on PaymentInitiationConsentConstraints {
  PaymentInitiationConsentConstraints copyWith(
      {PaymentConsentValidDateTime? validDateTime,
      PaymentConsentMaxPaymentAmount? maxPaymentAmount,
      List<PaymentConsentPeriodicAmount>? periodicAmounts}) {
    return PaymentInitiationConsentConstraints(
        validDateTime: validDateTime ?? this.validDateTime,
        maxPaymentAmount: maxPaymentAmount ?? this.maxPaymentAmount,
        periodicAmounts: periodicAmounts ?? this.periodicAmounts);
  }

  PaymentInitiationConsentConstraints copyWithWrapped(
      {Wrapped<PaymentConsentValidDateTime?>? validDateTime,
      Wrapped<PaymentConsentMaxPaymentAmount>? maxPaymentAmount,
      Wrapped<List<PaymentConsentPeriodicAmount>>? periodicAmounts}) {
    return PaymentInitiationConsentConstraints(
        validDateTime:
            (validDateTime != null ? validDateTime.value : this.validDateTime),
        maxPaymentAmount: (maxPaymentAmount != null
            ? maxPaymentAmount.value
            : this.maxPaymentAmount),
        periodicAmounts: (periodicAmounts != null
            ? periodicAmounts.value
            : this.periodicAmounts));
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentConsentMaxPaymentAmount {
  PaymentConsentMaxPaymentAmount({
    required this.currency,
    required this.value,
  });

  factory PaymentConsentMaxPaymentAmount.fromJson(Map<String, dynamic> json) =>
      _$PaymentConsentMaxPaymentAmountFromJson(json);

  @JsonKey(
    name: 'currency',
    toJson: paymentAmountCurrencyToJson,
    fromJson: paymentAmountCurrencyFromJson,
  )
  final enums.PaymentAmountCurrency currency;
  @JsonKey(name: 'value')
  final double value;
  static const fromJsonFactory = _$PaymentConsentMaxPaymentAmountFromJson;
  static const toJsonFactory = _$PaymentConsentMaxPaymentAmountToJson;
  Map<String, dynamic> toJson() => _$PaymentConsentMaxPaymentAmountToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentConsentMaxPaymentAmount &&
            (identical(other.currency, currency) ||
                const DeepCollectionEquality()
                    .equals(other.currency, currency)) &&
            (identical(other.value, value) ||
                const DeepCollectionEquality().equals(other.value, value)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(currency) ^
      const DeepCollectionEquality().hash(value) ^
      runtimeType.hashCode;
}

extension $PaymentConsentMaxPaymentAmountExtension
    on PaymentConsentMaxPaymentAmount {
  PaymentConsentMaxPaymentAmount copyWith(
      {enums.PaymentAmountCurrency? currency, double? value}) {
    return PaymentConsentMaxPaymentAmount(
        currency: currency ?? this.currency, value: value ?? this.value);
  }

  PaymentConsentMaxPaymentAmount copyWithWrapped(
      {Wrapped<enums.PaymentAmountCurrency>? currency,
      Wrapped<double>? value}) {
    return PaymentConsentMaxPaymentAmount(
        currency: (currency != null ? currency.value : this.currency),
        value: (value != null ? value.value : this.value));
  }
}

@JsonSerializable(explicitToJson: true)
class ExternalPaymentOptions {
  ExternalPaymentOptions({
    this.requestRefundDetails,
    this.iban,
    this.bacs,
    this.walletId,
    this.scheme,
  });

  factory ExternalPaymentOptions.fromJson(Map<String, dynamic> json) =>
      _$ExternalPaymentOptionsFromJson(json);

  @JsonKey(name: 'request_refund_details')
  final bool? requestRefundDetails;
  @JsonKey(name: 'iban')
  final String? iban;
  @JsonKey(name: 'bacs')
  final PaymentInitiationOptionalRestrictionBacs? bacs;
  @JsonKey(name: 'wallet_id')
  final String? walletId;
  @JsonKey(
    name: 'scheme',
    toJson: paymentSchemeToJson,
    fromJson: paymentSchemeFromJson,
  )
  final enums.PaymentScheme? scheme;
  static const fromJsonFactory = _$ExternalPaymentOptionsFromJson;
  static const toJsonFactory = _$ExternalPaymentOptionsToJson;
  Map<String, dynamic> toJson() => _$ExternalPaymentOptionsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ExternalPaymentOptions &&
            (identical(other.requestRefundDetails, requestRefundDetails) ||
                const DeepCollectionEquality().equals(
                    other.requestRefundDetails, requestRefundDetails)) &&
            (identical(other.iban, iban) ||
                const DeepCollectionEquality().equals(other.iban, iban)) &&
            (identical(other.bacs, bacs) ||
                const DeepCollectionEquality().equals(other.bacs, bacs)) &&
            (identical(other.walletId, walletId) ||
                const DeepCollectionEquality()
                    .equals(other.walletId, walletId)) &&
            (identical(other.scheme, scheme) ||
                const DeepCollectionEquality().equals(other.scheme, scheme)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(requestRefundDetails) ^
      const DeepCollectionEquality().hash(iban) ^
      const DeepCollectionEquality().hash(bacs) ^
      const DeepCollectionEquality().hash(walletId) ^
      const DeepCollectionEquality().hash(scheme) ^
      runtimeType.hashCode;
}

extension $ExternalPaymentOptionsExtension on ExternalPaymentOptions {
  ExternalPaymentOptions copyWith(
      {bool? requestRefundDetails,
      String? iban,
      PaymentInitiationOptionalRestrictionBacs? bacs,
      String? walletId,
      enums.PaymentScheme? scheme}) {
    return ExternalPaymentOptions(
        requestRefundDetails: requestRefundDetails ?? this.requestRefundDetails,
        iban: iban ?? this.iban,
        bacs: bacs ?? this.bacs,
        walletId: walletId ?? this.walletId,
        scheme: scheme ?? this.scheme);
  }

  ExternalPaymentOptions copyWithWrapped(
      {Wrapped<bool?>? requestRefundDetails,
      Wrapped<String?>? iban,
      Wrapped<PaymentInitiationOptionalRestrictionBacs?>? bacs,
      Wrapped<String?>? walletId,
      Wrapped<enums.PaymentScheme?>? scheme}) {
    return ExternalPaymentOptions(
        requestRefundDetails: (requestRefundDetails != null
            ? requestRefundDetails.value
            : this.requestRefundDetails),
        iban: (iban != null ? iban.value : this.iban),
        bacs: (bacs != null ? bacs.value : this.bacs),
        walletId: (walletId != null ? walletId.value : this.walletId),
        scheme: (scheme != null ? scheme.value : this.scheme));
  }
}

@JsonSerializable(explicitToJson: true)
class ExternalPaymentRefundDetails {
  ExternalPaymentRefundDetails({
    required this.name,
    required this.iban,
    required this.bacs,
  });

  factory ExternalPaymentRefundDetails.fromJson(Map<String, dynamic> json) =>
      _$ExternalPaymentRefundDetailsFromJson(json);

  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'iban')
  final String? iban;
  @JsonKey(name: 'bacs')
  final RecipientBACSNullable? bacs;
  static const fromJsonFactory = _$ExternalPaymentRefundDetailsFromJson;
  static const toJsonFactory = _$ExternalPaymentRefundDetailsToJson;
  Map<String, dynamic> toJson() => _$ExternalPaymentRefundDetailsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ExternalPaymentRefundDetails &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.iban, iban) ||
                const DeepCollectionEquality().equals(other.iban, iban)) &&
            (identical(other.bacs, bacs) ||
                const DeepCollectionEquality().equals(other.bacs, bacs)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(iban) ^
      const DeepCollectionEquality().hash(bacs) ^
      runtimeType.hashCode;
}

extension $ExternalPaymentRefundDetailsExtension
    on ExternalPaymentRefundDetails {
  ExternalPaymentRefundDetails copyWith(
      {String? name, String? iban, RecipientBACSNullable? bacs}) {
    return ExternalPaymentRefundDetails(
        name: name ?? this.name,
        iban: iban ?? this.iban,
        bacs: bacs ?? this.bacs);
  }

  ExternalPaymentRefundDetails copyWithWrapped(
      {Wrapped<String>? name,
      Wrapped<String?>? iban,
      Wrapped<RecipientBACSNullable?>? bacs}) {
    return ExternalPaymentRefundDetails(
        name: (name != null ? name.value : this.name),
        iban: (iban != null ? iban.value : this.iban),
        bacs: (bacs != null ? bacs.value : this.bacs));
  }
}

@JsonSerializable(explicitToJson: true)
class ExternalPaymentScheduleGet {
  ExternalPaymentScheduleGet({
    required this.interval,
    required this.intervalExecutionDay,
    required this.startDate,
    required this.endDate,
    required this.adjustedStartDate,
  });

  factory ExternalPaymentScheduleGet.fromJson(Map<String, dynamic> json) =>
      _$ExternalPaymentScheduleGetFromJson(json);

  @JsonKey(
    name: 'interval',
    toJson: paymentScheduleIntervalToJson,
    fromJson: paymentScheduleIntervalFromJson,
  )
  final enums.PaymentScheduleInterval interval;
  @JsonKey(name: 'interval_execution_day')
  final int intervalExecutionDay;
  @JsonKey(name: 'start_date', toJson: _dateToJson)
  final DateTime startDate;
  @JsonKey(name: 'end_date', toJson: _dateToJson)
  final DateTime? endDate;
  @JsonKey(name: 'adjusted_start_date', toJson: _dateToJson)
  final DateTime? adjustedStartDate;
  static const fromJsonFactory = _$ExternalPaymentScheduleGetFromJson;
  static const toJsonFactory = _$ExternalPaymentScheduleGetToJson;
  Map<String, dynamic> toJson() => _$ExternalPaymentScheduleGetToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ExternalPaymentScheduleGet &&
            (identical(other.interval, interval) ||
                const DeepCollectionEquality()
                    .equals(other.interval, interval)) &&
            (identical(other.intervalExecutionDay, intervalExecutionDay) ||
                const DeepCollectionEquality().equals(
                    other.intervalExecutionDay, intervalExecutionDay)) &&
            (identical(other.startDate, startDate) ||
                const DeepCollectionEquality()
                    .equals(other.startDate, startDate)) &&
            (identical(other.endDate, endDate) ||
                const DeepCollectionEquality()
                    .equals(other.endDate, endDate)) &&
            (identical(other.adjustedStartDate, adjustedStartDate) ||
                const DeepCollectionEquality()
                    .equals(other.adjustedStartDate, adjustedStartDate)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(interval) ^
      const DeepCollectionEquality().hash(intervalExecutionDay) ^
      const DeepCollectionEquality().hash(startDate) ^
      const DeepCollectionEquality().hash(endDate) ^
      const DeepCollectionEquality().hash(adjustedStartDate) ^
      runtimeType.hashCode;
}

extension $ExternalPaymentScheduleGetExtension on ExternalPaymentScheduleGet {
  ExternalPaymentScheduleGet copyWith(
      {enums.PaymentScheduleInterval? interval,
      int? intervalExecutionDay,
      DateTime? startDate,
      DateTime? endDate,
      DateTime? adjustedStartDate}) {
    return ExternalPaymentScheduleGet(
        interval: interval ?? this.interval,
        intervalExecutionDay: intervalExecutionDay ?? this.intervalExecutionDay,
        startDate: startDate ?? this.startDate,
        endDate: endDate ?? this.endDate,
        adjustedStartDate: adjustedStartDate ?? this.adjustedStartDate);
  }

  ExternalPaymentScheduleGet copyWithWrapped(
      {Wrapped<enums.PaymentScheduleInterval>? interval,
      Wrapped<int>? intervalExecutionDay,
      Wrapped<DateTime>? startDate,
      Wrapped<DateTime?>? endDate,
      Wrapped<DateTime?>? adjustedStartDate}) {
    return ExternalPaymentScheduleGet(
        interval: (interval != null ? interval.value : this.interval),
        intervalExecutionDay: (intervalExecutionDay != null
            ? intervalExecutionDay.value
            : this.intervalExecutionDay),
        startDate: (startDate != null ? startDate.value : this.startDate),
        endDate: (endDate != null ? endDate.value : this.endDate),
        adjustedStartDate: (adjustedStartDate != null
            ? adjustedStartDate.value
            : this.adjustedStartDate));
  }
}

@JsonSerializable(explicitToJson: true)
class ProductStatus {
  ProductStatus({
    required this.status,
    required this.lastStatusChange,
    required this.breakdown,
  });

  factory ProductStatus.fromJson(Map<String, dynamic> json) =>
      _$ProductStatusFromJson(json);

  @JsonKey(
    name: 'status',
    toJson: productStatusStatusToJson,
    fromJson: productStatusStatusFromJson,
  )
  final enums.ProductStatusStatus status;
  @JsonKey(name: 'last_status_change')
  final DateTime lastStatusChange;
  @JsonKey(name: 'breakdown')
  final ProductStatusBreakdown breakdown;
  static const fromJsonFactory = _$ProductStatusFromJson;
  static const toJsonFactory = _$ProductStatusToJson;
  Map<String, dynamic> toJson() => _$ProductStatusToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ProductStatus &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.lastStatusChange, lastStatusChange) ||
                const DeepCollectionEquality()
                    .equals(other.lastStatusChange, lastStatusChange)) &&
            (identical(other.breakdown, breakdown) ||
                const DeepCollectionEquality()
                    .equals(other.breakdown, breakdown)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(lastStatusChange) ^
      const DeepCollectionEquality().hash(breakdown) ^
      runtimeType.hashCode;
}

extension $ProductStatusExtension on ProductStatus {
  ProductStatus copyWith(
      {enums.ProductStatusStatus? status,
      DateTime? lastStatusChange,
      ProductStatusBreakdown? breakdown}) {
    return ProductStatus(
        status: status ?? this.status,
        lastStatusChange: lastStatusChange ?? this.lastStatusChange,
        breakdown: breakdown ?? this.breakdown);
  }

  ProductStatus copyWithWrapped(
      {Wrapped<enums.ProductStatusStatus>? status,
      Wrapped<DateTime>? lastStatusChange,
      Wrapped<ProductStatusBreakdown>? breakdown}) {
    return ProductStatus(
        status: (status != null ? status.value : this.status),
        lastStatusChange: (lastStatusChange != null
            ? lastStatusChange.value
            : this.lastStatusChange),
        breakdown: (breakdown != null ? breakdown.value : this.breakdown));
  }
}

@JsonSerializable(explicitToJson: true)
class ProductStatusBreakdown {
  ProductStatusBreakdown({
    required this.success,
    required this.errorPlaid,
    required this.errorInstitution,
    this.refreshInterval,
  });

  factory ProductStatusBreakdown.fromJson(Map<String, dynamic> json) =>
      _$ProductStatusBreakdownFromJson(json);

  @JsonKey(name: 'success')
  final double success;
  @JsonKey(name: 'error_plaid')
  final double errorPlaid;
  @JsonKey(name: 'error_institution')
  final double errorInstitution;
  @JsonKey(
    name: 'refresh_interval',
    toJson: productStatusBreakdownRefreshIntervalToJson,
    fromJson: productStatusBreakdownRefreshIntervalFromJson,
  )
  final enums.ProductStatusBreakdownRefreshInterval? refreshInterval;
  static const fromJsonFactory = _$ProductStatusBreakdownFromJson;
  static const toJsonFactory = _$ProductStatusBreakdownToJson;
  Map<String, dynamic> toJson() => _$ProductStatusBreakdownToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ProductStatusBreakdown &&
            (identical(other.success, success) ||
                const DeepCollectionEquality()
                    .equals(other.success, success)) &&
            (identical(other.errorPlaid, errorPlaid) ||
                const DeepCollectionEquality()
                    .equals(other.errorPlaid, errorPlaid)) &&
            (identical(other.errorInstitution, errorInstitution) ||
                const DeepCollectionEquality()
                    .equals(other.errorInstitution, errorInstitution)) &&
            (identical(other.refreshInterval, refreshInterval) ||
                const DeepCollectionEquality()
                    .equals(other.refreshInterval, refreshInterval)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(success) ^
      const DeepCollectionEquality().hash(errorPlaid) ^
      const DeepCollectionEquality().hash(errorInstitution) ^
      const DeepCollectionEquality().hash(refreshInterval) ^
      runtimeType.hashCode;
}

extension $ProductStatusBreakdownExtension on ProductStatusBreakdown {
  ProductStatusBreakdown copyWith(
      {double? success,
      double? errorPlaid,
      double? errorInstitution,
      enums.ProductStatusBreakdownRefreshInterval? refreshInterval}) {
    return ProductStatusBreakdown(
        success: success ?? this.success,
        errorPlaid: errorPlaid ?? this.errorPlaid,
        errorInstitution: errorInstitution ?? this.errorInstitution,
        refreshInterval: refreshInterval ?? this.refreshInterval);
  }

  ProductStatusBreakdown copyWithWrapped(
      {Wrapped<double>? success,
      Wrapped<double>? errorPlaid,
      Wrapped<double>? errorInstitution,
      Wrapped<enums.ProductStatusBreakdownRefreshInterval?>? refreshInterval}) {
    return ProductStatusBreakdown(
        success: (success != null ? success.value : this.success),
        errorPlaid: (errorPlaid != null ? errorPlaid.value : this.errorPlaid),
        errorInstitution: (errorInstitution != null
            ? errorInstitution.value
            : this.errorInstitution),
        refreshInterval: (refreshInterval != null
            ? refreshInterval.value
            : this.refreshInterval));
  }
}

@JsonSerializable(explicitToJson: true)
class UserCustomPassword {
  UserCustomPassword({
    this.version,
    required this.seed,
    required this.overrideAccounts,
    required this.mfa,
    required this.recaptcha,
    required this.forceError,
  });

  factory UserCustomPassword.fromJson(Map<String, dynamic> json) =>
      _$UserCustomPasswordFromJson(json);

  @JsonKey(name: 'version')
  final String? version;
  @JsonKey(name: 'seed')
  final String seed;
  @JsonKey(name: 'override_accounts', defaultValue: <OverrideAccounts>[])
  final List<OverrideAccounts> overrideAccounts;
  @JsonKey(name: 'mfa')
  final Mfa mfa;
  @JsonKey(name: 'recaptcha')
  final String recaptcha;
  @JsonKey(name: 'force_error')
  final String forceError;
  static const fromJsonFactory = _$UserCustomPasswordFromJson;
  static const toJsonFactory = _$UserCustomPasswordToJson;
  Map<String, dynamic> toJson() => _$UserCustomPasswordToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is UserCustomPassword &&
            (identical(other.version, version) ||
                const DeepCollectionEquality()
                    .equals(other.version, version)) &&
            (identical(other.seed, seed) ||
                const DeepCollectionEquality().equals(other.seed, seed)) &&
            (identical(other.overrideAccounts, overrideAccounts) ||
                const DeepCollectionEquality()
                    .equals(other.overrideAccounts, overrideAccounts)) &&
            (identical(other.mfa, mfa) ||
                const DeepCollectionEquality().equals(other.mfa, mfa)) &&
            (identical(other.recaptcha, recaptcha) ||
                const DeepCollectionEquality()
                    .equals(other.recaptcha, recaptcha)) &&
            (identical(other.forceError, forceError) ||
                const DeepCollectionEquality()
                    .equals(other.forceError, forceError)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(version) ^
      const DeepCollectionEquality().hash(seed) ^
      const DeepCollectionEquality().hash(overrideAccounts) ^
      const DeepCollectionEquality().hash(mfa) ^
      const DeepCollectionEquality().hash(recaptcha) ^
      const DeepCollectionEquality().hash(forceError) ^
      runtimeType.hashCode;
}

extension $UserCustomPasswordExtension on UserCustomPassword {
  UserCustomPassword copyWith(
      {String? version,
      String? seed,
      List<OverrideAccounts>? overrideAccounts,
      Mfa? mfa,
      String? recaptcha,
      String? forceError}) {
    return UserCustomPassword(
        version: version ?? this.version,
        seed: seed ?? this.seed,
        overrideAccounts: overrideAccounts ?? this.overrideAccounts,
        mfa: mfa ?? this.mfa,
        recaptcha: recaptcha ?? this.recaptcha,
        forceError: forceError ?? this.forceError);
  }

  UserCustomPassword copyWithWrapped(
      {Wrapped<String?>? version,
      Wrapped<String>? seed,
      Wrapped<List<OverrideAccounts>>? overrideAccounts,
      Wrapped<Mfa>? mfa,
      Wrapped<String>? recaptcha,
      Wrapped<String>? forceError}) {
    return UserCustomPassword(
        version: (version != null ? version.value : this.version),
        seed: (seed != null ? seed.value : this.seed),
        overrideAccounts: (overrideAccounts != null
            ? overrideAccounts.value
            : this.overrideAccounts),
        mfa: (mfa != null ? mfa.value : this.mfa),
        recaptcha: (recaptcha != null ? recaptcha.value : this.recaptcha),
        forceError: (forceError != null ? forceError.value : this.forceError));
  }
}

@JsonSerializable(explicitToJson: true)
class Mfa {
  Mfa({
    required this.type,
    required this.questionRounds,
    required this.questionsPerRound,
    required this.selectionRounds,
    required this.selectionsPerQuestion,
  });

  factory Mfa.fromJson(Map<String, dynamic> json) => _$MfaFromJson(json);

  @JsonKey(name: 'type')
  final String type;
  @JsonKey(name: 'question_rounds')
  final double questionRounds;
  @JsonKey(name: 'questions_per_round')
  final double questionsPerRound;
  @JsonKey(name: 'selection_rounds')
  final double selectionRounds;
  @JsonKey(name: 'selections_per_question')
  final double selectionsPerQuestion;
  static const fromJsonFactory = _$MfaFromJson;
  static const toJsonFactory = _$MfaToJson;
  Map<String, dynamic> toJson() => _$MfaToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Mfa &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.questionRounds, questionRounds) ||
                const DeepCollectionEquality()
                    .equals(other.questionRounds, questionRounds)) &&
            (identical(other.questionsPerRound, questionsPerRound) ||
                const DeepCollectionEquality()
                    .equals(other.questionsPerRound, questionsPerRound)) &&
            (identical(other.selectionRounds, selectionRounds) ||
                const DeepCollectionEquality()
                    .equals(other.selectionRounds, selectionRounds)) &&
            (identical(other.selectionsPerQuestion, selectionsPerQuestion) ||
                const DeepCollectionEquality().equals(
                    other.selectionsPerQuestion, selectionsPerQuestion)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(questionRounds) ^
      const DeepCollectionEquality().hash(questionsPerRound) ^
      const DeepCollectionEquality().hash(selectionRounds) ^
      const DeepCollectionEquality().hash(selectionsPerQuestion) ^
      runtimeType.hashCode;
}

extension $MfaExtension on Mfa {
  Mfa copyWith(
      {String? type,
      double? questionRounds,
      double? questionsPerRound,
      double? selectionRounds,
      double? selectionsPerQuestion}) {
    return Mfa(
        type: type ?? this.type,
        questionRounds: questionRounds ?? this.questionRounds,
        questionsPerRound: questionsPerRound ?? this.questionsPerRound,
        selectionRounds: selectionRounds ?? this.selectionRounds,
        selectionsPerQuestion:
            selectionsPerQuestion ?? this.selectionsPerQuestion);
  }

  Mfa copyWithWrapped(
      {Wrapped<String>? type,
      Wrapped<double>? questionRounds,
      Wrapped<double>? questionsPerRound,
      Wrapped<double>? selectionRounds,
      Wrapped<double>? selectionsPerQuestion}) {
    return Mfa(
        type: (type != null ? type.value : this.type),
        questionRounds: (questionRounds != null
            ? questionRounds.value
            : this.questionRounds),
        questionsPerRound: (questionsPerRound != null
            ? questionsPerRound.value
            : this.questionsPerRound),
        selectionRounds: (selectionRounds != null
            ? selectionRounds.value
            : this.selectionRounds),
        selectionsPerQuestion: (selectionsPerQuestion != null
            ? selectionsPerQuestion.value
            : this.selectionsPerQuestion));
  }
}

@JsonSerializable(explicitToJson: true)
class OverrideAccounts {
  OverrideAccounts({
    required this.type,
    required this.subtype,
    required this.startingBalance,
    required this.forceAvailableBalance,
    required this.currency,
    required this.meta,
    required this.numbers,
    required this.transactions,
    this.holdings,
    this.investmentTransactions,
    required this.identity,
    required this.liability,
    required this.inflowModel,
    this.income,
  });

  factory OverrideAccounts.fromJson(Map<String, dynamic> json) =>
      _$OverrideAccountsFromJson(json);

  @JsonKey(
    name: 'type',
    toJson: overrideAccountTypeToJson,
    fromJson: overrideAccountTypeFromJson,
  )
  final enums.OverrideAccountType type;
  @JsonKey(
    name: 'subtype',
    toJson: accountSubtypeToJson,
    fromJson: accountSubtypeFromJson,
  )
  final enums.AccountSubtype? subtype;
  @JsonKey(name: 'starting_balance')
  final double startingBalance;
  @JsonKey(name: 'force_available_balance')
  final double forceAvailableBalance;
  @JsonKey(name: 'currency')
  final String currency;
  @JsonKey(name: 'meta')
  final Meta meta;
  @JsonKey(name: 'numbers')
  final Numbers numbers;
  @JsonKey(name: 'transactions', defaultValue: <TransactionOverride>[])
  final List<TransactionOverride> transactions;
  @JsonKey(name: 'holdings')
  final HoldingsOverride? holdings;
  @JsonKey(name: 'investment_transactions')
  final InvestmentsTransactionsOverride? investmentTransactions;
  @JsonKey(name: 'identity')
  final OwnerOverride identity;
  @JsonKey(name: 'liability')
  final LiabilityOverride liability;
  @JsonKey(name: 'inflow_model')
  final InflowModel inflowModel;
  @JsonKey(name: 'income')
  final IncomeOverride? income;
  static const fromJsonFactory = _$OverrideAccountsFromJson;
  static const toJsonFactory = _$OverrideAccountsToJson;
  Map<String, dynamic> toJson() => _$OverrideAccountsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is OverrideAccounts &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.subtype, subtype) ||
                const DeepCollectionEquality()
                    .equals(other.subtype, subtype)) &&
            (identical(other.startingBalance, startingBalance) ||
                const DeepCollectionEquality()
                    .equals(other.startingBalance, startingBalance)) &&
            (identical(other.forceAvailableBalance, forceAvailableBalance) ||
                const DeepCollectionEquality().equals(
                    other.forceAvailableBalance, forceAvailableBalance)) &&
            (identical(other.currency, currency) ||
                const DeepCollectionEquality()
                    .equals(other.currency, currency)) &&
            (identical(other.meta, meta) ||
                const DeepCollectionEquality().equals(other.meta, meta)) &&
            (identical(other.numbers, numbers) ||
                const DeepCollectionEquality()
                    .equals(other.numbers, numbers)) &&
            (identical(other.transactions, transactions) ||
                const DeepCollectionEquality()
                    .equals(other.transactions, transactions)) &&
            (identical(other.holdings, holdings) ||
                const DeepCollectionEquality()
                    .equals(other.holdings, holdings)) &&
            (identical(other.investmentTransactions, investmentTransactions) ||
                const DeepCollectionEquality().equals(
                    other.investmentTransactions, investmentTransactions)) &&
            (identical(other.identity, identity) ||
                const DeepCollectionEquality()
                    .equals(other.identity, identity)) &&
            (identical(other.liability, liability) ||
                const DeepCollectionEquality()
                    .equals(other.liability, liability)) &&
            (identical(other.inflowModel, inflowModel) ||
                const DeepCollectionEquality()
                    .equals(other.inflowModel, inflowModel)) &&
            (identical(other.income, income) ||
                const DeepCollectionEquality().equals(other.income, income)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(subtype) ^
      const DeepCollectionEquality().hash(startingBalance) ^
      const DeepCollectionEquality().hash(forceAvailableBalance) ^
      const DeepCollectionEquality().hash(currency) ^
      const DeepCollectionEquality().hash(meta) ^
      const DeepCollectionEquality().hash(numbers) ^
      const DeepCollectionEquality().hash(transactions) ^
      const DeepCollectionEquality().hash(holdings) ^
      const DeepCollectionEquality().hash(investmentTransactions) ^
      const DeepCollectionEquality().hash(identity) ^
      const DeepCollectionEquality().hash(liability) ^
      const DeepCollectionEquality().hash(inflowModel) ^
      const DeepCollectionEquality().hash(income) ^
      runtimeType.hashCode;
}

extension $OverrideAccountsExtension on OverrideAccounts {
  OverrideAccounts copyWith(
      {enums.OverrideAccountType? type,
      enums.AccountSubtype? subtype,
      double? startingBalance,
      double? forceAvailableBalance,
      String? currency,
      Meta? meta,
      Numbers? numbers,
      List<TransactionOverride>? transactions,
      HoldingsOverride? holdings,
      InvestmentsTransactionsOverride? investmentTransactions,
      OwnerOverride? identity,
      LiabilityOverride? liability,
      InflowModel? inflowModel,
      IncomeOverride? income}) {
    return OverrideAccounts(
        type: type ?? this.type,
        subtype: subtype ?? this.subtype,
        startingBalance: startingBalance ?? this.startingBalance,
        forceAvailableBalance:
            forceAvailableBalance ?? this.forceAvailableBalance,
        currency: currency ?? this.currency,
        meta: meta ?? this.meta,
        numbers: numbers ?? this.numbers,
        transactions: transactions ?? this.transactions,
        holdings: holdings ?? this.holdings,
        investmentTransactions:
            investmentTransactions ?? this.investmentTransactions,
        identity: identity ?? this.identity,
        liability: liability ?? this.liability,
        inflowModel: inflowModel ?? this.inflowModel,
        income: income ?? this.income);
  }

  OverrideAccounts copyWithWrapped(
      {Wrapped<enums.OverrideAccountType>? type,
      Wrapped<enums.AccountSubtype?>? subtype,
      Wrapped<double>? startingBalance,
      Wrapped<double>? forceAvailableBalance,
      Wrapped<String>? currency,
      Wrapped<Meta>? meta,
      Wrapped<Numbers>? numbers,
      Wrapped<List<TransactionOverride>>? transactions,
      Wrapped<HoldingsOverride?>? holdings,
      Wrapped<InvestmentsTransactionsOverride?>? investmentTransactions,
      Wrapped<OwnerOverride>? identity,
      Wrapped<LiabilityOverride>? liability,
      Wrapped<InflowModel>? inflowModel,
      Wrapped<IncomeOverride?>? income}) {
    return OverrideAccounts(
        type: (type != null ? type.value : this.type),
        subtype: (subtype != null ? subtype.value : this.subtype),
        startingBalance: (startingBalance != null
            ? startingBalance.value
            : this.startingBalance),
        forceAvailableBalance: (forceAvailableBalance != null
            ? forceAvailableBalance.value
            : this.forceAvailableBalance),
        currency: (currency != null ? currency.value : this.currency),
        meta: (meta != null ? meta.value : this.meta),
        numbers: (numbers != null ? numbers.value : this.numbers),
        transactions:
            (transactions != null ? transactions.value : this.transactions),
        holdings: (holdings != null ? holdings.value : this.holdings),
        investmentTransactions: (investmentTransactions != null
            ? investmentTransactions.value
            : this.investmentTransactions),
        identity: (identity != null ? identity.value : this.identity),
        liability: (liability != null ? liability.value : this.liability),
        inflowModel:
            (inflowModel != null ? inflowModel.value : this.inflowModel),
        income: (income != null ? income.value : this.income));
  }
}

@JsonSerializable(explicitToJson: true)
class Meta {
  Meta({
    required this.name,
    required this.officialName,
    required this.limit,
    required this.mask,
  });

  factory Meta.fromJson(Map<String, dynamic> json) => _$MetaFromJson(json);

  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'official_name')
  final String officialName;
  @JsonKey(name: 'limit')
  final double limit;
  @JsonKey(name: 'mask')
  final String mask;
  static const fromJsonFactory = _$MetaFromJson;
  static const toJsonFactory = _$MetaToJson;
  Map<String, dynamic> toJson() => _$MetaToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Meta &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.officialName, officialName) ||
                const DeepCollectionEquality()
                    .equals(other.officialName, officialName)) &&
            (identical(other.limit, limit) ||
                const DeepCollectionEquality().equals(other.limit, limit)) &&
            (identical(other.mask, mask) ||
                const DeepCollectionEquality().equals(other.mask, mask)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(officialName) ^
      const DeepCollectionEquality().hash(limit) ^
      const DeepCollectionEquality().hash(mask) ^
      runtimeType.hashCode;
}

extension $MetaExtension on Meta {
  Meta copyWith(
      {String? name, String? officialName, double? limit, String? mask}) {
    return Meta(
        name: name ?? this.name,
        officialName: officialName ?? this.officialName,
        limit: limit ?? this.limit,
        mask: mask ?? this.mask);
  }

  Meta copyWithWrapped(
      {Wrapped<String>? name,
      Wrapped<String>? officialName,
      Wrapped<double>? limit,
      Wrapped<String>? mask}) {
    return Meta(
        name: (name != null ? name.value : this.name),
        officialName:
            (officialName != null ? officialName.value : this.officialName),
        limit: (limit != null ? limit.value : this.limit),
        mask: (mask != null ? mask.value : this.mask));
  }
}

@JsonSerializable(explicitToJson: true)
class Numbers {
  Numbers({
    this.account,
    this.achRouting,
    this.achWireRouting,
    this.eftInstitution,
    this.eftBranch,
    this.internationalBic,
    this.internationalIban,
    this.bacsSortCode,
  });

  factory Numbers.fromJson(Map<String, dynamic> json) =>
      _$NumbersFromJson(json);

  @JsonKey(name: 'account')
  final String? account;
  @JsonKey(name: 'ach_routing')
  final String? achRouting;
  @JsonKey(name: 'ach_wire_routing')
  final String? achWireRouting;
  @JsonKey(name: 'eft_institution')
  final String? eftInstitution;
  @JsonKey(name: 'eft_branch')
  final String? eftBranch;
  @JsonKey(name: 'international_bic')
  final String? internationalBic;
  @JsonKey(name: 'international_iban')
  final String? internationalIban;
  @JsonKey(name: 'bacs_sort_code')
  final String? bacsSortCode;
  static const fromJsonFactory = _$NumbersFromJson;
  static const toJsonFactory = _$NumbersToJson;
  Map<String, dynamic> toJson() => _$NumbersToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Numbers &&
            (identical(other.account, account) ||
                const DeepCollectionEquality()
                    .equals(other.account, account)) &&
            (identical(other.achRouting, achRouting) ||
                const DeepCollectionEquality()
                    .equals(other.achRouting, achRouting)) &&
            (identical(other.achWireRouting, achWireRouting) ||
                const DeepCollectionEquality()
                    .equals(other.achWireRouting, achWireRouting)) &&
            (identical(other.eftInstitution, eftInstitution) ||
                const DeepCollectionEquality()
                    .equals(other.eftInstitution, eftInstitution)) &&
            (identical(other.eftBranch, eftBranch) ||
                const DeepCollectionEquality()
                    .equals(other.eftBranch, eftBranch)) &&
            (identical(other.internationalBic, internationalBic) ||
                const DeepCollectionEquality()
                    .equals(other.internationalBic, internationalBic)) &&
            (identical(other.internationalIban, internationalIban) ||
                const DeepCollectionEquality()
                    .equals(other.internationalIban, internationalIban)) &&
            (identical(other.bacsSortCode, bacsSortCode) ||
                const DeepCollectionEquality()
                    .equals(other.bacsSortCode, bacsSortCode)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(account) ^
      const DeepCollectionEquality().hash(achRouting) ^
      const DeepCollectionEquality().hash(achWireRouting) ^
      const DeepCollectionEquality().hash(eftInstitution) ^
      const DeepCollectionEquality().hash(eftBranch) ^
      const DeepCollectionEquality().hash(internationalBic) ^
      const DeepCollectionEquality().hash(internationalIban) ^
      const DeepCollectionEquality().hash(bacsSortCode) ^
      runtimeType.hashCode;
}

extension $NumbersExtension on Numbers {
  Numbers copyWith(
      {String? account,
      String? achRouting,
      String? achWireRouting,
      String? eftInstitution,
      String? eftBranch,
      String? internationalBic,
      String? internationalIban,
      String? bacsSortCode}) {
    return Numbers(
        account: account ?? this.account,
        achRouting: achRouting ?? this.achRouting,
        achWireRouting: achWireRouting ?? this.achWireRouting,
        eftInstitution: eftInstitution ?? this.eftInstitution,
        eftBranch: eftBranch ?? this.eftBranch,
        internationalBic: internationalBic ?? this.internationalBic,
        internationalIban: internationalIban ?? this.internationalIban,
        bacsSortCode: bacsSortCode ?? this.bacsSortCode);
  }

  Numbers copyWithWrapped(
      {Wrapped<String?>? account,
      Wrapped<String?>? achRouting,
      Wrapped<String?>? achWireRouting,
      Wrapped<String?>? eftInstitution,
      Wrapped<String?>? eftBranch,
      Wrapped<String?>? internationalBic,
      Wrapped<String?>? internationalIban,
      Wrapped<String?>? bacsSortCode}) {
    return Numbers(
        account: (account != null ? account.value : this.account),
        achRouting: (achRouting != null ? achRouting.value : this.achRouting),
        achWireRouting: (achWireRouting != null
            ? achWireRouting.value
            : this.achWireRouting),
        eftInstitution: (eftInstitution != null
            ? eftInstitution.value
            : this.eftInstitution),
        eftBranch: (eftBranch != null ? eftBranch.value : this.eftBranch),
        internationalBic: (internationalBic != null
            ? internationalBic.value
            : this.internationalBic),
        internationalIban: (internationalIban != null
            ? internationalIban.value
            : this.internationalIban),
        bacsSortCode:
            (bacsSortCode != null ? bacsSortCode.value : this.bacsSortCode));
  }
}

@JsonSerializable(explicitToJson: true)
class TransactionOverride {
  TransactionOverride({
    required this.dateTransacted,
    required this.datePosted,
    required this.amount,
    required this.description,
    this.currency,
  });

  factory TransactionOverride.fromJson(Map<String, dynamic> json) =>
      _$TransactionOverrideFromJson(json);

  @JsonKey(name: 'date_transacted', toJson: _dateToJson)
  final DateTime dateTransacted;
  @JsonKey(name: 'date_posted', toJson: _dateToJson)
  final DateTime datePosted;
  @JsonKey(name: 'amount')
  final double amount;
  @JsonKey(name: 'description')
  final String description;
  @JsonKey(name: 'currency')
  final String? currency;
  static const fromJsonFactory = _$TransactionOverrideFromJson;
  static const toJsonFactory = _$TransactionOverrideToJson;
  Map<String, dynamic> toJson() => _$TransactionOverrideToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransactionOverride &&
            (identical(other.dateTransacted, dateTransacted) ||
                const DeepCollectionEquality()
                    .equals(other.dateTransacted, dateTransacted)) &&
            (identical(other.datePosted, datePosted) ||
                const DeepCollectionEquality()
                    .equals(other.datePosted, datePosted)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.currency, currency) ||
                const DeepCollectionEquality()
                    .equals(other.currency, currency)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(dateTransacted) ^
      const DeepCollectionEquality().hash(datePosted) ^
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(currency) ^
      runtimeType.hashCode;
}

extension $TransactionOverrideExtension on TransactionOverride {
  TransactionOverride copyWith(
      {DateTime? dateTransacted,
      DateTime? datePosted,
      double? amount,
      String? description,
      String? currency}) {
    return TransactionOverride(
        dateTransacted: dateTransacted ?? this.dateTransacted,
        datePosted: datePosted ?? this.datePosted,
        amount: amount ?? this.amount,
        description: description ?? this.description,
        currency: currency ?? this.currency);
  }

  TransactionOverride copyWithWrapped(
      {Wrapped<DateTime>? dateTransacted,
      Wrapped<DateTime>? datePosted,
      Wrapped<double>? amount,
      Wrapped<String>? description,
      Wrapped<String?>? currency}) {
    return TransactionOverride(
        dateTransacted: (dateTransacted != null
            ? dateTransacted.value
            : this.dateTransacted),
        datePosted: (datePosted != null ? datePosted.value : this.datePosted),
        amount: (amount != null ? amount.value : this.amount),
        description:
            (description != null ? description.value : this.description),
        currency: (currency != null ? currency.value : this.currency));
  }
}

@JsonSerializable(explicitToJson: true)
class SecurityOverride {
  SecurityOverride({
    this.isin,
    this.cusip,
    this.sedol,
    this.name,
    this.tickerSymbol,
    this.currency,
  });

  factory SecurityOverride.fromJson(Map<String, dynamic> json) =>
      _$SecurityOverrideFromJson(json);

  @JsonKey(name: 'isin')
  final String? isin;
  @JsonKey(name: 'cusip')
  final String? cusip;
  @JsonKey(name: 'sedol')
  final String? sedol;
  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'ticker_symbol')
  final String? tickerSymbol;
  @JsonKey(name: 'currency')
  final String? currency;
  static const fromJsonFactory = _$SecurityOverrideFromJson;
  static const toJsonFactory = _$SecurityOverrideToJson;
  Map<String, dynamic> toJson() => _$SecurityOverrideToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SecurityOverride &&
            (identical(other.isin, isin) ||
                const DeepCollectionEquality().equals(other.isin, isin)) &&
            (identical(other.cusip, cusip) ||
                const DeepCollectionEquality().equals(other.cusip, cusip)) &&
            (identical(other.sedol, sedol) ||
                const DeepCollectionEquality().equals(other.sedol, sedol)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.tickerSymbol, tickerSymbol) ||
                const DeepCollectionEquality()
                    .equals(other.tickerSymbol, tickerSymbol)) &&
            (identical(other.currency, currency) ||
                const DeepCollectionEquality()
                    .equals(other.currency, currency)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(isin) ^
      const DeepCollectionEquality().hash(cusip) ^
      const DeepCollectionEquality().hash(sedol) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(tickerSymbol) ^
      const DeepCollectionEquality().hash(currency) ^
      runtimeType.hashCode;
}

extension $SecurityOverrideExtension on SecurityOverride {
  SecurityOverride copyWith(
      {String? isin,
      String? cusip,
      String? sedol,
      String? name,
      String? tickerSymbol,
      String? currency}) {
    return SecurityOverride(
        isin: isin ?? this.isin,
        cusip: cusip ?? this.cusip,
        sedol: sedol ?? this.sedol,
        name: name ?? this.name,
        tickerSymbol: tickerSymbol ?? this.tickerSymbol,
        currency: currency ?? this.currency);
  }

  SecurityOverride copyWithWrapped(
      {Wrapped<String?>? isin,
      Wrapped<String?>? cusip,
      Wrapped<String?>? sedol,
      Wrapped<String?>? name,
      Wrapped<String?>? tickerSymbol,
      Wrapped<String?>? currency}) {
    return SecurityOverride(
        isin: (isin != null ? isin.value : this.isin),
        cusip: (cusip != null ? cusip.value : this.cusip),
        sedol: (sedol != null ? sedol.value : this.sedol),
        name: (name != null ? name.value : this.name),
        tickerSymbol:
            (tickerSymbol != null ? tickerSymbol.value : this.tickerSymbol),
        currency: (currency != null ? currency.value : this.currency));
  }
}

@JsonSerializable(explicitToJson: true)
class HoldingsOverride {
  HoldingsOverride({
    required this.institutionPrice,
    this.institutionPriceAsOf,
    this.costBasis,
    required this.quantity,
    required this.currency,
    required this.security,
  });

  factory HoldingsOverride.fromJson(Map<String, dynamic> json) =>
      _$HoldingsOverrideFromJson(json);

  @JsonKey(name: 'institution_price')
  final double institutionPrice;
  @JsonKey(name: 'institution_price_as_of', toJson: _dateToJson)
  final DateTime? institutionPriceAsOf;
  @JsonKey(name: 'cost_basis')
  final double? costBasis;
  @JsonKey(name: 'quantity')
  final double quantity;
  @JsonKey(name: 'currency')
  final String currency;
  @JsonKey(name: 'security')
  final SecurityOverride security;
  static const fromJsonFactory = _$HoldingsOverrideFromJson;
  static const toJsonFactory = _$HoldingsOverrideToJson;
  Map<String, dynamic> toJson() => _$HoldingsOverrideToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is HoldingsOverride &&
            (identical(other.institutionPrice, institutionPrice) ||
                const DeepCollectionEquality()
                    .equals(other.institutionPrice, institutionPrice)) &&
            (identical(other.institutionPriceAsOf, institutionPriceAsOf) ||
                const DeepCollectionEquality().equals(
                    other.institutionPriceAsOf, institutionPriceAsOf)) &&
            (identical(other.costBasis, costBasis) ||
                const DeepCollectionEquality()
                    .equals(other.costBasis, costBasis)) &&
            (identical(other.quantity, quantity) ||
                const DeepCollectionEquality()
                    .equals(other.quantity, quantity)) &&
            (identical(other.currency, currency) ||
                const DeepCollectionEquality()
                    .equals(other.currency, currency)) &&
            (identical(other.security, security) ||
                const DeepCollectionEquality()
                    .equals(other.security, security)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(institutionPrice) ^
      const DeepCollectionEquality().hash(institutionPriceAsOf) ^
      const DeepCollectionEquality().hash(costBasis) ^
      const DeepCollectionEquality().hash(quantity) ^
      const DeepCollectionEquality().hash(currency) ^
      const DeepCollectionEquality().hash(security) ^
      runtimeType.hashCode;
}

extension $HoldingsOverrideExtension on HoldingsOverride {
  HoldingsOverride copyWith(
      {double? institutionPrice,
      DateTime? institutionPriceAsOf,
      double? costBasis,
      double? quantity,
      String? currency,
      SecurityOverride? security}) {
    return HoldingsOverride(
        institutionPrice: institutionPrice ?? this.institutionPrice,
        institutionPriceAsOf: institutionPriceAsOf ?? this.institutionPriceAsOf,
        costBasis: costBasis ?? this.costBasis,
        quantity: quantity ?? this.quantity,
        currency: currency ?? this.currency,
        security: security ?? this.security);
  }

  HoldingsOverride copyWithWrapped(
      {Wrapped<double>? institutionPrice,
      Wrapped<DateTime?>? institutionPriceAsOf,
      Wrapped<double?>? costBasis,
      Wrapped<double>? quantity,
      Wrapped<String>? currency,
      Wrapped<SecurityOverride>? security}) {
    return HoldingsOverride(
        institutionPrice: (institutionPrice != null
            ? institutionPrice.value
            : this.institutionPrice),
        institutionPriceAsOf: (institutionPriceAsOf != null
            ? institutionPriceAsOf.value
            : this.institutionPriceAsOf),
        costBasis: (costBasis != null ? costBasis.value : this.costBasis),
        quantity: (quantity != null ? quantity.value : this.quantity),
        currency: (currency != null ? currency.value : this.currency),
        security: (security != null ? security.value : this.security));
  }
}

@JsonSerializable(explicitToJson: true)
class InvestmentsTransactionsOverride {
  InvestmentsTransactionsOverride({
    required this.date,
    required this.name,
    required this.quantity,
    required this.price,
    this.fees,
    required this.type,
    required this.currency,
    this.security,
  });

  factory InvestmentsTransactionsOverride.fromJson(Map<String, dynamic> json) =>
      _$InvestmentsTransactionsOverrideFromJson(json);

  @JsonKey(name: 'date', toJson: _dateToJson)
  final DateTime date;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'quantity')
  final double quantity;
  @JsonKey(name: 'price')
  final double price;
  @JsonKey(name: 'fees')
  final double? fees;
  @JsonKey(name: 'type')
  final String type;
  @JsonKey(name: 'currency')
  final String currency;
  @JsonKey(name: 'security')
  final SecurityOverride? security;
  static const fromJsonFactory = _$InvestmentsTransactionsOverrideFromJson;
  static const toJsonFactory = _$InvestmentsTransactionsOverrideToJson;
  Map<String, dynamic> toJson() =>
      _$InvestmentsTransactionsOverrideToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvestmentsTransactionsOverride &&
            (identical(other.date, date) ||
                const DeepCollectionEquality().equals(other.date, date)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.quantity, quantity) ||
                const DeepCollectionEquality()
                    .equals(other.quantity, quantity)) &&
            (identical(other.price, price) ||
                const DeepCollectionEquality().equals(other.price, price)) &&
            (identical(other.fees, fees) ||
                const DeepCollectionEquality().equals(other.fees, fees)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.currency, currency) ||
                const DeepCollectionEquality()
                    .equals(other.currency, currency)) &&
            (identical(other.security, security) ||
                const DeepCollectionEquality()
                    .equals(other.security, security)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(date) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(quantity) ^
      const DeepCollectionEquality().hash(price) ^
      const DeepCollectionEquality().hash(fees) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(currency) ^
      const DeepCollectionEquality().hash(security) ^
      runtimeType.hashCode;
}

extension $InvestmentsTransactionsOverrideExtension
    on InvestmentsTransactionsOverride {
  InvestmentsTransactionsOverride copyWith(
      {DateTime? date,
      String? name,
      double? quantity,
      double? price,
      double? fees,
      String? type,
      String? currency,
      SecurityOverride? security}) {
    return InvestmentsTransactionsOverride(
        date: date ?? this.date,
        name: name ?? this.name,
        quantity: quantity ?? this.quantity,
        price: price ?? this.price,
        fees: fees ?? this.fees,
        type: type ?? this.type,
        currency: currency ?? this.currency,
        security: security ?? this.security);
  }

  InvestmentsTransactionsOverride copyWithWrapped(
      {Wrapped<DateTime>? date,
      Wrapped<String>? name,
      Wrapped<double>? quantity,
      Wrapped<double>? price,
      Wrapped<double?>? fees,
      Wrapped<String>? type,
      Wrapped<String>? currency,
      Wrapped<SecurityOverride?>? security}) {
    return InvestmentsTransactionsOverride(
        date: (date != null ? date.value : this.date),
        name: (name != null ? name.value : this.name),
        quantity: (quantity != null ? quantity.value : this.quantity),
        price: (price != null ? price.value : this.price),
        fees: (fees != null ? fees.value : this.fees),
        type: (type != null ? type.value : this.type),
        currency: (currency != null ? currency.value : this.currency),
        security: (security != null ? security.value : this.security));
  }
}

@JsonSerializable(explicitToJson: true)
class LiabilityOverride {
  LiabilityOverride({
    required this.type,
    required this.purchaseApr,
    required this.cashApr,
    required this.balanceTransferApr,
    required this.specialApr,
    required this.lastPaymentAmount,
    required this.minimumPaymentAmount,
    required this.isOverdue,
    required this.originationDate,
    required this.principal,
    required this.nominalApr,
    required this.interestCapitalizationGracePeriodMonths,
    required this.repaymentModel,
    required this.expectedPayoffDate,
    required this.guarantor,
    required this.isFederal,
    required this.loanName,
    required this.loanStatus,
    required this.paymentReferenceNumber,
    required this.pslfStatus,
    required this.repaymentPlanDescription,
    required this.repaymentPlanType,
    required this.sequenceNumber,
    required this.servicerAddress,
  });

  factory LiabilityOverride.fromJson(Map<String, dynamic> json) =>
      _$LiabilityOverrideFromJson(json);

  @JsonKey(name: 'type')
  final String type;
  @JsonKey(name: 'purchase_apr')
  final double purchaseApr;
  @JsonKey(name: 'cash_apr')
  final double cashApr;
  @JsonKey(name: 'balance_transfer_apr')
  final double balanceTransferApr;
  @JsonKey(name: 'special_apr')
  final double specialApr;
  @JsonKey(name: 'last_payment_amount')
  final double lastPaymentAmount;
  @JsonKey(name: 'minimum_payment_amount')
  final double minimumPaymentAmount;
  @JsonKey(name: 'is_overdue')
  final bool isOverdue;
  @JsonKey(name: 'origination_date', toJson: _dateToJson)
  final DateTime originationDate;
  @JsonKey(name: 'principal')
  final double principal;
  @JsonKey(name: 'nominal_apr')
  final double nominalApr;
  @JsonKey(name: 'interest_capitalization_grace_period_months')
  final double interestCapitalizationGracePeriodMonths;
  @JsonKey(name: 'repayment_model')
  final StudentLoanRepaymentModel repaymentModel;
  @JsonKey(name: 'expected_payoff_date', toJson: _dateToJson)
  final DateTime expectedPayoffDate;
  @JsonKey(name: 'guarantor')
  final String guarantor;
  @JsonKey(name: 'is_federal')
  final bool isFederal;
  @JsonKey(name: 'loan_name')
  final String loanName;
  @JsonKey(name: 'loan_status')
  final StudentLoanStatus loanStatus;
  @JsonKey(name: 'payment_reference_number')
  final String paymentReferenceNumber;
  @JsonKey(name: 'pslf_status')
  final PSLFStatus pslfStatus;
  @JsonKey(name: 'repayment_plan_description')
  final String repaymentPlanDescription;
  @JsonKey(name: 'repayment_plan_type')
  final String repaymentPlanType;
  @JsonKey(name: 'sequence_number')
  final String sequenceNumber;
  @JsonKey(name: 'servicer_address')
  final Address servicerAddress;
  static const fromJsonFactory = _$LiabilityOverrideFromJson;
  static const toJsonFactory = _$LiabilityOverrideToJson;
  Map<String, dynamic> toJson() => _$LiabilityOverrideToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LiabilityOverride &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.purchaseApr, purchaseApr) ||
                const DeepCollectionEquality()
                    .equals(other.purchaseApr, purchaseApr)) &&
            (identical(other.cashApr, cashApr) ||
                const DeepCollectionEquality()
                    .equals(other.cashApr, cashApr)) &&
            (identical(other.balanceTransferApr, balanceTransferApr) ||
                const DeepCollectionEquality()
                    .equals(other.balanceTransferApr, balanceTransferApr)) &&
            (identical(other.specialApr, specialApr) ||
                const DeepCollectionEquality()
                    .equals(other.specialApr, specialApr)) &&
            (identical(other.lastPaymentAmount, lastPaymentAmount) ||
                const DeepCollectionEquality()
                    .equals(other.lastPaymentAmount, lastPaymentAmount)) &&
            (identical(other.minimumPaymentAmount, minimumPaymentAmount) ||
                const DeepCollectionEquality().equals(
                    other.minimumPaymentAmount, minimumPaymentAmount)) &&
            (identical(other.isOverdue, isOverdue) ||
                const DeepCollectionEquality()
                    .equals(other.isOverdue, isOverdue)) &&
            (identical(other.originationDate, originationDate) ||
                const DeepCollectionEquality()
                    .equals(other.originationDate, originationDate)) &&
            (identical(other.principal, principal) ||
                const DeepCollectionEquality()
                    .equals(other.principal, principal)) &&
            (identical(other.nominalApr, nominalApr) ||
                const DeepCollectionEquality()
                    .equals(other.nominalApr, nominalApr)) &&
            (identical(other.interestCapitalizationGracePeriodMonths, interestCapitalizationGracePeriodMonths) ||
                const DeepCollectionEquality().equals(
                    other.interestCapitalizationGracePeriodMonths,
                    interestCapitalizationGracePeriodMonths)) &&
            (identical(other.repaymentModel, repaymentModel) ||
                const DeepCollectionEquality()
                    .equals(other.repaymentModel, repaymentModel)) &&
            (identical(other.expectedPayoffDate, expectedPayoffDate) ||
                const DeepCollectionEquality()
                    .equals(other.expectedPayoffDate, expectedPayoffDate)) &&
            (identical(other.guarantor, guarantor) ||
                const DeepCollectionEquality()
                    .equals(other.guarantor, guarantor)) &&
            (identical(other.isFederal, isFederal) ||
                const DeepCollectionEquality()
                    .equals(other.isFederal, isFederal)) &&
            (identical(other.loanName, loanName) ||
                const DeepCollectionEquality()
                    .equals(other.loanName, loanName)) &&
            (identical(other.loanStatus, loanStatus) ||
                const DeepCollectionEquality()
                    .equals(other.loanStatus, loanStatus)) &&
            (identical(other.paymentReferenceNumber, paymentReferenceNumber) ||
                const DeepCollectionEquality().equals(
                    other.paymentReferenceNumber, paymentReferenceNumber)) &&
            (identical(other.pslfStatus, pslfStatus) ||
                const DeepCollectionEquality().equals(other.pslfStatus, pslfStatus)) &&
            (identical(other.repaymentPlanDescription, repaymentPlanDescription) || const DeepCollectionEquality().equals(other.repaymentPlanDescription, repaymentPlanDescription)) &&
            (identical(other.repaymentPlanType, repaymentPlanType) || const DeepCollectionEquality().equals(other.repaymentPlanType, repaymentPlanType)) &&
            (identical(other.sequenceNumber, sequenceNumber) || const DeepCollectionEquality().equals(other.sequenceNumber, sequenceNumber)) &&
            (identical(other.servicerAddress, servicerAddress) || const DeepCollectionEquality().equals(other.servicerAddress, servicerAddress)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(purchaseApr) ^
      const DeepCollectionEquality().hash(cashApr) ^
      const DeepCollectionEquality().hash(balanceTransferApr) ^
      const DeepCollectionEquality().hash(specialApr) ^
      const DeepCollectionEquality().hash(lastPaymentAmount) ^
      const DeepCollectionEquality().hash(minimumPaymentAmount) ^
      const DeepCollectionEquality().hash(isOverdue) ^
      const DeepCollectionEquality().hash(originationDate) ^
      const DeepCollectionEquality().hash(principal) ^
      const DeepCollectionEquality().hash(nominalApr) ^
      const DeepCollectionEquality()
          .hash(interestCapitalizationGracePeriodMonths) ^
      const DeepCollectionEquality().hash(repaymentModel) ^
      const DeepCollectionEquality().hash(expectedPayoffDate) ^
      const DeepCollectionEquality().hash(guarantor) ^
      const DeepCollectionEquality().hash(isFederal) ^
      const DeepCollectionEquality().hash(loanName) ^
      const DeepCollectionEquality().hash(loanStatus) ^
      const DeepCollectionEquality().hash(paymentReferenceNumber) ^
      const DeepCollectionEquality().hash(pslfStatus) ^
      const DeepCollectionEquality().hash(repaymentPlanDescription) ^
      const DeepCollectionEquality().hash(repaymentPlanType) ^
      const DeepCollectionEquality().hash(sequenceNumber) ^
      const DeepCollectionEquality().hash(servicerAddress) ^
      runtimeType.hashCode;
}

extension $LiabilityOverrideExtension on LiabilityOverride {
  LiabilityOverride copyWith(
      {String? type,
      double? purchaseApr,
      double? cashApr,
      double? balanceTransferApr,
      double? specialApr,
      double? lastPaymentAmount,
      double? minimumPaymentAmount,
      bool? isOverdue,
      DateTime? originationDate,
      double? principal,
      double? nominalApr,
      double? interestCapitalizationGracePeriodMonths,
      StudentLoanRepaymentModel? repaymentModel,
      DateTime? expectedPayoffDate,
      String? guarantor,
      bool? isFederal,
      String? loanName,
      StudentLoanStatus? loanStatus,
      String? paymentReferenceNumber,
      PSLFStatus? pslfStatus,
      String? repaymentPlanDescription,
      String? repaymentPlanType,
      String? sequenceNumber,
      Address? servicerAddress}) {
    return LiabilityOverride(
        type: type ?? this.type,
        purchaseApr: purchaseApr ?? this.purchaseApr,
        cashApr: cashApr ?? this.cashApr,
        balanceTransferApr: balanceTransferApr ?? this.balanceTransferApr,
        specialApr: specialApr ?? this.specialApr,
        lastPaymentAmount: lastPaymentAmount ?? this.lastPaymentAmount,
        minimumPaymentAmount: minimumPaymentAmount ?? this.minimumPaymentAmount,
        isOverdue: isOverdue ?? this.isOverdue,
        originationDate: originationDate ?? this.originationDate,
        principal: principal ?? this.principal,
        nominalApr: nominalApr ?? this.nominalApr,
        interestCapitalizationGracePeriodMonths:
            interestCapitalizationGracePeriodMonths ??
                this.interestCapitalizationGracePeriodMonths,
        repaymentModel: repaymentModel ?? this.repaymentModel,
        expectedPayoffDate: expectedPayoffDate ?? this.expectedPayoffDate,
        guarantor: guarantor ?? this.guarantor,
        isFederal: isFederal ?? this.isFederal,
        loanName: loanName ?? this.loanName,
        loanStatus: loanStatus ?? this.loanStatus,
        paymentReferenceNumber:
            paymentReferenceNumber ?? this.paymentReferenceNumber,
        pslfStatus: pslfStatus ?? this.pslfStatus,
        repaymentPlanDescription:
            repaymentPlanDescription ?? this.repaymentPlanDescription,
        repaymentPlanType: repaymentPlanType ?? this.repaymentPlanType,
        sequenceNumber: sequenceNumber ?? this.sequenceNumber,
        servicerAddress: servicerAddress ?? this.servicerAddress);
  }

  LiabilityOverride copyWithWrapped(
      {Wrapped<String>? type,
      Wrapped<double>? purchaseApr,
      Wrapped<double>? cashApr,
      Wrapped<double>? balanceTransferApr,
      Wrapped<double>? specialApr,
      Wrapped<double>? lastPaymentAmount,
      Wrapped<double>? minimumPaymentAmount,
      Wrapped<bool>? isOverdue,
      Wrapped<DateTime>? originationDate,
      Wrapped<double>? principal,
      Wrapped<double>? nominalApr,
      Wrapped<double>? interestCapitalizationGracePeriodMonths,
      Wrapped<StudentLoanRepaymentModel>? repaymentModel,
      Wrapped<DateTime>? expectedPayoffDate,
      Wrapped<String>? guarantor,
      Wrapped<bool>? isFederal,
      Wrapped<String>? loanName,
      Wrapped<StudentLoanStatus>? loanStatus,
      Wrapped<String>? paymentReferenceNumber,
      Wrapped<PSLFStatus>? pslfStatus,
      Wrapped<String>? repaymentPlanDescription,
      Wrapped<String>? repaymentPlanType,
      Wrapped<String>? sequenceNumber,
      Wrapped<Address>? servicerAddress}) {
    return LiabilityOverride(
        type: (type != null ? type.value : this.type),
        purchaseApr:
            (purchaseApr != null ? purchaseApr.value : this.purchaseApr),
        cashApr: (cashApr != null ? cashApr.value : this.cashApr),
        balanceTransferApr: (balanceTransferApr != null
            ? balanceTransferApr.value
            : this.balanceTransferApr),
        specialApr: (specialApr != null ? specialApr.value : this.specialApr),
        lastPaymentAmount: (lastPaymentAmount != null
            ? lastPaymentAmount.value
            : this.lastPaymentAmount),
        minimumPaymentAmount: (minimumPaymentAmount != null
            ? minimumPaymentAmount.value
            : this.minimumPaymentAmount),
        isOverdue: (isOverdue != null ? isOverdue.value : this.isOverdue),
        originationDate: (originationDate != null
            ? originationDate.value
            : this.originationDate),
        principal: (principal != null ? principal.value : this.principal),
        nominalApr: (nominalApr != null ? nominalApr.value : this.nominalApr),
        interestCapitalizationGracePeriodMonths:
            (interestCapitalizationGracePeriodMonths != null
                ? interestCapitalizationGracePeriodMonths.value
                : this.interestCapitalizationGracePeriodMonths),
        repaymentModel: (repaymentModel != null
            ? repaymentModel.value
            : this.repaymentModel),
        expectedPayoffDate: (expectedPayoffDate != null
            ? expectedPayoffDate.value
            : this.expectedPayoffDate),
        guarantor: (guarantor != null ? guarantor.value : this.guarantor),
        isFederal: (isFederal != null ? isFederal.value : this.isFederal),
        loanName: (loanName != null ? loanName.value : this.loanName),
        loanStatus: (loanStatus != null ? loanStatus.value : this.loanStatus),
        paymentReferenceNumber: (paymentReferenceNumber != null
            ? paymentReferenceNumber.value
            : this.paymentReferenceNumber),
        pslfStatus: (pslfStatus != null ? pslfStatus.value : this.pslfStatus),
        repaymentPlanDescription: (repaymentPlanDescription != null
            ? repaymentPlanDescription.value
            : this.repaymentPlanDescription),
        repaymentPlanType: (repaymentPlanType != null
            ? repaymentPlanType.value
            : this.repaymentPlanType),
        sequenceNumber: (sequenceNumber != null
            ? sequenceNumber.value
            : this.sequenceNumber),
        servicerAddress: (servicerAddress != null
            ? servicerAddress.value
            : this.servicerAddress));
  }
}

@JsonSerializable(explicitToJson: true)
class StudentLoanRepaymentModel {
  StudentLoanRepaymentModel({
    required this.type,
    required this.nonRepaymentMonths,
    required this.repaymentMonths,
  });

  factory StudentLoanRepaymentModel.fromJson(Map<String, dynamic> json) =>
      _$StudentLoanRepaymentModelFromJson(json);

  @JsonKey(name: 'type')
  final String type;
  @JsonKey(name: 'non_repayment_months')
  final double nonRepaymentMonths;
  @JsonKey(name: 'repayment_months')
  final double repaymentMonths;
  static const fromJsonFactory = _$StudentLoanRepaymentModelFromJson;
  static const toJsonFactory = _$StudentLoanRepaymentModelToJson;
  Map<String, dynamic> toJson() => _$StudentLoanRepaymentModelToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is StudentLoanRepaymentModel &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.nonRepaymentMonths, nonRepaymentMonths) ||
                const DeepCollectionEquality()
                    .equals(other.nonRepaymentMonths, nonRepaymentMonths)) &&
            (identical(other.repaymentMonths, repaymentMonths) ||
                const DeepCollectionEquality()
                    .equals(other.repaymentMonths, repaymentMonths)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(nonRepaymentMonths) ^
      const DeepCollectionEquality().hash(repaymentMonths) ^
      runtimeType.hashCode;
}

extension $StudentLoanRepaymentModelExtension on StudentLoanRepaymentModel {
  StudentLoanRepaymentModel copyWith(
      {String? type, double? nonRepaymentMonths, double? repaymentMonths}) {
    return StudentLoanRepaymentModel(
        type: type ?? this.type,
        nonRepaymentMonths: nonRepaymentMonths ?? this.nonRepaymentMonths,
        repaymentMonths: repaymentMonths ?? this.repaymentMonths);
  }

  StudentLoanRepaymentModel copyWithWrapped(
      {Wrapped<String>? type,
      Wrapped<double>? nonRepaymentMonths,
      Wrapped<double>? repaymentMonths}) {
    return StudentLoanRepaymentModel(
        type: (type != null ? type.value : this.type),
        nonRepaymentMonths: (nonRepaymentMonths != null
            ? nonRepaymentMonths.value
            : this.nonRepaymentMonths),
        repaymentMonths: (repaymentMonths != null
            ? repaymentMonths.value
            : this.repaymentMonths));
  }
}

@JsonSerializable(explicitToJson: true)
class InflowModel {
  InflowModel({
    required this.type,
    required this.incomeAmount,
    required this.paymentDayOfMonth,
    required this.transactionName,
    required this.statementDayOfMonth,
  });

  factory InflowModel.fromJson(Map<String, dynamic> json) =>
      _$InflowModelFromJson(json);

  @JsonKey(name: 'type')
  final String type;
  @JsonKey(name: 'income_amount')
  final double incomeAmount;
  @JsonKey(name: 'payment_day_of_month')
  final double paymentDayOfMonth;
  @JsonKey(name: 'transaction_name')
  final String transactionName;
  @JsonKey(name: 'statement_day_of_month')
  final String statementDayOfMonth;
  static const fromJsonFactory = _$InflowModelFromJson;
  static const toJsonFactory = _$InflowModelToJson;
  Map<String, dynamic> toJson() => _$InflowModelToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InflowModel &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.incomeAmount, incomeAmount) ||
                const DeepCollectionEquality()
                    .equals(other.incomeAmount, incomeAmount)) &&
            (identical(other.paymentDayOfMonth, paymentDayOfMonth) ||
                const DeepCollectionEquality()
                    .equals(other.paymentDayOfMonth, paymentDayOfMonth)) &&
            (identical(other.transactionName, transactionName) ||
                const DeepCollectionEquality()
                    .equals(other.transactionName, transactionName)) &&
            (identical(other.statementDayOfMonth, statementDayOfMonth) ||
                const DeepCollectionEquality()
                    .equals(other.statementDayOfMonth, statementDayOfMonth)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(incomeAmount) ^
      const DeepCollectionEquality().hash(paymentDayOfMonth) ^
      const DeepCollectionEquality().hash(transactionName) ^
      const DeepCollectionEquality().hash(statementDayOfMonth) ^
      runtimeType.hashCode;
}

extension $InflowModelExtension on InflowModel {
  InflowModel copyWith(
      {String? type,
      double? incomeAmount,
      double? paymentDayOfMonth,
      String? transactionName,
      String? statementDayOfMonth}) {
    return InflowModel(
        type: type ?? this.type,
        incomeAmount: incomeAmount ?? this.incomeAmount,
        paymentDayOfMonth: paymentDayOfMonth ?? this.paymentDayOfMonth,
        transactionName: transactionName ?? this.transactionName,
        statementDayOfMonth: statementDayOfMonth ?? this.statementDayOfMonth);
  }

  InflowModel copyWithWrapped(
      {Wrapped<String>? type,
      Wrapped<double>? incomeAmount,
      Wrapped<double>? paymentDayOfMonth,
      Wrapped<String>? transactionName,
      Wrapped<String>? statementDayOfMonth}) {
    return InflowModel(
        type: (type != null ? type.value : this.type),
        incomeAmount:
            (incomeAmount != null ? incomeAmount.value : this.incomeAmount),
        paymentDayOfMonth: (paymentDayOfMonth != null
            ? paymentDayOfMonth.value
            : this.paymentDayOfMonth),
        transactionName: (transactionName != null
            ? transactionName.value
            : this.transactionName),
        statementDayOfMonth: (statementDayOfMonth != null
            ? statementDayOfMonth.value
            : this.statementDayOfMonth));
  }
}

@JsonSerializable(explicitToJson: true)
class IncomeOverride {
  IncomeOverride({
    this.paystubs,
  });

  factory IncomeOverride.fromJson(Map<String, dynamic> json) =>
      _$IncomeOverrideFromJson(json);

  @JsonKey(name: 'paystubs', defaultValue: <PaystubOverride>[])
  final List<PaystubOverride>? paystubs;
  static const fromJsonFactory = _$IncomeOverrideFromJson;
  static const toJsonFactory = _$IncomeOverrideToJson;
  Map<String, dynamic> toJson() => _$IncomeOverrideToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IncomeOverride &&
            (identical(other.paystubs, paystubs) ||
                const DeepCollectionEquality()
                    .equals(other.paystubs, paystubs)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(paystubs) ^ runtimeType.hashCode;
}

extension $IncomeOverrideExtension on IncomeOverride {
  IncomeOverride copyWith({List<PaystubOverride>? paystubs}) {
    return IncomeOverride(paystubs: paystubs ?? this.paystubs);
  }

  IncomeOverride copyWithWrapped({Wrapped<List<PaystubOverride>?>? paystubs}) {
    return IncomeOverride(
        paystubs: (paystubs != null ? paystubs.value : this.paystubs));
  }
}

@JsonSerializable(explicitToJson: true)
class PaystubOverride {
  PaystubOverride({
    this.employer,
    this.employee,
    this.incomeBreakdown,
    this.payPeriodDetails,
  });

  factory PaystubOverride.fromJson(Map<String, dynamic> json) =>
      _$PaystubOverrideFromJson(json);

  @JsonKey(name: 'employer')
  final PaystubOverrideEmployer? employer;
  @JsonKey(name: 'employee')
  final PaystubOverrideEmployee? employee;
  @JsonKey(name: 'income_breakdown', defaultValue: <IncomeBreakdown>[])
  final List<IncomeBreakdown>? incomeBreakdown;
  @JsonKey(name: 'pay_period_details')
  final PayPeriodDetails? payPeriodDetails;
  static const fromJsonFactory = _$PaystubOverrideFromJson;
  static const toJsonFactory = _$PaystubOverrideToJson;
  Map<String, dynamic> toJson() => _$PaystubOverrideToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaystubOverride &&
            (identical(other.employer, employer) ||
                const DeepCollectionEquality()
                    .equals(other.employer, employer)) &&
            (identical(other.employee, employee) ||
                const DeepCollectionEquality()
                    .equals(other.employee, employee)) &&
            (identical(other.incomeBreakdown, incomeBreakdown) ||
                const DeepCollectionEquality()
                    .equals(other.incomeBreakdown, incomeBreakdown)) &&
            (identical(other.payPeriodDetails, payPeriodDetails) ||
                const DeepCollectionEquality()
                    .equals(other.payPeriodDetails, payPeriodDetails)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(employer) ^
      const DeepCollectionEquality().hash(employee) ^
      const DeepCollectionEquality().hash(incomeBreakdown) ^
      const DeepCollectionEquality().hash(payPeriodDetails) ^
      runtimeType.hashCode;
}

extension $PaystubOverrideExtension on PaystubOverride {
  PaystubOverride copyWith(
      {PaystubOverrideEmployer? employer,
      PaystubOverrideEmployee? employee,
      List<IncomeBreakdown>? incomeBreakdown,
      PayPeriodDetails? payPeriodDetails}) {
    return PaystubOverride(
        employer: employer ?? this.employer,
        employee: employee ?? this.employee,
        incomeBreakdown: incomeBreakdown ?? this.incomeBreakdown,
        payPeriodDetails: payPeriodDetails ?? this.payPeriodDetails);
  }

  PaystubOverride copyWithWrapped(
      {Wrapped<PaystubOverrideEmployer?>? employer,
      Wrapped<PaystubOverrideEmployee?>? employee,
      Wrapped<List<IncomeBreakdown>?>? incomeBreakdown,
      Wrapped<PayPeriodDetails?>? payPeriodDetails}) {
    return PaystubOverride(
        employer: (employer != null ? employer.value : this.employer),
        employee: (employee != null ? employee.value : this.employee),
        incomeBreakdown: (incomeBreakdown != null
            ? incomeBreakdown.value
            : this.incomeBreakdown),
        payPeriodDetails: (payPeriodDetails != null
            ? payPeriodDetails.value
            : this.payPeriodDetails));
  }
}

@JsonSerializable(explicitToJson: true)
class PaystubOverrideEmployer {
  PaystubOverrideEmployer({
    this.name,
  });

  factory PaystubOverrideEmployer.fromJson(Map<String, dynamic> json) =>
      _$PaystubOverrideEmployerFromJson(json);

  @JsonKey(name: 'name')
  final String? name;
  static const fromJsonFactory = _$PaystubOverrideEmployerFromJson;
  static const toJsonFactory = _$PaystubOverrideEmployerToJson;
  Map<String, dynamic> toJson() => _$PaystubOverrideEmployerToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaystubOverrideEmployer &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^ runtimeType.hashCode;
}

extension $PaystubOverrideEmployerExtension on PaystubOverrideEmployer {
  PaystubOverrideEmployer copyWith({String? name}) {
    return PaystubOverrideEmployer(name: name ?? this.name);
  }

  PaystubOverrideEmployer copyWithWrapped({Wrapped<String?>? name}) {
    return PaystubOverrideEmployer(
        name: (name != null ? name.value : this.name));
  }
}

@JsonSerializable(explicitToJson: true)
class PaystubOverrideEmployee {
  PaystubOverrideEmployee({
    this.name,
    this.address,
  });

  factory PaystubOverrideEmployee.fromJson(Map<String, dynamic> json) =>
      _$PaystubOverrideEmployeeFromJson(json);

  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'address')
  final PaystubOverrideEmployeeAddress? address;
  static const fromJsonFactory = _$PaystubOverrideEmployeeFromJson;
  static const toJsonFactory = _$PaystubOverrideEmployeeToJson;
  Map<String, dynamic> toJson() => _$PaystubOverrideEmployeeToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaystubOverrideEmployee &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality().equals(other.address, address)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(address) ^
      runtimeType.hashCode;
}

extension $PaystubOverrideEmployeeExtension on PaystubOverrideEmployee {
  PaystubOverrideEmployee copyWith(
      {String? name, PaystubOverrideEmployeeAddress? address}) {
    return PaystubOverrideEmployee(
        name: name ?? this.name, address: address ?? this.address);
  }

  PaystubOverrideEmployee copyWithWrapped(
      {Wrapped<String?>? name,
      Wrapped<PaystubOverrideEmployeeAddress?>? address}) {
    return PaystubOverrideEmployee(
        name: (name != null ? name.value : this.name),
        address: (address != null ? address.value : this.address));
  }
}

@JsonSerializable(explicitToJson: true)
class PaystubOverrideEmployeeAddress {
  PaystubOverrideEmployeeAddress({
    this.city,
    this.region,
    this.street,
    this.postalCode,
    this.country,
  });

  factory PaystubOverrideEmployeeAddress.fromJson(Map<String, dynamic> json) =>
      _$PaystubOverrideEmployeeAddressFromJson(json);

  @JsonKey(name: 'city')
  final String? city;
  @JsonKey(name: 'region')
  final String? region;
  @JsonKey(name: 'street')
  final String? street;
  @JsonKey(name: 'postal_code')
  final String? postalCode;
  @JsonKey(name: 'country')
  final String? country;
  static const fromJsonFactory = _$PaystubOverrideEmployeeAddressFromJson;
  static const toJsonFactory = _$PaystubOverrideEmployeeAddressToJson;
  Map<String, dynamic> toJson() => _$PaystubOverrideEmployeeAddressToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaystubOverrideEmployeeAddress &&
            (identical(other.city, city) ||
                const DeepCollectionEquality().equals(other.city, city)) &&
            (identical(other.region, region) ||
                const DeepCollectionEquality().equals(other.region, region)) &&
            (identical(other.street, street) ||
                const DeepCollectionEquality().equals(other.street, street)) &&
            (identical(other.postalCode, postalCode) ||
                const DeepCollectionEquality()
                    .equals(other.postalCode, postalCode)) &&
            (identical(other.country, country) ||
                const DeepCollectionEquality().equals(other.country, country)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(city) ^
      const DeepCollectionEquality().hash(region) ^
      const DeepCollectionEquality().hash(street) ^
      const DeepCollectionEquality().hash(postalCode) ^
      const DeepCollectionEquality().hash(country) ^
      runtimeType.hashCode;
}

extension $PaystubOverrideEmployeeAddressExtension
    on PaystubOverrideEmployeeAddress {
  PaystubOverrideEmployeeAddress copyWith(
      {String? city,
      String? region,
      String? street,
      String? postalCode,
      String? country}) {
    return PaystubOverrideEmployeeAddress(
        city: city ?? this.city,
        region: region ?? this.region,
        street: street ?? this.street,
        postalCode: postalCode ?? this.postalCode,
        country: country ?? this.country);
  }

  PaystubOverrideEmployeeAddress copyWithWrapped(
      {Wrapped<String?>? city,
      Wrapped<String?>? region,
      Wrapped<String?>? street,
      Wrapped<String?>? postalCode,
      Wrapped<String?>? country}) {
    return PaystubOverrideEmployeeAddress(
        city: (city != null ? city.value : this.city),
        region: (region != null ? region.value : this.region),
        street: (street != null ? street.value : this.street),
        postalCode: (postalCode != null ? postalCode.value : this.postalCode),
        country: (country != null ? country.value : this.country));
  }
}

@JsonSerializable(explicitToJson: true)
class AutomaticallyVerifiedWebhook {
  AutomaticallyVerifiedWebhook({
    required this.webhookType,
    required this.webhookCode,
    required this.accountId,
    required this.itemId,
    required this.environment,
  });

  factory AutomaticallyVerifiedWebhook.fromJson(Map<String, dynamic> json) =>
      _$AutomaticallyVerifiedWebhookFromJson(json);

  @JsonKey(name: 'webhook_type')
  final String webhookType;
  @JsonKey(name: 'webhook_code')
  final String webhookCode;
  @JsonKey(name: 'account_id')
  final String accountId;
  @JsonKey(name: 'item_id')
  final String itemId;
  @JsonKey(
    name: 'environment',
    toJson: webhookEnvironmentValuesToJson,
    fromJson: webhookEnvironmentValuesFromJson,
  )
  final enums.WebhookEnvironmentValues environment;
  static const fromJsonFactory = _$AutomaticallyVerifiedWebhookFromJson;
  static const toJsonFactory = _$AutomaticallyVerifiedWebhookToJson;
  Map<String, dynamic> toJson() => _$AutomaticallyVerifiedWebhookToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AutomaticallyVerifiedWebhook &&
            (identical(other.webhookType, webhookType) ||
                const DeepCollectionEquality()
                    .equals(other.webhookType, webhookType)) &&
            (identical(other.webhookCode, webhookCode) ||
                const DeepCollectionEquality()
                    .equals(other.webhookCode, webhookCode)) &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)) &&
            (identical(other.environment, environment) ||
                const DeepCollectionEquality()
                    .equals(other.environment, environment)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(webhookType) ^
      const DeepCollectionEquality().hash(webhookCode) ^
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(itemId) ^
      const DeepCollectionEquality().hash(environment) ^
      runtimeType.hashCode;
}

extension $AutomaticallyVerifiedWebhookExtension
    on AutomaticallyVerifiedWebhook {
  AutomaticallyVerifiedWebhook copyWith(
      {String? webhookType,
      String? webhookCode,
      String? accountId,
      String? itemId,
      enums.WebhookEnvironmentValues? environment}) {
    return AutomaticallyVerifiedWebhook(
        webhookType: webhookType ?? this.webhookType,
        webhookCode: webhookCode ?? this.webhookCode,
        accountId: accountId ?? this.accountId,
        itemId: itemId ?? this.itemId,
        environment: environment ?? this.environment);
  }

  AutomaticallyVerifiedWebhook copyWithWrapped(
      {Wrapped<String>? webhookType,
      Wrapped<String>? webhookCode,
      Wrapped<String>? accountId,
      Wrapped<String>? itemId,
      Wrapped<enums.WebhookEnvironmentValues>? environment}) {
    return AutomaticallyVerifiedWebhook(
        webhookType:
            (webhookType != null ? webhookType.value : this.webhookType),
        webhookCode:
            (webhookCode != null ? webhookCode.value : this.webhookCode),
        accountId: (accountId != null ? accountId.value : this.accountId),
        itemId: (itemId != null ? itemId.value : this.itemId),
        environment:
            (environment != null ? environment.value : this.environment));
  }
}

@JsonSerializable(explicitToJson: true)
class JWTHeader {
  JWTHeader({
    required this.id,
  });

  factory JWTHeader.fromJson(Map<String, dynamic> json) =>
      _$JWTHeaderFromJson(json);

  @JsonKey(name: 'id')
  final String id;
  static const fromJsonFactory = _$JWTHeaderFromJson;
  static const toJsonFactory = _$JWTHeaderToJson;
  Map<String, dynamic> toJson() => _$JWTHeaderToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is JWTHeader &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^ runtimeType.hashCode;
}

extension $JWTHeaderExtension on JWTHeader {
  JWTHeader copyWith({String? id}) {
    return JWTHeader(id: id ?? this.id);
  }

  JWTHeader copyWithWrapped({Wrapped<String>? id}) {
    return JWTHeader(id: (id != null ? id.value : this.id));
  }
}

@JsonSerializable(explicitToJson: true)
class VerificationExpiredWebhook {
  VerificationExpiredWebhook({
    required this.webhookType,
    required this.webhookCode,
    required this.itemId,
    required this.accountId,
    required this.environment,
  });

  factory VerificationExpiredWebhook.fromJson(Map<String, dynamic> json) =>
      _$VerificationExpiredWebhookFromJson(json);

  @JsonKey(name: 'webhook_type')
  final String webhookType;
  @JsonKey(name: 'webhook_code')
  final String webhookCode;
  @JsonKey(name: 'item_id')
  final String itemId;
  @JsonKey(name: 'account_id')
  final String accountId;
  @JsonKey(
    name: 'environment',
    toJson: webhookEnvironmentValuesToJson,
    fromJson: webhookEnvironmentValuesFromJson,
  )
  final enums.WebhookEnvironmentValues environment;
  static const fromJsonFactory = _$VerificationExpiredWebhookFromJson;
  static const toJsonFactory = _$VerificationExpiredWebhookToJson;
  Map<String, dynamic> toJson() => _$VerificationExpiredWebhookToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is VerificationExpiredWebhook &&
            (identical(other.webhookType, webhookType) ||
                const DeepCollectionEquality()
                    .equals(other.webhookType, webhookType)) &&
            (identical(other.webhookCode, webhookCode) ||
                const DeepCollectionEquality()
                    .equals(other.webhookCode, webhookCode)) &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)) &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.environment, environment) ||
                const DeepCollectionEquality()
                    .equals(other.environment, environment)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(webhookType) ^
      const DeepCollectionEquality().hash(webhookCode) ^
      const DeepCollectionEquality().hash(itemId) ^
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(environment) ^
      runtimeType.hashCode;
}

extension $VerificationExpiredWebhookExtension on VerificationExpiredWebhook {
  VerificationExpiredWebhook copyWith(
      {String? webhookType,
      String? webhookCode,
      String? itemId,
      String? accountId,
      enums.WebhookEnvironmentValues? environment}) {
    return VerificationExpiredWebhook(
        webhookType: webhookType ?? this.webhookType,
        webhookCode: webhookCode ?? this.webhookCode,
        itemId: itemId ?? this.itemId,
        accountId: accountId ?? this.accountId,
        environment: environment ?? this.environment);
  }

  VerificationExpiredWebhook copyWithWrapped(
      {Wrapped<String>? webhookType,
      Wrapped<String>? webhookCode,
      Wrapped<String>? itemId,
      Wrapped<String>? accountId,
      Wrapped<enums.WebhookEnvironmentValues>? environment}) {
    return VerificationExpiredWebhook(
        webhookType:
            (webhookType != null ? webhookType.value : this.webhookType),
        webhookCode:
            (webhookCode != null ? webhookCode.value : this.webhookCode),
        itemId: (itemId != null ? itemId.value : this.itemId),
        accountId: (accountId != null ? accountId.value : this.accountId),
        environment:
            (environment != null ? environment.value : this.environment));
  }
}

@JsonSerializable(explicitToJson: true)
class WebhookUpdateAcknowledgedWebhook {
  WebhookUpdateAcknowledgedWebhook({
    required this.webhookType,
    required this.webhookCode,
    required this.itemId,
    required this.newWebhookUrl,
    this.error,
    required this.environment,
  });

  factory WebhookUpdateAcknowledgedWebhook.fromJson(
          Map<String, dynamic> json) =>
      _$WebhookUpdateAcknowledgedWebhookFromJson(json);

  @JsonKey(name: 'webhook_type')
  final String webhookType;
  @JsonKey(name: 'webhook_code')
  final String webhookCode;
  @JsonKey(name: 'item_id')
  final String itemId;
  @JsonKey(name: 'new_webhook_url')
  final String newWebhookUrl;
  @JsonKey(name: 'error')
  final PlaidError? error;
  @JsonKey(
    name: 'environment',
    toJson: webhookEnvironmentValuesToJson,
    fromJson: webhookEnvironmentValuesFromJson,
  )
  final enums.WebhookEnvironmentValues environment;
  static const fromJsonFactory = _$WebhookUpdateAcknowledgedWebhookFromJson;
  static const toJsonFactory = _$WebhookUpdateAcknowledgedWebhookToJson;
  Map<String, dynamic> toJson() =>
      _$WebhookUpdateAcknowledgedWebhookToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WebhookUpdateAcknowledgedWebhook &&
            (identical(other.webhookType, webhookType) ||
                const DeepCollectionEquality()
                    .equals(other.webhookType, webhookType)) &&
            (identical(other.webhookCode, webhookCode) ||
                const DeepCollectionEquality()
                    .equals(other.webhookCode, webhookCode)) &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)) &&
            (identical(other.newWebhookUrl, newWebhookUrl) ||
                const DeepCollectionEquality()
                    .equals(other.newWebhookUrl, newWebhookUrl)) &&
            (identical(other.error, error) ||
                const DeepCollectionEquality().equals(other.error, error)) &&
            (identical(other.environment, environment) ||
                const DeepCollectionEquality()
                    .equals(other.environment, environment)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(webhookType) ^
      const DeepCollectionEquality().hash(webhookCode) ^
      const DeepCollectionEquality().hash(itemId) ^
      const DeepCollectionEquality().hash(newWebhookUrl) ^
      const DeepCollectionEquality().hash(error) ^
      const DeepCollectionEquality().hash(environment) ^
      runtimeType.hashCode;
}

extension $WebhookUpdateAcknowledgedWebhookExtension
    on WebhookUpdateAcknowledgedWebhook {
  WebhookUpdateAcknowledgedWebhook copyWith(
      {String? webhookType,
      String? webhookCode,
      String? itemId,
      String? newWebhookUrl,
      PlaidError? error,
      enums.WebhookEnvironmentValues? environment}) {
    return WebhookUpdateAcknowledgedWebhook(
        webhookType: webhookType ?? this.webhookType,
        webhookCode: webhookCode ?? this.webhookCode,
        itemId: itemId ?? this.itemId,
        newWebhookUrl: newWebhookUrl ?? this.newWebhookUrl,
        error: error ?? this.error,
        environment: environment ?? this.environment);
  }

  WebhookUpdateAcknowledgedWebhook copyWithWrapped(
      {Wrapped<String>? webhookType,
      Wrapped<String>? webhookCode,
      Wrapped<String>? itemId,
      Wrapped<String>? newWebhookUrl,
      Wrapped<PlaidError?>? error,
      Wrapped<enums.WebhookEnvironmentValues>? environment}) {
    return WebhookUpdateAcknowledgedWebhook(
        webhookType:
            (webhookType != null ? webhookType.value : this.webhookType),
        webhookCode:
            (webhookCode != null ? webhookCode.value : this.webhookCode),
        itemId: (itemId != null ? itemId.value : this.itemId),
        newWebhookUrl:
            (newWebhookUrl != null ? newWebhookUrl.value : this.newWebhookUrl),
        error: (error != null ? error.value : this.error),
        environment:
            (environment != null ? environment.value : this.environment));
  }
}

@JsonSerializable(explicitToJson: true)
class PendingExpirationWebhook {
  PendingExpirationWebhook({
    required this.webhookType,
    required this.webhookCode,
    required this.itemId,
    required this.consentExpirationTime,
    required this.environment,
  });

  factory PendingExpirationWebhook.fromJson(Map<String, dynamic> json) =>
      _$PendingExpirationWebhookFromJson(json);

  @JsonKey(name: 'webhook_type')
  final String webhookType;
  @JsonKey(name: 'webhook_code')
  final String webhookCode;
  @JsonKey(name: 'item_id')
  final String itemId;
  @JsonKey(name: 'consent_expiration_time')
  final DateTime consentExpirationTime;
  @JsonKey(
    name: 'environment',
    toJson: webhookEnvironmentValuesToJson,
    fromJson: webhookEnvironmentValuesFromJson,
  )
  final enums.WebhookEnvironmentValues environment;
  static const fromJsonFactory = _$PendingExpirationWebhookFromJson;
  static const toJsonFactory = _$PendingExpirationWebhookToJson;
  Map<String, dynamic> toJson() => _$PendingExpirationWebhookToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PendingExpirationWebhook &&
            (identical(other.webhookType, webhookType) ||
                const DeepCollectionEquality()
                    .equals(other.webhookType, webhookType)) &&
            (identical(other.webhookCode, webhookCode) ||
                const DeepCollectionEquality()
                    .equals(other.webhookCode, webhookCode)) &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)) &&
            (identical(other.consentExpirationTime, consentExpirationTime) ||
                const DeepCollectionEquality().equals(
                    other.consentExpirationTime, consentExpirationTime)) &&
            (identical(other.environment, environment) ||
                const DeepCollectionEquality()
                    .equals(other.environment, environment)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(webhookType) ^
      const DeepCollectionEquality().hash(webhookCode) ^
      const DeepCollectionEquality().hash(itemId) ^
      const DeepCollectionEquality().hash(consentExpirationTime) ^
      const DeepCollectionEquality().hash(environment) ^
      runtimeType.hashCode;
}

extension $PendingExpirationWebhookExtension on PendingExpirationWebhook {
  PendingExpirationWebhook copyWith(
      {String? webhookType,
      String? webhookCode,
      String? itemId,
      DateTime? consentExpirationTime,
      enums.WebhookEnvironmentValues? environment}) {
    return PendingExpirationWebhook(
        webhookType: webhookType ?? this.webhookType,
        webhookCode: webhookCode ?? this.webhookCode,
        itemId: itemId ?? this.itemId,
        consentExpirationTime:
            consentExpirationTime ?? this.consentExpirationTime,
        environment: environment ?? this.environment);
  }

  PendingExpirationWebhook copyWithWrapped(
      {Wrapped<String>? webhookType,
      Wrapped<String>? webhookCode,
      Wrapped<String>? itemId,
      Wrapped<DateTime>? consentExpirationTime,
      Wrapped<enums.WebhookEnvironmentValues>? environment}) {
    return PendingExpirationWebhook(
        webhookType:
            (webhookType != null ? webhookType.value : this.webhookType),
        webhookCode:
            (webhookCode != null ? webhookCode.value : this.webhookCode),
        itemId: (itemId != null ? itemId.value : this.itemId),
        consentExpirationTime: (consentExpirationTime != null
            ? consentExpirationTime.value
            : this.consentExpirationTime),
        environment:
            (environment != null ? environment.value : this.environment));
  }
}

@JsonSerializable(explicitToJson: true)
class ItemErrorWebhook {
  ItemErrorWebhook({
    required this.webhookType,
    required this.webhookCode,
    required this.itemId,
    required this.error,
    required this.environment,
  });

  factory ItemErrorWebhook.fromJson(Map<String, dynamic> json) =>
      _$ItemErrorWebhookFromJson(json);

  @JsonKey(name: 'webhook_type')
  final String webhookType;
  @JsonKey(name: 'webhook_code')
  final String webhookCode;
  @JsonKey(name: 'item_id')
  final String itemId;
  @JsonKey(name: 'error')
  final PlaidError? error;
  @JsonKey(
    name: 'environment',
    toJson: webhookEnvironmentValuesToJson,
    fromJson: webhookEnvironmentValuesFromJson,
  )
  final enums.WebhookEnvironmentValues environment;
  static const fromJsonFactory = _$ItemErrorWebhookFromJson;
  static const toJsonFactory = _$ItemErrorWebhookToJson;
  Map<String, dynamic> toJson() => _$ItemErrorWebhookToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ItemErrorWebhook &&
            (identical(other.webhookType, webhookType) ||
                const DeepCollectionEquality()
                    .equals(other.webhookType, webhookType)) &&
            (identical(other.webhookCode, webhookCode) ||
                const DeepCollectionEquality()
                    .equals(other.webhookCode, webhookCode)) &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)) &&
            (identical(other.error, error) ||
                const DeepCollectionEquality().equals(other.error, error)) &&
            (identical(other.environment, environment) ||
                const DeepCollectionEquality()
                    .equals(other.environment, environment)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(webhookType) ^
      const DeepCollectionEquality().hash(webhookCode) ^
      const DeepCollectionEquality().hash(itemId) ^
      const DeepCollectionEquality().hash(error) ^
      const DeepCollectionEquality().hash(environment) ^
      runtimeType.hashCode;
}

extension $ItemErrorWebhookExtension on ItemErrorWebhook {
  ItemErrorWebhook copyWith(
      {String? webhookType,
      String? webhookCode,
      String? itemId,
      PlaidError? error,
      enums.WebhookEnvironmentValues? environment}) {
    return ItemErrorWebhook(
        webhookType: webhookType ?? this.webhookType,
        webhookCode: webhookCode ?? this.webhookCode,
        itemId: itemId ?? this.itemId,
        error: error ?? this.error,
        environment: environment ?? this.environment);
  }

  ItemErrorWebhook copyWithWrapped(
      {Wrapped<String>? webhookType,
      Wrapped<String>? webhookCode,
      Wrapped<String>? itemId,
      Wrapped<PlaidError?>? error,
      Wrapped<enums.WebhookEnvironmentValues>? environment}) {
    return ItemErrorWebhook(
        webhookType:
            (webhookType != null ? webhookType.value : this.webhookType),
        webhookCode:
            (webhookCode != null ? webhookCode.value : this.webhookCode),
        itemId: (itemId != null ? itemId.value : this.itemId),
        error: (error != null ? error.value : this.error),
        environment:
            (environment != null ? environment.value : this.environment));
  }
}

@JsonSerializable(explicitToJson: true)
class ItemProductReadyWebhook {
  ItemProductReadyWebhook({
    required this.webhookType,
    required this.webhookCode,
    required this.itemId,
    this.error,
    required this.environment,
  });

  factory ItemProductReadyWebhook.fromJson(Map<String, dynamic> json) =>
      _$ItemProductReadyWebhookFromJson(json);

  @JsonKey(name: 'webhook_type')
  final String webhookType;
  @JsonKey(name: 'webhook_code')
  final String webhookCode;
  @JsonKey(name: 'item_id')
  final String itemId;
  @JsonKey(name: 'error')
  final PlaidError? error;
  @JsonKey(
    name: 'environment',
    toJson: webhookEnvironmentValuesToJson,
    fromJson: webhookEnvironmentValuesFromJson,
  )
  final enums.WebhookEnvironmentValues environment;
  static const fromJsonFactory = _$ItemProductReadyWebhookFromJson;
  static const toJsonFactory = _$ItemProductReadyWebhookToJson;
  Map<String, dynamic> toJson() => _$ItemProductReadyWebhookToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ItemProductReadyWebhook &&
            (identical(other.webhookType, webhookType) ||
                const DeepCollectionEquality()
                    .equals(other.webhookType, webhookType)) &&
            (identical(other.webhookCode, webhookCode) ||
                const DeepCollectionEquality()
                    .equals(other.webhookCode, webhookCode)) &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)) &&
            (identical(other.error, error) ||
                const DeepCollectionEquality().equals(other.error, error)) &&
            (identical(other.environment, environment) ||
                const DeepCollectionEquality()
                    .equals(other.environment, environment)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(webhookType) ^
      const DeepCollectionEquality().hash(webhookCode) ^
      const DeepCollectionEquality().hash(itemId) ^
      const DeepCollectionEquality().hash(error) ^
      const DeepCollectionEquality().hash(environment) ^
      runtimeType.hashCode;
}

extension $ItemProductReadyWebhookExtension on ItemProductReadyWebhook {
  ItemProductReadyWebhook copyWith(
      {String? webhookType,
      String? webhookCode,
      String? itemId,
      PlaidError? error,
      enums.WebhookEnvironmentValues? environment}) {
    return ItemProductReadyWebhook(
        webhookType: webhookType ?? this.webhookType,
        webhookCode: webhookCode ?? this.webhookCode,
        itemId: itemId ?? this.itemId,
        error: error ?? this.error,
        environment: environment ?? this.environment);
  }

  ItemProductReadyWebhook copyWithWrapped(
      {Wrapped<String>? webhookType,
      Wrapped<String>? webhookCode,
      Wrapped<String>? itemId,
      Wrapped<PlaidError?>? error,
      Wrapped<enums.WebhookEnvironmentValues>? environment}) {
    return ItemProductReadyWebhook(
        webhookType:
            (webhookType != null ? webhookType.value : this.webhookType),
        webhookCode:
            (webhookCode != null ? webhookCode.value : this.webhookCode),
        itemId: (itemId != null ? itemId.value : this.itemId),
        error: (error != null ? error.value : this.error),
        environment:
            (environment != null ? environment.value : this.environment));
  }
}

@JsonSerializable(explicitToJson: true)
class RecaptchaRequiredError {
  RecaptchaRequiredError({
    required this.errorType,
    required this.errorCode,
    required this.displayMessage,
    required this.httpCode,
    required this.linkUserExperience,
    required this.commonCauses,
    required this.troubleshootingSteps,
  });

  factory RecaptchaRequiredError.fromJson(Map<String, dynamic> json) =>
      _$RecaptchaRequiredErrorFromJson(json);

  @JsonKey(name: 'error_type')
  final String errorType;
  @JsonKey(name: 'error_code')
  final String errorCode;
  @JsonKey(name: 'display_message')
  final String displayMessage;
  @JsonKey(name: 'http_code')
  final String httpCode;
  @JsonKey(name: 'link_user_experience')
  final String linkUserExperience;
  @JsonKey(name: 'common_causes')
  final String commonCauses;
  @JsonKey(name: 'troubleshooting_steps')
  final String troubleshootingSteps;
  static const fromJsonFactory = _$RecaptchaRequiredErrorFromJson;
  static const toJsonFactory = _$RecaptchaRequiredErrorToJson;
  Map<String, dynamic> toJson() => _$RecaptchaRequiredErrorToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is RecaptchaRequiredError &&
            (identical(other.errorType, errorType) ||
                const DeepCollectionEquality()
                    .equals(other.errorType, errorType)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.displayMessage, displayMessage) ||
                const DeepCollectionEquality()
                    .equals(other.displayMessage, displayMessage)) &&
            (identical(other.httpCode, httpCode) ||
                const DeepCollectionEquality()
                    .equals(other.httpCode, httpCode)) &&
            (identical(other.linkUserExperience, linkUserExperience) ||
                const DeepCollectionEquality()
                    .equals(other.linkUserExperience, linkUserExperience)) &&
            (identical(other.commonCauses, commonCauses) ||
                const DeepCollectionEquality()
                    .equals(other.commonCauses, commonCauses)) &&
            (identical(other.troubleshootingSteps, troubleshootingSteps) ||
                const DeepCollectionEquality()
                    .equals(other.troubleshootingSteps, troubleshootingSteps)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(errorType) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(displayMessage) ^
      const DeepCollectionEquality().hash(httpCode) ^
      const DeepCollectionEquality().hash(linkUserExperience) ^
      const DeepCollectionEquality().hash(commonCauses) ^
      const DeepCollectionEquality().hash(troubleshootingSteps) ^
      runtimeType.hashCode;
}

extension $RecaptchaRequiredErrorExtension on RecaptchaRequiredError {
  RecaptchaRequiredError copyWith(
      {String? errorType,
      String? errorCode,
      String? displayMessage,
      String? httpCode,
      String? linkUserExperience,
      String? commonCauses,
      String? troubleshootingSteps}) {
    return RecaptchaRequiredError(
        errorType: errorType ?? this.errorType,
        errorCode: errorCode ?? this.errorCode,
        displayMessage: displayMessage ?? this.displayMessage,
        httpCode: httpCode ?? this.httpCode,
        linkUserExperience: linkUserExperience ?? this.linkUserExperience,
        commonCauses: commonCauses ?? this.commonCauses,
        troubleshootingSteps:
            troubleshootingSteps ?? this.troubleshootingSteps);
  }

  RecaptchaRequiredError copyWithWrapped(
      {Wrapped<String>? errorType,
      Wrapped<String>? errorCode,
      Wrapped<String>? displayMessage,
      Wrapped<String>? httpCode,
      Wrapped<String>? linkUserExperience,
      Wrapped<String>? commonCauses,
      Wrapped<String>? troubleshootingSteps}) {
    return RecaptchaRequiredError(
        errorType: (errorType != null ? errorType.value : this.errorType),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        displayMessage: (displayMessage != null
            ? displayMessage.value
            : this.displayMessage),
        httpCode: (httpCode != null ? httpCode.value : this.httpCode),
        linkUserExperience: (linkUserExperience != null
            ? linkUserExperience.value
            : this.linkUserExperience),
        commonCauses:
            (commonCauses != null ? commonCauses.value : this.commonCauses),
        troubleshootingSteps: (troubleshootingSteps != null
            ? troubleshootingSteps.value
            : this.troubleshootingSteps));
  }
}

@JsonSerializable(explicitToJson: true)
class BankTransfersEventsUpdateWebhook {
  BankTransfersEventsUpdateWebhook({
    required this.webhookType,
    required this.webhookCode,
    required this.environment,
  });

  factory BankTransfersEventsUpdateWebhook.fromJson(
          Map<String, dynamic> json) =>
      _$BankTransfersEventsUpdateWebhookFromJson(json);

  @JsonKey(name: 'webhook_type')
  final String webhookType;
  @JsonKey(name: 'webhook_code')
  final String webhookCode;
  @JsonKey(
    name: 'environment',
    toJson: webhookEnvironmentValuesToJson,
    fromJson: webhookEnvironmentValuesFromJson,
  )
  final enums.WebhookEnvironmentValues environment;
  static const fromJsonFactory = _$BankTransfersEventsUpdateWebhookFromJson;
  static const toJsonFactory = _$BankTransfersEventsUpdateWebhookToJson;
  Map<String, dynamic> toJson() =>
      _$BankTransfersEventsUpdateWebhookToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BankTransfersEventsUpdateWebhook &&
            (identical(other.webhookType, webhookType) ||
                const DeepCollectionEquality()
                    .equals(other.webhookType, webhookType)) &&
            (identical(other.webhookCode, webhookCode) ||
                const DeepCollectionEquality()
                    .equals(other.webhookCode, webhookCode)) &&
            (identical(other.environment, environment) ||
                const DeepCollectionEquality()
                    .equals(other.environment, environment)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(webhookType) ^
      const DeepCollectionEquality().hash(webhookCode) ^
      const DeepCollectionEquality().hash(environment) ^
      runtimeType.hashCode;
}

extension $BankTransfersEventsUpdateWebhookExtension
    on BankTransfersEventsUpdateWebhook {
  BankTransfersEventsUpdateWebhook copyWith(
      {String? webhookType,
      String? webhookCode,
      enums.WebhookEnvironmentValues? environment}) {
    return BankTransfersEventsUpdateWebhook(
        webhookType: webhookType ?? this.webhookType,
        webhookCode: webhookCode ?? this.webhookCode,
        environment: environment ?? this.environment);
  }

  BankTransfersEventsUpdateWebhook copyWithWrapped(
      {Wrapped<String>? webhookType,
      Wrapped<String>? webhookCode,
      Wrapped<enums.WebhookEnvironmentValues>? environment}) {
    return BankTransfersEventsUpdateWebhook(
        webhookType:
            (webhookType != null ? webhookType.value : this.webhookType),
        webhookCode:
            (webhookCode != null ? webhookCode.value : this.webhookCode),
        environment:
            (environment != null ? environment.value : this.environment));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferEventsUpdateWebhook {
  TransferEventsUpdateWebhook({
    required this.webhookType,
    required this.webhookCode,
    required this.environment,
  });

  factory TransferEventsUpdateWebhook.fromJson(Map<String, dynamic> json) =>
      _$TransferEventsUpdateWebhookFromJson(json);

  @JsonKey(name: 'webhook_type')
  final String webhookType;
  @JsonKey(name: 'webhook_code')
  final String webhookCode;
  @JsonKey(
    name: 'environment',
    toJson: webhookEnvironmentValuesToJson,
    fromJson: webhookEnvironmentValuesFromJson,
  )
  final enums.WebhookEnvironmentValues environment;
  static const fromJsonFactory = _$TransferEventsUpdateWebhookFromJson;
  static const toJsonFactory = _$TransferEventsUpdateWebhookToJson;
  Map<String, dynamic> toJson() => _$TransferEventsUpdateWebhookToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferEventsUpdateWebhook &&
            (identical(other.webhookType, webhookType) ||
                const DeepCollectionEquality()
                    .equals(other.webhookType, webhookType)) &&
            (identical(other.webhookCode, webhookCode) ||
                const DeepCollectionEquality()
                    .equals(other.webhookCode, webhookCode)) &&
            (identical(other.environment, environment) ||
                const DeepCollectionEquality()
                    .equals(other.environment, environment)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(webhookType) ^
      const DeepCollectionEquality().hash(webhookCode) ^
      const DeepCollectionEquality().hash(environment) ^
      runtimeType.hashCode;
}

extension $TransferEventsUpdateWebhookExtension on TransferEventsUpdateWebhook {
  TransferEventsUpdateWebhook copyWith(
      {String? webhookType,
      String? webhookCode,
      enums.WebhookEnvironmentValues? environment}) {
    return TransferEventsUpdateWebhook(
        webhookType: webhookType ?? this.webhookType,
        webhookCode: webhookCode ?? this.webhookCode,
        environment: environment ?? this.environment);
  }

  TransferEventsUpdateWebhook copyWithWrapped(
      {Wrapped<String>? webhookType,
      Wrapped<String>? webhookCode,
      Wrapped<enums.WebhookEnvironmentValues>? environment}) {
    return TransferEventsUpdateWebhook(
        webhookType:
            (webhookType != null ? webhookType.value : this.webhookType),
        webhookCode:
            (webhookCode != null ? webhookCode.value : this.webhookCode),
        environment:
            (environment != null ? environment.value : this.environment));
  }
}

@JsonSerializable(explicitToJson: true)
class InvestmentsDefaultUpdateWebhook {
  InvestmentsDefaultUpdateWebhook({
    required this.webhookType,
    required this.webhookCode,
    required this.itemId,
    this.error,
    required this.newInvestmentsTransactions,
    required this.canceledInvestmentsTransactions,
    required this.environment,
  });

  factory InvestmentsDefaultUpdateWebhook.fromJson(Map<String, dynamic> json) =>
      _$InvestmentsDefaultUpdateWebhookFromJson(json);

  @JsonKey(name: 'webhook_type')
  final String webhookType;
  @JsonKey(name: 'webhook_code')
  final String webhookCode;
  @JsonKey(name: 'item_id')
  final String itemId;
  @JsonKey(name: 'error')
  final PlaidError? error;
  @JsonKey(name: 'new_investments_transactions')
  final double newInvestmentsTransactions;
  @JsonKey(name: 'canceled_investments_transactions')
  final double canceledInvestmentsTransactions;
  @JsonKey(
    name: 'environment',
    toJson: webhookEnvironmentValuesToJson,
    fromJson: webhookEnvironmentValuesFromJson,
  )
  final enums.WebhookEnvironmentValues environment;
  static const fromJsonFactory = _$InvestmentsDefaultUpdateWebhookFromJson;
  static const toJsonFactory = _$InvestmentsDefaultUpdateWebhookToJson;
  Map<String, dynamic> toJson() =>
      _$InvestmentsDefaultUpdateWebhookToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvestmentsDefaultUpdateWebhook &&
            (identical(other.webhookType, webhookType) ||
                const DeepCollectionEquality()
                    .equals(other.webhookType, webhookType)) &&
            (identical(other.webhookCode, webhookCode) ||
                const DeepCollectionEquality()
                    .equals(other.webhookCode, webhookCode)) &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)) &&
            (identical(other.error, error) ||
                const DeepCollectionEquality().equals(other.error, error)) &&
            (identical(other.newInvestmentsTransactions,
                    newInvestmentsTransactions) ||
                const DeepCollectionEquality().equals(
                    other.newInvestmentsTransactions,
                    newInvestmentsTransactions)) &&
            (identical(other.canceledInvestmentsTransactions,
                    canceledInvestmentsTransactions) ||
                const DeepCollectionEquality().equals(
                    other.canceledInvestmentsTransactions,
                    canceledInvestmentsTransactions)) &&
            (identical(other.environment, environment) ||
                const DeepCollectionEquality()
                    .equals(other.environment, environment)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(webhookType) ^
      const DeepCollectionEquality().hash(webhookCode) ^
      const DeepCollectionEquality().hash(itemId) ^
      const DeepCollectionEquality().hash(error) ^
      const DeepCollectionEquality().hash(newInvestmentsTransactions) ^
      const DeepCollectionEquality().hash(canceledInvestmentsTransactions) ^
      const DeepCollectionEquality().hash(environment) ^
      runtimeType.hashCode;
}

extension $InvestmentsDefaultUpdateWebhookExtension
    on InvestmentsDefaultUpdateWebhook {
  InvestmentsDefaultUpdateWebhook copyWith(
      {String? webhookType,
      String? webhookCode,
      String? itemId,
      PlaidError? error,
      double? newInvestmentsTransactions,
      double? canceledInvestmentsTransactions,
      enums.WebhookEnvironmentValues? environment}) {
    return InvestmentsDefaultUpdateWebhook(
        webhookType: webhookType ?? this.webhookType,
        webhookCode: webhookCode ?? this.webhookCode,
        itemId: itemId ?? this.itemId,
        error: error ?? this.error,
        newInvestmentsTransactions:
            newInvestmentsTransactions ?? this.newInvestmentsTransactions,
        canceledInvestmentsTransactions: canceledInvestmentsTransactions ??
            this.canceledInvestmentsTransactions,
        environment: environment ?? this.environment);
  }

  InvestmentsDefaultUpdateWebhook copyWithWrapped(
      {Wrapped<String>? webhookType,
      Wrapped<String>? webhookCode,
      Wrapped<String>? itemId,
      Wrapped<PlaidError?>? error,
      Wrapped<double>? newInvestmentsTransactions,
      Wrapped<double>? canceledInvestmentsTransactions,
      Wrapped<enums.WebhookEnvironmentValues>? environment}) {
    return InvestmentsDefaultUpdateWebhook(
        webhookType:
            (webhookType != null ? webhookType.value : this.webhookType),
        webhookCode:
            (webhookCode != null ? webhookCode.value : this.webhookCode),
        itemId: (itemId != null ? itemId.value : this.itemId),
        error: (error != null ? error.value : this.error),
        newInvestmentsTransactions: (newInvestmentsTransactions != null
            ? newInvestmentsTransactions.value
            : this.newInvestmentsTransactions),
        canceledInvestmentsTransactions:
            (canceledInvestmentsTransactions != null
                ? canceledInvestmentsTransactions.value
                : this.canceledInvestmentsTransactions),
        environment:
            (environment != null ? environment.value : this.environment));
  }
}

@JsonSerializable(explicitToJson: true)
class HoldingsDefaultUpdateWebhook {
  HoldingsDefaultUpdateWebhook({
    required this.webhookType,
    required this.webhookCode,
    required this.itemId,
    this.error,
    required this.newHoldings,
    required this.updatedHoldings,
    required this.environment,
  });

  factory HoldingsDefaultUpdateWebhook.fromJson(Map<String, dynamic> json) =>
      _$HoldingsDefaultUpdateWebhookFromJson(json);

  @JsonKey(name: 'webhook_type')
  final String webhookType;
  @JsonKey(name: 'webhook_code')
  final String webhookCode;
  @JsonKey(name: 'item_id')
  final String itemId;
  @JsonKey(name: 'error')
  final PlaidError? error;
  @JsonKey(name: 'new_holdings')
  final double newHoldings;
  @JsonKey(name: 'updated_holdings')
  final double updatedHoldings;
  @JsonKey(
    name: 'environment',
    toJson: webhookEnvironmentValuesToJson,
    fromJson: webhookEnvironmentValuesFromJson,
  )
  final enums.WebhookEnvironmentValues environment;
  static const fromJsonFactory = _$HoldingsDefaultUpdateWebhookFromJson;
  static const toJsonFactory = _$HoldingsDefaultUpdateWebhookToJson;
  Map<String, dynamic> toJson() => _$HoldingsDefaultUpdateWebhookToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is HoldingsDefaultUpdateWebhook &&
            (identical(other.webhookType, webhookType) ||
                const DeepCollectionEquality()
                    .equals(other.webhookType, webhookType)) &&
            (identical(other.webhookCode, webhookCode) ||
                const DeepCollectionEquality()
                    .equals(other.webhookCode, webhookCode)) &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)) &&
            (identical(other.error, error) ||
                const DeepCollectionEquality().equals(other.error, error)) &&
            (identical(other.newHoldings, newHoldings) ||
                const DeepCollectionEquality()
                    .equals(other.newHoldings, newHoldings)) &&
            (identical(other.updatedHoldings, updatedHoldings) ||
                const DeepCollectionEquality()
                    .equals(other.updatedHoldings, updatedHoldings)) &&
            (identical(other.environment, environment) ||
                const DeepCollectionEquality()
                    .equals(other.environment, environment)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(webhookType) ^
      const DeepCollectionEquality().hash(webhookCode) ^
      const DeepCollectionEquality().hash(itemId) ^
      const DeepCollectionEquality().hash(error) ^
      const DeepCollectionEquality().hash(newHoldings) ^
      const DeepCollectionEquality().hash(updatedHoldings) ^
      const DeepCollectionEquality().hash(environment) ^
      runtimeType.hashCode;
}

extension $HoldingsDefaultUpdateWebhookExtension
    on HoldingsDefaultUpdateWebhook {
  HoldingsDefaultUpdateWebhook copyWith(
      {String? webhookType,
      String? webhookCode,
      String? itemId,
      PlaidError? error,
      double? newHoldings,
      double? updatedHoldings,
      enums.WebhookEnvironmentValues? environment}) {
    return HoldingsDefaultUpdateWebhook(
        webhookType: webhookType ?? this.webhookType,
        webhookCode: webhookCode ?? this.webhookCode,
        itemId: itemId ?? this.itemId,
        error: error ?? this.error,
        newHoldings: newHoldings ?? this.newHoldings,
        updatedHoldings: updatedHoldings ?? this.updatedHoldings,
        environment: environment ?? this.environment);
  }

  HoldingsDefaultUpdateWebhook copyWithWrapped(
      {Wrapped<String>? webhookType,
      Wrapped<String>? webhookCode,
      Wrapped<String>? itemId,
      Wrapped<PlaidError?>? error,
      Wrapped<double>? newHoldings,
      Wrapped<double>? updatedHoldings,
      Wrapped<enums.WebhookEnvironmentValues>? environment}) {
    return HoldingsDefaultUpdateWebhook(
        webhookType:
            (webhookType != null ? webhookType.value : this.webhookType),
        webhookCode:
            (webhookCode != null ? webhookCode.value : this.webhookCode),
        itemId: (itemId != null ? itemId.value : this.itemId),
        error: (error != null ? error.value : this.error),
        newHoldings:
            (newHoldings != null ? newHoldings.value : this.newHoldings),
        updatedHoldings: (updatedHoldings != null
            ? updatedHoldings.value
            : this.updatedHoldings),
        environment:
            (environment != null ? environment.value : this.environment));
  }
}

@JsonSerializable(explicitToJson: true)
class LiabilitiesDefaultUpdateWebhook {
  LiabilitiesDefaultUpdateWebhook({
    required this.webhookType,
    required this.webhookCode,
    required this.itemId,
    required this.error,
    required this.accountIdsWithNewLiabilities,
    required this.accountIdsWithUpdatedLiabilities,
    required this.environment,
  });

  factory LiabilitiesDefaultUpdateWebhook.fromJson(Map<String, dynamic> json) =>
      _$LiabilitiesDefaultUpdateWebhookFromJson(json);

  @JsonKey(name: 'webhook_type')
  final String webhookType;
  @JsonKey(name: 'webhook_code')
  final String webhookCode;
  @JsonKey(name: 'item_id')
  final String itemId;
  @JsonKey(name: 'error')
  final PlaidError? error;
  @JsonKey(name: 'account_ids_with_new_liabilities', defaultValue: <String>[])
  final List<String> accountIdsWithNewLiabilities;
  @JsonKey(name: 'account_ids_with_updated_liabilities')
  final LiabilitiesAccountIdsWithUpdatedLiabilities
      accountIdsWithUpdatedLiabilities;
  @JsonKey(
    name: 'environment',
    toJson: webhookEnvironmentValuesToJson,
    fromJson: webhookEnvironmentValuesFromJson,
  )
  final enums.WebhookEnvironmentValues environment;
  static const fromJsonFactory = _$LiabilitiesDefaultUpdateWebhookFromJson;
  static const toJsonFactory = _$LiabilitiesDefaultUpdateWebhookToJson;
  Map<String, dynamic> toJson() =>
      _$LiabilitiesDefaultUpdateWebhookToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LiabilitiesDefaultUpdateWebhook &&
            (identical(other.webhookType, webhookType) ||
                const DeepCollectionEquality()
                    .equals(other.webhookType, webhookType)) &&
            (identical(other.webhookCode, webhookCode) ||
                const DeepCollectionEquality()
                    .equals(other.webhookCode, webhookCode)) &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)) &&
            (identical(other.error, error) ||
                const DeepCollectionEquality().equals(other.error, error)) &&
            (identical(other.accountIdsWithNewLiabilities,
                    accountIdsWithNewLiabilities) ||
                const DeepCollectionEquality().equals(
                    other.accountIdsWithNewLiabilities,
                    accountIdsWithNewLiabilities)) &&
            (identical(other.accountIdsWithUpdatedLiabilities,
                    accountIdsWithUpdatedLiabilities) ||
                const DeepCollectionEquality().equals(
                    other.accountIdsWithUpdatedLiabilities,
                    accountIdsWithUpdatedLiabilities)) &&
            (identical(other.environment, environment) ||
                const DeepCollectionEquality()
                    .equals(other.environment, environment)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(webhookType) ^
      const DeepCollectionEquality().hash(webhookCode) ^
      const DeepCollectionEquality().hash(itemId) ^
      const DeepCollectionEquality().hash(error) ^
      const DeepCollectionEquality().hash(accountIdsWithNewLiabilities) ^
      const DeepCollectionEquality().hash(accountIdsWithUpdatedLiabilities) ^
      const DeepCollectionEquality().hash(environment) ^
      runtimeType.hashCode;
}

extension $LiabilitiesDefaultUpdateWebhookExtension
    on LiabilitiesDefaultUpdateWebhook {
  LiabilitiesDefaultUpdateWebhook copyWith(
      {String? webhookType,
      String? webhookCode,
      String? itemId,
      PlaidError? error,
      List<String>? accountIdsWithNewLiabilities,
      LiabilitiesAccountIdsWithUpdatedLiabilities?
          accountIdsWithUpdatedLiabilities,
      enums.WebhookEnvironmentValues? environment}) {
    return LiabilitiesDefaultUpdateWebhook(
        webhookType: webhookType ?? this.webhookType,
        webhookCode: webhookCode ?? this.webhookCode,
        itemId: itemId ?? this.itemId,
        error: error ?? this.error,
        accountIdsWithNewLiabilities:
            accountIdsWithNewLiabilities ?? this.accountIdsWithNewLiabilities,
        accountIdsWithUpdatedLiabilities: accountIdsWithUpdatedLiabilities ??
            this.accountIdsWithUpdatedLiabilities,
        environment: environment ?? this.environment);
  }

  LiabilitiesDefaultUpdateWebhook copyWithWrapped(
      {Wrapped<String>? webhookType,
      Wrapped<String>? webhookCode,
      Wrapped<String>? itemId,
      Wrapped<PlaidError?>? error,
      Wrapped<List<String>>? accountIdsWithNewLiabilities,
      Wrapped<LiabilitiesAccountIdsWithUpdatedLiabilities>?
          accountIdsWithUpdatedLiabilities,
      Wrapped<enums.WebhookEnvironmentValues>? environment}) {
    return LiabilitiesDefaultUpdateWebhook(
        webhookType:
            (webhookType != null ? webhookType.value : this.webhookType),
        webhookCode:
            (webhookCode != null ? webhookCode.value : this.webhookCode),
        itemId: (itemId != null ? itemId.value : this.itemId),
        error: (error != null ? error.value : this.error),
        accountIdsWithNewLiabilities: (accountIdsWithNewLiabilities != null
            ? accountIdsWithNewLiabilities.value
            : this.accountIdsWithNewLiabilities),
        accountIdsWithUpdatedLiabilities:
            (accountIdsWithUpdatedLiabilities != null
                ? accountIdsWithUpdatedLiabilities.value
                : this.accountIdsWithUpdatedLiabilities),
        environment:
            (environment != null ? environment.value : this.environment));
  }
}

@JsonSerializable(explicitToJson: true)
class LiabilitiesAccountIdsWithUpdatedLiabilities {
  LiabilitiesAccountIdsWithUpdatedLiabilities();

  factory LiabilitiesAccountIdsWithUpdatedLiabilities.fromJson(
          Map<String, dynamic> json) =>
      _$LiabilitiesAccountIdsWithUpdatedLiabilitiesFromJson(json);

  static const fromJsonFactory =
      _$LiabilitiesAccountIdsWithUpdatedLiabilitiesFromJson;
  static const toJsonFactory =
      _$LiabilitiesAccountIdsWithUpdatedLiabilitiesToJson;
  Map<String, dynamic> toJson() =>
      _$LiabilitiesAccountIdsWithUpdatedLiabilitiesToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => runtimeType.hashCode;
}

@JsonSerializable(explicitToJson: true)
class Cause {
  Cause({
    required this.itemId,
    required this.errorType,
    required this.errorCode,
    required this.errorMessage,
    required this.displayMessage,
    this.requestId,
    this.causes,
    this.status,
    this.documentationUrl,
    this.suggestedAction,
  });

  factory Cause.fromJson(Map<String, dynamic> json) => _$CauseFromJson(json);

  @JsonKey(name: 'item_id')
  final String itemId;
  @JsonKey(
    name: 'error_type',
    toJson: plaidErrorTypeToJson,
    fromJson: plaidErrorTypeFromJson,
  )
  final enums.PlaidErrorType errorType;
  @JsonKey(name: 'error_code')
  final String errorCode;
  @JsonKey(name: 'error_message')
  final String errorMessage;
  @JsonKey(name: 'display_message')
  final String? displayMessage;
  @JsonKey(name: 'request_id')
  final String? requestId;
  @JsonKey(name: 'causes', defaultValue: <Object>[])
  final List<Object>? causes;
  @JsonKey(name: 'status')
  final double? status;
  @JsonKey(name: 'documentation_url')
  final String? documentationUrl;
  @JsonKey(name: 'suggested_action')
  final String? suggestedAction;
  static const fromJsonFactory = _$CauseFromJson;
  static const toJsonFactory = _$CauseToJson;
  Map<String, dynamic> toJson() => _$CauseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Cause &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)) &&
            (identical(other.errorType, errorType) ||
                const DeepCollectionEquality()
                    .equals(other.errorType, errorType)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.errorMessage, errorMessage) ||
                const DeepCollectionEquality()
                    .equals(other.errorMessage, errorMessage)) &&
            (identical(other.displayMessage, displayMessage) ||
                const DeepCollectionEquality()
                    .equals(other.displayMessage, displayMessage)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)) &&
            (identical(other.causes, causes) ||
                const DeepCollectionEquality().equals(other.causes, causes)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.documentationUrl, documentationUrl) ||
                const DeepCollectionEquality()
                    .equals(other.documentationUrl, documentationUrl)) &&
            (identical(other.suggestedAction, suggestedAction) ||
                const DeepCollectionEquality()
                    .equals(other.suggestedAction, suggestedAction)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(itemId) ^
      const DeepCollectionEquality().hash(errorType) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(errorMessage) ^
      const DeepCollectionEquality().hash(displayMessage) ^
      const DeepCollectionEquality().hash(requestId) ^
      const DeepCollectionEquality().hash(causes) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(documentationUrl) ^
      const DeepCollectionEquality().hash(suggestedAction) ^
      runtimeType.hashCode;
}

extension $CauseExtension on Cause {
  Cause copyWith(
      {String? itemId,
      enums.PlaidErrorType? errorType,
      String? errorCode,
      String? errorMessage,
      String? displayMessage,
      String? requestId,
      List<Object>? causes,
      double? status,
      String? documentationUrl,
      String? suggestedAction}) {
    return Cause(
        itemId: itemId ?? this.itemId,
        errorType: errorType ?? this.errorType,
        errorCode: errorCode ?? this.errorCode,
        errorMessage: errorMessage ?? this.errorMessage,
        displayMessage: displayMessage ?? this.displayMessage,
        requestId: requestId ?? this.requestId,
        causes: causes ?? this.causes,
        status: status ?? this.status,
        documentationUrl: documentationUrl ?? this.documentationUrl,
        suggestedAction: suggestedAction ?? this.suggestedAction);
  }

  Cause copyWithWrapped(
      {Wrapped<String>? itemId,
      Wrapped<enums.PlaidErrorType>? errorType,
      Wrapped<String>? errorCode,
      Wrapped<String>? errorMessage,
      Wrapped<String?>? displayMessage,
      Wrapped<String?>? requestId,
      Wrapped<List<Object>?>? causes,
      Wrapped<double?>? status,
      Wrapped<String?>? documentationUrl,
      Wrapped<String?>? suggestedAction}) {
    return Cause(
        itemId: (itemId != null ? itemId.value : this.itemId),
        errorType: (errorType != null ? errorType.value : this.errorType),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        errorMessage:
            (errorMessage != null ? errorMessage.value : this.errorMessage),
        displayMessage: (displayMessage != null
            ? displayMessage.value
            : this.displayMessage),
        requestId: (requestId != null ? requestId.value : this.requestId),
        causes: (causes != null ? causes.value : this.causes),
        status: (status != null ? status.value : this.status),
        documentationUrl: (documentationUrl != null
            ? documentationUrl.value
            : this.documentationUrl),
        suggestedAction: (suggestedAction != null
            ? suggestedAction.value
            : this.suggestedAction));
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentAmount {
  PaymentAmount({
    required this.currency,
    required this.value,
  });

  factory PaymentAmount.fromJson(Map<String, dynamic> json) =>
      _$PaymentAmountFromJson(json);

  @JsonKey(
    name: 'currency',
    toJson: paymentAmountCurrencyToJson,
    fromJson: paymentAmountCurrencyFromJson,
  )
  final enums.PaymentAmountCurrency currency;
  @JsonKey(name: 'value')
  final double value;
  static const fromJsonFactory = _$PaymentAmountFromJson;
  static const toJsonFactory = _$PaymentAmountToJson;
  Map<String, dynamic> toJson() => _$PaymentAmountToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentAmount &&
            (identical(other.currency, currency) ||
                const DeepCollectionEquality()
                    .equals(other.currency, currency)) &&
            (identical(other.value, value) ||
                const DeepCollectionEquality().equals(other.value, value)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(currency) ^
      const DeepCollectionEquality().hash(value) ^
      runtimeType.hashCode;
}

extension $PaymentAmountExtension on PaymentAmount {
  PaymentAmount copyWith(
      {enums.PaymentAmountCurrency? currency, double? value}) {
    return PaymentAmount(
        currency: currency ?? this.currency, value: value ?? this.value);
  }

  PaymentAmount copyWithWrapped(
      {Wrapped<enums.PaymentAmountCurrency>? currency,
      Wrapped<double>? value}) {
    return PaymentAmount(
        currency: (currency != null ? currency.value : this.currency),
        value: (value != null ? value.value : this.value));
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentAmountNullable {
  PaymentAmountNullable({
    required this.currency,
    required this.value,
  });

  factory PaymentAmountNullable.fromJson(Map<String, dynamic> json) =>
      _$PaymentAmountNullableFromJson(json);

  @JsonKey(
    name: 'currency',
    toJson: paymentAmountCurrencyToJson,
    fromJson: paymentAmountCurrencyFromJson,
  )
  final enums.PaymentAmountCurrency currency;
  @JsonKey(name: 'value')
  final double value;
  static const fromJsonFactory = _$PaymentAmountNullableFromJson;
  static const toJsonFactory = _$PaymentAmountNullableToJson;
  Map<String, dynamic> toJson() => _$PaymentAmountNullableToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentAmountNullable &&
            (identical(other.currency, currency) ||
                const DeepCollectionEquality()
                    .equals(other.currency, currency)) &&
            (identical(other.value, value) ||
                const DeepCollectionEquality().equals(other.value, value)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(currency) ^
      const DeepCollectionEquality().hash(value) ^
      runtimeType.hashCode;
}

extension $PaymentAmountNullableExtension on PaymentAmountNullable {
  PaymentAmountNullable copyWith(
      {enums.PaymentAmountCurrency? currency, double? value}) {
    return PaymentAmountNullable(
        currency: currency ?? this.currency, value: value ?? this.value);
  }

  PaymentAmountNullable copyWithWrapped(
      {Wrapped<enums.PaymentAmountCurrency>? currency,
      Wrapped<double>? value}) {
    return PaymentAmountNullable(
        currency: (currency != null ? currency.value : this.currency),
        value: (value != null ? value.value : this.value));
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentAmountToRefund {
  PaymentAmountToRefund({
    required this.currency,
    required this.value,
  });

  factory PaymentAmountToRefund.fromJson(Map<String, dynamic> json) =>
      _$PaymentAmountToRefundFromJson(json);

  @JsonKey(
    name: 'currency',
    toJson: paymentAmountCurrencyToJson,
    fromJson: paymentAmountCurrencyFromJson,
  )
  final enums.PaymentAmountCurrency currency;
  @JsonKey(name: 'value')
  final double value;
  static const fromJsonFactory = _$PaymentAmountToRefundFromJson;
  static const toJsonFactory = _$PaymentAmountToRefundToJson;
  Map<String, dynamic> toJson() => _$PaymentAmountToRefundToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentAmountToRefund &&
            (identical(other.currency, currency) ||
                const DeepCollectionEquality()
                    .equals(other.currency, currency)) &&
            (identical(other.value, value) ||
                const DeepCollectionEquality().equals(other.value, value)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(currency) ^
      const DeepCollectionEquality().hash(value) ^
      runtimeType.hashCode;
}

extension $PaymentAmountToRefundExtension on PaymentAmountToRefund {
  PaymentAmountToRefund copyWith(
      {enums.PaymentAmountCurrency? currency, double? value}) {
    return PaymentAmountToRefund(
        currency: currency ?? this.currency, value: value ?? this.value);
  }

  PaymentAmountToRefund copyWithWrapped(
      {Wrapped<enums.PaymentAmountCurrency>? currency,
      Wrapped<double>? value}) {
    return PaymentAmountToRefund(
        currency: (currency != null ? currency.value : this.currency),
        value: (value != null ? value.value : this.value));
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentAmountRefunded {
  PaymentAmountRefunded({
    required this.currency,
    required this.value,
  });

  factory PaymentAmountRefunded.fromJson(Map<String, dynamic> json) =>
      _$PaymentAmountRefundedFromJson(json);

  @JsonKey(
    name: 'currency',
    toJson: paymentAmountCurrencyToJson,
    fromJson: paymentAmountCurrencyFromJson,
  )
  final enums.PaymentAmountCurrency currency;
  @JsonKey(name: 'value')
  final double value;
  static const fromJsonFactory = _$PaymentAmountRefundedFromJson;
  static const toJsonFactory = _$PaymentAmountRefundedToJson;
  Map<String, dynamic> toJson() => _$PaymentAmountRefundedToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentAmountRefunded &&
            (identical(other.currency, currency) ||
                const DeepCollectionEquality()
                    .equals(other.currency, currency)) &&
            (identical(other.value, value) ||
                const DeepCollectionEquality().equals(other.value, value)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(currency) ^
      const DeepCollectionEquality().hash(value) ^
      runtimeType.hashCode;
}

extension $PaymentAmountRefundedExtension on PaymentAmountRefunded {
  PaymentAmountRefunded copyWith(
      {enums.PaymentAmountCurrency? currency, double? value}) {
    return PaymentAmountRefunded(
        currency: currency ?? this.currency, value: value ?? this.value);
  }

  PaymentAmountRefunded copyWithWrapped(
      {Wrapped<enums.PaymentAmountCurrency>? currency,
      Wrapped<double>? value}) {
    return PaymentAmountRefunded(
        currency: (currency != null ? currency.value : this.currency),
        value: (value != null ? value.value : this.value));
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentConsentValidDateTime {
  PaymentConsentValidDateTime({
    this.from,
    this.to,
  });

  factory PaymentConsentValidDateTime.fromJson(Map<String, dynamic> json) =>
      _$PaymentConsentValidDateTimeFromJson(json);

  @JsonKey(name: 'from')
  final DateTime? from;
  @JsonKey(name: 'to')
  final DateTime? to;
  static const fromJsonFactory = _$PaymentConsentValidDateTimeFromJson;
  static const toJsonFactory = _$PaymentConsentValidDateTimeToJson;
  Map<String, dynamic> toJson() => _$PaymentConsentValidDateTimeToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentConsentValidDateTime &&
            (identical(other.from, from) ||
                const DeepCollectionEquality().equals(other.from, from)) &&
            (identical(other.to, to) ||
                const DeepCollectionEquality().equals(other.to, to)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(from) ^
      const DeepCollectionEquality().hash(to) ^
      runtimeType.hashCode;
}

extension $PaymentConsentValidDateTimeExtension on PaymentConsentValidDateTime {
  PaymentConsentValidDateTime copyWith({DateTime? from, DateTime? to}) {
    return PaymentConsentValidDateTime(
        from: from ?? this.from, to: to ?? this.to);
  }

  PaymentConsentValidDateTime copyWithWrapped(
      {Wrapped<DateTime?>? from, Wrapped<DateTime?>? to}) {
    return PaymentConsentValidDateTime(
        from: (from != null ? from.value : this.from),
        to: (to != null ? to.value : this.to));
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentConsentPeriodicAmount {
  PaymentConsentPeriodicAmount({
    required this.amount,
    required this.interval,
    required this.alignment,
  });

  factory PaymentConsentPeriodicAmount.fromJson(Map<String, dynamic> json) =>
      _$PaymentConsentPeriodicAmountFromJson(json);

  @JsonKey(name: 'amount')
  final PaymentConsentPeriodicAmountAmount amount;
  @JsonKey(
    name: 'interval',
    toJson: paymentConsentPeriodicIntervalToJson,
    fromJson: paymentConsentPeriodicIntervalFromJson,
  )
  final enums.PaymentConsentPeriodicInterval interval;
  @JsonKey(
    name: 'alignment',
    toJson: paymentConsentPeriodicAlignmentToJson,
    fromJson: paymentConsentPeriodicAlignmentFromJson,
  )
  final enums.PaymentConsentPeriodicAlignment alignment;
  static const fromJsonFactory = _$PaymentConsentPeriodicAmountFromJson;
  static const toJsonFactory = _$PaymentConsentPeriodicAmountToJson;
  Map<String, dynamic> toJson() => _$PaymentConsentPeriodicAmountToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentConsentPeriodicAmount &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.interval, interval) ||
                const DeepCollectionEquality()
                    .equals(other.interval, interval)) &&
            (identical(other.alignment, alignment) ||
                const DeepCollectionEquality()
                    .equals(other.alignment, alignment)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(interval) ^
      const DeepCollectionEquality().hash(alignment) ^
      runtimeType.hashCode;
}

extension $PaymentConsentPeriodicAmountExtension
    on PaymentConsentPeriodicAmount {
  PaymentConsentPeriodicAmount copyWith(
      {PaymentConsentPeriodicAmountAmount? amount,
      enums.PaymentConsentPeriodicInterval? interval,
      enums.PaymentConsentPeriodicAlignment? alignment}) {
    return PaymentConsentPeriodicAmount(
        amount: amount ?? this.amount,
        interval: interval ?? this.interval,
        alignment: alignment ?? this.alignment);
  }

  PaymentConsentPeriodicAmount copyWithWrapped(
      {Wrapped<PaymentConsentPeriodicAmountAmount>? amount,
      Wrapped<enums.PaymentConsentPeriodicInterval>? interval,
      Wrapped<enums.PaymentConsentPeriodicAlignment>? alignment}) {
    return PaymentConsentPeriodicAmount(
        amount: (amount != null ? amount.value : this.amount),
        interval: (interval != null ? interval.value : this.interval),
        alignment: (alignment != null ? alignment.value : this.alignment));
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentConsentPeriodicAmountAmount {
  PaymentConsentPeriodicAmountAmount({
    required this.currency,
    required this.value,
  });

  factory PaymentConsentPeriodicAmountAmount.fromJson(
          Map<String, dynamic> json) =>
      _$PaymentConsentPeriodicAmountAmountFromJson(json);

  @JsonKey(
    name: 'currency',
    toJson: paymentAmountCurrencyToJson,
    fromJson: paymentAmountCurrencyFromJson,
  )
  final enums.PaymentAmountCurrency currency;
  @JsonKey(name: 'value')
  final double value;
  static const fromJsonFactory = _$PaymentConsentPeriodicAmountAmountFromJson;
  static const toJsonFactory = _$PaymentConsentPeriodicAmountAmountToJson;
  Map<String, dynamic> toJson() =>
      _$PaymentConsentPeriodicAmountAmountToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentConsentPeriodicAmountAmount &&
            (identical(other.currency, currency) ||
                const DeepCollectionEquality()
                    .equals(other.currency, currency)) &&
            (identical(other.value, value) ||
                const DeepCollectionEquality().equals(other.value, value)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(currency) ^
      const DeepCollectionEquality().hash(value) ^
      runtimeType.hashCode;
}

extension $PaymentConsentPeriodicAmountAmountExtension
    on PaymentConsentPeriodicAmountAmount {
  PaymentConsentPeriodicAmountAmount copyWith(
      {enums.PaymentAmountCurrency? currency, double? value}) {
    return PaymentConsentPeriodicAmountAmount(
        currency: currency ?? this.currency, value: value ?? this.value);
  }

  PaymentConsentPeriodicAmountAmount copyWithWrapped(
      {Wrapped<enums.PaymentAmountCurrency>? currency,
      Wrapped<double>? value}) {
    return PaymentConsentPeriodicAmountAmount(
        currency: (currency != null ? currency.value : this.currency),
        value: (value != null ? value.value : this.value));
  }
}

@JsonSerializable(explicitToJson: true)
class StandaloneCurrencyCodeList {
  StandaloneCurrencyCodeList({
    required this.isoCurrencyCode,
    required this.unofficialCurrencyCode,
  });

  factory StandaloneCurrencyCodeList.fromJson(Map<String, dynamic> json) =>
      _$StandaloneCurrencyCodeListFromJson(json);

  @JsonKey(name: 'iso_currency_code')
  final String isoCurrencyCode;
  @JsonKey(name: 'unofficial_currency_code')
  final String unofficialCurrencyCode;
  static const fromJsonFactory = _$StandaloneCurrencyCodeListFromJson;
  static const toJsonFactory = _$StandaloneCurrencyCodeListToJson;
  Map<String, dynamic> toJson() => _$StandaloneCurrencyCodeListToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is StandaloneCurrencyCodeList &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)) &&
            (identical(other.unofficialCurrencyCode, unofficialCurrencyCode) ||
                const DeepCollectionEquality().equals(
                    other.unofficialCurrencyCode, unofficialCurrencyCode)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      const DeepCollectionEquality().hash(unofficialCurrencyCode) ^
      runtimeType.hashCode;
}

extension $StandaloneCurrencyCodeListExtension on StandaloneCurrencyCodeList {
  StandaloneCurrencyCodeList copyWith(
      {String? isoCurrencyCode, String? unofficialCurrencyCode}) {
    return StandaloneCurrencyCodeList(
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode,
        unofficialCurrencyCode:
            unofficialCurrencyCode ?? this.unofficialCurrencyCode);
  }

  StandaloneCurrencyCodeList copyWithWrapped(
      {Wrapped<String>? isoCurrencyCode,
      Wrapped<String>? unofficialCurrencyCode}) {
    return StandaloneCurrencyCodeList(
        isoCurrencyCode: (isoCurrencyCode != null
            ? isoCurrencyCode.value
            : this.isoCurrencyCode),
        unofficialCurrencyCode: (unofficialCurrencyCode != null
            ? unofficialCurrencyCode.value
            : this.unofficialCurrencyCode));
  }
}

@JsonSerializable(explicitToJson: true)
class StandaloneAccountType {
  StandaloneAccountType({
    required this.depository,
    required this.credit,
    required this.loan,
    required this.investment,
    required this.other,
  });

  factory StandaloneAccountType.fromJson(Map<String, dynamic> json) =>
      _$StandaloneAccountTypeFromJson(json);

  @JsonKey(name: 'depository')
  final String depository;
  @JsonKey(name: 'credit')
  final String credit;
  @JsonKey(name: 'loan')
  final String loan;
  @JsonKey(name: 'investment')
  final String investment;
  @JsonKey(name: 'other')
  final String other;
  static const fromJsonFactory = _$StandaloneAccountTypeFromJson;
  static const toJsonFactory = _$StandaloneAccountTypeToJson;
  Map<String, dynamic> toJson() => _$StandaloneAccountTypeToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is StandaloneAccountType &&
            (identical(other.depository, depository) ||
                const DeepCollectionEquality()
                    .equals(other.depository, depository)) &&
            (identical(other.credit, credit) ||
                const DeepCollectionEquality().equals(other.credit, credit)) &&
            (identical(other.loan, loan) ||
                const DeepCollectionEquality().equals(other.loan, loan)) &&
            (identical(other.investment, investment) ||
                const DeepCollectionEquality()
                    .equals(other.investment, investment)) &&
            (identical(other.other, other) ||
                const DeepCollectionEquality().equals(other.other, other)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(depository) ^
      const DeepCollectionEquality().hash(credit) ^
      const DeepCollectionEquality().hash(loan) ^
      const DeepCollectionEquality().hash(investment) ^
      const DeepCollectionEquality().hash(other) ^
      runtimeType.hashCode;
}

extension $StandaloneAccountTypeExtension on StandaloneAccountType {
  StandaloneAccountType copyWith(
      {String? depository,
      String? credit,
      String? loan,
      String? investment,
      String? other}) {
    return StandaloneAccountType(
        depository: depository ?? this.depository,
        credit: credit ?? this.credit,
        loan: loan ?? this.loan,
        investment: investment ?? this.investment,
        other: other ?? this.other);
  }

  StandaloneAccountType copyWithWrapped(
      {Wrapped<String>? depository,
      Wrapped<String>? credit,
      Wrapped<String>? loan,
      Wrapped<String>? investment,
      Wrapped<String>? other}) {
    return StandaloneAccountType(
        depository: (depository != null ? depository.value : this.depository),
        credit: (credit != null ? credit.value : this.credit),
        loan: (loan != null ? loan.value : this.loan),
        investment: (investment != null ? investment.value : this.investment),
        other: (other != null ? other.value : this.other));
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentStatusUpdateWebhook {
  PaymentStatusUpdateWebhook({
    required this.webhookType,
    required this.webhookCode,
    required this.paymentId,
    required this.newPaymentStatus,
    required this.oldPaymentStatus,
    required this.originalReference,
    this.adjustedReference,
    required this.originalStartDate,
    required this.adjustedStartDate,
    required this.timestamp,
    this.error,
    required this.environment,
  });

  factory PaymentStatusUpdateWebhook.fromJson(Map<String, dynamic> json) =>
      _$PaymentStatusUpdateWebhookFromJson(json);

  @JsonKey(name: 'webhook_type')
  final String webhookType;
  @JsonKey(name: 'webhook_code')
  final String webhookCode;
  @JsonKey(name: 'payment_id')
  final String paymentId;
  @JsonKey(
    name: 'new_payment_status',
    toJson: paymentInitiationPaymentStatusToJson,
    fromJson: paymentInitiationPaymentStatusFromJson,
  )
  final enums.PaymentInitiationPaymentStatus newPaymentStatus;
  @JsonKey(
    name: 'old_payment_status',
    toJson: paymentInitiationPaymentStatusToJson,
    fromJson: paymentInitiationPaymentStatusFromJson,
  )
  final enums.PaymentInitiationPaymentStatus oldPaymentStatus;
  @JsonKey(name: 'original_reference')
  final String? originalReference;
  @JsonKey(name: 'adjusted_reference')
  final String? adjustedReference;
  @JsonKey(name: 'original_start_date', toJson: _dateToJson)
  final DateTime? originalStartDate;
  @JsonKey(name: 'adjusted_start_date', toJson: _dateToJson)
  final DateTime? adjustedStartDate;
  @JsonKey(name: 'timestamp')
  final DateTime timestamp;
  @JsonKey(name: 'error')
  final PlaidError? error;
  @JsonKey(
    name: 'environment',
    toJson: webhookEnvironmentValuesToJson,
    fromJson: webhookEnvironmentValuesFromJson,
  )
  final enums.WebhookEnvironmentValues environment;
  static const fromJsonFactory = _$PaymentStatusUpdateWebhookFromJson;
  static const toJsonFactory = _$PaymentStatusUpdateWebhookToJson;
  Map<String, dynamic> toJson() => _$PaymentStatusUpdateWebhookToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentStatusUpdateWebhook &&
            (identical(other.webhookType, webhookType) ||
                const DeepCollectionEquality()
                    .equals(other.webhookType, webhookType)) &&
            (identical(other.webhookCode, webhookCode) ||
                const DeepCollectionEquality()
                    .equals(other.webhookCode, webhookCode)) &&
            (identical(other.paymentId, paymentId) ||
                const DeepCollectionEquality()
                    .equals(other.paymentId, paymentId)) &&
            (identical(other.newPaymentStatus, newPaymentStatus) ||
                const DeepCollectionEquality()
                    .equals(other.newPaymentStatus, newPaymentStatus)) &&
            (identical(other.oldPaymentStatus, oldPaymentStatus) ||
                const DeepCollectionEquality()
                    .equals(other.oldPaymentStatus, oldPaymentStatus)) &&
            (identical(other.originalReference, originalReference) ||
                const DeepCollectionEquality()
                    .equals(other.originalReference, originalReference)) &&
            (identical(other.adjustedReference, adjustedReference) ||
                const DeepCollectionEquality()
                    .equals(other.adjustedReference, adjustedReference)) &&
            (identical(other.originalStartDate, originalStartDate) ||
                const DeepCollectionEquality()
                    .equals(other.originalStartDate, originalStartDate)) &&
            (identical(other.adjustedStartDate, adjustedStartDate) ||
                const DeepCollectionEquality()
                    .equals(other.adjustedStartDate, adjustedStartDate)) &&
            (identical(other.timestamp, timestamp) ||
                const DeepCollectionEquality()
                    .equals(other.timestamp, timestamp)) &&
            (identical(other.error, error) ||
                const DeepCollectionEquality().equals(other.error, error)) &&
            (identical(other.environment, environment) ||
                const DeepCollectionEquality()
                    .equals(other.environment, environment)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(webhookType) ^
      const DeepCollectionEquality().hash(webhookCode) ^
      const DeepCollectionEquality().hash(paymentId) ^
      const DeepCollectionEquality().hash(newPaymentStatus) ^
      const DeepCollectionEquality().hash(oldPaymentStatus) ^
      const DeepCollectionEquality().hash(originalReference) ^
      const DeepCollectionEquality().hash(adjustedReference) ^
      const DeepCollectionEquality().hash(originalStartDate) ^
      const DeepCollectionEquality().hash(adjustedStartDate) ^
      const DeepCollectionEquality().hash(timestamp) ^
      const DeepCollectionEquality().hash(error) ^
      const DeepCollectionEquality().hash(environment) ^
      runtimeType.hashCode;
}

extension $PaymentStatusUpdateWebhookExtension on PaymentStatusUpdateWebhook {
  PaymentStatusUpdateWebhook copyWith(
      {String? webhookType,
      String? webhookCode,
      String? paymentId,
      enums.PaymentInitiationPaymentStatus? newPaymentStatus,
      enums.PaymentInitiationPaymentStatus? oldPaymentStatus,
      String? originalReference,
      String? adjustedReference,
      DateTime? originalStartDate,
      DateTime? adjustedStartDate,
      DateTime? timestamp,
      PlaidError? error,
      enums.WebhookEnvironmentValues? environment}) {
    return PaymentStatusUpdateWebhook(
        webhookType: webhookType ?? this.webhookType,
        webhookCode: webhookCode ?? this.webhookCode,
        paymentId: paymentId ?? this.paymentId,
        newPaymentStatus: newPaymentStatus ?? this.newPaymentStatus,
        oldPaymentStatus: oldPaymentStatus ?? this.oldPaymentStatus,
        originalReference: originalReference ?? this.originalReference,
        adjustedReference: adjustedReference ?? this.adjustedReference,
        originalStartDate: originalStartDate ?? this.originalStartDate,
        adjustedStartDate: adjustedStartDate ?? this.adjustedStartDate,
        timestamp: timestamp ?? this.timestamp,
        error: error ?? this.error,
        environment: environment ?? this.environment);
  }

  PaymentStatusUpdateWebhook copyWithWrapped(
      {Wrapped<String>? webhookType,
      Wrapped<String>? webhookCode,
      Wrapped<String>? paymentId,
      Wrapped<enums.PaymentInitiationPaymentStatus>? newPaymentStatus,
      Wrapped<enums.PaymentInitiationPaymentStatus>? oldPaymentStatus,
      Wrapped<String?>? originalReference,
      Wrapped<String?>? adjustedReference,
      Wrapped<DateTime?>? originalStartDate,
      Wrapped<DateTime?>? adjustedStartDate,
      Wrapped<DateTime>? timestamp,
      Wrapped<PlaidError?>? error,
      Wrapped<enums.WebhookEnvironmentValues>? environment}) {
    return PaymentStatusUpdateWebhook(
        webhookType:
            (webhookType != null ? webhookType.value : this.webhookType),
        webhookCode:
            (webhookCode != null ? webhookCode.value : this.webhookCode),
        paymentId: (paymentId != null ? paymentId.value : this.paymentId),
        newPaymentStatus: (newPaymentStatus != null
            ? newPaymentStatus.value
            : this.newPaymentStatus),
        oldPaymentStatus: (oldPaymentStatus != null
            ? oldPaymentStatus.value
            : this.oldPaymentStatus),
        originalReference: (originalReference != null
            ? originalReference.value
            : this.originalReference),
        adjustedReference: (adjustedReference != null
            ? adjustedReference.value
            : this.adjustedReference),
        originalStartDate: (originalStartDate != null
            ? originalStartDate.value
            : this.originalStartDate),
        adjustedStartDate: (adjustedStartDate != null
            ? adjustedStartDate.value
            : this.adjustedStartDate),
        timestamp: (timestamp != null ? timestamp.value : this.timestamp),
        error: (error != null ? error.value : this.error),
        environment:
            (environment != null ? environment.value : this.environment));
  }
}

@JsonSerializable(explicitToJson: true)
class WalletTransactionStatusUpdateWebhook {
  WalletTransactionStatusUpdateWebhook({
    required this.webhookType,
    required this.webhookCode,
    required this.transactionId,
    required this.newStatus,
    required this.oldStatus,
    required this.timestamp,
    required this.environment,
  });

  factory WalletTransactionStatusUpdateWebhook.fromJson(
          Map<String, dynamic> json) =>
      _$WalletTransactionStatusUpdateWebhookFromJson(json);

  @JsonKey(name: 'webhook_type')
  final String webhookType;
  @JsonKey(name: 'webhook_code')
  final String webhookCode;
  @JsonKey(name: 'transaction_id')
  final String transactionId;
  @JsonKey(
    name: 'new_status',
    toJson: walletTransactionStatusToJson,
    fromJson: walletTransactionStatusFromJson,
  )
  final enums.WalletTransactionStatus newStatus;
  @JsonKey(
    name: 'old_status',
    toJson: walletTransactionStatusToJson,
    fromJson: walletTransactionStatusFromJson,
  )
  final enums.WalletTransactionStatus oldStatus;
  @JsonKey(name: 'timestamp')
  final DateTime timestamp;
  @JsonKey(
    name: 'environment',
    toJson: webhookEnvironmentValuesToJson,
    fromJson: webhookEnvironmentValuesFromJson,
  )
  final enums.WebhookEnvironmentValues environment;
  static const fromJsonFactory = _$WalletTransactionStatusUpdateWebhookFromJson;
  static const toJsonFactory = _$WalletTransactionStatusUpdateWebhookToJson;
  Map<String, dynamic> toJson() =>
      _$WalletTransactionStatusUpdateWebhookToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WalletTransactionStatusUpdateWebhook &&
            (identical(other.webhookType, webhookType) ||
                const DeepCollectionEquality()
                    .equals(other.webhookType, webhookType)) &&
            (identical(other.webhookCode, webhookCode) ||
                const DeepCollectionEquality()
                    .equals(other.webhookCode, webhookCode)) &&
            (identical(other.transactionId, transactionId) ||
                const DeepCollectionEquality()
                    .equals(other.transactionId, transactionId)) &&
            (identical(other.newStatus, newStatus) ||
                const DeepCollectionEquality()
                    .equals(other.newStatus, newStatus)) &&
            (identical(other.oldStatus, oldStatus) ||
                const DeepCollectionEquality()
                    .equals(other.oldStatus, oldStatus)) &&
            (identical(other.timestamp, timestamp) ||
                const DeepCollectionEquality()
                    .equals(other.timestamp, timestamp)) &&
            (identical(other.environment, environment) ||
                const DeepCollectionEquality()
                    .equals(other.environment, environment)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(webhookType) ^
      const DeepCollectionEquality().hash(webhookCode) ^
      const DeepCollectionEquality().hash(transactionId) ^
      const DeepCollectionEquality().hash(newStatus) ^
      const DeepCollectionEquality().hash(oldStatus) ^
      const DeepCollectionEquality().hash(timestamp) ^
      const DeepCollectionEquality().hash(environment) ^
      runtimeType.hashCode;
}

extension $WalletTransactionStatusUpdateWebhookExtension
    on WalletTransactionStatusUpdateWebhook {
  WalletTransactionStatusUpdateWebhook copyWith(
      {String? webhookType,
      String? webhookCode,
      String? transactionId,
      enums.WalletTransactionStatus? newStatus,
      enums.WalletTransactionStatus? oldStatus,
      DateTime? timestamp,
      enums.WebhookEnvironmentValues? environment}) {
    return WalletTransactionStatusUpdateWebhook(
        webhookType: webhookType ?? this.webhookType,
        webhookCode: webhookCode ?? this.webhookCode,
        transactionId: transactionId ?? this.transactionId,
        newStatus: newStatus ?? this.newStatus,
        oldStatus: oldStatus ?? this.oldStatus,
        timestamp: timestamp ?? this.timestamp,
        environment: environment ?? this.environment);
  }

  WalletTransactionStatusUpdateWebhook copyWithWrapped(
      {Wrapped<String>? webhookType,
      Wrapped<String>? webhookCode,
      Wrapped<String>? transactionId,
      Wrapped<enums.WalletTransactionStatus>? newStatus,
      Wrapped<enums.WalletTransactionStatus>? oldStatus,
      Wrapped<DateTime>? timestamp,
      Wrapped<enums.WebhookEnvironmentValues>? environment}) {
    return WalletTransactionStatusUpdateWebhook(
        webhookType:
            (webhookType != null ? webhookType.value : this.webhookType),
        webhookCode:
            (webhookCode != null ? webhookCode.value : this.webhookCode),
        transactionId:
            (transactionId != null ? transactionId.value : this.transactionId),
        newStatus: (newStatus != null ? newStatus.value : this.newStatus),
        oldStatus: (oldStatus != null ? oldStatus.value : this.oldStatus),
        timestamp: (timestamp != null ? timestamp.value : this.timestamp),
        environment:
            (environment != null ? environment.value : this.environment));
  }
}

@JsonSerializable(explicitToJson: true)
class Holding {
  Holding({
    required this.accountId,
    required this.securityId,
    required this.institutionPrice,
    this.institutionPriceAsOf,
    this.institutionPriceDatetime,
    required this.institutionValue,
    required this.costBasis,
    required this.quantity,
    required this.isoCurrencyCode,
    required this.unofficialCurrencyCode,
  });

  factory Holding.fromJson(Map<String, dynamic> json) =>
      _$HoldingFromJson(json);

  @JsonKey(name: 'account_id')
  final String accountId;
  @JsonKey(name: 'security_id')
  final String securityId;
  @JsonKey(name: 'institution_price')
  final double institutionPrice;
  @JsonKey(name: 'institution_price_as_of', toJson: _dateToJson)
  final DateTime? institutionPriceAsOf;
  @JsonKey(name: 'institution_price_datetime')
  final DateTime? institutionPriceDatetime;
  @JsonKey(name: 'institution_value')
  final double institutionValue;
  @JsonKey(name: 'cost_basis')
  final double? costBasis;
  @JsonKey(name: 'quantity')
  final double quantity;
  @JsonKey(name: 'iso_currency_code')
  final String? isoCurrencyCode;
  @JsonKey(name: 'unofficial_currency_code')
  final String? unofficialCurrencyCode;
  static const fromJsonFactory = _$HoldingFromJson;
  static const toJsonFactory = _$HoldingToJson;
  Map<String, dynamic> toJson() => _$HoldingToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Holding &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.securityId, securityId) ||
                const DeepCollectionEquality()
                    .equals(other.securityId, securityId)) &&
            (identical(other.institutionPrice, institutionPrice) ||
                const DeepCollectionEquality()
                    .equals(other.institutionPrice, institutionPrice)) &&
            (identical(other.institutionPriceAsOf, institutionPriceAsOf) ||
                const DeepCollectionEquality().equals(
                    other.institutionPriceAsOf, institutionPriceAsOf)) &&
            (identical(
                    other.institutionPriceDatetime, institutionPriceDatetime) ||
                const DeepCollectionEquality().equals(
                    other.institutionPriceDatetime,
                    institutionPriceDatetime)) &&
            (identical(other.institutionValue, institutionValue) ||
                const DeepCollectionEquality()
                    .equals(other.institutionValue, institutionValue)) &&
            (identical(other.costBasis, costBasis) ||
                const DeepCollectionEquality()
                    .equals(other.costBasis, costBasis)) &&
            (identical(other.quantity, quantity) ||
                const DeepCollectionEquality()
                    .equals(other.quantity, quantity)) &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)) &&
            (identical(other.unofficialCurrencyCode, unofficialCurrencyCode) ||
                const DeepCollectionEquality().equals(
                    other.unofficialCurrencyCode, unofficialCurrencyCode)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(securityId) ^
      const DeepCollectionEquality().hash(institutionPrice) ^
      const DeepCollectionEquality().hash(institutionPriceAsOf) ^
      const DeepCollectionEquality().hash(institutionPriceDatetime) ^
      const DeepCollectionEquality().hash(institutionValue) ^
      const DeepCollectionEquality().hash(costBasis) ^
      const DeepCollectionEquality().hash(quantity) ^
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      const DeepCollectionEquality().hash(unofficialCurrencyCode) ^
      runtimeType.hashCode;
}

extension $HoldingExtension on Holding {
  Holding copyWith(
      {String? accountId,
      String? securityId,
      double? institutionPrice,
      DateTime? institutionPriceAsOf,
      DateTime? institutionPriceDatetime,
      double? institutionValue,
      double? costBasis,
      double? quantity,
      String? isoCurrencyCode,
      String? unofficialCurrencyCode}) {
    return Holding(
        accountId: accountId ?? this.accountId,
        securityId: securityId ?? this.securityId,
        institutionPrice: institutionPrice ?? this.institutionPrice,
        institutionPriceAsOf: institutionPriceAsOf ?? this.institutionPriceAsOf,
        institutionPriceDatetime:
            institutionPriceDatetime ?? this.institutionPriceDatetime,
        institutionValue: institutionValue ?? this.institutionValue,
        costBasis: costBasis ?? this.costBasis,
        quantity: quantity ?? this.quantity,
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode,
        unofficialCurrencyCode:
            unofficialCurrencyCode ?? this.unofficialCurrencyCode);
  }

  Holding copyWithWrapped(
      {Wrapped<String>? accountId,
      Wrapped<String>? securityId,
      Wrapped<double>? institutionPrice,
      Wrapped<DateTime?>? institutionPriceAsOf,
      Wrapped<DateTime?>? institutionPriceDatetime,
      Wrapped<double>? institutionValue,
      Wrapped<double?>? costBasis,
      Wrapped<double>? quantity,
      Wrapped<String?>? isoCurrencyCode,
      Wrapped<String?>? unofficialCurrencyCode}) {
    return Holding(
        accountId: (accountId != null ? accountId.value : this.accountId),
        securityId: (securityId != null ? securityId.value : this.securityId),
        institutionPrice: (institutionPrice != null
            ? institutionPrice.value
            : this.institutionPrice),
        institutionPriceAsOf: (institutionPriceAsOf != null
            ? institutionPriceAsOf.value
            : this.institutionPriceAsOf),
        institutionPriceDatetime: (institutionPriceDatetime != null
            ? institutionPriceDatetime.value
            : this.institutionPriceDatetime),
        institutionValue: (institutionValue != null
            ? institutionValue.value
            : this.institutionValue),
        costBasis: (costBasis != null ? costBasis.value : this.costBasis),
        quantity: (quantity != null ? quantity.value : this.quantity),
        isoCurrencyCode: (isoCurrencyCode != null
            ? isoCurrencyCode.value
            : this.isoCurrencyCode),
        unofficialCurrencyCode: (unofficialCurrencyCode != null
            ? unofficialCurrencyCode.value
            : this.unofficialCurrencyCode));
  }
}

@JsonSerializable(explicitToJson: true)
class Security {
  Security({
    required this.securityId,
    required this.isin,
    required this.cusip,
    required this.sedol,
    required this.institutionSecurityId,
    required this.institutionId,
    required this.proxySecurityId,
    required this.name,
    required this.tickerSymbol,
    required this.isCashEquivalent,
    required this.type,
    required this.closePrice,
    required this.closePriceAsOf,
    this.updateDatetime,
    required this.isoCurrencyCode,
    required this.unofficialCurrencyCode,
  });

  factory Security.fromJson(Map<String, dynamic> json) =>
      _$SecurityFromJson(json);

  @JsonKey(name: 'security_id')
  final String securityId;
  @JsonKey(name: 'isin')
  final String? isin;
  @JsonKey(name: 'cusip')
  final String? cusip;
  @JsonKey(name: 'sedol')
  final String? sedol;
  @JsonKey(name: 'institution_security_id')
  final String? institutionSecurityId;
  @JsonKey(name: 'institution_id')
  final String? institutionId;
  @JsonKey(name: 'proxy_security_id')
  final String? proxySecurityId;
  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'ticker_symbol')
  final String? tickerSymbol;
  @JsonKey(name: 'is_cash_equivalent')
  final bool? isCashEquivalent;
  @JsonKey(name: 'type')
  final String? type;
  @JsonKey(name: 'close_price')
  final double? closePrice;
  @JsonKey(name: 'close_price_as_of', toJson: _dateToJson)
  final DateTime? closePriceAsOf;
  @JsonKey(name: 'update_datetime')
  final DateTime? updateDatetime;
  @JsonKey(name: 'iso_currency_code')
  final String? isoCurrencyCode;
  @JsonKey(name: 'unofficial_currency_code')
  final String? unofficialCurrencyCode;
  static const fromJsonFactory = _$SecurityFromJson;
  static const toJsonFactory = _$SecurityToJson;
  Map<String, dynamic> toJson() => _$SecurityToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Security &&
            (identical(other.securityId, securityId) ||
                const DeepCollectionEquality()
                    .equals(other.securityId, securityId)) &&
            (identical(other.isin, isin) ||
                const DeepCollectionEquality().equals(other.isin, isin)) &&
            (identical(other.cusip, cusip) ||
                const DeepCollectionEquality().equals(other.cusip, cusip)) &&
            (identical(other.sedol, sedol) ||
                const DeepCollectionEquality().equals(other.sedol, sedol)) &&
            (identical(other.institutionSecurityId, institutionSecurityId) ||
                const DeepCollectionEquality().equals(
                    other.institutionSecurityId, institutionSecurityId)) &&
            (identical(other.institutionId, institutionId) ||
                const DeepCollectionEquality()
                    .equals(other.institutionId, institutionId)) &&
            (identical(other.proxySecurityId, proxySecurityId) ||
                const DeepCollectionEquality()
                    .equals(other.proxySecurityId, proxySecurityId)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.tickerSymbol, tickerSymbol) ||
                const DeepCollectionEquality()
                    .equals(other.tickerSymbol, tickerSymbol)) &&
            (identical(other.isCashEquivalent, isCashEquivalent) ||
                const DeepCollectionEquality()
                    .equals(other.isCashEquivalent, isCashEquivalent)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.closePrice, closePrice) ||
                const DeepCollectionEquality()
                    .equals(other.closePrice, closePrice)) &&
            (identical(other.closePriceAsOf, closePriceAsOf) ||
                const DeepCollectionEquality()
                    .equals(other.closePriceAsOf, closePriceAsOf)) &&
            (identical(other.updateDatetime, updateDatetime) ||
                const DeepCollectionEquality()
                    .equals(other.updateDatetime, updateDatetime)) &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)) &&
            (identical(other.unofficialCurrencyCode, unofficialCurrencyCode) ||
                const DeepCollectionEquality().equals(
                    other.unofficialCurrencyCode, unofficialCurrencyCode)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(securityId) ^
      const DeepCollectionEquality().hash(isin) ^
      const DeepCollectionEquality().hash(cusip) ^
      const DeepCollectionEquality().hash(sedol) ^
      const DeepCollectionEquality().hash(institutionSecurityId) ^
      const DeepCollectionEquality().hash(institutionId) ^
      const DeepCollectionEquality().hash(proxySecurityId) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(tickerSymbol) ^
      const DeepCollectionEquality().hash(isCashEquivalent) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(closePrice) ^
      const DeepCollectionEquality().hash(closePriceAsOf) ^
      const DeepCollectionEquality().hash(updateDatetime) ^
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      const DeepCollectionEquality().hash(unofficialCurrencyCode) ^
      runtimeType.hashCode;
}

extension $SecurityExtension on Security {
  Security copyWith(
      {String? securityId,
      String? isin,
      String? cusip,
      String? sedol,
      String? institutionSecurityId,
      String? institutionId,
      String? proxySecurityId,
      String? name,
      String? tickerSymbol,
      bool? isCashEquivalent,
      String? type,
      double? closePrice,
      DateTime? closePriceAsOf,
      DateTime? updateDatetime,
      String? isoCurrencyCode,
      String? unofficialCurrencyCode}) {
    return Security(
        securityId: securityId ?? this.securityId,
        isin: isin ?? this.isin,
        cusip: cusip ?? this.cusip,
        sedol: sedol ?? this.sedol,
        institutionSecurityId:
            institutionSecurityId ?? this.institutionSecurityId,
        institutionId: institutionId ?? this.institutionId,
        proxySecurityId: proxySecurityId ?? this.proxySecurityId,
        name: name ?? this.name,
        tickerSymbol: tickerSymbol ?? this.tickerSymbol,
        isCashEquivalent: isCashEquivalent ?? this.isCashEquivalent,
        type: type ?? this.type,
        closePrice: closePrice ?? this.closePrice,
        closePriceAsOf: closePriceAsOf ?? this.closePriceAsOf,
        updateDatetime: updateDatetime ?? this.updateDatetime,
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode,
        unofficialCurrencyCode:
            unofficialCurrencyCode ?? this.unofficialCurrencyCode);
  }

  Security copyWithWrapped(
      {Wrapped<String>? securityId,
      Wrapped<String?>? isin,
      Wrapped<String?>? cusip,
      Wrapped<String?>? sedol,
      Wrapped<String?>? institutionSecurityId,
      Wrapped<String?>? institutionId,
      Wrapped<String?>? proxySecurityId,
      Wrapped<String?>? name,
      Wrapped<String?>? tickerSymbol,
      Wrapped<bool?>? isCashEquivalent,
      Wrapped<String?>? type,
      Wrapped<double?>? closePrice,
      Wrapped<DateTime?>? closePriceAsOf,
      Wrapped<DateTime?>? updateDatetime,
      Wrapped<String?>? isoCurrencyCode,
      Wrapped<String?>? unofficialCurrencyCode}) {
    return Security(
        securityId: (securityId != null ? securityId.value : this.securityId),
        isin: (isin != null ? isin.value : this.isin),
        cusip: (cusip != null ? cusip.value : this.cusip),
        sedol: (sedol != null ? sedol.value : this.sedol),
        institutionSecurityId: (institutionSecurityId != null
            ? institutionSecurityId.value
            : this.institutionSecurityId),
        institutionId:
            (institutionId != null ? institutionId.value : this.institutionId),
        proxySecurityId: (proxySecurityId != null
            ? proxySecurityId.value
            : this.proxySecurityId),
        name: (name != null ? name.value : this.name),
        tickerSymbol:
            (tickerSymbol != null ? tickerSymbol.value : this.tickerSymbol),
        isCashEquivalent: (isCashEquivalent != null
            ? isCashEquivalent.value
            : this.isCashEquivalent),
        type: (type != null ? type.value : this.type),
        closePrice: (closePrice != null ? closePrice.value : this.closePrice),
        closePriceAsOf: (closePriceAsOf != null
            ? closePriceAsOf.value
            : this.closePriceAsOf),
        updateDatetime: (updateDatetime != null
            ? updateDatetime.value
            : this.updateDatetime),
        isoCurrencyCode: (isoCurrencyCode != null
            ? isoCurrencyCode.value
            : this.isoCurrencyCode),
        unofficialCurrencyCode: (unofficialCurrencyCode != null
            ? unofficialCurrencyCode.value
            : this.unofficialCurrencyCode));
  }
}

@JsonSerializable(explicitToJson: true)
class InvestmentTransaction {
  InvestmentTransaction({
    required this.investmentTransactionId,
    this.cancelTransactionId,
    required this.accountId,
    required this.securityId,
    required this.date,
    required this.name,
    required this.quantity,
    required this.amount,
    required this.price,
    required this.fees,
    required this.type,
    required this.subtype,
    required this.isoCurrencyCode,
    required this.unofficialCurrencyCode,
  });

  factory InvestmentTransaction.fromJson(Map<String, dynamic> json) =>
      _$InvestmentTransactionFromJson(json);

  @JsonKey(name: 'investment_transaction_id')
  final String investmentTransactionId;
  @JsonKey(name: 'cancel_transaction_id')
  final String? cancelTransactionId;
  @JsonKey(name: 'account_id')
  final String accountId;
  @JsonKey(name: 'security_id')
  final String? securityId;
  @JsonKey(name: 'date', toJson: _dateToJson)
  final DateTime date;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'quantity')
  final double quantity;
  @JsonKey(name: 'amount')
  final double amount;
  @JsonKey(name: 'price')
  final double price;
  @JsonKey(name: 'fees')
  final double? fees;
  @JsonKey(
    name: 'type',
    toJson: investmentTransactionTypeToJson,
    fromJson: investmentTransactionTypeFromJson,
  )
  final enums.InvestmentTransactionType type;
  @JsonKey(
    name: 'subtype',
    toJson: investmentTransactionSubtypeToJson,
    fromJson: investmentTransactionSubtypeFromJson,
  )
  final enums.InvestmentTransactionSubtype subtype;
  @JsonKey(name: 'iso_currency_code')
  final String? isoCurrencyCode;
  @JsonKey(name: 'unofficial_currency_code')
  final String? unofficialCurrencyCode;
  static const fromJsonFactory = _$InvestmentTransactionFromJson;
  static const toJsonFactory = _$InvestmentTransactionToJson;
  Map<String, dynamic> toJson() => _$InvestmentTransactionToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvestmentTransaction &&
            (identical(
                    other.investmentTransactionId, investmentTransactionId) ||
                const DeepCollectionEquality().equals(
                    other.investmentTransactionId, investmentTransactionId)) &&
            (identical(other.cancelTransactionId, cancelTransactionId) ||
                const DeepCollectionEquality()
                    .equals(other.cancelTransactionId, cancelTransactionId)) &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.securityId, securityId) ||
                const DeepCollectionEquality()
                    .equals(other.securityId, securityId)) &&
            (identical(other.date, date) ||
                const DeepCollectionEquality().equals(other.date, date)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.quantity, quantity) ||
                const DeepCollectionEquality()
                    .equals(other.quantity, quantity)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.price, price) ||
                const DeepCollectionEquality().equals(other.price, price)) &&
            (identical(other.fees, fees) ||
                const DeepCollectionEquality().equals(other.fees, fees)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.subtype, subtype) ||
                const DeepCollectionEquality()
                    .equals(other.subtype, subtype)) &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)) &&
            (identical(other.unofficialCurrencyCode, unofficialCurrencyCode) ||
                const DeepCollectionEquality().equals(
                    other.unofficialCurrencyCode, unofficialCurrencyCode)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(investmentTransactionId) ^
      const DeepCollectionEquality().hash(cancelTransactionId) ^
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(securityId) ^
      const DeepCollectionEquality().hash(date) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(quantity) ^
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(price) ^
      const DeepCollectionEquality().hash(fees) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(subtype) ^
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      const DeepCollectionEquality().hash(unofficialCurrencyCode) ^
      runtimeType.hashCode;
}

extension $InvestmentTransactionExtension on InvestmentTransaction {
  InvestmentTransaction copyWith(
      {String? investmentTransactionId,
      String? cancelTransactionId,
      String? accountId,
      String? securityId,
      DateTime? date,
      String? name,
      double? quantity,
      double? amount,
      double? price,
      double? fees,
      enums.InvestmentTransactionType? type,
      enums.InvestmentTransactionSubtype? subtype,
      String? isoCurrencyCode,
      String? unofficialCurrencyCode}) {
    return InvestmentTransaction(
        investmentTransactionId:
            investmentTransactionId ?? this.investmentTransactionId,
        cancelTransactionId: cancelTransactionId ?? this.cancelTransactionId,
        accountId: accountId ?? this.accountId,
        securityId: securityId ?? this.securityId,
        date: date ?? this.date,
        name: name ?? this.name,
        quantity: quantity ?? this.quantity,
        amount: amount ?? this.amount,
        price: price ?? this.price,
        fees: fees ?? this.fees,
        type: type ?? this.type,
        subtype: subtype ?? this.subtype,
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode,
        unofficialCurrencyCode:
            unofficialCurrencyCode ?? this.unofficialCurrencyCode);
  }

  InvestmentTransaction copyWithWrapped(
      {Wrapped<String>? investmentTransactionId,
      Wrapped<String?>? cancelTransactionId,
      Wrapped<String>? accountId,
      Wrapped<String?>? securityId,
      Wrapped<DateTime>? date,
      Wrapped<String>? name,
      Wrapped<double>? quantity,
      Wrapped<double>? amount,
      Wrapped<double>? price,
      Wrapped<double?>? fees,
      Wrapped<enums.InvestmentTransactionType>? type,
      Wrapped<enums.InvestmentTransactionSubtype>? subtype,
      Wrapped<String?>? isoCurrencyCode,
      Wrapped<String?>? unofficialCurrencyCode}) {
    return InvestmentTransaction(
        investmentTransactionId: (investmentTransactionId != null
            ? investmentTransactionId.value
            : this.investmentTransactionId),
        cancelTransactionId: (cancelTransactionId != null
            ? cancelTransactionId.value
            : this.cancelTransactionId),
        accountId: (accountId != null ? accountId.value : this.accountId),
        securityId: (securityId != null ? securityId.value : this.securityId),
        date: (date != null ? date.value : this.date),
        name: (name != null ? name.value : this.name),
        quantity: (quantity != null ? quantity.value : this.quantity),
        amount: (amount != null ? amount.value : this.amount),
        price: (price != null ? price.value : this.price),
        fees: (fees != null ? fees.value : this.fees),
        type: (type != null ? type.value : this.type),
        subtype: (subtype != null ? subtype.value : this.subtype),
        isoCurrencyCode: (isoCurrencyCode != null
            ? isoCurrencyCode.value
            : this.isoCurrencyCode),
        unofficialCurrencyCode: (unofficialCurrencyCode != null
            ? unofficialCurrencyCode.value
            : this.unofficialCurrencyCode));
  }
}

@JsonSerializable(explicitToJson: true)
class StandaloneInvestmentTransactionType {
  StandaloneInvestmentTransactionType({
    required this.buy,
    required this.sell,
    required this.cancel,
    required this.cash,
    required this.fee,
    required this.transfer,
  });

  factory StandaloneInvestmentTransactionType.fromJson(
          Map<String, dynamic> json) =>
      _$StandaloneInvestmentTransactionTypeFromJson(json);

  @JsonKey(name: 'buy')
  final String buy;
  @JsonKey(name: 'sell')
  final String sell;
  @JsonKey(name: 'cancel')
  final String cancel;
  @JsonKey(name: 'cash')
  final String cash;
  @JsonKey(name: 'fee')
  final String fee;
  @JsonKey(name: 'transfer')
  final String transfer;
  static const fromJsonFactory = _$StandaloneInvestmentTransactionTypeFromJson;
  static const toJsonFactory = _$StandaloneInvestmentTransactionTypeToJson;
  Map<String, dynamic> toJson() =>
      _$StandaloneInvestmentTransactionTypeToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is StandaloneInvestmentTransactionType &&
            (identical(other.buy, buy) ||
                const DeepCollectionEquality().equals(other.buy, buy)) &&
            (identical(other.sell, sell) ||
                const DeepCollectionEquality().equals(other.sell, sell)) &&
            (identical(other.cancel, cancel) ||
                const DeepCollectionEquality().equals(other.cancel, cancel)) &&
            (identical(other.cash, cash) ||
                const DeepCollectionEquality().equals(other.cash, cash)) &&
            (identical(other.fee, fee) ||
                const DeepCollectionEquality().equals(other.fee, fee)) &&
            (identical(other.transfer, transfer) ||
                const DeepCollectionEquality()
                    .equals(other.transfer, transfer)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(buy) ^
      const DeepCollectionEquality().hash(sell) ^
      const DeepCollectionEquality().hash(cancel) ^
      const DeepCollectionEquality().hash(cash) ^
      const DeepCollectionEquality().hash(fee) ^
      const DeepCollectionEquality().hash(transfer) ^
      runtimeType.hashCode;
}

extension $StandaloneInvestmentTransactionTypeExtension
    on StandaloneInvestmentTransactionType {
  StandaloneInvestmentTransactionType copyWith(
      {String? buy,
      String? sell,
      String? cancel,
      String? cash,
      String? fee,
      String? transfer}) {
    return StandaloneInvestmentTransactionType(
        buy: buy ?? this.buy,
        sell: sell ?? this.sell,
        cancel: cancel ?? this.cancel,
        cash: cash ?? this.cash,
        fee: fee ?? this.fee,
        transfer: transfer ?? this.transfer);
  }

  StandaloneInvestmentTransactionType copyWithWrapped(
      {Wrapped<String>? buy,
      Wrapped<String>? sell,
      Wrapped<String>? cancel,
      Wrapped<String>? cash,
      Wrapped<String>? fee,
      Wrapped<String>? transfer}) {
    return StandaloneInvestmentTransactionType(
        buy: (buy != null ? buy.value : this.buy),
        sell: (sell != null ? sell.value : this.sell),
        cancel: (cancel != null ? cancel.value : this.cancel),
        cash: (cash != null ? cash.value : this.cash),
        fee: (fee != null ? fee.value : this.fee),
        transfer: (transfer != null ? transfer.value : this.transfer));
  }
}

typedef AccountSubtypes = List<String>;

@JsonSerializable(explicitToJson: true)
class UserPermissionRevokedWebhook {
  UserPermissionRevokedWebhook({
    required this.webhookType,
    required this.webhookCode,
    required this.itemId,
    this.error,
    required this.environment,
  });

  factory UserPermissionRevokedWebhook.fromJson(Map<String, dynamic> json) =>
      _$UserPermissionRevokedWebhookFromJson(json);

  @JsonKey(name: 'webhook_type')
  final String webhookType;
  @JsonKey(name: 'webhook_code')
  final String webhookCode;
  @JsonKey(name: 'item_id')
  final String itemId;
  @JsonKey(name: 'error')
  final PlaidError? error;
  @JsonKey(
    name: 'environment',
    toJson: webhookEnvironmentValuesToJson,
    fromJson: webhookEnvironmentValuesFromJson,
  )
  final enums.WebhookEnvironmentValues environment;
  static const fromJsonFactory = _$UserPermissionRevokedWebhookFromJson;
  static const toJsonFactory = _$UserPermissionRevokedWebhookToJson;
  Map<String, dynamic> toJson() => _$UserPermissionRevokedWebhookToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is UserPermissionRevokedWebhook &&
            (identical(other.webhookType, webhookType) ||
                const DeepCollectionEquality()
                    .equals(other.webhookType, webhookType)) &&
            (identical(other.webhookCode, webhookCode) ||
                const DeepCollectionEquality()
                    .equals(other.webhookCode, webhookCode)) &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)) &&
            (identical(other.error, error) ||
                const DeepCollectionEquality().equals(other.error, error)) &&
            (identical(other.environment, environment) ||
                const DeepCollectionEquality()
                    .equals(other.environment, environment)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(webhookType) ^
      const DeepCollectionEquality().hash(webhookCode) ^
      const DeepCollectionEquality().hash(itemId) ^
      const DeepCollectionEquality().hash(error) ^
      const DeepCollectionEquality().hash(environment) ^
      runtimeType.hashCode;
}

extension $UserPermissionRevokedWebhookExtension
    on UserPermissionRevokedWebhook {
  UserPermissionRevokedWebhook copyWith(
      {String? webhookType,
      String? webhookCode,
      String? itemId,
      PlaidError? error,
      enums.WebhookEnvironmentValues? environment}) {
    return UserPermissionRevokedWebhook(
        webhookType: webhookType ?? this.webhookType,
        webhookCode: webhookCode ?? this.webhookCode,
        itemId: itemId ?? this.itemId,
        error: error ?? this.error,
        environment: environment ?? this.environment);
  }

  UserPermissionRevokedWebhook copyWithWrapped(
      {Wrapped<String>? webhookType,
      Wrapped<String>? webhookCode,
      Wrapped<String>? itemId,
      Wrapped<PlaidError?>? error,
      Wrapped<enums.WebhookEnvironmentValues>? environment}) {
    return UserPermissionRevokedWebhook(
        webhookType:
            (webhookType != null ? webhookType.value : this.webhookType),
        webhookCode:
            (webhookCode != null ? webhookCode.value : this.webhookCode),
        itemId: (itemId != null ? itemId.value : this.itemId),
        error: (error != null ? error.value : this.error),
        environment:
            (environment != null ? environment.value : this.environment));
  }
}

@JsonSerializable(explicitToJson: true)
class DepositSwitchGetRequest {
  DepositSwitchGetRequest({
    this.clientId,
    this.secret,
    required this.depositSwitchId,
  });

  factory DepositSwitchGetRequest.fromJson(Map<String, dynamic> json) =>
      _$DepositSwitchGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'deposit_switch_id')
  final String depositSwitchId;
  static const fromJsonFactory = _$DepositSwitchGetRequestFromJson;
  static const toJsonFactory = _$DepositSwitchGetRequestToJson;
  Map<String, dynamic> toJson() => _$DepositSwitchGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is DepositSwitchGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.depositSwitchId, depositSwitchId) ||
                const DeepCollectionEquality()
                    .equals(other.depositSwitchId, depositSwitchId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(depositSwitchId) ^
      runtimeType.hashCode;
}

extension $DepositSwitchGetRequestExtension on DepositSwitchGetRequest {
  DepositSwitchGetRequest copyWith(
      {String? clientId, String? secret, String? depositSwitchId}) {
    return DepositSwitchGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        depositSwitchId: depositSwitchId ?? this.depositSwitchId);
  }

  DepositSwitchGetRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? depositSwitchId}) {
    return DepositSwitchGetRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        depositSwitchId: (depositSwitchId != null
            ? depositSwitchId.value
            : this.depositSwitchId));
  }
}

@JsonSerializable(explicitToJson: true)
class DepositSwitchGetResponse {
  DepositSwitchGetResponse({
    required this.depositSwitchId,
    required this.targetAccountId,
    required this.targetItemId,
    required this.state,
    this.switchMethod,
    required this.accountHasMultipleAllocations,
    required this.isAllocatedRemainder,
    required this.percentAllocated,
    required this.amountAllocated,
    this.employerName,
    this.employerId,
    this.institutionName,
    this.institutionId,
    required this.dateCreated,
    required this.dateCompleted,
    required this.requestId,
  });

  factory DepositSwitchGetResponse.fromJson(Map<String, dynamic> json) =>
      _$DepositSwitchGetResponseFromJson(json);

  @JsonKey(name: 'deposit_switch_id')
  final String depositSwitchId;
  @JsonKey(name: 'target_account_id')
  final String? targetAccountId;
  @JsonKey(name: 'target_item_id')
  final String? targetItemId;
  @JsonKey(
    name: 'state',
    toJson: depositSwitchGetResponseStateToJson,
    fromJson: depositSwitchGetResponseStateFromJson,
  )
  final enums.DepositSwitchGetResponseState state;
  @JsonKey(
    name: 'switch_method',
    toJson: depositSwitchGetResponseSwitchMethodToJson,
    fromJson: depositSwitchGetResponseSwitchMethodFromJson,
  )
  final enums.DepositSwitchGetResponseSwitchMethod? switchMethod;
  @JsonKey(name: 'account_has_multiple_allocations')
  final bool? accountHasMultipleAllocations;
  @JsonKey(name: 'is_allocated_remainder')
  final bool? isAllocatedRemainder;
  @JsonKey(name: 'percent_allocated')
  final double? percentAllocated;
  @JsonKey(name: 'amount_allocated')
  final double? amountAllocated;
  @JsonKey(name: 'employer_name')
  final String? employerName;
  @JsonKey(name: 'employer_id')
  final String? employerId;
  @JsonKey(name: 'institution_name')
  final String? institutionName;
  @JsonKey(name: 'institution_id')
  final String? institutionId;
  @JsonKey(name: 'date_created', toJson: _dateToJson)
  final DateTime dateCreated;
  @JsonKey(name: 'date_completed', toJson: _dateToJson)
  final DateTime? dateCompleted;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$DepositSwitchGetResponseFromJson;
  static const toJsonFactory = _$DepositSwitchGetResponseToJson;
  Map<String, dynamic> toJson() => _$DepositSwitchGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is DepositSwitchGetResponse &&
            (identical(other.depositSwitchId, depositSwitchId) ||
                const DeepCollectionEquality()
                    .equals(other.depositSwitchId, depositSwitchId)) &&
            (identical(other.targetAccountId, targetAccountId) ||
                const DeepCollectionEquality()
                    .equals(other.targetAccountId, targetAccountId)) &&
            (identical(other.targetItemId, targetItemId) ||
                const DeepCollectionEquality()
                    .equals(other.targetItemId, targetItemId)) &&
            (identical(other.state, state) ||
                const DeepCollectionEquality().equals(other.state, state)) &&
            (identical(other.switchMethod, switchMethod) ||
                const DeepCollectionEquality()
                    .equals(other.switchMethod, switchMethod)) &&
            (identical(other.accountHasMultipleAllocations,
                    accountHasMultipleAllocations) ||
                const DeepCollectionEquality().equals(
                    other.accountHasMultipleAllocations,
                    accountHasMultipleAllocations)) &&
            (identical(other.isAllocatedRemainder, isAllocatedRemainder) ||
                const DeepCollectionEquality().equals(
                    other.isAllocatedRemainder, isAllocatedRemainder)) &&
            (identical(other.percentAllocated, percentAllocated) ||
                const DeepCollectionEquality()
                    .equals(other.percentAllocated, percentAllocated)) &&
            (identical(other.amountAllocated, amountAllocated) ||
                const DeepCollectionEquality()
                    .equals(other.amountAllocated, amountAllocated)) &&
            (identical(other.employerName, employerName) ||
                const DeepCollectionEquality()
                    .equals(other.employerName, employerName)) &&
            (identical(other.employerId, employerId) ||
                const DeepCollectionEquality()
                    .equals(other.employerId, employerId)) &&
            (identical(other.institutionName, institutionName) ||
                const DeepCollectionEquality()
                    .equals(other.institutionName, institutionName)) &&
            (identical(other.institutionId, institutionId) ||
                const DeepCollectionEquality()
                    .equals(other.institutionId, institutionId)) &&
            (identical(other.dateCreated, dateCreated) ||
                const DeepCollectionEquality()
                    .equals(other.dateCreated, dateCreated)) &&
            (identical(other.dateCompleted, dateCompleted) ||
                const DeepCollectionEquality()
                    .equals(other.dateCompleted, dateCompleted)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(depositSwitchId) ^
      const DeepCollectionEquality().hash(targetAccountId) ^
      const DeepCollectionEquality().hash(targetItemId) ^
      const DeepCollectionEquality().hash(state) ^
      const DeepCollectionEquality().hash(switchMethod) ^
      const DeepCollectionEquality().hash(accountHasMultipleAllocations) ^
      const DeepCollectionEquality().hash(isAllocatedRemainder) ^
      const DeepCollectionEquality().hash(percentAllocated) ^
      const DeepCollectionEquality().hash(amountAllocated) ^
      const DeepCollectionEquality().hash(employerName) ^
      const DeepCollectionEquality().hash(employerId) ^
      const DeepCollectionEquality().hash(institutionName) ^
      const DeepCollectionEquality().hash(institutionId) ^
      const DeepCollectionEquality().hash(dateCreated) ^
      const DeepCollectionEquality().hash(dateCompleted) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $DepositSwitchGetResponseExtension on DepositSwitchGetResponse {
  DepositSwitchGetResponse copyWith(
      {String? depositSwitchId,
      String? targetAccountId,
      String? targetItemId,
      enums.DepositSwitchGetResponseState? state,
      enums.DepositSwitchGetResponseSwitchMethod? switchMethod,
      bool? accountHasMultipleAllocations,
      bool? isAllocatedRemainder,
      double? percentAllocated,
      double? amountAllocated,
      String? employerName,
      String? employerId,
      String? institutionName,
      String? institutionId,
      DateTime? dateCreated,
      DateTime? dateCompleted,
      String? requestId}) {
    return DepositSwitchGetResponse(
        depositSwitchId: depositSwitchId ?? this.depositSwitchId,
        targetAccountId: targetAccountId ?? this.targetAccountId,
        targetItemId: targetItemId ?? this.targetItemId,
        state: state ?? this.state,
        switchMethod: switchMethod ?? this.switchMethod,
        accountHasMultipleAllocations:
            accountHasMultipleAllocations ?? this.accountHasMultipleAllocations,
        isAllocatedRemainder: isAllocatedRemainder ?? this.isAllocatedRemainder,
        percentAllocated: percentAllocated ?? this.percentAllocated,
        amountAllocated: amountAllocated ?? this.amountAllocated,
        employerName: employerName ?? this.employerName,
        employerId: employerId ?? this.employerId,
        institutionName: institutionName ?? this.institutionName,
        institutionId: institutionId ?? this.institutionId,
        dateCreated: dateCreated ?? this.dateCreated,
        dateCompleted: dateCompleted ?? this.dateCompleted,
        requestId: requestId ?? this.requestId);
  }

  DepositSwitchGetResponse copyWithWrapped(
      {Wrapped<String>? depositSwitchId,
      Wrapped<String?>? targetAccountId,
      Wrapped<String?>? targetItemId,
      Wrapped<enums.DepositSwitchGetResponseState>? state,
      Wrapped<enums.DepositSwitchGetResponseSwitchMethod?>? switchMethod,
      Wrapped<bool?>? accountHasMultipleAllocations,
      Wrapped<bool?>? isAllocatedRemainder,
      Wrapped<double?>? percentAllocated,
      Wrapped<double?>? amountAllocated,
      Wrapped<String?>? employerName,
      Wrapped<String?>? employerId,
      Wrapped<String?>? institutionName,
      Wrapped<String?>? institutionId,
      Wrapped<DateTime>? dateCreated,
      Wrapped<DateTime?>? dateCompleted,
      Wrapped<String>? requestId}) {
    return DepositSwitchGetResponse(
        depositSwitchId: (depositSwitchId != null
            ? depositSwitchId.value
            : this.depositSwitchId),
        targetAccountId: (targetAccountId != null
            ? targetAccountId.value
            : this.targetAccountId),
        targetItemId:
            (targetItemId != null ? targetItemId.value : this.targetItemId),
        state: (state != null ? state.value : this.state),
        switchMethod:
            (switchMethod != null ? switchMethod.value : this.switchMethod),
        accountHasMultipleAllocations: (accountHasMultipleAllocations != null
            ? accountHasMultipleAllocations.value
            : this.accountHasMultipleAllocations),
        isAllocatedRemainder: (isAllocatedRemainder != null
            ? isAllocatedRemainder.value
            : this.isAllocatedRemainder),
        percentAllocated: (percentAllocated != null
            ? percentAllocated.value
            : this.percentAllocated),
        amountAllocated: (amountAllocated != null
            ? amountAllocated.value
            : this.amountAllocated),
        employerName:
            (employerName != null ? employerName.value : this.employerName),
        employerId: (employerId != null ? employerId.value : this.employerId),
        institutionName: (institutionName != null
            ? institutionName.value
            : this.institutionName),
        institutionId:
            (institutionId != null ? institutionId.value : this.institutionId),
        dateCreated:
            (dateCreated != null ? dateCreated.value : this.dateCreated),
        dateCompleted:
            (dateCompleted != null ? dateCompleted.value : this.dateCompleted),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class DepositSwitchStateUpdateWebhook {
  DepositSwitchStateUpdateWebhook({
    this.webhookType,
    this.webhookCode,
    this.state,
    this.depositSwitchId,
    this.environment,
  });

  factory DepositSwitchStateUpdateWebhook.fromJson(Map<String, dynamic> json) =>
      _$DepositSwitchStateUpdateWebhookFromJson(json);

  @JsonKey(name: 'webhook_type')
  final String? webhookType;
  @JsonKey(name: 'webhook_code')
  final String? webhookCode;
  @JsonKey(name: 'state')
  final String? state;
  @JsonKey(name: 'deposit_switch_id')
  final String? depositSwitchId;
  @JsonKey(
    name: 'environment',
    toJson: webhookEnvironmentValuesToJson,
    fromJson: webhookEnvironmentValuesFromJson,
  )
  final enums.WebhookEnvironmentValues? environment;
  static const fromJsonFactory = _$DepositSwitchStateUpdateWebhookFromJson;
  static const toJsonFactory = _$DepositSwitchStateUpdateWebhookToJson;
  Map<String, dynamic> toJson() =>
      _$DepositSwitchStateUpdateWebhookToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is DepositSwitchStateUpdateWebhook &&
            (identical(other.webhookType, webhookType) ||
                const DeepCollectionEquality()
                    .equals(other.webhookType, webhookType)) &&
            (identical(other.webhookCode, webhookCode) ||
                const DeepCollectionEquality()
                    .equals(other.webhookCode, webhookCode)) &&
            (identical(other.state, state) ||
                const DeepCollectionEquality().equals(other.state, state)) &&
            (identical(other.depositSwitchId, depositSwitchId) ||
                const DeepCollectionEquality()
                    .equals(other.depositSwitchId, depositSwitchId)) &&
            (identical(other.environment, environment) ||
                const DeepCollectionEquality()
                    .equals(other.environment, environment)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(webhookType) ^
      const DeepCollectionEquality().hash(webhookCode) ^
      const DeepCollectionEquality().hash(state) ^
      const DeepCollectionEquality().hash(depositSwitchId) ^
      const DeepCollectionEquality().hash(environment) ^
      runtimeType.hashCode;
}

extension $DepositSwitchStateUpdateWebhookExtension
    on DepositSwitchStateUpdateWebhook {
  DepositSwitchStateUpdateWebhook copyWith(
      {String? webhookType,
      String? webhookCode,
      String? state,
      String? depositSwitchId,
      enums.WebhookEnvironmentValues? environment}) {
    return DepositSwitchStateUpdateWebhook(
        webhookType: webhookType ?? this.webhookType,
        webhookCode: webhookCode ?? this.webhookCode,
        state: state ?? this.state,
        depositSwitchId: depositSwitchId ?? this.depositSwitchId,
        environment: environment ?? this.environment);
  }

  DepositSwitchStateUpdateWebhook copyWithWrapped(
      {Wrapped<String?>? webhookType,
      Wrapped<String?>? webhookCode,
      Wrapped<String?>? state,
      Wrapped<String?>? depositSwitchId,
      Wrapped<enums.WebhookEnvironmentValues?>? environment}) {
    return DepositSwitchStateUpdateWebhook(
        webhookType:
            (webhookType != null ? webhookType.value : this.webhookType),
        webhookCode:
            (webhookCode != null ? webhookCode.value : this.webhookCode),
        state: (state != null ? state.value : this.state),
        depositSwitchId: (depositSwitchId != null
            ? depositSwitchId.value
            : this.depositSwitchId),
        environment:
            (environment != null ? environment.value : this.environment));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferGetRequest {
  TransferGetRequest({
    this.clientId,
    this.secret,
    required this.transferId,
  });

  factory TransferGetRequest.fromJson(Map<String, dynamic> json) =>
      _$TransferGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'transfer_id')
  final String transferId;
  static const fromJsonFactory = _$TransferGetRequestFromJson;
  static const toJsonFactory = _$TransferGetRequestToJson;
  Map<String, dynamic> toJson() => _$TransferGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.transferId, transferId) ||
                const DeepCollectionEquality()
                    .equals(other.transferId, transferId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(transferId) ^
      runtimeType.hashCode;
}

extension $TransferGetRequestExtension on TransferGetRequest {
  TransferGetRequest copyWith(
      {String? clientId, String? secret, String? transferId}) {
    return TransferGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        transferId: transferId ?? this.transferId);
  }

  TransferGetRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? transferId}) {
    return TransferGetRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        transferId: (transferId != null ? transferId.value : this.transferId));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferRecurringGetRequest {
  TransferRecurringGetRequest({
    required this.clientId,
    required this.secret,
    required this.recurringTransferId,
  });

  factory TransferRecurringGetRequest.fromJson(Map<String, dynamic> json) =>
      _$TransferRecurringGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String clientId;
  @JsonKey(name: 'secret')
  final String secret;
  @JsonKey(name: 'recurring_transfer_id')
  final String recurringTransferId;
  static const fromJsonFactory = _$TransferRecurringGetRequestFromJson;
  static const toJsonFactory = _$TransferRecurringGetRequestToJson;
  Map<String, dynamic> toJson() => _$TransferRecurringGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferRecurringGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.recurringTransferId, recurringTransferId) ||
                const DeepCollectionEquality()
                    .equals(other.recurringTransferId, recurringTransferId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(recurringTransferId) ^
      runtimeType.hashCode;
}

extension $TransferRecurringGetRequestExtension on TransferRecurringGetRequest {
  TransferRecurringGetRequest copyWith(
      {String? clientId, String? secret, String? recurringTransferId}) {
    return TransferRecurringGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        recurringTransferId: recurringTransferId ?? this.recurringTransferId);
  }

  TransferRecurringGetRequest copyWithWrapped(
      {Wrapped<String>? clientId,
      Wrapped<String>? secret,
      Wrapped<String>? recurringTransferId}) {
    return TransferRecurringGetRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        recurringTransferId: (recurringTransferId != null
            ? recurringTransferId.value
            : this.recurringTransferId));
  }
}

@JsonSerializable(explicitToJson: true)
class BankTransferGetRequest {
  BankTransferGetRequest({
    this.clientId,
    this.secret,
    required this.bankTransferId,
  });

  factory BankTransferGetRequest.fromJson(Map<String, dynamic> json) =>
      _$BankTransferGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'bank_transfer_id')
  final String bankTransferId;
  static const fromJsonFactory = _$BankTransferGetRequestFromJson;
  static const toJsonFactory = _$BankTransferGetRequestToJson;
  Map<String, dynamic> toJson() => _$BankTransferGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BankTransferGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.bankTransferId, bankTransferId) ||
                const DeepCollectionEquality()
                    .equals(other.bankTransferId, bankTransferId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(bankTransferId) ^
      runtimeType.hashCode;
}

extension $BankTransferGetRequestExtension on BankTransferGetRequest {
  BankTransferGetRequest copyWith(
      {String? clientId, String? secret, String? bankTransferId}) {
    return BankTransferGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        bankTransferId: bankTransferId ?? this.bankTransferId);
  }

  BankTransferGetRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? bankTransferId}) {
    return BankTransferGetRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        bankTransferId: (bankTransferId != null
            ? bankTransferId.value
            : this.bankTransferId));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferGetResponse {
  TransferGetResponse({
    required this.transfer,
    required this.requestId,
  });

  factory TransferGetResponse.fromJson(Map<String, dynamic> json) =>
      _$TransferGetResponseFromJson(json);

  @JsonKey(name: 'transfer')
  final Transfer transfer;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$TransferGetResponseFromJson;
  static const toJsonFactory = _$TransferGetResponseToJson;
  Map<String, dynamic> toJson() => _$TransferGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferGetResponse &&
            (identical(other.transfer, transfer) ||
                const DeepCollectionEquality()
                    .equals(other.transfer, transfer)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(transfer) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $TransferGetResponseExtension on TransferGetResponse {
  TransferGetResponse copyWith({Transfer? transfer, String? requestId}) {
    return TransferGetResponse(
        transfer: transfer ?? this.transfer,
        requestId: requestId ?? this.requestId);
  }

  TransferGetResponse copyWithWrapped(
      {Wrapped<Transfer>? transfer, Wrapped<String>? requestId}) {
    return TransferGetResponse(
        transfer: (transfer != null ? transfer.value : this.transfer),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferRecurringGetResponse {
  TransferRecurringGetResponse({
    required this.recurringTransfer,
    required this.requestId,
  });

  factory TransferRecurringGetResponse.fromJson(Map<String, dynamic> json) =>
      _$TransferRecurringGetResponseFromJson(json);

  @JsonKey(name: 'recurring_transfer')
  final RecurringTransfer recurringTransfer;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$TransferRecurringGetResponseFromJson;
  static const toJsonFactory = _$TransferRecurringGetResponseToJson;
  Map<String, dynamic> toJson() => _$TransferRecurringGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferRecurringGetResponse &&
            (identical(other.recurringTransfer, recurringTransfer) ||
                const DeepCollectionEquality()
                    .equals(other.recurringTransfer, recurringTransfer)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(recurringTransfer) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $TransferRecurringGetResponseExtension
    on TransferRecurringGetResponse {
  TransferRecurringGetResponse copyWith(
      {RecurringTransfer? recurringTransfer, String? requestId}) {
    return TransferRecurringGetResponse(
        recurringTransfer: recurringTransfer ?? this.recurringTransfer,
        requestId: requestId ?? this.requestId);
  }

  TransferRecurringGetResponse copyWithWrapped(
      {Wrapped<RecurringTransfer>? recurringTransfer,
      Wrapped<String>? requestId}) {
    return TransferRecurringGetResponse(
        recurringTransfer: (recurringTransfer != null
            ? recurringTransfer.value
            : this.recurringTransfer),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class BankTransferGetResponse {
  BankTransferGetResponse({
    required this.bankTransfer,
    required this.requestId,
  });

  factory BankTransferGetResponse.fromJson(Map<String, dynamic> json) =>
      _$BankTransferGetResponseFromJson(json);

  @JsonKey(name: 'bank_transfer')
  final BankTransfer bankTransfer;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$BankTransferGetResponseFromJson;
  static const toJsonFactory = _$BankTransferGetResponseToJson;
  Map<String, dynamic> toJson() => _$BankTransferGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BankTransferGetResponse &&
            (identical(other.bankTransfer, bankTransfer) ||
                const DeepCollectionEquality()
                    .equals(other.bankTransfer, bankTransfer)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(bankTransfer) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $BankTransferGetResponseExtension on BankTransferGetResponse {
  BankTransferGetResponse copyWith(
      {BankTransfer? bankTransfer, String? requestId}) {
    return BankTransferGetResponse(
        bankTransfer: bankTransfer ?? this.bankTransfer,
        requestId: requestId ?? this.requestId);
  }

  BankTransferGetResponse copyWithWrapped(
      {Wrapped<BankTransfer>? bankTransfer, Wrapped<String>? requestId}) {
    return BankTransferGetResponse(
        bankTransfer:
            (bankTransfer != null ? bankTransfer.value : this.bankTransfer),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class Transfer {
  Transfer({
    required this.id,
    this.achClass,
    this.accountId,
    required this.type,
    required this.user,
    required this.amount,
    required this.description,
    required this.created,
    required this.status,
    this.sweepStatus,
    required this.network,
    required this.cancellable,
    required this.failureReason,
    required this.metadata,
    required this.originationAccountId,
    required this.guaranteeDecision,
    required this.guaranteeDecisionRationale,
    required this.isoCurrencyCode,
    required this.standardReturnWindow,
    required this.unauthorizedReturnWindow,
    required this.originatorClientId,
    required this.refunds,
  });

  factory Transfer.fromJson(Map<String, dynamic> json) =>
      _$TransferFromJson(json);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(
    name: 'ach_class',
    toJson: aCHClassToJson,
    fromJson: aCHClassFromJson,
  )
  final enums.ACHClass? achClass;
  @JsonKey(name: 'account_id')
  final String? accountId;
  @JsonKey(
    name: 'type',
    toJson: transferTypeToJson,
    fromJson: transferTypeFromJson,
  )
  final enums.TransferType type;
  @JsonKey(name: 'user')
  final TransferUserInResponse user;
  @JsonKey(name: 'amount')
  final String amount;
  @JsonKey(name: 'description')
  final String description;
  @JsonKey(name: 'created')
  final DateTime created;
  @JsonKey(
    name: 'status',
    toJson: transferStatusToJson,
    fromJson: transferStatusFromJson,
  )
  final enums.TransferStatus status;
  @JsonKey(
    name: 'sweep_status',
    toJson: transferSweepStatusToJson,
    fromJson: transferSweepStatusFromJson,
  )
  final enums.TransferSweepStatus? sweepStatus;
  @JsonKey(
    name: 'network',
    toJson: transferNetworkToJson,
    fromJson: transferNetworkFromJson,
  )
  final enums.TransferNetwork network;
  @JsonKey(name: 'cancellable')
  final bool cancellable;
  @JsonKey(name: 'failure_reason')
  final TransferFailure? failureReason;
  @JsonKey(name: 'metadata')
  final TransferMetadata? metadata;
  @JsonKey(name: 'origination_account_id')
  final String originationAccountId;
  @JsonKey(
    name: 'guarantee_decision',
    toJson: transferAuthorizationGuaranteeDecisionToJson,
    fromJson: transferAuthorizationGuaranteeDecisionFromJson,
  )
  final enums.TransferAuthorizationGuaranteeDecision? guaranteeDecision;
  @JsonKey(name: 'guarantee_decision_rationale')
  final TransferAuthorizationGuaranteeDecisionRationale?
      guaranteeDecisionRationale;
  @JsonKey(name: 'iso_currency_code')
  final String isoCurrencyCode;
  @JsonKey(name: 'standard_return_window', toJson: _dateToJson)
  final DateTime? standardReturnWindow;
  @JsonKey(name: 'unauthorized_return_window', toJson: _dateToJson)
  final DateTime? unauthorizedReturnWindow;
  @JsonKey(name: 'originator_client_id')
  final String? originatorClientId;
  @JsonKey(name: 'refunds', defaultValue: <TransferRefund>[])
  final List<TransferRefund> refunds;
  static const fromJsonFactory = _$TransferFromJson;
  static const toJsonFactory = _$TransferToJson;
  Map<String, dynamic> toJson() => _$TransferToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Transfer &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.achClass, achClass) ||
                const DeepCollectionEquality()
                    .equals(other.achClass, achClass)) &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.user, user) ||
                const DeepCollectionEquality().equals(other.user, user)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.created, created) ||
                const DeepCollectionEquality()
                    .equals(other.created, created)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.sweepStatus, sweepStatus) ||
                const DeepCollectionEquality()
                    .equals(other.sweepStatus, sweepStatus)) &&
            (identical(other.network, network) ||
                const DeepCollectionEquality()
                    .equals(other.network, network)) &&
            (identical(other.cancellable, cancellable) ||
                const DeepCollectionEquality()
                    .equals(other.cancellable, cancellable)) &&
            (identical(other.failureReason, failureReason) ||
                const DeepCollectionEquality()
                    .equals(other.failureReason, failureReason)) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality()
                    .equals(other.metadata, metadata)) &&
            (identical(other.originationAccountId, originationAccountId) ||
                const DeepCollectionEquality().equals(
                    other.originationAccountId, originationAccountId)) &&
            (identical(other.guaranteeDecision, guaranteeDecision) ||
                const DeepCollectionEquality()
                    .equals(other.guaranteeDecision, guaranteeDecision)) &&
            (identical(other.guaranteeDecisionRationale, guaranteeDecisionRationale) ||
                const DeepCollectionEquality().equals(
                    other.guaranteeDecisionRationale,
                    guaranteeDecisionRationale)) &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)) &&
            (identical(other.standardReturnWindow, standardReturnWindow) ||
                const DeepCollectionEquality().equals(
                    other.standardReturnWindow, standardReturnWindow)) &&
            (identical(other.unauthorizedReturnWindow, unauthorizedReturnWindow) ||
                const DeepCollectionEquality().equals(
                    other.unauthorizedReturnWindow,
                    unauthorizedReturnWindow)) &&
            (identical(other.originatorClientId, originatorClientId) ||
                const DeepCollectionEquality()
                    .equals(other.originatorClientId, originatorClientId)) &&
            (identical(other.refunds, refunds) ||
                const DeepCollectionEquality().equals(other.refunds, refunds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(achClass) ^
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(user) ^
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(created) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(sweepStatus) ^
      const DeepCollectionEquality().hash(network) ^
      const DeepCollectionEquality().hash(cancellable) ^
      const DeepCollectionEquality().hash(failureReason) ^
      const DeepCollectionEquality().hash(metadata) ^
      const DeepCollectionEquality().hash(originationAccountId) ^
      const DeepCollectionEquality().hash(guaranteeDecision) ^
      const DeepCollectionEquality().hash(guaranteeDecisionRationale) ^
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      const DeepCollectionEquality().hash(standardReturnWindow) ^
      const DeepCollectionEquality().hash(unauthorizedReturnWindow) ^
      const DeepCollectionEquality().hash(originatorClientId) ^
      const DeepCollectionEquality().hash(refunds) ^
      runtimeType.hashCode;
}

extension $TransferExtension on Transfer {
  Transfer copyWith(
      {String? id,
      enums.ACHClass? achClass,
      String? accountId,
      enums.TransferType? type,
      TransferUserInResponse? user,
      String? amount,
      String? description,
      DateTime? created,
      enums.TransferStatus? status,
      enums.TransferSweepStatus? sweepStatus,
      enums.TransferNetwork? network,
      bool? cancellable,
      TransferFailure? failureReason,
      TransferMetadata? metadata,
      String? originationAccountId,
      enums.TransferAuthorizationGuaranteeDecision? guaranteeDecision,
      TransferAuthorizationGuaranteeDecisionRationale?
          guaranteeDecisionRationale,
      String? isoCurrencyCode,
      DateTime? standardReturnWindow,
      DateTime? unauthorizedReturnWindow,
      String? originatorClientId,
      List<TransferRefund>? refunds}) {
    return Transfer(
        id: id ?? this.id,
        achClass: achClass ?? this.achClass,
        accountId: accountId ?? this.accountId,
        type: type ?? this.type,
        user: user ?? this.user,
        amount: amount ?? this.amount,
        description: description ?? this.description,
        created: created ?? this.created,
        status: status ?? this.status,
        sweepStatus: sweepStatus ?? this.sweepStatus,
        network: network ?? this.network,
        cancellable: cancellable ?? this.cancellable,
        failureReason: failureReason ?? this.failureReason,
        metadata: metadata ?? this.metadata,
        originationAccountId: originationAccountId ?? this.originationAccountId,
        guaranteeDecision: guaranteeDecision ?? this.guaranteeDecision,
        guaranteeDecisionRationale:
            guaranteeDecisionRationale ?? this.guaranteeDecisionRationale,
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode,
        standardReturnWindow: standardReturnWindow ?? this.standardReturnWindow,
        unauthorizedReturnWindow:
            unauthorizedReturnWindow ?? this.unauthorizedReturnWindow,
        originatorClientId: originatorClientId ?? this.originatorClientId,
        refunds: refunds ?? this.refunds);
  }

  Transfer copyWithWrapped(
      {Wrapped<String>? id,
      Wrapped<enums.ACHClass?>? achClass,
      Wrapped<String?>? accountId,
      Wrapped<enums.TransferType>? type,
      Wrapped<TransferUserInResponse>? user,
      Wrapped<String>? amount,
      Wrapped<String>? description,
      Wrapped<DateTime>? created,
      Wrapped<enums.TransferStatus>? status,
      Wrapped<enums.TransferSweepStatus?>? sweepStatus,
      Wrapped<enums.TransferNetwork>? network,
      Wrapped<bool>? cancellable,
      Wrapped<TransferFailure?>? failureReason,
      Wrapped<TransferMetadata?>? metadata,
      Wrapped<String>? originationAccountId,
      Wrapped<enums.TransferAuthorizationGuaranteeDecision?>? guaranteeDecision,
      Wrapped<TransferAuthorizationGuaranteeDecisionRationale?>?
          guaranteeDecisionRationale,
      Wrapped<String>? isoCurrencyCode,
      Wrapped<DateTime?>? standardReturnWindow,
      Wrapped<DateTime?>? unauthorizedReturnWindow,
      Wrapped<String?>? originatorClientId,
      Wrapped<List<TransferRefund>>? refunds}) {
    return Transfer(
        id: (id != null ? id.value : this.id),
        achClass: (achClass != null ? achClass.value : this.achClass),
        accountId: (accountId != null ? accountId.value : this.accountId),
        type: (type != null ? type.value : this.type),
        user: (user != null ? user.value : this.user),
        amount: (amount != null ? amount.value : this.amount),
        description:
            (description != null ? description.value : this.description),
        created: (created != null ? created.value : this.created),
        status: (status != null ? status.value : this.status),
        sweepStatus:
            (sweepStatus != null ? sweepStatus.value : this.sweepStatus),
        network: (network != null ? network.value : this.network),
        cancellable:
            (cancellable != null ? cancellable.value : this.cancellable),
        failureReason:
            (failureReason != null ? failureReason.value : this.failureReason),
        metadata: (metadata != null ? metadata.value : this.metadata),
        originationAccountId: (originationAccountId != null
            ? originationAccountId.value
            : this.originationAccountId),
        guaranteeDecision: (guaranteeDecision != null
            ? guaranteeDecision.value
            : this.guaranteeDecision),
        guaranteeDecisionRationale: (guaranteeDecisionRationale != null
            ? guaranteeDecisionRationale.value
            : this.guaranteeDecisionRationale),
        isoCurrencyCode: (isoCurrencyCode != null
            ? isoCurrencyCode.value
            : this.isoCurrencyCode),
        standardReturnWindow: (standardReturnWindow != null
            ? standardReturnWindow.value
            : this.standardReturnWindow),
        unauthorizedReturnWindow: (unauthorizedReturnWindow != null
            ? unauthorizedReturnWindow.value
            : this.unauthorizedReturnWindow),
        originatorClientId: (originatorClientId != null
            ? originatorClientId.value
            : this.originatorClientId),
        refunds: (refunds != null ? refunds.value : this.refunds));
  }
}

@JsonSerializable(explicitToJson: true)
class RecurringTransfer {
  RecurringTransfer({
    required this.recurringTransferId,
    required this.created,
    required this.nextOriginationDate,
    this.testClockId,
    required this.type,
    required this.amount,
    required this.status,
    this.achClass,
    required this.network,
    required this.originationAccountId,
    required this.accountId,
    required this.isoCurrencyCode,
    this.transferIds,
    this.decision,
    this.decisionRationale,
    required this.user,
    required this.schedule,
  });

  factory RecurringTransfer.fromJson(Map<String, dynamic> json) =>
      _$RecurringTransferFromJson(json);

  @JsonKey(name: 'recurring_transfer_id')
  final String recurringTransferId;
  @JsonKey(name: 'created')
  final DateTime created;
  @JsonKey(name: 'next_origination_date', toJson: _dateToJson)
  final DateTime nextOriginationDate;
  @JsonKey(name: 'test_clock_id')
  final String? testClockId;
  @JsonKey(
    name: 'type',
    toJson: transferTypeToJson,
    fromJson: transferTypeFromJson,
  )
  final enums.TransferType type;
  @JsonKey(name: 'amount')
  final String amount;
  @JsonKey(
    name: 'status',
    toJson: transferRecurringStatusToJson,
    fromJson: transferRecurringStatusFromJson,
  )
  final enums.TransferRecurringStatus? status;
  @JsonKey(
    name: 'ach_class',
    toJson: aCHClassToJson,
    fromJson: aCHClassFromJson,
  )
  final enums.ACHClass? achClass;
  @JsonKey(
    name: 'network',
    toJson: transferNetworkToJson,
    fromJson: transferNetworkFromJson,
  )
  final enums.TransferNetwork network;
  @JsonKey(name: 'origination_account_id')
  final String originationAccountId;
  @JsonKey(name: 'account_id')
  final String accountId;
  @JsonKey(name: 'iso_currency_code')
  final String isoCurrencyCode;
  @JsonKey(name: 'transfer_ids', defaultValue: <String>[])
  final List<String>? transferIds;
  @JsonKey(
    name: 'decision',
    toJson: transferAuthorizationDecisionToJson,
    fromJson: transferAuthorizationDecisionFromJson,
  )
  final enums.TransferAuthorizationDecision? decision;
  @JsonKey(name: 'decision_rationale')
  final TransferAuthorizationDecisionRationale? decisionRationale;
  @JsonKey(name: 'user')
  final TransferUserInResponse user;
  @JsonKey(name: 'schedule')
  final TransferRecurringSchedule schedule;
  static const fromJsonFactory = _$RecurringTransferFromJson;
  static const toJsonFactory = _$RecurringTransferToJson;
  Map<String, dynamic> toJson() => _$RecurringTransferToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is RecurringTransfer &&
            (identical(other.recurringTransferId, recurringTransferId) ||
                const DeepCollectionEquality()
                    .equals(other.recurringTransferId, recurringTransferId)) &&
            (identical(other.created, created) ||
                const DeepCollectionEquality()
                    .equals(other.created, created)) &&
            (identical(other.nextOriginationDate, nextOriginationDate) ||
                const DeepCollectionEquality()
                    .equals(other.nextOriginationDate, nextOriginationDate)) &&
            (identical(other.testClockId, testClockId) ||
                const DeepCollectionEquality()
                    .equals(other.testClockId, testClockId)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.achClass, achClass) ||
                const DeepCollectionEquality()
                    .equals(other.achClass, achClass)) &&
            (identical(other.network, network) ||
                const DeepCollectionEquality()
                    .equals(other.network, network)) &&
            (identical(other.originationAccountId, originationAccountId) ||
                const DeepCollectionEquality().equals(
                    other.originationAccountId, originationAccountId)) &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)) &&
            (identical(other.transferIds, transferIds) ||
                const DeepCollectionEquality()
                    .equals(other.transferIds, transferIds)) &&
            (identical(other.decision, decision) ||
                const DeepCollectionEquality()
                    .equals(other.decision, decision)) &&
            (identical(other.decisionRationale, decisionRationale) ||
                const DeepCollectionEquality()
                    .equals(other.decisionRationale, decisionRationale)) &&
            (identical(other.user, user) ||
                const DeepCollectionEquality().equals(other.user, user)) &&
            (identical(other.schedule, schedule) ||
                const DeepCollectionEquality()
                    .equals(other.schedule, schedule)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(recurringTransferId) ^
      const DeepCollectionEquality().hash(created) ^
      const DeepCollectionEquality().hash(nextOriginationDate) ^
      const DeepCollectionEquality().hash(testClockId) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(achClass) ^
      const DeepCollectionEquality().hash(network) ^
      const DeepCollectionEquality().hash(originationAccountId) ^
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      const DeepCollectionEquality().hash(transferIds) ^
      const DeepCollectionEquality().hash(decision) ^
      const DeepCollectionEquality().hash(decisionRationale) ^
      const DeepCollectionEquality().hash(user) ^
      const DeepCollectionEquality().hash(schedule) ^
      runtimeType.hashCode;
}

extension $RecurringTransferExtension on RecurringTransfer {
  RecurringTransfer copyWith(
      {String? recurringTransferId,
      DateTime? created,
      DateTime? nextOriginationDate,
      String? testClockId,
      enums.TransferType? type,
      String? amount,
      enums.TransferRecurringStatus? status,
      enums.ACHClass? achClass,
      enums.TransferNetwork? network,
      String? originationAccountId,
      String? accountId,
      String? isoCurrencyCode,
      List<String>? transferIds,
      enums.TransferAuthorizationDecision? decision,
      TransferAuthorizationDecisionRationale? decisionRationale,
      TransferUserInResponse? user,
      TransferRecurringSchedule? schedule}) {
    return RecurringTransfer(
        recurringTransferId: recurringTransferId ?? this.recurringTransferId,
        created: created ?? this.created,
        nextOriginationDate: nextOriginationDate ?? this.nextOriginationDate,
        testClockId: testClockId ?? this.testClockId,
        type: type ?? this.type,
        amount: amount ?? this.amount,
        status: status ?? this.status,
        achClass: achClass ?? this.achClass,
        network: network ?? this.network,
        originationAccountId: originationAccountId ?? this.originationAccountId,
        accountId: accountId ?? this.accountId,
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode,
        transferIds: transferIds ?? this.transferIds,
        decision: decision ?? this.decision,
        decisionRationale: decisionRationale ?? this.decisionRationale,
        user: user ?? this.user,
        schedule: schedule ?? this.schedule);
  }

  RecurringTransfer copyWithWrapped(
      {Wrapped<String>? recurringTransferId,
      Wrapped<DateTime>? created,
      Wrapped<DateTime>? nextOriginationDate,
      Wrapped<String?>? testClockId,
      Wrapped<enums.TransferType>? type,
      Wrapped<String>? amount,
      Wrapped<enums.TransferRecurringStatus?>? status,
      Wrapped<enums.ACHClass?>? achClass,
      Wrapped<enums.TransferNetwork>? network,
      Wrapped<String>? originationAccountId,
      Wrapped<String>? accountId,
      Wrapped<String>? isoCurrencyCode,
      Wrapped<List<String>?>? transferIds,
      Wrapped<enums.TransferAuthorizationDecision?>? decision,
      Wrapped<TransferAuthorizationDecisionRationale?>? decisionRationale,
      Wrapped<TransferUserInResponse>? user,
      Wrapped<TransferRecurringSchedule>? schedule}) {
    return RecurringTransfer(
        recurringTransferId: (recurringTransferId != null
            ? recurringTransferId.value
            : this.recurringTransferId),
        created: (created != null ? created.value : this.created),
        nextOriginationDate: (nextOriginationDate != null
            ? nextOriginationDate.value
            : this.nextOriginationDate),
        testClockId:
            (testClockId != null ? testClockId.value : this.testClockId),
        type: (type != null ? type.value : this.type),
        amount: (amount != null ? amount.value : this.amount),
        status: (status != null ? status.value : this.status),
        achClass: (achClass != null ? achClass.value : this.achClass),
        network: (network != null ? network.value : this.network),
        originationAccountId: (originationAccountId != null
            ? originationAccountId.value
            : this.originationAccountId),
        accountId: (accountId != null ? accountId.value : this.accountId),
        isoCurrencyCode: (isoCurrencyCode != null
            ? isoCurrencyCode.value
            : this.isoCurrencyCode),
        transferIds:
            (transferIds != null ? transferIds.value : this.transferIds),
        decision: (decision != null ? decision.value : this.decision),
        decisionRationale: (decisionRationale != null
            ? decisionRationale.value
            : this.decisionRationale),
        user: (user != null ? user.value : this.user),
        schedule: (schedule != null ? schedule.value : this.schedule));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferTestClock {
  TransferTestClock({
    required this.testClockId,
    required this.frozenTimestamp,
  });

  factory TransferTestClock.fromJson(Map<String, dynamic> json) =>
      _$TransferTestClockFromJson(json);

  @JsonKey(name: 'test_clock_id')
  final String? testClockId;
  @JsonKey(name: 'frozen_timestamp')
  final String frozenTimestamp;
  static const fromJsonFactory = _$TransferTestClockFromJson;
  static const toJsonFactory = _$TransferTestClockToJson;
  Map<String, dynamic> toJson() => _$TransferTestClockToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferTestClock &&
            (identical(other.testClockId, testClockId) ||
                const DeepCollectionEquality()
                    .equals(other.testClockId, testClockId)) &&
            (identical(other.frozenTimestamp, frozenTimestamp) ||
                const DeepCollectionEquality()
                    .equals(other.frozenTimestamp, frozenTimestamp)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(testClockId) ^
      const DeepCollectionEquality().hash(frozenTimestamp) ^
      runtimeType.hashCode;
}

extension $TransferTestClockExtension on TransferTestClock {
  TransferTestClock copyWith({String? testClockId, String? frozenTimestamp}) {
    return TransferTestClock(
        testClockId: testClockId ?? this.testClockId,
        frozenTimestamp: frozenTimestamp ?? this.frozenTimestamp);
  }

  TransferTestClock copyWithWrapped(
      {Wrapped<String?>? testClockId, Wrapped<String>? frozenTimestamp}) {
    return TransferTestClock(
        testClockId:
            (testClockId != null ? testClockId.value : this.testClockId),
        frozenTimestamp: (frozenTimestamp != null
            ? frozenTimestamp.value
            : this.frozenTimestamp));
  }
}

@JsonSerializable(explicitToJson: true)
class BankTransfer {
  BankTransfer({
    required this.id,
    required this.achClass,
    required this.accountId,
    required this.type,
    required this.user,
    required this.amount,
    required this.isoCurrencyCode,
    required this.description,
    required this.created,
    required this.status,
    required this.network,
    required this.cancellable,
    required this.failureReason,
    required this.customTag,
    required this.metadata,
    required this.originationAccountId,
    required this.direction,
  });

  factory BankTransfer.fromJson(Map<String, dynamic> json) =>
      _$BankTransferFromJson(json);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(
    name: 'ach_class',
    toJson: aCHClassToJson,
    fromJson: aCHClassFromJson,
  )
  final enums.ACHClass achClass;
  @JsonKey(name: 'account_id')
  final String accountId;
  @JsonKey(
    name: 'type',
    toJson: bankTransferTypeToJson,
    fromJson: bankTransferTypeFromJson,
  )
  final enums.BankTransferType type;
  @JsonKey(name: 'user')
  final BankTransferUser user;
  @JsonKey(name: 'amount')
  final String amount;
  @JsonKey(name: 'iso_currency_code')
  final String isoCurrencyCode;
  @JsonKey(name: 'description')
  final String description;
  @JsonKey(name: 'created')
  final DateTime created;
  @JsonKey(
    name: 'status',
    toJson: bankTransferStatusToJson,
    fromJson: bankTransferStatusFromJson,
  )
  final enums.BankTransferStatus status;
  @JsonKey(
    name: 'network',
    toJson: bankTransferNetworkToJson,
    fromJson: bankTransferNetworkFromJson,
  )
  final enums.BankTransferNetwork network;
  @JsonKey(name: 'cancellable')
  final bool cancellable;
  @JsonKey(name: 'failure_reason')
  final BankTransferFailure? failureReason;
  @JsonKey(name: 'custom_tag')
  final String? customTag;
  @JsonKey(name: 'metadata')
  final BankTransferMetadata? metadata;
  @JsonKey(name: 'origination_account_id')
  final String originationAccountId;
  @JsonKey(
    name: 'direction',
    toJson: bankTransferDirectionToJson,
    fromJson: bankTransferDirectionFromJson,
  )
  final enums.BankTransferDirection? direction;
  static const fromJsonFactory = _$BankTransferFromJson;
  static const toJsonFactory = _$BankTransferToJson;
  Map<String, dynamic> toJson() => _$BankTransferToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BankTransfer &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.achClass, achClass) ||
                const DeepCollectionEquality()
                    .equals(other.achClass, achClass)) &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.user, user) ||
                const DeepCollectionEquality().equals(other.user, user)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.created, created) ||
                const DeepCollectionEquality()
                    .equals(other.created, created)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.network, network) ||
                const DeepCollectionEquality()
                    .equals(other.network, network)) &&
            (identical(other.cancellable, cancellable) ||
                const DeepCollectionEquality()
                    .equals(other.cancellable, cancellable)) &&
            (identical(other.failureReason, failureReason) ||
                const DeepCollectionEquality()
                    .equals(other.failureReason, failureReason)) &&
            (identical(other.customTag, customTag) ||
                const DeepCollectionEquality()
                    .equals(other.customTag, customTag)) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality()
                    .equals(other.metadata, metadata)) &&
            (identical(other.originationAccountId, originationAccountId) ||
                const DeepCollectionEquality().equals(
                    other.originationAccountId, originationAccountId)) &&
            (identical(other.direction, direction) ||
                const DeepCollectionEquality()
                    .equals(other.direction, direction)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(achClass) ^
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(user) ^
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(created) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(network) ^
      const DeepCollectionEquality().hash(cancellable) ^
      const DeepCollectionEquality().hash(failureReason) ^
      const DeepCollectionEquality().hash(customTag) ^
      const DeepCollectionEquality().hash(metadata) ^
      const DeepCollectionEquality().hash(originationAccountId) ^
      const DeepCollectionEquality().hash(direction) ^
      runtimeType.hashCode;
}

extension $BankTransferExtension on BankTransfer {
  BankTransfer copyWith(
      {String? id,
      enums.ACHClass? achClass,
      String? accountId,
      enums.BankTransferType? type,
      BankTransferUser? user,
      String? amount,
      String? isoCurrencyCode,
      String? description,
      DateTime? created,
      enums.BankTransferStatus? status,
      enums.BankTransferNetwork? network,
      bool? cancellable,
      BankTransferFailure? failureReason,
      String? customTag,
      BankTransferMetadata? metadata,
      String? originationAccountId,
      enums.BankTransferDirection? direction}) {
    return BankTransfer(
        id: id ?? this.id,
        achClass: achClass ?? this.achClass,
        accountId: accountId ?? this.accountId,
        type: type ?? this.type,
        user: user ?? this.user,
        amount: amount ?? this.amount,
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode,
        description: description ?? this.description,
        created: created ?? this.created,
        status: status ?? this.status,
        network: network ?? this.network,
        cancellable: cancellable ?? this.cancellable,
        failureReason: failureReason ?? this.failureReason,
        customTag: customTag ?? this.customTag,
        metadata: metadata ?? this.metadata,
        originationAccountId: originationAccountId ?? this.originationAccountId,
        direction: direction ?? this.direction);
  }

  BankTransfer copyWithWrapped(
      {Wrapped<String>? id,
      Wrapped<enums.ACHClass>? achClass,
      Wrapped<String>? accountId,
      Wrapped<enums.BankTransferType>? type,
      Wrapped<BankTransferUser>? user,
      Wrapped<String>? amount,
      Wrapped<String>? isoCurrencyCode,
      Wrapped<String>? description,
      Wrapped<DateTime>? created,
      Wrapped<enums.BankTransferStatus>? status,
      Wrapped<enums.BankTransferNetwork>? network,
      Wrapped<bool>? cancellable,
      Wrapped<BankTransferFailure?>? failureReason,
      Wrapped<String?>? customTag,
      Wrapped<BankTransferMetadata?>? metadata,
      Wrapped<String>? originationAccountId,
      Wrapped<enums.BankTransferDirection?>? direction}) {
    return BankTransfer(
        id: (id != null ? id.value : this.id),
        achClass: (achClass != null ? achClass.value : this.achClass),
        accountId: (accountId != null ? accountId.value : this.accountId),
        type: (type != null ? type.value : this.type),
        user: (user != null ? user.value : this.user),
        amount: (amount != null ? amount.value : this.amount),
        isoCurrencyCode: (isoCurrencyCode != null
            ? isoCurrencyCode.value
            : this.isoCurrencyCode),
        description:
            (description != null ? description.value : this.description),
        created: (created != null ? created.value : this.created),
        status: (status != null ? status.value : this.status),
        network: (network != null ? network.value : this.network),
        cancellable:
            (cancellable != null ? cancellable.value : this.cancellable),
        failureReason:
            (failureReason != null ? failureReason.value : this.failureReason),
        customTag: (customTag != null ? customTag.value : this.customTag),
        metadata: (metadata != null ? metadata.value : this.metadata),
        originationAccountId: (originationAccountId != null
            ? originationAccountId.value
            : this.originationAccountId),
        direction: (direction != null ? direction.value : this.direction));
  }
}

@JsonSerializable(explicitToJson: true)
class DisbursementLimits {
  DisbursementLimits({
    required this.averageAmount,
    required this.maximumAmount,
    required this.monthlyAmount,
  });

  factory DisbursementLimits.fromJson(Map<String, dynamic> json) =>
      _$DisbursementLimitsFromJson(json);

  @JsonKey(name: 'average_amount')
  final int averageAmount;
  @JsonKey(name: 'maximum_amount')
  final int maximumAmount;
  @JsonKey(name: 'monthly_amount')
  final int monthlyAmount;
  static const fromJsonFactory = _$DisbursementLimitsFromJson;
  static const toJsonFactory = _$DisbursementLimitsToJson;
  Map<String, dynamic> toJson() => _$DisbursementLimitsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is DisbursementLimits &&
            (identical(other.averageAmount, averageAmount) ||
                const DeepCollectionEquality()
                    .equals(other.averageAmount, averageAmount)) &&
            (identical(other.maximumAmount, maximumAmount) ||
                const DeepCollectionEquality()
                    .equals(other.maximumAmount, maximumAmount)) &&
            (identical(other.monthlyAmount, monthlyAmount) ||
                const DeepCollectionEquality()
                    .equals(other.monthlyAmount, monthlyAmount)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(averageAmount) ^
      const DeepCollectionEquality().hash(maximumAmount) ^
      const DeepCollectionEquality().hash(monthlyAmount) ^
      runtimeType.hashCode;
}

extension $DisbursementLimitsExtension on DisbursementLimits {
  DisbursementLimits copyWith(
      {int? averageAmount, int? maximumAmount, int? monthlyAmount}) {
    return DisbursementLimits(
        averageAmount: averageAmount ?? this.averageAmount,
        maximumAmount: maximumAmount ?? this.maximumAmount,
        monthlyAmount: monthlyAmount ?? this.monthlyAmount);
  }

  DisbursementLimits copyWithWrapped(
      {Wrapped<int>? averageAmount,
      Wrapped<int>? maximumAmount,
      Wrapped<int>? monthlyAmount}) {
    return DisbursementLimits(
        averageAmount:
            (averageAmount != null ? averageAmount.value : this.averageAmount),
        maximumAmount:
            (maximumAmount != null ? maximumAmount.value : this.maximumAmount),
        monthlyAmount:
            (monthlyAmount != null ? monthlyAmount.value : this.monthlyAmount));
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentLimits {
  PaymentLimits({
    required this.averageAmount,
    required this.maximumAmount,
    required this.monthlyAmount,
  });

  factory PaymentLimits.fromJson(Map<String, dynamic> json) =>
      _$PaymentLimitsFromJson(json);

  @JsonKey(name: 'average_amount')
  final int averageAmount;
  @JsonKey(name: 'maximum_amount')
  final int maximumAmount;
  @JsonKey(name: 'monthly_amount')
  final int monthlyAmount;
  static const fromJsonFactory = _$PaymentLimitsFromJson;
  static const toJsonFactory = _$PaymentLimitsToJson;
  Map<String, dynamic> toJson() => _$PaymentLimitsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentLimits &&
            (identical(other.averageAmount, averageAmount) ||
                const DeepCollectionEquality()
                    .equals(other.averageAmount, averageAmount)) &&
            (identical(other.maximumAmount, maximumAmount) ||
                const DeepCollectionEquality()
                    .equals(other.maximumAmount, maximumAmount)) &&
            (identical(other.monthlyAmount, monthlyAmount) ||
                const DeepCollectionEquality()
                    .equals(other.monthlyAmount, monthlyAmount)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(averageAmount) ^
      const DeepCollectionEquality().hash(maximumAmount) ^
      const DeepCollectionEquality().hash(monthlyAmount) ^
      runtimeType.hashCode;
}

extension $PaymentLimitsExtension on PaymentLimits {
  PaymentLimits copyWith(
      {int? averageAmount, int? maximumAmount, int? monthlyAmount}) {
    return PaymentLimits(
        averageAmount: averageAmount ?? this.averageAmount,
        maximumAmount: maximumAmount ?? this.maximumAmount,
        monthlyAmount: monthlyAmount ?? this.monthlyAmount);
  }

  PaymentLimits copyWithWrapped(
      {Wrapped<int>? averageAmount,
      Wrapped<int>? maximumAmount,
      Wrapped<int>? monthlyAmount}) {
    return PaymentLimits(
        averageAmount:
            (averageAmount != null ? averageAmount.value : this.averageAmount),
        maximumAmount:
            (maximumAmount != null ? maximumAmount.value : this.maximumAmount),
        monthlyAmount:
            (monthlyAmount != null ? monthlyAmount.value : this.monthlyAmount));
  }
}

@JsonSerializable(explicitToJson: true)
class Originator {
  Originator({
    required this.clientId,
    required this.transferDiligenceStatus,
  });

  factory Originator.fromJson(Map<String, dynamic> json) =>
      _$OriginatorFromJson(json);

  @JsonKey(name: 'client_id')
  final String clientId;
  @JsonKey(
    name: 'transfer_diligence_status',
    toJson: transferDiligenceStatusToJson,
    fromJson: transferDiligenceStatusFromJson,
  )
  final enums.TransferDiligenceStatus transferDiligenceStatus;
  static const fromJsonFactory = _$OriginatorFromJson;
  static const toJsonFactory = _$OriginatorToJson;
  Map<String, dynamic> toJson() => _$OriginatorToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Originator &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(
                    other.transferDiligenceStatus, transferDiligenceStatus) ||
                const DeepCollectionEquality().equals(
                    other.transferDiligenceStatus, transferDiligenceStatus)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(transferDiligenceStatus) ^
      runtimeType.hashCode;
}

extension $OriginatorExtension on Originator {
  Originator copyWith(
      {String? clientId,
      enums.TransferDiligenceStatus? transferDiligenceStatus}) {
    return Originator(
        clientId: clientId ?? this.clientId,
        transferDiligenceStatus:
            transferDiligenceStatus ?? this.transferDiligenceStatus);
  }

  Originator copyWithWrapped(
      {Wrapped<String>? clientId,
      Wrapped<enums.TransferDiligenceStatus>? transferDiligenceStatus}) {
    return Originator(
        clientId: (clientId != null ? clientId.value : this.clientId),
        transferDiligenceStatus: (transferDiligenceStatus != null
            ? transferDiligenceStatus.value
            : this.transferDiligenceStatus));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferIntentGetFailureReason {
  TransferIntentGetFailureReason({
    this.errorType,
    this.errorCode,
    this.errorMessage,
  });

  factory TransferIntentGetFailureReason.fromJson(Map<String, dynamic> json) =>
      _$TransferIntentGetFailureReasonFromJson(json);

  @JsonKey(name: 'error_type')
  final String? errorType;
  @JsonKey(name: 'error_code')
  final String? errorCode;
  @JsonKey(name: 'error_message')
  final String? errorMessage;
  static const fromJsonFactory = _$TransferIntentGetFailureReasonFromJson;
  static const toJsonFactory = _$TransferIntentGetFailureReasonToJson;
  Map<String, dynamic> toJson() => _$TransferIntentGetFailureReasonToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferIntentGetFailureReason &&
            (identical(other.errorType, errorType) ||
                const DeepCollectionEquality()
                    .equals(other.errorType, errorType)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.errorMessage, errorMessage) ||
                const DeepCollectionEquality()
                    .equals(other.errorMessage, errorMessage)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(errorType) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(errorMessage) ^
      runtimeType.hashCode;
}

extension $TransferIntentGetFailureReasonExtension
    on TransferIntentGetFailureReason {
  TransferIntentGetFailureReason copyWith(
      {String? errorType, String? errorCode, String? errorMessage}) {
    return TransferIntentGetFailureReason(
        errorType: errorType ?? this.errorType,
        errorCode: errorCode ?? this.errorCode,
        errorMessage: errorMessage ?? this.errorMessage);
  }

  TransferIntentGetFailureReason copyWithWrapped(
      {Wrapped<String?>? errorType,
      Wrapped<String?>? errorCode,
      Wrapped<String?>? errorMessage}) {
    return TransferIntentGetFailureReason(
        errorType: (errorType != null ? errorType.value : this.errorType),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        errorMessage:
            (errorMessage != null ? errorMessage.value : this.errorMessage));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferAuthorizationUserInRequest {
  TransferAuthorizationUserInRequest({
    required this.legalName,
    this.phoneNumber,
    this.emailAddress,
    this.address,
  });

  factory TransferAuthorizationUserInRequest.fromJson(
          Map<String, dynamic> json) =>
      _$TransferAuthorizationUserInRequestFromJson(json);

  @JsonKey(name: 'legal_name')
  final String legalName;
  @JsonKey(name: 'phone_number')
  final String? phoneNumber;
  @JsonKey(name: 'email_address')
  final String? emailAddress;
  @JsonKey(name: 'address')
  final TransferUserAddressInRequest? address;
  static const fromJsonFactory = _$TransferAuthorizationUserInRequestFromJson;
  static const toJsonFactory = _$TransferAuthorizationUserInRequestToJson;
  Map<String, dynamic> toJson() =>
      _$TransferAuthorizationUserInRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferAuthorizationUserInRequest &&
            (identical(other.legalName, legalName) ||
                const DeepCollectionEquality()
                    .equals(other.legalName, legalName)) &&
            (identical(other.phoneNumber, phoneNumber) ||
                const DeepCollectionEquality()
                    .equals(other.phoneNumber, phoneNumber)) &&
            (identical(other.emailAddress, emailAddress) ||
                const DeepCollectionEquality()
                    .equals(other.emailAddress, emailAddress)) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality().equals(other.address, address)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(legalName) ^
      const DeepCollectionEquality().hash(phoneNumber) ^
      const DeepCollectionEquality().hash(emailAddress) ^
      const DeepCollectionEquality().hash(address) ^
      runtimeType.hashCode;
}

extension $TransferAuthorizationUserInRequestExtension
    on TransferAuthorizationUserInRequest {
  TransferAuthorizationUserInRequest copyWith(
      {String? legalName,
      String? phoneNumber,
      String? emailAddress,
      TransferUserAddressInRequest? address}) {
    return TransferAuthorizationUserInRequest(
        legalName: legalName ?? this.legalName,
        phoneNumber: phoneNumber ?? this.phoneNumber,
        emailAddress: emailAddress ?? this.emailAddress,
        address: address ?? this.address);
  }

  TransferAuthorizationUserInRequest copyWithWrapped(
      {Wrapped<String>? legalName,
      Wrapped<String?>? phoneNumber,
      Wrapped<String?>? emailAddress,
      Wrapped<TransferUserAddressInRequest?>? address}) {
    return TransferAuthorizationUserInRequest(
        legalName: (legalName != null ? legalName.value : this.legalName),
        phoneNumber:
            (phoneNumber != null ? phoneNumber.value : this.phoneNumber),
        emailAddress:
            (emailAddress != null ? emailAddress.value : this.emailAddress),
        address: (address != null ? address.value : this.address));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferUserInRequest {
  TransferUserInRequest({
    required this.legalName,
    this.phoneNumber,
    this.emailAddress,
    this.address,
  });

  factory TransferUserInRequest.fromJson(Map<String, dynamic> json) =>
      _$TransferUserInRequestFromJson(json);

  @JsonKey(name: 'legal_name')
  final String legalName;
  @JsonKey(name: 'phone_number')
  final String? phoneNumber;
  @JsonKey(name: 'email_address')
  final String? emailAddress;
  @JsonKey(name: 'address')
  final TransferUserAddressInRequest? address;
  static const fromJsonFactory = _$TransferUserInRequestFromJson;
  static const toJsonFactory = _$TransferUserInRequestToJson;
  Map<String, dynamic> toJson() => _$TransferUserInRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferUserInRequest &&
            (identical(other.legalName, legalName) ||
                const DeepCollectionEquality()
                    .equals(other.legalName, legalName)) &&
            (identical(other.phoneNumber, phoneNumber) ||
                const DeepCollectionEquality()
                    .equals(other.phoneNumber, phoneNumber)) &&
            (identical(other.emailAddress, emailAddress) ||
                const DeepCollectionEquality()
                    .equals(other.emailAddress, emailAddress)) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality().equals(other.address, address)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(legalName) ^
      const DeepCollectionEquality().hash(phoneNumber) ^
      const DeepCollectionEquality().hash(emailAddress) ^
      const DeepCollectionEquality().hash(address) ^
      runtimeType.hashCode;
}

extension $TransferUserInRequestExtension on TransferUserInRequest {
  TransferUserInRequest copyWith(
      {String? legalName,
      String? phoneNumber,
      String? emailAddress,
      TransferUserAddressInRequest? address}) {
    return TransferUserInRequest(
        legalName: legalName ?? this.legalName,
        phoneNumber: phoneNumber ?? this.phoneNumber,
        emailAddress: emailAddress ?? this.emailAddress,
        address: address ?? this.address);
  }

  TransferUserInRequest copyWithWrapped(
      {Wrapped<String>? legalName,
      Wrapped<String?>? phoneNumber,
      Wrapped<String?>? emailAddress,
      Wrapped<TransferUserAddressInRequest?>? address}) {
    return TransferUserInRequest(
        legalName: (legalName != null ? legalName.value : this.legalName),
        phoneNumber:
            (phoneNumber != null ? phoneNumber.value : this.phoneNumber),
        emailAddress:
            (emailAddress != null ? emailAddress.value : this.emailAddress),
        address: (address != null ? address.value : this.address));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferUserInRequestDeprecated {
  TransferUserInRequestDeprecated({
    this.legalName,
    this.phoneNumber,
    this.emailAddress,
    this.address,
  });

  factory TransferUserInRequestDeprecated.fromJson(Map<String, dynamic> json) =>
      _$TransferUserInRequestDeprecatedFromJson(json);

  @JsonKey(name: 'legal_name')
  final String? legalName;
  @JsonKey(name: 'phone_number')
  final String? phoneNumber;
  @JsonKey(name: 'email_address')
  final String? emailAddress;
  @JsonKey(name: 'address')
  final TransferUserAddressInRequest? address;
  static const fromJsonFactory = _$TransferUserInRequestDeprecatedFromJson;
  static const toJsonFactory = _$TransferUserInRequestDeprecatedToJson;
  Map<String, dynamic> toJson() =>
      _$TransferUserInRequestDeprecatedToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferUserInRequestDeprecated &&
            (identical(other.legalName, legalName) ||
                const DeepCollectionEquality()
                    .equals(other.legalName, legalName)) &&
            (identical(other.phoneNumber, phoneNumber) ||
                const DeepCollectionEquality()
                    .equals(other.phoneNumber, phoneNumber)) &&
            (identical(other.emailAddress, emailAddress) ||
                const DeepCollectionEquality()
                    .equals(other.emailAddress, emailAddress)) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality().equals(other.address, address)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(legalName) ^
      const DeepCollectionEquality().hash(phoneNumber) ^
      const DeepCollectionEquality().hash(emailAddress) ^
      const DeepCollectionEquality().hash(address) ^
      runtimeType.hashCode;
}

extension $TransferUserInRequestDeprecatedExtension
    on TransferUserInRequestDeprecated {
  TransferUserInRequestDeprecated copyWith(
      {String? legalName,
      String? phoneNumber,
      String? emailAddress,
      TransferUserAddressInRequest? address}) {
    return TransferUserInRequestDeprecated(
        legalName: legalName ?? this.legalName,
        phoneNumber: phoneNumber ?? this.phoneNumber,
        emailAddress: emailAddress ?? this.emailAddress,
        address: address ?? this.address);
  }

  TransferUserInRequestDeprecated copyWithWrapped(
      {Wrapped<String?>? legalName,
      Wrapped<String?>? phoneNumber,
      Wrapped<String?>? emailAddress,
      Wrapped<TransferUserAddressInRequest?>? address}) {
    return TransferUserInRequestDeprecated(
        legalName: (legalName != null ? legalName.value : this.legalName),
        phoneNumber:
            (phoneNumber != null ? phoneNumber.value : this.phoneNumber),
        emailAddress:
            (emailAddress != null ? emailAddress.value : this.emailAddress),
        address: (address != null ? address.value : this.address));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferUserInResponse {
  TransferUserInResponse({
    required this.legalName,
    required this.phoneNumber,
    required this.emailAddress,
    required this.address,
  });

  factory TransferUserInResponse.fromJson(Map<String, dynamic> json) =>
      _$TransferUserInResponseFromJson(json);

  @JsonKey(name: 'legal_name')
  final String legalName;
  @JsonKey(name: 'phone_number')
  final String? phoneNumber;
  @JsonKey(name: 'email_address')
  final String? emailAddress;
  @JsonKey(name: 'address')
  final TransferUserAddressInResponse? address;
  static const fromJsonFactory = _$TransferUserInResponseFromJson;
  static const toJsonFactory = _$TransferUserInResponseToJson;
  Map<String, dynamic> toJson() => _$TransferUserInResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferUserInResponse &&
            (identical(other.legalName, legalName) ||
                const DeepCollectionEquality()
                    .equals(other.legalName, legalName)) &&
            (identical(other.phoneNumber, phoneNumber) ||
                const DeepCollectionEquality()
                    .equals(other.phoneNumber, phoneNumber)) &&
            (identical(other.emailAddress, emailAddress) ||
                const DeepCollectionEquality()
                    .equals(other.emailAddress, emailAddress)) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality().equals(other.address, address)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(legalName) ^
      const DeepCollectionEquality().hash(phoneNumber) ^
      const DeepCollectionEquality().hash(emailAddress) ^
      const DeepCollectionEquality().hash(address) ^
      runtimeType.hashCode;
}

extension $TransferUserInResponseExtension on TransferUserInResponse {
  TransferUserInResponse copyWith(
      {String? legalName,
      String? phoneNumber,
      String? emailAddress,
      TransferUserAddressInResponse? address}) {
    return TransferUserInResponse(
        legalName: legalName ?? this.legalName,
        phoneNumber: phoneNumber ?? this.phoneNumber,
        emailAddress: emailAddress ?? this.emailAddress,
        address: address ?? this.address);
  }

  TransferUserInResponse copyWithWrapped(
      {Wrapped<String>? legalName,
      Wrapped<String?>? phoneNumber,
      Wrapped<String?>? emailAddress,
      Wrapped<TransferUserAddressInResponse?>? address}) {
    return TransferUserInResponse(
        legalName: (legalName != null ? legalName.value : this.legalName),
        phoneNumber:
            (phoneNumber != null ? phoneNumber.value : this.phoneNumber),
        emailAddress:
            (emailAddress != null ? emailAddress.value : this.emailAddress),
        address: (address != null ? address.value : this.address));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferUserAddressInRequest {
  TransferUserAddressInRequest({
    this.street,
    this.city,
    this.region,
    this.postalCode,
    this.country,
  });

  factory TransferUserAddressInRequest.fromJson(Map<String, dynamic> json) =>
      _$TransferUserAddressInRequestFromJson(json);

  @JsonKey(name: 'street')
  final String? street;
  @JsonKey(name: 'city')
  final String? city;
  @JsonKey(name: 'region')
  final String? region;
  @JsonKey(name: 'postal_code')
  final String? postalCode;
  @JsonKey(name: 'country')
  final String? country;
  static const fromJsonFactory = _$TransferUserAddressInRequestFromJson;
  static const toJsonFactory = _$TransferUserAddressInRequestToJson;
  Map<String, dynamic> toJson() => _$TransferUserAddressInRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferUserAddressInRequest &&
            (identical(other.street, street) ||
                const DeepCollectionEquality().equals(other.street, street)) &&
            (identical(other.city, city) ||
                const DeepCollectionEquality().equals(other.city, city)) &&
            (identical(other.region, region) ||
                const DeepCollectionEquality().equals(other.region, region)) &&
            (identical(other.postalCode, postalCode) ||
                const DeepCollectionEquality()
                    .equals(other.postalCode, postalCode)) &&
            (identical(other.country, country) ||
                const DeepCollectionEquality().equals(other.country, country)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(street) ^
      const DeepCollectionEquality().hash(city) ^
      const DeepCollectionEquality().hash(region) ^
      const DeepCollectionEquality().hash(postalCode) ^
      const DeepCollectionEquality().hash(country) ^
      runtimeType.hashCode;
}

extension $TransferUserAddressInRequestExtension
    on TransferUserAddressInRequest {
  TransferUserAddressInRequest copyWith(
      {String? street,
      String? city,
      String? region,
      String? postalCode,
      String? country}) {
    return TransferUserAddressInRequest(
        street: street ?? this.street,
        city: city ?? this.city,
        region: region ?? this.region,
        postalCode: postalCode ?? this.postalCode,
        country: country ?? this.country);
  }

  TransferUserAddressInRequest copyWithWrapped(
      {Wrapped<String?>? street,
      Wrapped<String?>? city,
      Wrapped<String?>? region,
      Wrapped<String?>? postalCode,
      Wrapped<String?>? country}) {
    return TransferUserAddressInRequest(
        street: (street != null ? street.value : this.street),
        city: (city != null ? city.value : this.city),
        region: (region != null ? region.value : this.region),
        postalCode: (postalCode != null ? postalCode.value : this.postalCode),
        country: (country != null ? country.value : this.country));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferUserAddressInResponse {
  TransferUserAddressInResponse({
    required this.street,
    required this.city,
    required this.region,
    required this.postalCode,
    required this.country,
  });

  factory TransferUserAddressInResponse.fromJson(Map<String, dynamic> json) =>
      _$TransferUserAddressInResponseFromJson(json);

  @JsonKey(name: 'street')
  final String? street;
  @JsonKey(name: 'city')
  final String? city;
  @JsonKey(name: 'region')
  final String? region;
  @JsonKey(name: 'postal_code')
  final String? postalCode;
  @JsonKey(name: 'country')
  final String? country;
  static const fromJsonFactory = _$TransferUserAddressInResponseFromJson;
  static const toJsonFactory = _$TransferUserAddressInResponseToJson;
  Map<String, dynamic> toJson() => _$TransferUserAddressInResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferUserAddressInResponse &&
            (identical(other.street, street) ||
                const DeepCollectionEquality().equals(other.street, street)) &&
            (identical(other.city, city) ||
                const DeepCollectionEquality().equals(other.city, city)) &&
            (identical(other.region, region) ||
                const DeepCollectionEquality().equals(other.region, region)) &&
            (identical(other.postalCode, postalCode) ||
                const DeepCollectionEquality()
                    .equals(other.postalCode, postalCode)) &&
            (identical(other.country, country) ||
                const DeepCollectionEquality().equals(other.country, country)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(street) ^
      const DeepCollectionEquality().hash(city) ^
      const DeepCollectionEquality().hash(region) ^
      const DeepCollectionEquality().hash(postalCode) ^
      const DeepCollectionEquality().hash(country) ^
      runtimeType.hashCode;
}

extension $TransferUserAddressInResponseExtension
    on TransferUserAddressInResponse {
  TransferUserAddressInResponse copyWith(
      {String? street,
      String? city,
      String? region,
      String? postalCode,
      String? country}) {
    return TransferUserAddressInResponse(
        street: street ?? this.street,
        city: city ?? this.city,
        region: region ?? this.region,
        postalCode: postalCode ?? this.postalCode,
        country: country ?? this.country);
  }

  TransferUserAddressInResponse copyWithWrapped(
      {Wrapped<String?>? street,
      Wrapped<String?>? city,
      Wrapped<String?>? region,
      Wrapped<String?>? postalCode,
      Wrapped<String?>? country}) {
    return TransferUserAddressInResponse(
        street: (street != null ? street.value : this.street),
        city: (city != null ? city.value : this.city),
        region: (region != null ? region.value : this.region),
        postalCode: (postalCode != null ? postalCode.value : this.postalCode),
        country: (country != null ? country.value : this.country));
  }
}

@JsonSerializable(explicitToJson: true)
class BankTransferUser {
  BankTransferUser({
    required this.legalName,
    this.emailAddress,
    this.routingNumber,
  });

  factory BankTransferUser.fromJson(Map<String, dynamic> json) =>
      _$BankTransferUserFromJson(json);

  @JsonKey(name: 'legal_name')
  final String legalName;
  @JsonKey(name: 'email_address')
  final String? emailAddress;
  @JsonKey(name: 'routing_number')
  final String? routingNumber;
  static const fromJsonFactory = _$BankTransferUserFromJson;
  static const toJsonFactory = _$BankTransferUserToJson;
  Map<String, dynamic> toJson() => _$BankTransferUserToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BankTransferUser &&
            (identical(other.legalName, legalName) ||
                const DeepCollectionEquality()
                    .equals(other.legalName, legalName)) &&
            (identical(other.emailAddress, emailAddress) ||
                const DeepCollectionEquality()
                    .equals(other.emailAddress, emailAddress)) &&
            (identical(other.routingNumber, routingNumber) ||
                const DeepCollectionEquality()
                    .equals(other.routingNumber, routingNumber)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(legalName) ^
      const DeepCollectionEquality().hash(emailAddress) ^
      const DeepCollectionEquality().hash(routingNumber) ^
      runtimeType.hashCode;
}

extension $BankTransferUserExtension on BankTransferUser {
  BankTransferUser copyWith(
      {String? legalName, String? emailAddress, String? routingNumber}) {
    return BankTransferUser(
        legalName: legalName ?? this.legalName,
        emailAddress: emailAddress ?? this.emailAddress,
        routingNumber: routingNumber ?? this.routingNumber);
  }

  BankTransferUser copyWithWrapped(
      {Wrapped<String>? legalName,
      Wrapped<String?>? emailAddress,
      Wrapped<String?>? routingNumber}) {
    return BankTransferUser(
        legalName: (legalName != null ? legalName.value : this.legalName),
        emailAddress:
            (emailAddress != null ? emailAddress.value : this.emailAddress),
        routingNumber:
            (routingNumber != null ? routingNumber.value : this.routingNumber));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferAuthorizationDecisionRationale {
  TransferAuthorizationDecisionRationale({
    required this.code,
    required this.description,
  });

  factory TransferAuthorizationDecisionRationale.fromJson(
          Map<String, dynamic> json) =>
      _$TransferAuthorizationDecisionRationaleFromJson(json);

  @JsonKey(
    name: 'code',
    toJson: transferAuthorizationDecisionRationaleCodeToJson,
    fromJson: transferAuthorizationDecisionRationaleCodeFromJson,
  )
  final enums.TransferAuthorizationDecisionRationaleCode code;
  @JsonKey(name: 'description')
  final String description;
  static const fromJsonFactory =
      _$TransferAuthorizationDecisionRationaleFromJson;
  static const toJsonFactory = _$TransferAuthorizationDecisionRationaleToJson;
  Map<String, dynamic> toJson() =>
      _$TransferAuthorizationDecisionRationaleToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferAuthorizationDecisionRationale &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(description) ^
      runtimeType.hashCode;
}

extension $TransferAuthorizationDecisionRationaleExtension
    on TransferAuthorizationDecisionRationale {
  TransferAuthorizationDecisionRationale copyWith(
      {enums.TransferAuthorizationDecisionRationaleCode? code,
      String? description}) {
    return TransferAuthorizationDecisionRationale(
        code: code ?? this.code, description: description ?? this.description);
  }

  TransferAuthorizationDecisionRationale copyWithWrapped(
      {Wrapped<enums.TransferAuthorizationDecisionRationaleCode>? code,
      Wrapped<String>? description}) {
    return TransferAuthorizationDecisionRationale(
        code: (code != null ? code.value : this.code),
        description:
            (description != null ? description.value : this.description));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferAuthorizationGuaranteeDecisionRationale {
  TransferAuthorizationGuaranteeDecisionRationale({
    required this.code,
    required this.description,
  });

  factory TransferAuthorizationGuaranteeDecisionRationale.fromJson(
          Map<String, dynamic> json) =>
      _$TransferAuthorizationGuaranteeDecisionRationaleFromJson(json);

  @JsonKey(
    name: 'code',
    toJson: transferAuthorizationGuaranteeDecisionRationaleCodeToJson,
    fromJson: transferAuthorizationGuaranteeDecisionRationaleCodeFromJson,
  )
  final enums.TransferAuthorizationGuaranteeDecisionRationaleCode code;
  @JsonKey(name: 'description')
  final String description;
  static const fromJsonFactory =
      _$TransferAuthorizationGuaranteeDecisionRationaleFromJson;
  static const toJsonFactory =
      _$TransferAuthorizationGuaranteeDecisionRationaleToJson;
  Map<String, dynamic> toJson() =>
      _$TransferAuthorizationGuaranteeDecisionRationaleToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferAuthorizationGuaranteeDecisionRationale &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(description) ^
      runtimeType.hashCode;
}

extension $TransferAuthorizationGuaranteeDecisionRationaleExtension
    on TransferAuthorizationGuaranteeDecisionRationale {
  TransferAuthorizationGuaranteeDecisionRationale copyWith(
      {enums.TransferAuthorizationGuaranteeDecisionRationaleCode? code,
      String? description}) {
    return TransferAuthorizationGuaranteeDecisionRationale(
        code: code ?? this.code, description: description ?? this.description);
  }

  TransferAuthorizationGuaranteeDecisionRationale copyWithWrapped(
      {Wrapped<enums.TransferAuthorizationGuaranteeDecisionRationaleCode>? code,
      Wrapped<String>? description}) {
    return TransferAuthorizationGuaranteeDecisionRationale(
        code: (code != null ? code.value : this.code),
        description:
            (description != null ? description.value : this.description));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferAuthorizationProposedTransfer {
  TransferAuthorizationProposedTransfer({
    this.achClass,
    this.accountId,
    required this.type,
    required this.user,
    required this.amount,
    required this.network,
    required this.originationAccountId,
    required this.isoCurrencyCode,
    required this.originatorClientId,
  });

  factory TransferAuthorizationProposedTransfer.fromJson(
          Map<String, dynamic> json) =>
      _$TransferAuthorizationProposedTransferFromJson(json);

  @JsonKey(
    name: 'ach_class',
    toJson: aCHClassToJson,
    fromJson: aCHClassFromJson,
  )
  final enums.ACHClass? achClass;
  @JsonKey(name: 'account_id')
  final String? accountId;
  @JsonKey(
    name: 'type',
    toJson: transferTypeToJson,
    fromJson: transferTypeFromJson,
  )
  final enums.TransferType type;
  @JsonKey(name: 'user')
  final TransferUserInResponse user;
  @JsonKey(name: 'amount')
  final String amount;
  @JsonKey(name: 'network')
  final String network;
  @JsonKey(name: 'origination_account_id')
  final String originationAccountId;
  @JsonKey(name: 'iso_currency_code')
  final String isoCurrencyCode;
  @JsonKey(name: 'originator_client_id')
  final String? originatorClientId;
  static const fromJsonFactory =
      _$TransferAuthorizationProposedTransferFromJson;
  static const toJsonFactory = _$TransferAuthorizationProposedTransferToJson;
  Map<String, dynamic> toJson() =>
      _$TransferAuthorizationProposedTransferToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferAuthorizationProposedTransfer &&
            (identical(other.achClass, achClass) ||
                const DeepCollectionEquality()
                    .equals(other.achClass, achClass)) &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.user, user) ||
                const DeepCollectionEquality().equals(other.user, user)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.network, network) ||
                const DeepCollectionEquality()
                    .equals(other.network, network)) &&
            (identical(other.originationAccountId, originationAccountId) ||
                const DeepCollectionEquality().equals(
                    other.originationAccountId, originationAccountId)) &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)) &&
            (identical(other.originatorClientId, originatorClientId) ||
                const DeepCollectionEquality()
                    .equals(other.originatorClientId, originatorClientId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(achClass) ^
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(user) ^
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(network) ^
      const DeepCollectionEquality().hash(originationAccountId) ^
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      const DeepCollectionEquality().hash(originatorClientId) ^
      runtimeType.hashCode;
}

extension $TransferAuthorizationProposedTransferExtension
    on TransferAuthorizationProposedTransfer {
  TransferAuthorizationProposedTransfer copyWith(
      {enums.ACHClass? achClass,
      String? accountId,
      enums.TransferType? type,
      TransferUserInResponse? user,
      String? amount,
      String? network,
      String? originationAccountId,
      String? isoCurrencyCode,
      String? originatorClientId}) {
    return TransferAuthorizationProposedTransfer(
        achClass: achClass ?? this.achClass,
        accountId: accountId ?? this.accountId,
        type: type ?? this.type,
        user: user ?? this.user,
        amount: amount ?? this.amount,
        network: network ?? this.network,
        originationAccountId: originationAccountId ?? this.originationAccountId,
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode,
        originatorClientId: originatorClientId ?? this.originatorClientId);
  }

  TransferAuthorizationProposedTransfer copyWithWrapped(
      {Wrapped<enums.ACHClass?>? achClass,
      Wrapped<String?>? accountId,
      Wrapped<enums.TransferType>? type,
      Wrapped<TransferUserInResponse>? user,
      Wrapped<String>? amount,
      Wrapped<String>? network,
      Wrapped<String>? originationAccountId,
      Wrapped<String>? isoCurrencyCode,
      Wrapped<String?>? originatorClientId}) {
    return TransferAuthorizationProposedTransfer(
        achClass: (achClass != null ? achClass.value : this.achClass),
        accountId: (accountId != null ? accountId.value : this.accountId),
        type: (type != null ? type.value : this.type),
        user: (user != null ? user.value : this.user),
        amount: (amount != null ? amount.value : this.amount),
        network: (network != null ? network.value : this.network),
        originationAccountId: (originationAccountId != null
            ? originationAccountId.value
            : this.originationAccountId),
        isoCurrencyCode: (isoCurrencyCode != null
            ? isoCurrencyCode.value
            : this.isoCurrencyCode),
        originatorClientId: (originatorClientId != null
            ? originatorClientId.value
            : this.originatorClientId));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferAuthorizationDevice {
  TransferAuthorizationDevice({
    this.ipAddress,
    this.userAgent,
  });

  factory TransferAuthorizationDevice.fromJson(Map<String, dynamic> json) =>
      _$TransferAuthorizationDeviceFromJson(json);

  @JsonKey(name: 'ip_address')
  final String? ipAddress;
  @JsonKey(name: 'user_agent')
  final String? userAgent;
  static const fromJsonFactory = _$TransferAuthorizationDeviceFromJson;
  static const toJsonFactory = _$TransferAuthorizationDeviceToJson;
  Map<String, dynamic> toJson() => _$TransferAuthorizationDeviceToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferAuthorizationDevice &&
            (identical(other.ipAddress, ipAddress) ||
                const DeepCollectionEquality()
                    .equals(other.ipAddress, ipAddress)) &&
            (identical(other.userAgent, userAgent) ||
                const DeepCollectionEquality()
                    .equals(other.userAgent, userAgent)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ipAddress) ^
      const DeepCollectionEquality().hash(userAgent) ^
      runtimeType.hashCode;
}

extension $TransferAuthorizationDeviceExtension on TransferAuthorizationDevice {
  TransferAuthorizationDevice copyWith({String? ipAddress, String? userAgent}) {
    return TransferAuthorizationDevice(
        ipAddress: ipAddress ?? this.ipAddress,
        userAgent: userAgent ?? this.userAgent);
  }

  TransferAuthorizationDevice copyWithWrapped(
      {Wrapped<String?>? ipAddress, Wrapped<String?>? userAgent}) {
    return TransferAuthorizationDevice(
        ipAddress: (ipAddress != null ? ipAddress.value : this.ipAddress),
        userAgent: (userAgent != null ? userAgent.value : this.userAgent));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferDevice {
  TransferDevice({
    required this.ipAddress,
    required this.userAgent,
  });

  factory TransferDevice.fromJson(Map<String, dynamic> json) =>
      _$TransferDeviceFromJson(json);

  @JsonKey(name: 'ip_address')
  final String ipAddress;
  @JsonKey(name: 'user_agent')
  final String userAgent;
  static const fromJsonFactory = _$TransferDeviceFromJson;
  static const toJsonFactory = _$TransferDeviceToJson;
  Map<String, dynamic> toJson() => _$TransferDeviceToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferDevice &&
            (identical(other.ipAddress, ipAddress) ||
                const DeepCollectionEquality()
                    .equals(other.ipAddress, ipAddress)) &&
            (identical(other.userAgent, userAgent) ||
                const DeepCollectionEquality()
                    .equals(other.userAgent, userAgent)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ipAddress) ^
      const DeepCollectionEquality().hash(userAgent) ^
      runtimeType.hashCode;
}

extension $TransferDeviceExtension on TransferDevice {
  TransferDevice copyWith({String? ipAddress, String? userAgent}) {
    return TransferDevice(
        ipAddress: ipAddress ?? this.ipAddress,
        userAgent: userAgent ?? this.userAgent);
  }

  TransferDevice copyWithWrapped(
      {Wrapped<String>? ipAddress, Wrapped<String>? userAgent}) {
    return TransferDevice(
        ipAddress: (ipAddress != null ? ipAddress.value : this.ipAddress),
        userAgent: (userAgent != null ? userAgent.value : this.userAgent));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferRecurringSchedule {
  TransferRecurringSchedule({
    this.intervalUnit,
    this.intervalCount,
    this.intervalExecutionDay,
    this.startDate,
    this.endDate,
  });

  factory TransferRecurringSchedule.fromJson(Map<String, dynamic> json) =>
      _$TransferRecurringScheduleFromJson(json);

  @JsonKey(
    name: 'interval_unit',
    toJson: transferScheduleIntervalUnitToJson,
    fromJson: transferScheduleIntervalUnitFromJson,
  )
  final enums.TransferScheduleIntervalUnit? intervalUnit;
  @JsonKey(name: 'interval_count')
  final int? intervalCount;
  @JsonKey(name: 'interval_execution_day')
  final int? intervalExecutionDay;
  @JsonKey(name: 'start_date', toJson: _dateToJson)
  final DateTime? startDate;
  @JsonKey(name: 'end_date', toJson: _dateToJson)
  final DateTime? endDate;
  static const fromJsonFactory = _$TransferRecurringScheduleFromJson;
  static const toJsonFactory = _$TransferRecurringScheduleToJson;
  Map<String, dynamic> toJson() => _$TransferRecurringScheduleToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferRecurringSchedule &&
            (identical(other.intervalUnit, intervalUnit) ||
                const DeepCollectionEquality()
                    .equals(other.intervalUnit, intervalUnit)) &&
            (identical(other.intervalCount, intervalCount) ||
                const DeepCollectionEquality()
                    .equals(other.intervalCount, intervalCount)) &&
            (identical(other.intervalExecutionDay, intervalExecutionDay) ||
                const DeepCollectionEquality().equals(
                    other.intervalExecutionDay, intervalExecutionDay)) &&
            (identical(other.startDate, startDate) ||
                const DeepCollectionEquality()
                    .equals(other.startDate, startDate)) &&
            (identical(other.endDate, endDate) ||
                const DeepCollectionEquality().equals(other.endDate, endDate)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(intervalUnit) ^
      const DeepCollectionEquality().hash(intervalCount) ^
      const DeepCollectionEquality().hash(intervalExecutionDay) ^
      const DeepCollectionEquality().hash(startDate) ^
      const DeepCollectionEquality().hash(endDate) ^
      runtimeType.hashCode;
}

extension $TransferRecurringScheduleExtension on TransferRecurringSchedule {
  TransferRecurringSchedule copyWith(
      {enums.TransferScheduleIntervalUnit? intervalUnit,
      int? intervalCount,
      int? intervalExecutionDay,
      DateTime? startDate,
      DateTime? endDate}) {
    return TransferRecurringSchedule(
        intervalUnit: intervalUnit ?? this.intervalUnit,
        intervalCount: intervalCount ?? this.intervalCount,
        intervalExecutionDay: intervalExecutionDay ?? this.intervalExecutionDay,
        startDate: startDate ?? this.startDate,
        endDate: endDate ?? this.endDate);
  }

  TransferRecurringSchedule copyWithWrapped(
      {Wrapped<enums.TransferScheduleIntervalUnit?>? intervalUnit,
      Wrapped<int?>? intervalCount,
      Wrapped<int?>? intervalExecutionDay,
      Wrapped<DateTime?>? startDate,
      Wrapped<DateTime?>? endDate}) {
    return TransferRecurringSchedule(
        intervalUnit:
            (intervalUnit != null ? intervalUnit.value : this.intervalUnit),
        intervalCount:
            (intervalCount != null ? intervalCount.value : this.intervalCount),
        intervalExecutionDay: (intervalExecutionDay != null
            ? intervalExecutionDay.value
            : this.intervalExecutionDay),
        startDate: (startDate != null ? startDate.value : this.startDate),
        endDate: (endDate != null ? endDate.value : this.endDate));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferMetadata {
  TransferMetadata();

  factory TransferMetadata.fromJson(Map<String, dynamic> json) =>
      _$TransferMetadataFromJson(json);

  static const fromJsonFactory = _$TransferMetadataFromJson;
  static const toJsonFactory = _$TransferMetadataToJson;
  Map<String, dynamic> toJson() => _$TransferMetadataToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => runtimeType.hashCode;
}

@JsonSerializable(explicitToJson: true)
class BankTransferMetadata {
  BankTransferMetadata();

  factory BankTransferMetadata.fromJson(Map<String, dynamic> json) =>
      _$BankTransferMetadataFromJson(json);

  static const fromJsonFactory = _$BankTransferMetadataFromJson;
  static const toJsonFactory = _$BankTransferMetadataToJson;
  Map<String, dynamic> toJson() => _$BankTransferMetadataToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => runtimeType.hashCode;
}

@JsonSerializable(explicitToJson: true)
class TransferFailure {
  TransferFailure({
    this.achReturnCode,
    this.description,
  });

  factory TransferFailure.fromJson(Map<String, dynamic> json) =>
      _$TransferFailureFromJson(json);

  @JsonKey(name: 'ach_return_code')
  final String? achReturnCode;
  @JsonKey(name: 'description')
  final String? description;
  static const fromJsonFactory = _$TransferFailureFromJson;
  static const toJsonFactory = _$TransferFailureToJson;
  Map<String, dynamic> toJson() => _$TransferFailureToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferFailure &&
            (identical(other.achReturnCode, achReturnCode) ||
                const DeepCollectionEquality()
                    .equals(other.achReturnCode, achReturnCode)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(achReturnCode) ^
      const DeepCollectionEquality().hash(description) ^
      runtimeType.hashCode;
}

extension $TransferFailureExtension on TransferFailure {
  TransferFailure copyWith({String? achReturnCode, String? description}) {
    return TransferFailure(
        achReturnCode: achReturnCode ?? this.achReturnCode,
        description: description ?? this.description);
  }

  TransferFailure copyWithWrapped(
      {Wrapped<String?>? achReturnCode, Wrapped<String?>? description}) {
    return TransferFailure(
        achReturnCode:
            (achReturnCode != null ? achReturnCode.value : this.achReturnCode),
        description:
            (description != null ? description.value : this.description));
  }
}

@JsonSerializable(explicitToJson: true)
class BankTransferFailure {
  BankTransferFailure({
    this.achReturnCode,
    this.description,
  });

  factory BankTransferFailure.fromJson(Map<String, dynamic> json) =>
      _$BankTransferFailureFromJson(json);

  @JsonKey(name: 'ach_return_code')
  final String? achReturnCode;
  @JsonKey(name: 'description')
  final String? description;
  static const fromJsonFactory = _$BankTransferFailureFromJson;
  static const toJsonFactory = _$BankTransferFailureToJson;
  Map<String, dynamic> toJson() => _$BankTransferFailureToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BankTransferFailure &&
            (identical(other.achReturnCode, achReturnCode) ||
                const DeepCollectionEquality()
                    .equals(other.achReturnCode, achReturnCode)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(achReturnCode) ^
      const DeepCollectionEquality().hash(description) ^
      runtimeType.hashCode;
}

extension $BankTransferFailureExtension on BankTransferFailure {
  BankTransferFailure copyWith({String? achReturnCode, String? description}) {
    return BankTransferFailure(
        achReturnCode: achReturnCode ?? this.achReturnCode,
        description: description ?? this.description);
  }

  BankTransferFailure copyWithWrapped(
      {Wrapped<String?>? achReturnCode, Wrapped<String?>? description}) {
    return BankTransferFailure(
        achReturnCode:
            (achReturnCode != null ? achReturnCode.value : this.achReturnCode),
        description:
            (description != null ? description.value : this.description));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferAuthorizationCreateRequest {
  TransferAuthorizationCreateRequest({
    this.clientId,
    this.secret,
    this.accessToken,
    this.accountId,
    this.paymentProfileToken,
    required this.type,
    required this.network,
    required this.amount,
    this.achClass,
    required this.user,
    this.device,
    this.originationAccountId,
    this.isoCurrencyCode,
    this.idempotencyKey,
    this.userPresent,
    this.withGuarantee,
    this.beaconSessionId,
    this.originatorClientId,
  });

  factory TransferAuthorizationCreateRequest.fromJson(
          Map<String, dynamic> json) =>
      _$TransferAuthorizationCreateRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'access_token')
  final String? accessToken;
  @JsonKey(name: 'account_id')
  final String? accountId;
  @JsonKey(name: 'payment_profile_token')
  final String? paymentProfileToken;
  @JsonKey(
    name: 'type',
    toJson: transferTypeToJson,
    fromJson: transferTypeFromJson,
  )
  final enums.TransferType type;
  @JsonKey(
    name: 'network',
    toJson: transferNetworkToJson,
    fromJson: transferNetworkFromJson,
  )
  final enums.TransferNetwork network;
  @JsonKey(name: 'amount')
  final String amount;
  @JsonKey(
    name: 'ach_class',
    toJson: aCHClassToJson,
    fromJson: aCHClassFromJson,
  )
  final enums.ACHClass? achClass;
  @JsonKey(name: 'user')
  final TransferAuthorizationUserInRequest user;
  @JsonKey(name: 'device')
  final TransferAuthorizationDevice? device;
  @JsonKey(name: 'origination_account_id')
  final String? originationAccountId;
  @JsonKey(name: 'iso_currency_code')
  final String? isoCurrencyCode;
  @JsonKey(name: 'idempotency_key')
  final String? idempotencyKey;
  @JsonKey(name: 'user_present')
  final bool? userPresent;
  @JsonKey(name: 'with_guarantee', defaultValue: true)
  final bool? withGuarantee;
  @JsonKey(name: 'beacon_session_id')
  final String? beaconSessionId;
  @JsonKey(name: 'originator_client_id')
  final String? originatorClientId;
  static const fromJsonFactory = _$TransferAuthorizationCreateRequestFromJson;
  static const toJsonFactory = _$TransferAuthorizationCreateRequestToJson;
  Map<String, dynamic> toJson() =>
      _$TransferAuthorizationCreateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferAuthorizationCreateRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)) &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.paymentProfileToken, paymentProfileToken) ||
                const DeepCollectionEquality()
                    .equals(other.paymentProfileToken, paymentProfileToken)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.network, network) ||
                const DeepCollectionEquality()
                    .equals(other.network, network)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.achClass, achClass) ||
                const DeepCollectionEquality()
                    .equals(other.achClass, achClass)) &&
            (identical(other.user, user) ||
                const DeepCollectionEquality().equals(other.user, user)) &&
            (identical(other.device, device) ||
                const DeepCollectionEquality().equals(other.device, device)) &&
            (identical(other.originationAccountId, originationAccountId) ||
                const DeepCollectionEquality().equals(
                    other.originationAccountId, originationAccountId)) &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)) &&
            (identical(other.idempotencyKey, idempotencyKey) ||
                const DeepCollectionEquality()
                    .equals(other.idempotencyKey, idempotencyKey)) &&
            (identical(other.userPresent, userPresent) ||
                const DeepCollectionEquality()
                    .equals(other.userPresent, userPresent)) &&
            (identical(other.withGuarantee, withGuarantee) ||
                const DeepCollectionEquality()
                    .equals(other.withGuarantee, withGuarantee)) &&
            (identical(other.beaconSessionId, beaconSessionId) ||
                const DeepCollectionEquality()
                    .equals(other.beaconSessionId, beaconSessionId)) &&
            (identical(other.originatorClientId, originatorClientId) ||
                const DeepCollectionEquality()
                    .equals(other.originatorClientId, originatorClientId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(accessToken) ^
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(paymentProfileToken) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(network) ^
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(achClass) ^
      const DeepCollectionEquality().hash(user) ^
      const DeepCollectionEquality().hash(device) ^
      const DeepCollectionEquality().hash(originationAccountId) ^
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      const DeepCollectionEquality().hash(idempotencyKey) ^
      const DeepCollectionEquality().hash(userPresent) ^
      const DeepCollectionEquality().hash(withGuarantee) ^
      const DeepCollectionEquality().hash(beaconSessionId) ^
      const DeepCollectionEquality().hash(originatorClientId) ^
      runtimeType.hashCode;
}

extension $TransferAuthorizationCreateRequestExtension
    on TransferAuthorizationCreateRequest {
  TransferAuthorizationCreateRequest copyWith(
      {String? clientId,
      String? secret,
      String? accessToken,
      String? accountId,
      String? paymentProfileToken,
      enums.TransferType? type,
      enums.TransferNetwork? network,
      String? amount,
      enums.ACHClass? achClass,
      TransferAuthorizationUserInRequest? user,
      TransferAuthorizationDevice? device,
      String? originationAccountId,
      String? isoCurrencyCode,
      String? idempotencyKey,
      bool? userPresent,
      bool? withGuarantee,
      String? beaconSessionId,
      String? originatorClientId}) {
    return TransferAuthorizationCreateRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        accessToken: accessToken ?? this.accessToken,
        accountId: accountId ?? this.accountId,
        paymentProfileToken: paymentProfileToken ?? this.paymentProfileToken,
        type: type ?? this.type,
        network: network ?? this.network,
        amount: amount ?? this.amount,
        achClass: achClass ?? this.achClass,
        user: user ?? this.user,
        device: device ?? this.device,
        originationAccountId: originationAccountId ?? this.originationAccountId,
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode,
        idempotencyKey: idempotencyKey ?? this.idempotencyKey,
        userPresent: userPresent ?? this.userPresent,
        withGuarantee: withGuarantee ?? this.withGuarantee,
        beaconSessionId: beaconSessionId ?? this.beaconSessionId,
        originatorClientId: originatorClientId ?? this.originatorClientId);
  }

  TransferAuthorizationCreateRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String?>? accessToken,
      Wrapped<String?>? accountId,
      Wrapped<String?>? paymentProfileToken,
      Wrapped<enums.TransferType>? type,
      Wrapped<enums.TransferNetwork>? network,
      Wrapped<String>? amount,
      Wrapped<enums.ACHClass?>? achClass,
      Wrapped<TransferAuthorizationUserInRequest>? user,
      Wrapped<TransferAuthorizationDevice?>? device,
      Wrapped<String?>? originationAccountId,
      Wrapped<String?>? isoCurrencyCode,
      Wrapped<String?>? idempotencyKey,
      Wrapped<bool?>? userPresent,
      Wrapped<bool?>? withGuarantee,
      Wrapped<String?>? beaconSessionId,
      Wrapped<String?>? originatorClientId}) {
    return TransferAuthorizationCreateRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        accessToken:
            (accessToken != null ? accessToken.value : this.accessToken),
        accountId: (accountId != null ? accountId.value : this.accountId),
        paymentProfileToken: (paymentProfileToken != null
            ? paymentProfileToken.value
            : this.paymentProfileToken),
        type: (type != null ? type.value : this.type),
        network: (network != null ? network.value : this.network),
        amount: (amount != null ? amount.value : this.amount),
        achClass: (achClass != null ? achClass.value : this.achClass),
        user: (user != null ? user.value : this.user),
        device: (device != null ? device.value : this.device),
        originationAccountId: (originationAccountId != null
            ? originationAccountId.value
            : this.originationAccountId),
        isoCurrencyCode: (isoCurrencyCode != null
            ? isoCurrencyCode.value
            : this.isoCurrencyCode),
        idempotencyKey: (idempotencyKey != null
            ? idempotencyKey.value
            : this.idempotencyKey),
        userPresent:
            (userPresent != null ? userPresent.value : this.userPresent),
        withGuarantee:
            (withGuarantee != null ? withGuarantee.value : this.withGuarantee),
        beaconSessionId: (beaconSessionId != null
            ? beaconSessionId.value
            : this.beaconSessionId),
        originatorClientId: (originatorClientId != null
            ? originatorClientId.value
            : this.originatorClientId));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferCreateRequest {
  TransferCreateRequest({
    this.clientId,
    this.secret,
    this.idempotencyKey,
    this.accessToken,
    this.accountId,
    this.paymentProfileToken,
    required this.authorizationId,
    this.type,
    this.network,
    this.amount,
    required this.description,
    this.achClass,
    this.user,
    this.metadata,
    this.originationAccountId,
    this.isoCurrencyCode,
  });

  factory TransferCreateRequest.fromJson(Map<String, dynamic> json) =>
      _$TransferCreateRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'idempotency_key')
  final String? idempotencyKey;
  @JsonKey(name: 'access_token')
  final String? accessToken;
  @JsonKey(name: 'account_id')
  final String? accountId;
  @JsonKey(name: 'payment_profile_token')
  final String? paymentProfileToken;
  @JsonKey(name: 'authorization_id')
  final String authorizationId;
  @JsonKey(
    name: 'type',
    toJson: transferTypeToJson,
    fromJson: transferTypeFromJson,
  )
  final enums.TransferType? type;
  @JsonKey(
    name: 'network',
    toJson: transferNetworkToJson,
    fromJson: transferNetworkFromJson,
  )
  final enums.TransferNetwork? network;
  @JsonKey(name: 'amount')
  final String? amount;
  @JsonKey(name: 'description')
  final String description;
  @JsonKey(
    name: 'ach_class',
    toJson: aCHClassToJson,
    fromJson: aCHClassFromJson,
  )
  final enums.ACHClass? achClass;
  @JsonKey(name: 'user')
  final TransferUserInRequestDeprecated? user;
  @JsonKey(name: 'metadata')
  final TransferMetadata? metadata;
  @JsonKey(name: 'origination_account_id')
  final String? originationAccountId;
  @JsonKey(name: 'iso_currency_code')
  final String? isoCurrencyCode;
  static const fromJsonFactory = _$TransferCreateRequestFromJson;
  static const toJsonFactory = _$TransferCreateRequestToJson;
  Map<String, dynamic> toJson() => _$TransferCreateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferCreateRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.idempotencyKey, idempotencyKey) ||
                const DeepCollectionEquality()
                    .equals(other.idempotencyKey, idempotencyKey)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)) &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.paymentProfileToken, paymentProfileToken) ||
                const DeepCollectionEquality()
                    .equals(other.paymentProfileToken, paymentProfileToken)) &&
            (identical(other.authorizationId, authorizationId) ||
                const DeepCollectionEquality()
                    .equals(other.authorizationId, authorizationId)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.network, network) ||
                const DeepCollectionEquality()
                    .equals(other.network, network)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.achClass, achClass) ||
                const DeepCollectionEquality()
                    .equals(other.achClass, achClass)) &&
            (identical(other.user, user) ||
                const DeepCollectionEquality().equals(other.user, user)) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality()
                    .equals(other.metadata, metadata)) &&
            (identical(other.originationAccountId, originationAccountId) ||
                const DeepCollectionEquality().equals(
                    other.originationAccountId, originationAccountId)) &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(idempotencyKey) ^
      const DeepCollectionEquality().hash(accessToken) ^
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(paymentProfileToken) ^
      const DeepCollectionEquality().hash(authorizationId) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(network) ^
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(achClass) ^
      const DeepCollectionEquality().hash(user) ^
      const DeepCollectionEquality().hash(metadata) ^
      const DeepCollectionEquality().hash(originationAccountId) ^
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      runtimeType.hashCode;
}

extension $TransferCreateRequestExtension on TransferCreateRequest {
  TransferCreateRequest copyWith(
      {String? clientId,
      String? secret,
      String? idempotencyKey,
      String? accessToken,
      String? accountId,
      String? paymentProfileToken,
      String? authorizationId,
      enums.TransferType? type,
      enums.TransferNetwork? network,
      String? amount,
      String? description,
      enums.ACHClass? achClass,
      TransferUserInRequestDeprecated? user,
      TransferMetadata? metadata,
      String? originationAccountId,
      String? isoCurrencyCode}) {
    return TransferCreateRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        idempotencyKey: idempotencyKey ?? this.idempotencyKey,
        accessToken: accessToken ?? this.accessToken,
        accountId: accountId ?? this.accountId,
        paymentProfileToken: paymentProfileToken ?? this.paymentProfileToken,
        authorizationId: authorizationId ?? this.authorizationId,
        type: type ?? this.type,
        network: network ?? this.network,
        amount: amount ?? this.amount,
        description: description ?? this.description,
        achClass: achClass ?? this.achClass,
        user: user ?? this.user,
        metadata: metadata ?? this.metadata,
        originationAccountId: originationAccountId ?? this.originationAccountId,
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode);
  }

  TransferCreateRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String?>? idempotencyKey,
      Wrapped<String?>? accessToken,
      Wrapped<String?>? accountId,
      Wrapped<String?>? paymentProfileToken,
      Wrapped<String>? authorizationId,
      Wrapped<enums.TransferType?>? type,
      Wrapped<enums.TransferNetwork?>? network,
      Wrapped<String?>? amount,
      Wrapped<String>? description,
      Wrapped<enums.ACHClass?>? achClass,
      Wrapped<TransferUserInRequestDeprecated?>? user,
      Wrapped<TransferMetadata?>? metadata,
      Wrapped<String?>? originationAccountId,
      Wrapped<String?>? isoCurrencyCode}) {
    return TransferCreateRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        idempotencyKey: (idempotencyKey != null
            ? idempotencyKey.value
            : this.idempotencyKey),
        accessToken:
            (accessToken != null ? accessToken.value : this.accessToken),
        accountId: (accountId != null ? accountId.value : this.accountId),
        paymentProfileToken: (paymentProfileToken != null
            ? paymentProfileToken.value
            : this.paymentProfileToken),
        authorizationId: (authorizationId != null
            ? authorizationId.value
            : this.authorizationId),
        type: (type != null ? type.value : this.type),
        network: (network != null ? network.value : this.network),
        amount: (amount != null ? amount.value : this.amount),
        description:
            (description != null ? description.value : this.description),
        achClass: (achClass != null ? achClass.value : this.achClass),
        user: (user != null ? user.value : this.user),
        metadata: (metadata != null ? metadata.value : this.metadata),
        originationAccountId: (originationAccountId != null
            ? originationAccountId.value
            : this.originationAccountId),
        isoCurrencyCode: (isoCurrencyCode != null
            ? isoCurrencyCode.value
            : this.isoCurrencyCode));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferRecurringCreateRequest {
  TransferRecurringCreateRequest({
    required this.clientId,
    required this.secret,
    required this.accessToken,
    required this.idempotencyKey,
    required this.accountId,
    required this.type,
    required this.network,
    this.achClass,
    required this.amount,
    required this.userPresent,
    this.isoCurrencyCode,
    this.testClockId,
    required this.schedule,
    required this.user,
    required this.device,
  });

  factory TransferRecurringCreateRequest.fromJson(Map<String, dynamic> json) =>
      _$TransferRecurringCreateRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String clientId;
  @JsonKey(name: 'secret')
  final String secret;
  @JsonKey(name: 'access_token')
  final String accessToken;
  @JsonKey(name: 'idempotency_key')
  final String? idempotencyKey;
  @JsonKey(name: 'account_id')
  final String accountId;
  @JsonKey(
    name: 'type',
    toJson: transferTypeToJson,
    fromJson: transferTypeFromJson,
  )
  final enums.TransferType type;
  @JsonKey(
    name: 'network',
    toJson: transferNetworkToJson,
    fromJson: transferNetworkFromJson,
  )
  final enums.TransferNetwork network;
  @JsonKey(
    name: 'ach_class',
    toJson: aCHClassToJson,
    fromJson: aCHClassFromJson,
  )
  final enums.ACHClass? achClass;
  @JsonKey(name: 'amount')
  final String amount;
  @JsonKey(name: 'user_present')
  final bool? userPresent;
  @JsonKey(name: 'iso_currency_code')
  final String? isoCurrencyCode;
  @JsonKey(name: 'test_clock_id')
  final String? testClockId;
  @JsonKey(name: 'schedule')
  final TransferRecurringSchedule schedule;
  @JsonKey(name: 'user')
  final TransferUserInRequest user;
  @JsonKey(name: 'device')
  final TransferDevice device;
  static const fromJsonFactory = _$TransferRecurringCreateRequestFromJson;
  static const toJsonFactory = _$TransferRecurringCreateRequestToJson;
  Map<String, dynamic> toJson() => _$TransferRecurringCreateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferRecurringCreateRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)) &&
            (identical(other.idempotencyKey, idempotencyKey) ||
                const DeepCollectionEquality()
                    .equals(other.idempotencyKey, idempotencyKey)) &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.network, network) ||
                const DeepCollectionEquality()
                    .equals(other.network, network)) &&
            (identical(other.achClass, achClass) ||
                const DeepCollectionEquality()
                    .equals(other.achClass, achClass)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.userPresent, userPresent) ||
                const DeepCollectionEquality()
                    .equals(other.userPresent, userPresent)) &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)) &&
            (identical(other.testClockId, testClockId) ||
                const DeepCollectionEquality()
                    .equals(other.testClockId, testClockId)) &&
            (identical(other.schedule, schedule) ||
                const DeepCollectionEquality()
                    .equals(other.schedule, schedule)) &&
            (identical(other.user, user) ||
                const DeepCollectionEquality().equals(other.user, user)) &&
            (identical(other.device, device) ||
                const DeepCollectionEquality().equals(other.device, device)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(accessToken) ^
      const DeepCollectionEquality().hash(idempotencyKey) ^
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(network) ^
      const DeepCollectionEquality().hash(achClass) ^
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(userPresent) ^
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      const DeepCollectionEquality().hash(testClockId) ^
      const DeepCollectionEquality().hash(schedule) ^
      const DeepCollectionEquality().hash(user) ^
      const DeepCollectionEquality().hash(device) ^
      runtimeType.hashCode;
}

extension $TransferRecurringCreateRequestExtension
    on TransferRecurringCreateRequest {
  TransferRecurringCreateRequest copyWith(
      {String? clientId,
      String? secret,
      String? accessToken,
      String? idempotencyKey,
      String? accountId,
      enums.TransferType? type,
      enums.TransferNetwork? network,
      enums.ACHClass? achClass,
      String? amount,
      bool? userPresent,
      String? isoCurrencyCode,
      String? testClockId,
      TransferRecurringSchedule? schedule,
      TransferUserInRequest? user,
      TransferDevice? device}) {
    return TransferRecurringCreateRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        accessToken: accessToken ?? this.accessToken,
        idempotencyKey: idempotencyKey ?? this.idempotencyKey,
        accountId: accountId ?? this.accountId,
        type: type ?? this.type,
        network: network ?? this.network,
        achClass: achClass ?? this.achClass,
        amount: amount ?? this.amount,
        userPresent: userPresent ?? this.userPresent,
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode,
        testClockId: testClockId ?? this.testClockId,
        schedule: schedule ?? this.schedule,
        user: user ?? this.user,
        device: device ?? this.device);
  }

  TransferRecurringCreateRequest copyWithWrapped(
      {Wrapped<String>? clientId,
      Wrapped<String>? secret,
      Wrapped<String>? accessToken,
      Wrapped<String?>? idempotencyKey,
      Wrapped<String>? accountId,
      Wrapped<enums.TransferType>? type,
      Wrapped<enums.TransferNetwork>? network,
      Wrapped<enums.ACHClass?>? achClass,
      Wrapped<String>? amount,
      Wrapped<bool?>? userPresent,
      Wrapped<String?>? isoCurrencyCode,
      Wrapped<String?>? testClockId,
      Wrapped<TransferRecurringSchedule>? schedule,
      Wrapped<TransferUserInRequest>? user,
      Wrapped<TransferDevice>? device}) {
    return TransferRecurringCreateRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        accessToken:
            (accessToken != null ? accessToken.value : this.accessToken),
        idempotencyKey: (idempotencyKey != null
            ? idempotencyKey.value
            : this.idempotencyKey),
        accountId: (accountId != null ? accountId.value : this.accountId),
        type: (type != null ? type.value : this.type),
        network: (network != null ? network.value : this.network),
        achClass: (achClass != null ? achClass.value : this.achClass),
        amount: (amount != null ? amount.value : this.amount),
        userPresent:
            (userPresent != null ? userPresent.value : this.userPresent),
        isoCurrencyCode: (isoCurrencyCode != null
            ? isoCurrencyCode.value
            : this.isoCurrencyCode),
        testClockId:
            (testClockId != null ? testClockId.value : this.testClockId),
        schedule: (schedule != null ? schedule.value : this.schedule),
        user: (user != null ? user.value : this.user),
        device: (device != null ? device.value : this.device));
  }
}

@JsonSerializable(explicitToJson: true)
class BankTransferCreateRequest {
  BankTransferCreateRequest({
    this.clientId,
    this.secret,
    required this.idempotencyKey,
    required this.accessToken,
    required this.accountId,
    required this.type,
    required this.network,
    required this.amount,
    required this.isoCurrencyCode,
    required this.description,
    this.achClass,
    required this.user,
    this.customTag,
    this.metadata,
    this.originationAccountId,
  });

  factory BankTransferCreateRequest.fromJson(Map<String, dynamic> json) =>
      _$BankTransferCreateRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'idempotency_key')
  final String idempotencyKey;
  @JsonKey(name: 'access_token')
  final String accessToken;
  @JsonKey(name: 'account_id')
  final String accountId;
  @JsonKey(
    name: 'type',
    toJson: bankTransferTypeToJson,
    fromJson: bankTransferTypeFromJson,
  )
  final enums.BankTransferType type;
  @JsonKey(
    name: 'network',
    toJson: bankTransferNetworkToJson,
    fromJson: bankTransferNetworkFromJson,
  )
  final enums.BankTransferNetwork network;
  @JsonKey(name: 'amount')
  final String amount;
  @JsonKey(name: 'iso_currency_code')
  final String isoCurrencyCode;
  @JsonKey(name: 'description')
  final String description;
  @JsonKey(
    name: 'ach_class',
    toJson: aCHClassToJson,
    fromJson: aCHClassFromJson,
  )
  final enums.ACHClass? achClass;
  @JsonKey(name: 'user')
  final BankTransferUser user;
  @JsonKey(name: 'custom_tag')
  final String? customTag;
  @JsonKey(name: 'metadata')
  final BankTransferMetadata? metadata;
  @JsonKey(name: 'origination_account_id')
  final String? originationAccountId;
  static const fromJsonFactory = _$BankTransferCreateRequestFromJson;
  static const toJsonFactory = _$BankTransferCreateRequestToJson;
  Map<String, dynamic> toJson() => _$BankTransferCreateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BankTransferCreateRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.idempotencyKey, idempotencyKey) ||
                const DeepCollectionEquality()
                    .equals(other.idempotencyKey, idempotencyKey)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)) &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.network, network) ||
                const DeepCollectionEquality()
                    .equals(other.network, network)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.achClass, achClass) ||
                const DeepCollectionEquality()
                    .equals(other.achClass, achClass)) &&
            (identical(other.user, user) ||
                const DeepCollectionEquality().equals(other.user, user)) &&
            (identical(other.customTag, customTag) ||
                const DeepCollectionEquality()
                    .equals(other.customTag, customTag)) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality()
                    .equals(other.metadata, metadata)) &&
            (identical(other.originationAccountId, originationAccountId) ||
                const DeepCollectionEquality()
                    .equals(other.originationAccountId, originationAccountId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(idempotencyKey) ^
      const DeepCollectionEquality().hash(accessToken) ^
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(network) ^
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(achClass) ^
      const DeepCollectionEquality().hash(user) ^
      const DeepCollectionEquality().hash(customTag) ^
      const DeepCollectionEquality().hash(metadata) ^
      const DeepCollectionEquality().hash(originationAccountId) ^
      runtimeType.hashCode;
}

extension $BankTransferCreateRequestExtension on BankTransferCreateRequest {
  BankTransferCreateRequest copyWith(
      {String? clientId,
      String? secret,
      String? idempotencyKey,
      String? accessToken,
      String? accountId,
      enums.BankTransferType? type,
      enums.BankTransferNetwork? network,
      String? amount,
      String? isoCurrencyCode,
      String? description,
      enums.ACHClass? achClass,
      BankTransferUser? user,
      String? customTag,
      BankTransferMetadata? metadata,
      String? originationAccountId}) {
    return BankTransferCreateRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        idempotencyKey: idempotencyKey ?? this.idempotencyKey,
        accessToken: accessToken ?? this.accessToken,
        accountId: accountId ?? this.accountId,
        type: type ?? this.type,
        network: network ?? this.network,
        amount: amount ?? this.amount,
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode,
        description: description ?? this.description,
        achClass: achClass ?? this.achClass,
        user: user ?? this.user,
        customTag: customTag ?? this.customTag,
        metadata: metadata ?? this.metadata,
        originationAccountId:
            originationAccountId ?? this.originationAccountId);
  }

  BankTransferCreateRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? idempotencyKey,
      Wrapped<String>? accessToken,
      Wrapped<String>? accountId,
      Wrapped<enums.BankTransferType>? type,
      Wrapped<enums.BankTransferNetwork>? network,
      Wrapped<String>? amount,
      Wrapped<String>? isoCurrencyCode,
      Wrapped<String>? description,
      Wrapped<enums.ACHClass?>? achClass,
      Wrapped<BankTransferUser>? user,
      Wrapped<String?>? customTag,
      Wrapped<BankTransferMetadata?>? metadata,
      Wrapped<String?>? originationAccountId}) {
    return BankTransferCreateRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        idempotencyKey: (idempotencyKey != null
            ? idempotencyKey.value
            : this.idempotencyKey),
        accessToken:
            (accessToken != null ? accessToken.value : this.accessToken),
        accountId: (accountId != null ? accountId.value : this.accountId),
        type: (type != null ? type.value : this.type),
        network: (network != null ? network.value : this.network),
        amount: (amount != null ? amount.value : this.amount),
        isoCurrencyCode: (isoCurrencyCode != null
            ? isoCurrencyCode.value
            : this.isoCurrencyCode),
        description:
            (description != null ? description.value : this.description),
        achClass: (achClass != null ? achClass.value : this.achClass),
        user: (user != null ? user.value : this.user),
        customTag: (customTag != null ? customTag.value : this.customTag),
        metadata: (metadata != null ? metadata.value : this.metadata),
        originationAccountId: (originationAccountId != null
            ? originationAccountId.value
            : this.originationAccountId));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferAuthorizationCreateResponse {
  TransferAuthorizationCreateResponse({
    required this.authorization,
    required this.requestId,
  });

  factory TransferAuthorizationCreateResponse.fromJson(
          Map<String, dynamic> json) =>
      _$TransferAuthorizationCreateResponseFromJson(json);

  @JsonKey(name: 'authorization')
  final TransferAuthorization authorization;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$TransferAuthorizationCreateResponseFromJson;
  static const toJsonFactory = _$TransferAuthorizationCreateResponseToJson;
  Map<String, dynamic> toJson() =>
      _$TransferAuthorizationCreateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferAuthorizationCreateResponse &&
            (identical(other.authorization, authorization) ||
                const DeepCollectionEquality()
                    .equals(other.authorization, authorization)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(authorization) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $TransferAuthorizationCreateResponseExtension
    on TransferAuthorizationCreateResponse {
  TransferAuthorizationCreateResponse copyWith(
      {TransferAuthorization? authorization, String? requestId}) {
    return TransferAuthorizationCreateResponse(
        authorization: authorization ?? this.authorization,
        requestId: requestId ?? this.requestId);
  }

  TransferAuthorizationCreateResponse copyWithWrapped(
      {Wrapped<TransferAuthorization>? authorization,
      Wrapped<String>? requestId}) {
    return TransferAuthorizationCreateResponse(
        authorization:
            (authorization != null ? authorization.value : this.authorization),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferAuthorization {
  TransferAuthorization({
    required this.id,
    required this.created,
    required this.decision,
    required this.decisionRationale,
    required this.guaranteeDecision,
    required this.guaranteeDecisionRationale,
    required this.proposedTransfer,
  });

  factory TransferAuthorization.fromJson(Map<String, dynamic> json) =>
      _$TransferAuthorizationFromJson(json);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'created')
  final DateTime created;
  @JsonKey(
    name: 'decision',
    toJson: transferAuthorizationDecisionToJson,
    fromJson: transferAuthorizationDecisionFromJson,
  )
  final enums.TransferAuthorizationDecision decision;
  @JsonKey(name: 'decision_rationale')
  final TransferAuthorizationDecisionRationale? decisionRationale;
  @JsonKey(
    name: 'guarantee_decision',
    toJson: transferAuthorizationGuaranteeDecisionToJson,
    fromJson: transferAuthorizationGuaranteeDecisionFromJson,
  )
  final enums.TransferAuthorizationGuaranteeDecision? guaranteeDecision;
  @JsonKey(name: 'guarantee_decision_rationale')
  final TransferAuthorizationGuaranteeDecisionRationale?
      guaranteeDecisionRationale;
  @JsonKey(name: 'proposed_transfer')
  final TransferAuthorizationProposedTransfer proposedTransfer;
  static const fromJsonFactory = _$TransferAuthorizationFromJson;
  static const toJsonFactory = _$TransferAuthorizationToJson;
  Map<String, dynamic> toJson() => _$TransferAuthorizationToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferAuthorization &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.created, created) ||
                const DeepCollectionEquality()
                    .equals(other.created, created)) &&
            (identical(other.decision, decision) ||
                const DeepCollectionEquality()
                    .equals(other.decision, decision)) &&
            (identical(other.decisionRationale, decisionRationale) ||
                const DeepCollectionEquality()
                    .equals(other.decisionRationale, decisionRationale)) &&
            (identical(other.guaranteeDecision, guaranteeDecision) ||
                const DeepCollectionEquality()
                    .equals(other.guaranteeDecision, guaranteeDecision)) &&
            (identical(other.guaranteeDecisionRationale,
                    guaranteeDecisionRationale) ||
                const DeepCollectionEquality().equals(
                    other.guaranteeDecisionRationale,
                    guaranteeDecisionRationale)) &&
            (identical(other.proposedTransfer, proposedTransfer) ||
                const DeepCollectionEquality()
                    .equals(other.proposedTransfer, proposedTransfer)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(created) ^
      const DeepCollectionEquality().hash(decision) ^
      const DeepCollectionEquality().hash(decisionRationale) ^
      const DeepCollectionEquality().hash(guaranteeDecision) ^
      const DeepCollectionEquality().hash(guaranteeDecisionRationale) ^
      const DeepCollectionEquality().hash(proposedTransfer) ^
      runtimeType.hashCode;
}

extension $TransferAuthorizationExtension on TransferAuthorization {
  TransferAuthorization copyWith(
      {String? id,
      DateTime? created,
      enums.TransferAuthorizationDecision? decision,
      TransferAuthorizationDecisionRationale? decisionRationale,
      enums.TransferAuthorizationGuaranteeDecision? guaranteeDecision,
      TransferAuthorizationGuaranteeDecisionRationale?
          guaranteeDecisionRationale,
      TransferAuthorizationProposedTransfer? proposedTransfer}) {
    return TransferAuthorization(
        id: id ?? this.id,
        created: created ?? this.created,
        decision: decision ?? this.decision,
        decisionRationale: decisionRationale ?? this.decisionRationale,
        guaranteeDecision: guaranteeDecision ?? this.guaranteeDecision,
        guaranteeDecisionRationale:
            guaranteeDecisionRationale ?? this.guaranteeDecisionRationale,
        proposedTransfer: proposedTransfer ?? this.proposedTransfer);
  }

  TransferAuthorization copyWithWrapped(
      {Wrapped<String>? id,
      Wrapped<DateTime>? created,
      Wrapped<enums.TransferAuthorizationDecision>? decision,
      Wrapped<TransferAuthorizationDecisionRationale?>? decisionRationale,
      Wrapped<enums.TransferAuthorizationGuaranteeDecision?>? guaranteeDecision,
      Wrapped<TransferAuthorizationGuaranteeDecisionRationale?>?
          guaranteeDecisionRationale,
      Wrapped<TransferAuthorizationProposedTransfer>? proposedTransfer}) {
    return TransferAuthorization(
        id: (id != null ? id.value : this.id),
        created: (created != null ? created.value : this.created),
        decision: (decision != null ? decision.value : this.decision),
        decisionRationale: (decisionRationale != null
            ? decisionRationale.value
            : this.decisionRationale),
        guaranteeDecision: (guaranteeDecision != null
            ? guaranteeDecision.value
            : this.guaranteeDecision),
        guaranteeDecisionRationale: (guaranteeDecisionRationale != null
            ? guaranteeDecisionRationale.value
            : this.guaranteeDecisionRationale),
        proposedTransfer: (proposedTransfer != null
            ? proposedTransfer.value
            : this.proposedTransfer));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferCreateResponse {
  TransferCreateResponse({
    required this.transfer,
    required this.requestId,
  });

  factory TransferCreateResponse.fromJson(Map<String, dynamic> json) =>
      _$TransferCreateResponseFromJson(json);

  @JsonKey(name: 'transfer')
  final Transfer transfer;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$TransferCreateResponseFromJson;
  static const toJsonFactory = _$TransferCreateResponseToJson;
  Map<String, dynamic> toJson() => _$TransferCreateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferCreateResponse &&
            (identical(other.transfer, transfer) ||
                const DeepCollectionEquality()
                    .equals(other.transfer, transfer)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(transfer) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $TransferCreateResponseExtension on TransferCreateResponse {
  TransferCreateResponse copyWith({Transfer? transfer, String? requestId}) {
    return TransferCreateResponse(
        transfer: transfer ?? this.transfer,
        requestId: requestId ?? this.requestId);
  }

  TransferCreateResponse copyWithWrapped(
      {Wrapped<Transfer>? transfer, Wrapped<String>? requestId}) {
    return TransferCreateResponse(
        transfer: (transfer != null ? transfer.value : this.transfer),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferRecurringCreateResponse {
  TransferRecurringCreateResponse({
    required this.recurringTransfer,
    required this.requestId,
  });

  factory TransferRecurringCreateResponse.fromJson(Map<String, dynamic> json) =>
      _$TransferRecurringCreateResponseFromJson(json);

  @JsonKey(name: 'recurring_transfer')
  final RecurringTransfer recurringTransfer;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$TransferRecurringCreateResponseFromJson;
  static const toJsonFactory = _$TransferRecurringCreateResponseToJson;
  Map<String, dynamic> toJson() =>
      _$TransferRecurringCreateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferRecurringCreateResponse &&
            (identical(other.recurringTransfer, recurringTransfer) ||
                const DeepCollectionEquality()
                    .equals(other.recurringTransfer, recurringTransfer)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(recurringTransfer) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $TransferRecurringCreateResponseExtension
    on TransferRecurringCreateResponse {
  TransferRecurringCreateResponse copyWith(
      {RecurringTransfer? recurringTransfer, String? requestId}) {
    return TransferRecurringCreateResponse(
        recurringTransfer: recurringTransfer ?? this.recurringTransfer,
        requestId: requestId ?? this.requestId);
  }

  TransferRecurringCreateResponse copyWithWrapped(
      {Wrapped<RecurringTransfer>? recurringTransfer,
      Wrapped<String>? requestId}) {
    return TransferRecurringCreateResponse(
        recurringTransfer: (recurringTransfer != null
            ? recurringTransfer.value
            : this.recurringTransfer),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class BankTransferCreateResponse {
  BankTransferCreateResponse({
    required this.bankTransfer,
    required this.requestId,
  });

  factory BankTransferCreateResponse.fromJson(Map<String, dynamic> json) =>
      _$BankTransferCreateResponseFromJson(json);

  @JsonKey(name: 'bank_transfer')
  final BankTransfer bankTransfer;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$BankTransferCreateResponseFromJson;
  static const toJsonFactory = _$BankTransferCreateResponseToJson;
  Map<String, dynamic> toJson() => _$BankTransferCreateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BankTransferCreateResponse &&
            (identical(other.bankTransfer, bankTransfer) ||
                const DeepCollectionEquality()
                    .equals(other.bankTransfer, bankTransfer)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(bankTransfer) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $BankTransferCreateResponseExtension on BankTransferCreateResponse {
  BankTransferCreateResponse copyWith(
      {BankTransfer? bankTransfer, String? requestId}) {
    return BankTransferCreateResponse(
        bankTransfer: bankTransfer ?? this.bankTransfer,
        requestId: requestId ?? this.requestId);
  }

  BankTransferCreateResponse copyWithWrapped(
      {Wrapped<BankTransfer>? bankTransfer, Wrapped<String>? requestId}) {
    return BankTransferCreateResponse(
        bankTransfer:
            (bankTransfer != null ? bankTransfer.value : this.bankTransfer),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferListRequest {
  TransferListRequest({
    this.clientId,
    this.secret,
    this.startDate,
    this.endDate,
    this.count,
    this.offset,
    this.originationAccountId,
    this.originatorClientId,
  });

  factory TransferListRequest.fromJson(Map<String, dynamic> json) =>
      _$TransferListRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'start_date')
  final DateTime? startDate;
  @JsonKey(name: 'end_date')
  final DateTime? endDate;
  @JsonKey(name: 'count')
  final int? count;
  @JsonKey(name: 'offset')
  final int? offset;
  @JsonKey(name: 'origination_account_id')
  final String? originationAccountId;
  @JsonKey(name: 'originator_client_id')
  final String? originatorClientId;
  static const fromJsonFactory = _$TransferListRequestFromJson;
  static const toJsonFactory = _$TransferListRequestToJson;
  Map<String, dynamic> toJson() => _$TransferListRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferListRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.startDate, startDate) ||
                const DeepCollectionEquality()
                    .equals(other.startDate, startDate)) &&
            (identical(other.endDate, endDate) ||
                const DeepCollectionEquality()
                    .equals(other.endDate, endDate)) &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)) &&
            (identical(other.offset, offset) ||
                const DeepCollectionEquality().equals(other.offset, offset)) &&
            (identical(other.originationAccountId, originationAccountId) ||
                const DeepCollectionEquality().equals(
                    other.originationAccountId, originationAccountId)) &&
            (identical(other.originatorClientId, originatorClientId) ||
                const DeepCollectionEquality()
                    .equals(other.originatorClientId, originatorClientId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(startDate) ^
      const DeepCollectionEquality().hash(endDate) ^
      const DeepCollectionEquality().hash(count) ^
      const DeepCollectionEquality().hash(offset) ^
      const DeepCollectionEquality().hash(originationAccountId) ^
      const DeepCollectionEquality().hash(originatorClientId) ^
      runtimeType.hashCode;
}

extension $TransferListRequestExtension on TransferListRequest {
  TransferListRequest copyWith(
      {String? clientId,
      String? secret,
      DateTime? startDate,
      DateTime? endDate,
      int? count,
      int? offset,
      String? originationAccountId,
      String? originatorClientId}) {
    return TransferListRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        startDate: startDate ?? this.startDate,
        endDate: endDate ?? this.endDate,
        count: count ?? this.count,
        offset: offset ?? this.offset,
        originationAccountId: originationAccountId ?? this.originationAccountId,
        originatorClientId: originatorClientId ?? this.originatorClientId);
  }

  TransferListRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<DateTime?>? startDate,
      Wrapped<DateTime?>? endDate,
      Wrapped<int?>? count,
      Wrapped<int?>? offset,
      Wrapped<String?>? originationAccountId,
      Wrapped<String?>? originatorClientId}) {
    return TransferListRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        startDate: (startDate != null ? startDate.value : this.startDate),
        endDate: (endDate != null ? endDate.value : this.endDate),
        count: (count != null ? count.value : this.count),
        offset: (offset != null ? offset.value : this.offset),
        originationAccountId: (originationAccountId != null
            ? originationAccountId.value
            : this.originationAccountId),
        originatorClientId: (originatorClientId != null
            ? originatorClientId.value
            : this.originatorClientId));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferRecurringListRequest {
  TransferRecurringListRequest({
    required this.clientId,
    required this.secret,
    this.startDate,
    this.endDate,
    this.count,
    this.offset,
  });

  factory TransferRecurringListRequest.fromJson(Map<String, dynamic> json) =>
      _$TransferRecurringListRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String clientId;
  @JsonKey(name: 'secret')
  final String secret;
  @JsonKey(name: 'start_date')
  final DateTime? startDate;
  @JsonKey(name: 'end_date')
  final DateTime? endDate;
  @JsonKey(name: 'count')
  final int? count;
  @JsonKey(name: 'offset')
  final int? offset;
  static const fromJsonFactory = _$TransferRecurringListRequestFromJson;
  static const toJsonFactory = _$TransferRecurringListRequestToJson;
  Map<String, dynamic> toJson() => _$TransferRecurringListRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferRecurringListRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.startDate, startDate) ||
                const DeepCollectionEquality()
                    .equals(other.startDate, startDate)) &&
            (identical(other.endDate, endDate) ||
                const DeepCollectionEquality()
                    .equals(other.endDate, endDate)) &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)) &&
            (identical(other.offset, offset) ||
                const DeepCollectionEquality().equals(other.offset, offset)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(startDate) ^
      const DeepCollectionEquality().hash(endDate) ^
      const DeepCollectionEquality().hash(count) ^
      const DeepCollectionEquality().hash(offset) ^
      runtimeType.hashCode;
}

extension $TransferRecurringListRequestExtension
    on TransferRecurringListRequest {
  TransferRecurringListRequest copyWith(
      {String? clientId,
      String? secret,
      DateTime? startDate,
      DateTime? endDate,
      int? count,
      int? offset}) {
    return TransferRecurringListRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        startDate: startDate ?? this.startDate,
        endDate: endDate ?? this.endDate,
        count: count ?? this.count,
        offset: offset ?? this.offset);
  }

  TransferRecurringListRequest copyWithWrapped(
      {Wrapped<String>? clientId,
      Wrapped<String>? secret,
      Wrapped<DateTime?>? startDate,
      Wrapped<DateTime?>? endDate,
      Wrapped<int?>? count,
      Wrapped<int?>? offset}) {
    return TransferRecurringListRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        startDate: (startDate != null ? startDate.value : this.startDate),
        endDate: (endDate != null ? endDate.value : this.endDate),
        count: (count != null ? count.value : this.count),
        offset: (offset != null ? offset.value : this.offset));
  }
}

@JsonSerializable(explicitToJson: true)
class BankTransferListRequest {
  BankTransferListRequest({
    this.clientId,
    this.secret,
    this.startDate,
    this.endDate,
    this.count,
    this.offset,
    this.originationAccountId,
    this.direction,
  });

  factory BankTransferListRequest.fromJson(Map<String, dynamic> json) =>
      _$BankTransferListRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'start_date')
  final DateTime? startDate;
  @JsonKey(name: 'end_date')
  final DateTime? endDate;
  @JsonKey(name: 'count')
  final int? count;
  @JsonKey(name: 'offset')
  final int? offset;
  @JsonKey(name: 'origination_account_id')
  final String? originationAccountId;
  @JsonKey(
    name: 'direction',
    toJson: bankTransferDirectionToJson,
    fromJson: bankTransferDirectionFromJson,
  )
  final enums.BankTransferDirection? direction;
  static const fromJsonFactory = _$BankTransferListRequestFromJson;
  static const toJsonFactory = _$BankTransferListRequestToJson;
  Map<String, dynamic> toJson() => _$BankTransferListRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BankTransferListRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.startDate, startDate) ||
                const DeepCollectionEquality()
                    .equals(other.startDate, startDate)) &&
            (identical(other.endDate, endDate) ||
                const DeepCollectionEquality()
                    .equals(other.endDate, endDate)) &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)) &&
            (identical(other.offset, offset) ||
                const DeepCollectionEquality().equals(other.offset, offset)) &&
            (identical(other.originationAccountId, originationAccountId) ||
                const DeepCollectionEquality().equals(
                    other.originationAccountId, originationAccountId)) &&
            (identical(other.direction, direction) ||
                const DeepCollectionEquality()
                    .equals(other.direction, direction)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(startDate) ^
      const DeepCollectionEquality().hash(endDate) ^
      const DeepCollectionEquality().hash(count) ^
      const DeepCollectionEquality().hash(offset) ^
      const DeepCollectionEquality().hash(originationAccountId) ^
      const DeepCollectionEquality().hash(direction) ^
      runtimeType.hashCode;
}

extension $BankTransferListRequestExtension on BankTransferListRequest {
  BankTransferListRequest copyWith(
      {String? clientId,
      String? secret,
      DateTime? startDate,
      DateTime? endDate,
      int? count,
      int? offset,
      String? originationAccountId,
      enums.BankTransferDirection? direction}) {
    return BankTransferListRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        startDate: startDate ?? this.startDate,
        endDate: endDate ?? this.endDate,
        count: count ?? this.count,
        offset: offset ?? this.offset,
        originationAccountId: originationAccountId ?? this.originationAccountId,
        direction: direction ?? this.direction);
  }

  BankTransferListRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<DateTime?>? startDate,
      Wrapped<DateTime?>? endDate,
      Wrapped<int?>? count,
      Wrapped<int?>? offset,
      Wrapped<String?>? originationAccountId,
      Wrapped<enums.BankTransferDirection?>? direction}) {
    return BankTransferListRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        startDate: (startDate != null ? startDate.value : this.startDate),
        endDate: (endDate != null ? endDate.value : this.endDate),
        count: (count != null ? count.value : this.count),
        offset: (offset != null ? offset.value : this.offset),
        originationAccountId: (originationAccountId != null
            ? originationAccountId.value
            : this.originationAccountId),
        direction: (direction != null ? direction.value : this.direction));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferListResponse {
  TransferListResponse({
    required this.transfers,
    required this.requestId,
  });

  factory TransferListResponse.fromJson(Map<String, dynamic> json) =>
      _$TransferListResponseFromJson(json);

  @JsonKey(name: 'transfers', defaultValue: <Transfer>[])
  final List<Transfer> transfers;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$TransferListResponseFromJson;
  static const toJsonFactory = _$TransferListResponseToJson;
  Map<String, dynamic> toJson() => _$TransferListResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferListResponse &&
            (identical(other.transfers, transfers) ||
                const DeepCollectionEquality()
                    .equals(other.transfers, transfers)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(transfers) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $TransferListResponseExtension on TransferListResponse {
  TransferListResponse copyWith(
      {List<Transfer>? transfers, String? requestId}) {
    return TransferListResponse(
        transfers: transfers ?? this.transfers,
        requestId: requestId ?? this.requestId);
  }

  TransferListResponse copyWithWrapped(
      {Wrapped<List<Transfer>>? transfers, Wrapped<String>? requestId}) {
    return TransferListResponse(
        transfers: (transfers != null ? transfers.value : this.transfers),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferRecurringListResponse {
  TransferRecurringListResponse({
    required this.recurringTransfers,
    required this.requestId,
  });

  factory TransferRecurringListResponse.fromJson(Map<String, dynamic> json) =>
      _$TransferRecurringListResponseFromJson(json);

  @JsonKey(name: 'recurring_transfers', defaultValue: <RecurringTransfer>[])
  final List<RecurringTransfer> recurringTransfers;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$TransferRecurringListResponseFromJson;
  static const toJsonFactory = _$TransferRecurringListResponseToJson;
  Map<String, dynamic> toJson() => _$TransferRecurringListResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferRecurringListResponse &&
            (identical(other.recurringTransfers, recurringTransfers) ||
                const DeepCollectionEquality()
                    .equals(other.recurringTransfers, recurringTransfers)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(recurringTransfers) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $TransferRecurringListResponseExtension
    on TransferRecurringListResponse {
  TransferRecurringListResponse copyWith(
      {List<RecurringTransfer>? recurringTransfers, String? requestId}) {
    return TransferRecurringListResponse(
        recurringTransfers: recurringTransfers ?? this.recurringTransfers,
        requestId: requestId ?? this.requestId);
  }

  TransferRecurringListResponse copyWithWrapped(
      {Wrapped<List<RecurringTransfer>>? recurringTransfers,
      Wrapped<String>? requestId}) {
    return TransferRecurringListResponse(
        recurringTransfers: (recurringTransfers != null
            ? recurringTransfers.value
            : this.recurringTransfers),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class BankTransferListResponse {
  BankTransferListResponse({
    required this.bankTransfers,
    required this.requestId,
  });

  factory BankTransferListResponse.fromJson(Map<String, dynamic> json) =>
      _$BankTransferListResponseFromJson(json);

  @JsonKey(name: 'bank_transfers', defaultValue: <BankTransfer>[])
  final List<BankTransfer> bankTransfers;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$BankTransferListResponseFromJson;
  static const toJsonFactory = _$BankTransferListResponseToJson;
  Map<String, dynamic> toJson() => _$BankTransferListResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BankTransferListResponse &&
            (identical(other.bankTransfers, bankTransfers) ||
                const DeepCollectionEquality()
                    .equals(other.bankTransfers, bankTransfers)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(bankTransfers) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $BankTransferListResponseExtension on BankTransferListResponse {
  BankTransferListResponse copyWith(
      {List<BankTransfer>? bankTransfers, String? requestId}) {
    return BankTransferListResponse(
        bankTransfers: bankTransfers ?? this.bankTransfers,
        requestId: requestId ?? this.requestId);
  }

  BankTransferListResponse copyWithWrapped(
      {Wrapped<List<BankTransfer>>? bankTransfers,
      Wrapped<String>? requestId}) {
    return BankTransferListResponse(
        bankTransfers:
            (bankTransfers != null ? bankTransfers.value : this.bankTransfers),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferCancelRequest {
  TransferCancelRequest({
    this.clientId,
    this.secret,
    required this.transferId,
  });

  factory TransferCancelRequest.fromJson(Map<String, dynamic> json) =>
      _$TransferCancelRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'transfer_id')
  final String transferId;
  static const fromJsonFactory = _$TransferCancelRequestFromJson;
  static const toJsonFactory = _$TransferCancelRequestToJson;
  Map<String, dynamic> toJson() => _$TransferCancelRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferCancelRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.transferId, transferId) ||
                const DeepCollectionEquality()
                    .equals(other.transferId, transferId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(transferId) ^
      runtimeType.hashCode;
}

extension $TransferCancelRequestExtension on TransferCancelRequest {
  TransferCancelRequest copyWith(
      {String? clientId, String? secret, String? transferId}) {
    return TransferCancelRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        transferId: transferId ?? this.transferId);
  }

  TransferCancelRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? transferId}) {
    return TransferCancelRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        transferId: (transferId != null ? transferId.value : this.transferId));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferRecurringCancelRequest {
  TransferRecurringCancelRequest({
    required this.clientId,
    required this.secret,
    required this.recurringTransferId,
  });

  factory TransferRecurringCancelRequest.fromJson(Map<String, dynamic> json) =>
      _$TransferRecurringCancelRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String clientId;
  @JsonKey(name: 'secret')
  final String secret;
  @JsonKey(name: 'recurring_transfer_id')
  final String recurringTransferId;
  static const fromJsonFactory = _$TransferRecurringCancelRequestFromJson;
  static const toJsonFactory = _$TransferRecurringCancelRequestToJson;
  Map<String, dynamic> toJson() => _$TransferRecurringCancelRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferRecurringCancelRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.recurringTransferId, recurringTransferId) ||
                const DeepCollectionEquality()
                    .equals(other.recurringTransferId, recurringTransferId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(recurringTransferId) ^
      runtimeType.hashCode;
}

extension $TransferRecurringCancelRequestExtension
    on TransferRecurringCancelRequest {
  TransferRecurringCancelRequest copyWith(
      {String? clientId, String? secret, String? recurringTransferId}) {
    return TransferRecurringCancelRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        recurringTransferId: recurringTransferId ?? this.recurringTransferId);
  }

  TransferRecurringCancelRequest copyWithWrapped(
      {Wrapped<String>? clientId,
      Wrapped<String>? secret,
      Wrapped<String>? recurringTransferId}) {
    return TransferRecurringCancelRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        recurringTransferId: (recurringTransferId != null
            ? recurringTransferId.value
            : this.recurringTransferId));
  }
}

@JsonSerializable(explicitToJson: true)
class BankTransferCancelRequest {
  BankTransferCancelRequest({
    this.clientId,
    this.secret,
    required this.bankTransferId,
  });

  factory BankTransferCancelRequest.fromJson(Map<String, dynamic> json) =>
      _$BankTransferCancelRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'bank_transfer_id')
  final String bankTransferId;
  static const fromJsonFactory = _$BankTransferCancelRequestFromJson;
  static const toJsonFactory = _$BankTransferCancelRequestToJson;
  Map<String, dynamic> toJson() => _$BankTransferCancelRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BankTransferCancelRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.bankTransferId, bankTransferId) ||
                const DeepCollectionEquality()
                    .equals(other.bankTransferId, bankTransferId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(bankTransferId) ^
      runtimeType.hashCode;
}

extension $BankTransferCancelRequestExtension on BankTransferCancelRequest {
  BankTransferCancelRequest copyWith(
      {String? clientId, String? secret, String? bankTransferId}) {
    return BankTransferCancelRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        bankTransferId: bankTransferId ?? this.bankTransferId);
  }

  BankTransferCancelRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? bankTransferId}) {
    return BankTransferCancelRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        bankTransferId: (bankTransferId != null
            ? bankTransferId.value
            : this.bankTransferId));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferCancelResponse {
  TransferCancelResponse({
    required this.requestId,
  });

  factory TransferCancelResponse.fromJson(Map<String, dynamic> json) =>
      _$TransferCancelResponseFromJson(json);

  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$TransferCancelResponseFromJson;
  static const toJsonFactory = _$TransferCancelResponseToJson;
  Map<String, dynamic> toJson() => _$TransferCancelResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferCancelResponse &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(requestId) ^ runtimeType.hashCode;
}

extension $TransferCancelResponseExtension on TransferCancelResponse {
  TransferCancelResponse copyWith({String? requestId}) {
    return TransferCancelResponse(requestId: requestId ?? this.requestId);
  }

  TransferCancelResponse copyWithWrapped({Wrapped<String>? requestId}) {
    return TransferCancelResponse(
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferRecurringCancelResponse {
  TransferRecurringCancelResponse({
    required this.requestId,
  });

  factory TransferRecurringCancelResponse.fromJson(Map<String, dynamic> json) =>
      _$TransferRecurringCancelResponseFromJson(json);

  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$TransferRecurringCancelResponseFromJson;
  static const toJsonFactory = _$TransferRecurringCancelResponseToJson;
  Map<String, dynamic> toJson() =>
      _$TransferRecurringCancelResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferRecurringCancelResponse &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(requestId) ^ runtimeType.hashCode;
}

extension $TransferRecurringCancelResponseExtension
    on TransferRecurringCancelResponse {
  TransferRecurringCancelResponse copyWith({String? requestId}) {
    return TransferRecurringCancelResponse(
        requestId: requestId ?? this.requestId);
  }

  TransferRecurringCancelResponse copyWithWrapped(
      {Wrapped<String>? requestId}) {
    return TransferRecurringCancelResponse(
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class BankTransferCancelResponse {
  BankTransferCancelResponse({
    required this.requestId,
  });

  factory BankTransferCancelResponse.fromJson(Map<String, dynamic> json) =>
      _$BankTransferCancelResponseFromJson(json);

  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$BankTransferCancelResponseFromJson;
  static const toJsonFactory = _$BankTransferCancelResponseToJson;
  Map<String, dynamic> toJson() => _$BankTransferCancelResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BankTransferCancelResponse &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(requestId) ^ runtimeType.hashCode;
}

extension $BankTransferCancelResponseExtension on BankTransferCancelResponse {
  BankTransferCancelResponse copyWith({String? requestId}) {
    return BankTransferCancelResponse(requestId: requestId ?? this.requestId);
  }

  BankTransferCancelResponse copyWithWrapped({Wrapped<String>? requestId}) {
    return BankTransferCancelResponse(
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferEventListRequest {
  TransferEventListRequest({
    this.clientId,
    this.secret,
    this.startDate,
    this.endDate,
    this.transferId,
    this.accountId,
    this.transferType,
    this.eventTypes,
    this.sweepId,
    this.count,
    this.offset,
    this.originationAccountId,
    this.originatorClientId,
  });

  factory TransferEventListRequest.fromJson(Map<String, dynamic> json) =>
      _$TransferEventListRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'start_date')
  final DateTime? startDate;
  @JsonKey(name: 'end_date')
  final DateTime? endDate;
  @JsonKey(name: 'transfer_id')
  final String? transferId;
  @JsonKey(name: 'account_id')
  final String? accountId;
  @JsonKey(
    name: 'transfer_type',
    toJson: transferEventListTransferTypeToJson,
    fromJson: transferEventListTransferTypeFromJson,
  )
  final enums.TransferEventListTransferType? transferType;
  @JsonKey(
    name: 'event_types',
    toJson: transferEventTypeListToJson,
    fromJson: transferEventTypeListFromJson,
  )
  final List<enums.TransferEventType>? eventTypes;
  @JsonKey(name: 'sweep_id')
  final String? sweepId;
  @JsonKey(name: 'count')
  final int? count;
  @JsonKey(name: 'offset')
  final int? offset;
  @JsonKey(name: 'origination_account_id')
  final String? originationAccountId;
  @JsonKey(name: 'originator_client_id')
  final String? originatorClientId;
  static const fromJsonFactory = _$TransferEventListRequestFromJson;
  static const toJsonFactory = _$TransferEventListRequestToJson;
  Map<String, dynamic> toJson() => _$TransferEventListRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferEventListRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.startDate, startDate) ||
                const DeepCollectionEquality()
                    .equals(other.startDate, startDate)) &&
            (identical(other.endDate, endDate) ||
                const DeepCollectionEquality()
                    .equals(other.endDate, endDate)) &&
            (identical(other.transferId, transferId) ||
                const DeepCollectionEquality()
                    .equals(other.transferId, transferId)) &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.transferType, transferType) ||
                const DeepCollectionEquality()
                    .equals(other.transferType, transferType)) &&
            (identical(other.eventTypes, eventTypes) ||
                const DeepCollectionEquality()
                    .equals(other.eventTypes, eventTypes)) &&
            (identical(other.sweepId, sweepId) ||
                const DeepCollectionEquality()
                    .equals(other.sweepId, sweepId)) &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)) &&
            (identical(other.offset, offset) ||
                const DeepCollectionEquality().equals(other.offset, offset)) &&
            (identical(other.originationAccountId, originationAccountId) ||
                const DeepCollectionEquality().equals(
                    other.originationAccountId, originationAccountId)) &&
            (identical(other.originatorClientId, originatorClientId) ||
                const DeepCollectionEquality()
                    .equals(other.originatorClientId, originatorClientId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(startDate) ^
      const DeepCollectionEquality().hash(endDate) ^
      const DeepCollectionEquality().hash(transferId) ^
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(transferType) ^
      const DeepCollectionEquality().hash(eventTypes) ^
      const DeepCollectionEquality().hash(sweepId) ^
      const DeepCollectionEquality().hash(count) ^
      const DeepCollectionEquality().hash(offset) ^
      const DeepCollectionEquality().hash(originationAccountId) ^
      const DeepCollectionEquality().hash(originatorClientId) ^
      runtimeType.hashCode;
}

extension $TransferEventListRequestExtension on TransferEventListRequest {
  TransferEventListRequest copyWith(
      {String? clientId,
      String? secret,
      DateTime? startDate,
      DateTime? endDate,
      String? transferId,
      String? accountId,
      enums.TransferEventListTransferType? transferType,
      List<enums.TransferEventType>? eventTypes,
      String? sweepId,
      int? count,
      int? offset,
      String? originationAccountId,
      String? originatorClientId}) {
    return TransferEventListRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        startDate: startDate ?? this.startDate,
        endDate: endDate ?? this.endDate,
        transferId: transferId ?? this.transferId,
        accountId: accountId ?? this.accountId,
        transferType: transferType ?? this.transferType,
        eventTypes: eventTypes ?? this.eventTypes,
        sweepId: sweepId ?? this.sweepId,
        count: count ?? this.count,
        offset: offset ?? this.offset,
        originationAccountId: originationAccountId ?? this.originationAccountId,
        originatorClientId: originatorClientId ?? this.originatorClientId);
  }

  TransferEventListRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<DateTime?>? startDate,
      Wrapped<DateTime?>? endDate,
      Wrapped<String?>? transferId,
      Wrapped<String?>? accountId,
      Wrapped<enums.TransferEventListTransferType?>? transferType,
      Wrapped<List<enums.TransferEventType>?>? eventTypes,
      Wrapped<String?>? sweepId,
      Wrapped<int?>? count,
      Wrapped<int?>? offset,
      Wrapped<String?>? originationAccountId,
      Wrapped<String?>? originatorClientId}) {
    return TransferEventListRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        startDate: (startDate != null ? startDate.value : this.startDate),
        endDate: (endDate != null ? endDate.value : this.endDate),
        transferId: (transferId != null ? transferId.value : this.transferId),
        accountId: (accountId != null ? accountId.value : this.accountId),
        transferType:
            (transferType != null ? transferType.value : this.transferType),
        eventTypes: (eventTypes != null ? eventTypes.value : this.eventTypes),
        sweepId: (sweepId != null ? sweepId.value : this.sweepId),
        count: (count != null ? count.value : this.count),
        offset: (offset != null ? offset.value : this.offset),
        originationAccountId: (originationAccountId != null
            ? originationAccountId.value
            : this.originationAccountId),
        originatorClientId: (originatorClientId != null
            ? originatorClientId.value
            : this.originatorClientId));
  }
}

@JsonSerializable(explicitToJson: true)
class BankTransferEventListRequest {
  BankTransferEventListRequest({
    this.clientId,
    this.secret,
    this.startDate,
    this.endDate,
    this.bankTransferId,
    this.accountId,
    this.bankTransferType,
    this.eventTypes,
    this.count,
    this.offset,
    this.originationAccountId,
    this.direction,
  });

  factory BankTransferEventListRequest.fromJson(Map<String, dynamic> json) =>
      _$BankTransferEventListRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'start_date')
  final DateTime? startDate;
  @JsonKey(name: 'end_date')
  final DateTime? endDate;
  @JsonKey(name: 'bank_transfer_id')
  final String? bankTransferId;
  @JsonKey(name: 'account_id')
  final String? accountId;
  @JsonKey(
    name: 'bank_transfer_type',
    toJson: bankTransferEventListBankTransferTypeToJson,
    fromJson: bankTransferEventListBankTransferTypeFromJson,
  )
  final enums.BankTransferEventListBankTransferType? bankTransferType;
  @JsonKey(
    name: 'event_types',
    toJson: bankTransferEventTypeListToJson,
    fromJson: bankTransferEventTypeListFromJson,
  )
  final List<enums.BankTransferEventType>? eventTypes;
  @JsonKey(name: 'count')
  final int? count;
  @JsonKey(name: 'offset')
  final int? offset;
  @JsonKey(name: 'origination_account_id')
  final String? originationAccountId;
  @JsonKey(
    name: 'direction',
    toJson: bankTransferEventListDirectionToJson,
    fromJson: bankTransferEventListDirectionFromJson,
  )
  final enums.BankTransferEventListDirection? direction;
  static const fromJsonFactory = _$BankTransferEventListRequestFromJson;
  static const toJsonFactory = _$BankTransferEventListRequestToJson;
  Map<String, dynamic> toJson() => _$BankTransferEventListRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BankTransferEventListRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.startDate, startDate) ||
                const DeepCollectionEquality()
                    .equals(other.startDate, startDate)) &&
            (identical(other.endDate, endDate) ||
                const DeepCollectionEquality()
                    .equals(other.endDate, endDate)) &&
            (identical(other.bankTransferId, bankTransferId) ||
                const DeepCollectionEquality()
                    .equals(other.bankTransferId, bankTransferId)) &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.bankTransferType, bankTransferType) ||
                const DeepCollectionEquality()
                    .equals(other.bankTransferType, bankTransferType)) &&
            (identical(other.eventTypes, eventTypes) ||
                const DeepCollectionEquality()
                    .equals(other.eventTypes, eventTypes)) &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)) &&
            (identical(other.offset, offset) ||
                const DeepCollectionEquality().equals(other.offset, offset)) &&
            (identical(other.originationAccountId, originationAccountId) ||
                const DeepCollectionEquality().equals(
                    other.originationAccountId, originationAccountId)) &&
            (identical(other.direction, direction) ||
                const DeepCollectionEquality()
                    .equals(other.direction, direction)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(startDate) ^
      const DeepCollectionEquality().hash(endDate) ^
      const DeepCollectionEquality().hash(bankTransferId) ^
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(bankTransferType) ^
      const DeepCollectionEquality().hash(eventTypes) ^
      const DeepCollectionEquality().hash(count) ^
      const DeepCollectionEquality().hash(offset) ^
      const DeepCollectionEquality().hash(originationAccountId) ^
      const DeepCollectionEquality().hash(direction) ^
      runtimeType.hashCode;
}

extension $BankTransferEventListRequestExtension
    on BankTransferEventListRequest {
  BankTransferEventListRequest copyWith(
      {String? clientId,
      String? secret,
      DateTime? startDate,
      DateTime? endDate,
      String? bankTransferId,
      String? accountId,
      enums.BankTransferEventListBankTransferType? bankTransferType,
      List<enums.BankTransferEventType>? eventTypes,
      int? count,
      int? offset,
      String? originationAccountId,
      enums.BankTransferEventListDirection? direction}) {
    return BankTransferEventListRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        startDate: startDate ?? this.startDate,
        endDate: endDate ?? this.endDate,
        bankTransferId: bankTransferId ?? this.bankTransferId,
        accountId: accountId ?? this.accountId,
        bankTransferType: bankTransferType ?? this.bankTransferType,
        eventTypes: eventTypes ?? this.eventTypes,
        count: count ?? this.count,
        offset: offset ?? this.offset,
        originationAccountId: originationAccountId ?? this.originationAccountId,
        direction: direction ?? this.direction);
  }

  BankTransferEventListRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<DateTime?>? startDate,
      Wrapped<DateTime?>? endDate,
      Wrapped<String?>? bankTransferId,
      Wrapped<String?>? accountId,
      Wrapped<enums.BankTransferEventListBankTransferType?>? bankTransferType,
      Wrapped<List<enums.BankTransferEventType>?>? eventTypes,
      Wrapped<int?>? count,
      Wrapped<int?>? offset,
      Wrapped<String?>? originationAccountId,
      Wrapped<enums.BankTransferEventListDirection?>? direction}) {
    return BankTransferEventListRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        startDate: (startDate != null ? startDate.value : this.startDate),
        endDate: (endDate != null ? endDate.value : this.endDate),
        bankTransferId: (bankTransferId != null
            ? bankTransferId.value
            : this.bankTransferId),
        accountId: (accountId != null ? accountId.value : this.accountId),
        bankTransferType: (bankTransferType != null
            ? bankTransferType.value
            : this.bankTransferType),
        eventTypes: (eventTypes != null ? eventTypes.value : this.eventTypes),
        count: (count != null ? count.value : this.count),
        offset: (offset != null ? offset.value : this.offset),
        originationAccountId: (originationAccountId != null
            ? originationAccountId.value
            : this.originationAccountId),
        direction: (direction != null ? direction.value : this.direction));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferEvent {
  TransferEvent({
    required this.eventId,
    required this.timestamp,
    required this.eventType,
    required this.accountId,
    required this.transferId,
    required this.originationAccountId,
    required this.transferType,
    required this.transferAmount,
    required this.failureReason,
    required this.sweepId,
    required this.sweepAmount,
    required this.refundId,
    required this.originatorClientId,
  });

  factory TransferEvent.fromJson(Map<String, dynamic> json) =>
      _$TransferEventFromJson(json);

  @JsonKey(name: 'event_id')
  final int eventId;
  @JsonKey(name: 'timestamp')
  final DateTime timestamp;
  @JsonKey(
    name: 'event_type',
    toJson: transferEventTypeToJson,
    fromJson: transferEventTypeFromJson,
  )
  final enums.TransferEventType eventType;
  @JsonKey(name: 'account_id')
  final String accountId;
  @JsonKey(name: 'transfer_id')
  final String transferId;
  @JsonKey(name: 'origination_account_id')
  final String? originationAccountId;
  @JsonKey(
    name: 'transfer_type',
    toJson: transferTypeToJson,
    fromJson: transferTypeFromJson,
  )
  final enums.TransferType transferType;
  @JsonKey(name: 'transfer_amount')
  final String transferAmount;
  @JsonKey(name: 'failure_reason')
  final TransferFailure? failureReason;
  @JsonKey(name: 'sweep_id')
  final String? sweepId;
  @JsonKey(name: 'sweep_amount')
  final String? sweepAmount;
  @JsonKey(name: 'refund_id')
  final String? refundId;
  @JsonKey(name: 'originator_client_id')
  final String? originatorClientId;
  static const fromJsonFactory = _$TransferEventFromJson;
  static const toJsonFactory = _$TransferEventToJson;
  Map<String, dynamic> toJson() => _$TransferEventToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferEvent &&
            (identical(other.eventId, eventId) ||
                const DeepCollectionEquality()
                    .equals(other.eventId, eventId)) &&
            (identical(other.timestamp, timestamp) ||
                const DeepCollectionEquality()
                    .equals(other.timestamp, timestamp)) &&
            (identical(other.eventType, eventType) ||
                const DeepCollectionEquality()
                    .equals(other.eventType, eventType)) &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.transferId, transferId) ||
                const DeepCollectionEquality()
                    .equals(other.transferId, transferId)) &&
            (identical(other.originationAccountId, originationAccountId) ||
                const DeepCollectionEquality().equals(
                    other.originationAccountId, originationAccountId)) &&
            (identical(other.transferType, transferType) ||
                const DeepCollectionEquality()
                    .equals(other.transferType, transferType)) &&
            (identical(other.transferAmount, transferAmount) ||
                const DeepCollectionEquality()
                    .equals(other.transferAmount, transferAmount)) &&
            (identical(other.failureReason, failureReason) ||
                const DeepCollectionEquality()
                    .equals(other.failureReason, failureReason)) &&
            (identical(other.sweepId, sweepId) ||
                const DeepCollectionEquality()
                    .equals(other.sweepId, sweepId)) &&
            (identical(other.sweepAmount, sweepAmount) ||
                const DeepCollectionEquality()
                    .equals(other.sweepAmount, sweepAmount)) &&
            (identical(other.refundId, refundId) ||
                const DeepCollectionEquality()
                    .equals(other.refundId, refundId)) &&
            (identical(other.originatorClientId, originatorClientId) ||
                const DeepCollectionEquality()
                    .equals(other.originatorClientId, originatorClientId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(eventId) ^
      const DeepCollectionEquality().hash(timestamp) ^
      const DeepCollectionEquality().hash(eventType) ^
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(transferId) ^
      const DeepCollectionEquality().hash(originationAccountId) ^
      const DeepCollectionEquality().hash(transferType) ^
      const DeepCollectionEquality().hash(transferAmount) ^
      const DeepCollectionEquality().hash(failureReason) ^
      const DeepCollectionEquality().hash(sweepId) ^
      const DeepCollectionEquality().hash(sweepAmount) ^
      const DeepCollectionEquality().hash(refundId) ^
      const DeepCollectionEquality().hash(originatorClientId) ^
      runtimeType.hashCode;
}

extension $TransferEventExtension on TransferEvent {
  TransferEvent copyWith(
      {int? eventId,
      DateTime? timestamp,
      enums.TransferEventType? eventType,
      String? accountId,
      String? transferId,
      String? originationAccountId,
      enums.TransferType? transferType,
      String? transferAmount,
      TransferFailure? failureReason,
      String? sweepId,
      String? sweepAmount,
      String? refundId,
      String? originatorClientId}) {
    return TransferEvent(
        eventId: eventId ?? this.eventId,
        timestamp: timestamp ?? this.timestamp,
        eventType: eventType ?? this.eventType,
        accountId: accountId ?? this.accountId,
        transferId: transferId ?? this.transferId,
        originationAccountId: originationAccountId ?? this.originationAccountId,
        transferType: transferType ?? this.transferType,
        transferAmount: transferAmount ?? this.transferAmount,
        failureReason: failureReason ?? this.failureReason,
        sweepId: sweepId ?? this.sweepId,
        sweepAmount: sweepAmount ?? this.sweepAmount,
        refundId: refundId ?? this.refundId,
        originatorClientId: originatorClientId ?? this.originatorClientId);
  }

  TransferEvent copyWithWrapped(
      {Wrapped<int>? eventId,
      Wrapped<DateTime>? timestamp,
      Wrapped<enums.TransferEventType>? eventType,
      Wrapped<String>? accountId,
      Wrapped<String>? transferId,
      Wrapped<String?>? originationAccountId,
      Wrapped<enums.TransferType>? transferType,
      Wrapped<String>? transferAmount,
      Wrapped<TransferFailure?>? failureReason,
      Wrapped<String?>? sweepId,
      Wrapped<String?>? sweepAmount,
      Wrapped<String?>? refundId,
      Wrapped<String?>? originatorClientId}) {
    return TransferEvent(
        eventId: (eventId != null ? eventId.value : this.eventId),
        timestamp: (timestamp != null ? timestamp.value : this.timestamp),
        eventType: (eventType != null ? eventType.value : this.eventType),
        accountId: (accountId != null ? accountId.value : this.accountId),
        transferId: (transferId != null ? transferId.value : this.transferId),
        originationAccountId: (originationAccountId != null
            ? originationAccountId.value
            : this.originationAccountId),
        transferType:
            (transferType != null ? transferType.value : this.transferType),
        transferAmount: (transferAmount != null
            ? transferAmount.value
            : this.transferAmount),
        failureReason:
            (failureReason != null ? failureReason.value : this.failureReason),
        sweepId: (sweepId != null ? sweepId.value : this.sweepId),
        sweepAmount:
            (sweepAmount != null ? sweepAmount.value : this.sweepAmount),
        refundId: (refundId != null ? refundId.value : this.refundId),
        originatorClientId: (originatorClientId != null
            ? originatorClientId.value
            : this.originatorClientId));
  }
}

@JsonSerializable(explicitToJson: true)
class BankTransferEvent {
  BankTransferEvent({
    required this.eventId,
    required this.timestamp,
    required this.eventType,
    required this.accountId,
    required this.bankTransferId,
    required this.originationAccountId,
    required this.bankTransferType,
    required this.bankTransferAmount,
    required this.bankTransferIsoCurrencyCode,
    required this.failureReason,
    required this.direction,
  });

  factory BankTransferEvent.fromJson(Map<String, dynamic> json) =>
      _$BankTransferEventFromJson(json);

  @JsonKey(name: 'event_id')
  final int eventId;
  @JsonKey(name: 'timestamp')
  final DateTime timestamp;
  @JsonKey(
    name: 'event_type',
    toJson: bankTransferEventTypeToJson,
    fromJson: bankTransferEventTypeFromJson,
  )
  final enums.BankTransferEventType eventType;
  @JsonKey(name: 'account_id')
  final String accountId;
  @JsonKey(name: 'bank_transfer_id')
  final String bankTransferId;
  @JsonKey(name: 'origination_account_id')
  final String? originationAccountId;
  @JsonKey(
    name: 'bank_transfer_type',
    toJson: bankTransferTypeToJson,
    fromJson: bankTransferTypeFromJson,
  )
  final enums.BankTransferType bankTransferType;
  @JsonKey(name: 'bank_transfer_amount')
  final String bankTransferAmount;
  @JsonKey(name: 'bank_transfer_iso_currency_code')
  final String bankTransferIsoCurrencyCode;
  @JsonKey(name: 'failure_reason')
  final BankTransferFailure? failureReason;
  @JsonKey(
    name: 'direction',
    toJson: bankTransferDirectionToJson,
    fromJson: bankTransferDirectionFromJson,
  )
  final enums.BankTransferDirection? direction;
  static const fromJsonFactory = _$BankTransferEventFromJson;
  static const toJsonFactory = _$BankTransferEventToJson;
  Map<String, dynamic> toJson() => _$BankTransferEventToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BankTransferEvent &&
            (identical(other.eventId, eventId) ||
                const DeepCollectionEquality()
                    .equals(other.eventId, eventId)) &&
            (identical(other.timestamp, timestamp) ||
                const DeepCollectionEquality()
                    .equals(other.timestamp, timestamp)) &&
            (identical(other.eventType, eventType) ||
                const DeepCollectionEquality()
                    .equals(other.eventType, eventType)) &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.bankTransferId, bankTransferId) ||
                const DeepCollectionEquality()
                    .equals(other.bankTransferId, bankTransferId)) &&
            (identical(other.originationAccountId, originationAccountId) ||
                const DeepCollectionEquality().equals(
                    other.originationAccountId, originationAccountId)) &&
            (identical(other.bankTransferType, bankTransferType) ||
                const DeepCollectionEquality()
                    .equals(other.bankTransferType, bankTransferType)) &&
            (identical(other.bankTransferAmount, bankTransferAmount) ||
                const DeepCollectionEquality()
                    .equals(other.bankTransferAmount, bankTransferAmount)) &&
            (identical(other.bankTransferIsoCurrencyCode,
                    bankTransferIsoCurrencyCode) ||
                const DeepCollectionEquality().equals(
                    other.bankTransferIsoCurrencyCode,
                    bankTransferIsoCurrencyCode)) &&
            (identical(other.failureReason, failureReason) ||
                const DeepCollectionEquality()
                    .equals(other.failureReason, failureReason)) &&
            (identical(other.direction, direction) ||
                const DeepCollectionEquality()
                    .equals(other.direction, direction)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(eventId) ^
      const DeepCollectionEquality().hash(timestamp) ^
      const DeepCollectionEquality().hash(eventType) ^
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(bankTransferId) ^
      const DeepCollectionEquality().hash(originationAccountId) ^
      const DeepCollectionEquality().hash(bankTransferType) ^
      const DeepCollectionEquality().hash(bankTransferAmount) ^
      const DeepCollectionEquality().hash(bankTransferIsoCurrencyCode) ^
      const DeepCollectionEquality().hash(failureReason) ^
      const DeepCollectionEquality().hash(direction) ^
      runtimeType.hashCode;
}

extension $BankTransferEventExtension on BankTransferEvent {
  BankTransferEvent copyWith(
      {int? eventId,
      DateTime? timestamp,
      enums.BankTransferEventType? eventType,
      String? accountId,
      String? bankTransferId,
      String? originationAccountId,
      enums.BankTransferType? bankTransferType,
      String? bankTransferAmount,
      String? bankTransferIsoCurrencyCode,
      BankTransferFailure? failureReason,
      enums.BankTransferDirection? direction}) {
    return BankTransferEvent(
        eventId: eventId ?? this.eventId,
        timestamp: timestamp ?? this.timestamp,
        eventType: eventType ?? this.eventType,
        accountId: accountId ?? this.accountId,
        bankTransferId: bankTransferId ?? this.bankTransferId,
        originationAccountId: originationAccountId ?? this.originationAccountId,
        bankTransferType: bankTransferType ?? this.bankTransferType,
        bankTransferAmount: bankTransferAmount ?? this.bankTransferAmount,
        bankTransferIsoCurrencyCode:
            bankTransferIsoCurrencyCode ?? this.bankTransferIsoCurrencyCode,
        failureReason: failureReason ?? this.failureReason,
        direction: direction ?? this.direction);
  }

  BankTransferEvent copyWithWrapped(
      {Wrapped<int>? eventId,
      Wrapped<DateTime>? timestamp,
      Wrapped<enums.BankTransferEventType>? eventType,
      Wrapped<String>? accountId,
      Wrapped<String>? bankTransferId,
      Wrapped<String?>? originationAccountId,
      Wrapped<enums.BankTransferType>? bankTransferType,
      Wrapped<String>? bankTransferAmount,
      Wrapped<String>? bankTransferIsoCurrencyCode,
      Wrapped<BankTransferFailure?>? failureReason,
      Wrapped<enums.BankTransferDirection?>? direction}) {
    return BankTransferEvent(
        eventId: (eventId != null ? eventId.value : this.eventId),
        timestamp: (timestamp != null ? timestamp.value : this.timestamp),
        eventType: (eventType != null ? eventType.value : this.eventType),
        accountId: (accountId != null ? accountId.value : this.accountId),
        bankTransferId: (bankTransferId != null
            ? bankTransferId.value
            : this.bankTransferId),
        originationAccountId: (originationAccountId != null
            ? originationAccountId.value
            : this.originationAccountId),
        bankTransferType: (bankTransferType != null
            ? bankTransferType.value
            : this.bankTransferType),
        bankTransferAmount: (bankTransferAmount != null
            ? bankTransferAmount.value
            : this.bankTransferAmount),
        bankTransferIsoCurrencyCode: (bankTransferIsoCurrencyCode != null
            ? bankTransferIsoCurrencyCode.value
            : this.bankTransferIsoCurrencyCode),
        failureReason:
            (failureReason != null ? failureReason.value : this.failureReason),
        direction: (direction != null ? direction.value : this.direction));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferEventListResponse {
  TransferEventListResponse({
    required this.transferEvents,
    required this.requestId,
  });

  factory TransferEventListResponse.fromJson(Map<String, dynamic> json) =>
      _$TransferEventListResponseFromJson(json);

  @JsonKey(name: 'transfer_events', defaultValue: <TransferEvent>[])
  final List<TransferEvent> transferEvents;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$TransferEventListResponseFromJson;
  static const toJsonFactory = _$TransferEventListResponseToJson;
  Map<String, dynamic> toJson() => _$TransferEventListResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferEventListResponse &&
            (identical(other.transferEvents, transferEvents) ||
                const DeepCollectionEquality()
                    .equals(other.transferEvents, transferEvents)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(transferEvents) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $TransferEventListResponseExtension on TransferEventListResponse {
  TransferEventListResponse copyWith(
      {List<TransferEvent>? transferEvents, String? requestId}) {
    return TransferEventListResponse(
        transferEvents: transferEvents ?? this.transferEvents,
        requestId: requestId ?? this.requestId);
  }

  TransferEventListResponse copyWithWrapped(
      {Wrapped<List<TransferEvent>>? transferEvents,
      Wrapped<String>? requestId}) {
    return TransferEventListResponse(
        transferEvents: (transferEvents != null
            ? transferEvents.value
            : this.transferEvents),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class BankTransferEventListResponse {
  BankTransferEventListResponse({
    required this.bankTransferEvents,
    required this.requestId,
  });

  factory BankTransferEventListResponse.fromJson(Map<String, dynamic> json) =>
      _$BankTransferEventListResponseFromJson(json);

  @JsonKey(name: 'bank_transfer_events', defaultValue: <BankTransferEvent>[])
  final List<BankTransferEvent> bankTransferEvents;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$BankTransferEventListResponseFromJson;
  static const toJsonFactory = _$BankTransferEventListResponseToJson;
  Map<String, dynamic> toJson() => _$BankTransferEventListResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BankTransferEventListResponse &&
            (identical(other.bankTransferEvents, bankTransferEvents) ||
                const DeepCollectionEquality()
                    .equals(other.bankTransferEvents, bankTransferEvents)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(bankTransferEvents) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $BankTransferEventListResponseExtension
    on BankTransferEventListResponse {
  BankTransferEventListResponse copyWith(
      {List<BankTransferEvent>? bankTransferEvents, String? requestId}) {
    return BankTransferEventListResponse(
        bankTransferEvents: bankTransferEvents ?? this.bankTransferEvents,
        requestId: requestId ?? this.requestId);
  }

  BankTransferEventListResponse copyWithWrapped(
      {Wrapped<List<BankTransferEvent>>? bankTransferEvents,
      Wrapped<String>? requestId}) {
    return BankTransferEventListResponse(
        bankTransferEvents: (bankTransferEvents != null
            ? bankTransferEvents.value
            : this.bankTransferEvents),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class BankTransferEventSyncRequest {
  BankTransferEventSyncRequest({
    this.clientId,
    this.secret,
    required this.afterId,
    this.count,
  });

  factory BankTransferEventSyncRequest.fromJson(Map<String, dynamic> json) =>
      _$BankTransferEventSyncRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'after_id')
  final int afterId;
  @JsonKey(name: 'count')
  final int? count;
  static const fromJsonFactory = _$BankTransferEventSyncRequestFromJson;
  static const toJsonFactory = _$BankTransferEventSyncRequestToJson;
  Map<String, dynamic> toJson() => _$BankTransferEventSyncRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BankTransferEventSyncRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.afterId, afterId) ||
                const DeepCollectionEquality()
                    .equals(other.afterId, afterId)) &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(afterId) ^
      const DeepCollectionEquality().hash(count) ^
      runtimeType.hashCode;
}

extension $BankTransferEventSyncRequestExtension
    on BankTransferEventSyncRequest {
  BankTransferEventSyncRequest copyWith(
      {String? clientId, String? secret, int? afterId, int? count}) {
    return BankTransferEventSyncRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        afterId: afterId ?? this.afterId,
        count: count ?? this.count);
  }

  BankTransferEventSyncRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<int>? afterId,
      Wrapped<int?>? count}) {
    return BankTransferEventSyncRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        afterId: (afterId != null ? afterId.value : this.afterId),
        count: (count != null ? count.value : this.count));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferEventSyncRequest {
  TransferEventSyncRequest({
    this.clientId,
    this.secret,
    required this.afterId,
    this.count,
  });

  factory TransferEventSyncRequest.fromJson(Map<String, dynamic> json) =>
      _$TransferEventSyncRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'after_id')
  final int afterId;
  @JsonKey(name: 'count')
  final int? count;
  static const fromJsonFactory = _$TransferEventSyncRequestFromJson;
  static const toJsonFactory = _$TransferEventSyncRequestToJson;
  Map<String, dynamic> toJson() => _$TransferEventSyncRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferEventSyncRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.afterId, afterId) ||
                const DeepCollectionEquality()
                    .equals(other.afterId, afterId)) &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(afterId) ^
      const DeepCollectionEquality().hash(count) ^
      runtimeType.hashCode;
}

extension $TransferEventSyncRequestExtension on TransferEventSyncRequest {
  TransferEventSyncRequest copyWith(
      {String? clientId, String? secret, int? afterId, int? count}) {
    return TransferEventSyncRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        afterId: afterId ?? this.afterId,
        count: count ?? this.count);
  }

  TransferEventSyncRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<int>? afterId,
      Wrapped<int?>? count}) {
    return TransferEventSyncRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        afterId: (afterId != null ? afterId.value : this.afterId),
        count: (count != null ? count.value : this.count));
  }
}

@JsonSerializable(explicitToJson: true)
class BankTransferEventSyncResponse {
  BankTransferEventSyncResponse({
    required this.bankTransferEvents,
    required this.requestId,
  });

  factory BankTransferEventSyncResponse.fromJson(Map<String, dynamic> json) =>
      _$BankTransferEventSyncResponseFromJson(json);

  @JsonKey(name: 'bank_transfer_events', defaultValue: <BankTransferEvent>[])
  final List<BankTransferEvent> bankTransferEvents;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$BankTransferEventSyncResponseFromJson;
  static const toJsonFactory = _$BankTransferEventSyncResponseToJson;
  Map<String, dynamic> toJson() => _$BankTransferEventSyncResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BankTransferEventSyncResponse &&
            (identical(other.bankTransferEvents, bankTransferEvents) ||
                const DeepCollectionEquality()
                    .equals(other.bankTransferEvents, bankTransferEvents)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(bankTransferEvents) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $BankTransferEventSyncResponseExtension
    on BankTransferEventSyncResponse {
  BankTransferEventSyncResponse copyWith(
      {List<BankTransferEvent>? bankTransferEvents, String? requestId}) {
    return BankTransferEventSyncResponse(
        bankTransferEvents: bankTransferEvents ?? this.bankTransferEvents,
        requestId: requestId ?? this.requestId);
  }

  BankTransferEventSyncResponse copyWithWrapped(
      {Wrapped<List<BankTransferEvent>>? bankTransferEvents,
      Wrapped<String>? requestId}) {
    return BankTransferEventSyncResponse(
        bankTransferEvents: (bankTransferEvents != null
            ? bankTransferEvents.value
            : this.bankTransferEvents),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferEventSyncResponse {
  TransferEventSyncResponse({
    required this.transferEvents,
    required this.requestId,
  });

  factory TransferEventSyncResponse.fromJson(Map<String, dynamic> json) =>
      _$TransferEventSyncResponseFromJson(json);

  @JsonKey(name: 'transfer_events', defaultValue: <TransferEvent>[])
  final List<TransferEvent> transferEvents;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$TransferEventSyncResponseFromJson;
  static const toJsonFactory = _$TransferEventSyncResponseToJson;
  Map<String, dynamic> toJson() => _$TransferEventSyncResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferEventSyncResponse &&
            (identical(other.transferEvents, transferEvents) ||
                const DeepCollectionEquality()
                    .equals(other.transferEvents, transferEvents)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(transferEvents) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $TransferEventSyncResponseExtension on TransferEventSyncResponse {
  TransferEventSyncResponse copyWith(
      {List<TransferEvent>? transferEvents, String? requestId}) {
    return TransferEventSyncResponse(
        transferEvents: transferEvents ?? this.transferEvents,
        requestId: requestId ?? this.requestId);
  }

  TransferEventSyncResponse copyWithWrapped(
      {Wrapped<List<TransferEvent>>? transferEvents,
      Wrapped<String>? requestId}) {
    return TransferEventSyncResponse(
        transferEvents: (transferEvents != null
            ? transferEvents.value
            : this.transferEvents),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class BankTransferSweepGetRequest {
  BankTransferSweepGetRequest({
    this.clientId,
    this.secret,
    required this.sweepId,
  });

  factory BankTransferSweepGetRequest.fromJson(Map<String, dynamic> json) =>
      _$BankTransferSweepGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'sweep_id')
  final String sweepId;
  static const fromJsonFactory = _$BankTransferSweepGetRequestFromJson;
  static const toJsonFactory = _$BankTransferSweepGetRequestToJson;
  Map<String, dynamic> toJson() => _$BankTransferSweepGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BankTransferSweepGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.sweepId, sweepId) ||
                const DeepCollectionEquality().equals(other.sweepId, sweepId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(sweepId) ^
      runtimeType.hashCode;
}

extension $BankTransferSweepGetRequestExtension on BankTransferSweepGetRequest {
  BankTransferSweepGetRequest copyWith(
      {String? clientId, String? secret, String? sweepId}) {
    return BankTransferSweepGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        sweepId: sweepId ?? this.sweepId);
  }

  BankTransferSweepGetRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? sweepId}) {
    return BankTransferSweepGetRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        sweepId: (sweepId != null ? sweepId.value : this.sweepId));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferSweepGetRequest {
  TransferSweepGetRequest({
    this.clientId,
    this.secret,
    required this.sweepId,
  });

  factory TransferSweepGetRequest.fromJson(Map<String, dynamic> json) =>
      _$TransferSweepGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'sweep_id')
  final String sweepId;
  static const fromJsonFactory = _$TransferSweepGetRequestFromJson;
  static const toJsonFactory = _$TransferSweepGetRequestToJson;
  Map<String, dynamic> toJson() => _$TransferSweepGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferSweepGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.sweepId, sweepId) ||
                const DeepCollectionEquality().equals(other.sweepId, sweepId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(sweepId) ^
      runtimeType.hashCode;
}

extension $TransferSweepGetRequestExtension on TransferSweepGetRequest {
  TransferSweepGetRequest copyWith(
      {String? clientId, String? secret, String? sweepId}) {
    return TransferSweepGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        sweepId: sweepId ?? this.sweepId);
  }

  TransferSweepGetRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? sweepId}) {
    return TransferSweepGetRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        sweepId: (sweepId != null ? sweepId.value : this.sweepId));
  }
}

@JsonSerializable(explicitToJson: true)
class BankTransferSweepGetResponse {
  BankTransferSweepGetResponse({
    required this.sweep,
    required this.requestId,
  });

  factory BankTransferSweepGetResponse.fromJson(Map<String, dynamic> json) =>
      _$BankTransferSweepGetResponseFromJson(json);

  @JsonKey(name: 'sweep')
  final BankTransferSweep sweep;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$BankTransferSweepGetResponseFromJson;
  static const toJsonFactory = _$BankTransferSweepGetResponseToJson;
  Map<String, dynamic> toJson() => _$BankTransferSweepGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BankTransferSweepGetResponse &&
            (identical(other.sweep, sweep) ||
                const DeepCollectionEquality().equals(other.sweep, sweep)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(sweep) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $BankTransferSweepGetResponseExtension
    on BankTransferSweepGetResponse {
  BankTransferSweepGetResponse copyWith(
      {BankTransferSweep? sweep, String? requestId}) {
    return BankTransferSweepGetResponse(
        sweep: sweep ?? this.sweep, requestId: requestId ?? this.requestId);
  }

  BankTransferSweepGetResponse copyWithWrapped(
      {Wrapped<BankTransferSweep>? sweep, Wrapped<String>? requestId}) {
    return BankTransferSweepGetResponse(
        sweep: (sweep != null ? sweep.value : this.sweep),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferSweepGetResponse {
  TransferSweepGetResponse({
    required this.sweep,
    required this.requestId,
  });

  factory TransferSweepGetResponse.fromJson(Map<String, dynamic> json) =>
      _$TransferSweepGetResponseFromJson(json);

  @JsonKey(name: 'sweep')
  final TransferSweep sweep;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$TransferSweepGetResponseFromJson;
  static const toJsonFactory = _$TransferSweepGetResponseToJson;
  Map<String, dynamic> toJson() => _$TransferSweepGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferSweepGetResponse &&
            (identical(other.sweep, sweep) ||
                const DeepCollectionEquality().equals(other.sweep, sweep)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(sweep) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $TransferSweepGetResponseExtension on TransferSweepGetResponse {
  TransferSweepGetResponse copyWith({TransferSweep? sweep, String? requestId}) {
    return TransferSweepGetResponse(
        sweep: sweep ?? this.sweep, requestId: requestId ?? this.requestId);
  }

  TransferSweepGetResponse copyWithWrapped(
      {Wrapped<TransferSweep>? sweep, Wrapped<String>? requestId}) {
    return TransferSweepGetResponse(
        sweep: (sweep != null ? sweep.value : this.sweep),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class BankTransferSweepListRequest {
  BankTransferSweepListRequest({
    this.clientId,
    this.secret,
    this.originationAccountId,
    this.startTime,
    this.endTime,
    this.count,
  });

  factory BankTransferSweepListRequest.fromJson(Map<String, dynamic> json) =>
      _$BankTransferSweepListRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'origination_account_id')
  final String? originationAccountId;
  @JsonKey(name: 'start_time')
  final DateTime? startTime;
  @JsonKey(name: 'end_time')
  final DateTime? endTime;
  @JsonKey(name: 'count')
  final int? count;
  static const fromJsonFactory = _$BankTransferSweepListRequestFromJson;
  static const toJsonFactory = _$BankTransferSweepListRequestToJson;
  Map<String, dynamic> toJson() => _$BankTransferSweepListRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BankTransferSweepListRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.originationAccountId, originationAccountId) ||
                const DeepCollectionEquality().equals(
                    other.originationAccountId, originationAccountId)) &&
            (identical(other.startTime, startTime) ||
                const DeepCollectionEquality()
                    .equals(other.startTime, startTime)) &&
            (identical(other.endTime, endTime) ||
                const DeepCollectionEquality()
                    .equals(other.endTime, endTime)) &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(originationAccountId) ^
      const DeepCollectionEquality().hash(startTime) ^
      const DeepCollectionEquality().hash(endTime) ^
      const DeepCollectionEquality().hash(count) ^
      runtimeType.hashCode;
}

extension $BankTransferSweepListRequestExtension
    on BankTransferSweepListRequest {
  BankTransferSweepListRequest copyWith(
      {String? clientId,
      String? secret,
      String? originationAccountId,
      DateTime? startTime,
      DateTime? endTime,
      int? count}) {
    return BankTransferSweepListRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        originationAccountId: originationAccountId ?? this.originationAccountId,
        startTime: startTime ?? this.startTime,
        endTime: endTime ?? this.endTime,
        count: count ?? this.count);
  }

  BankTransferSweepListRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String?>? originationAccountId,
      Wrapped<DateTime?>? startTime,
      Wrapped<DateTime?>? endTime,
      Wrapped<int?>? count}) {
    return BankTransferSweepListRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        originationAccountId: (originationAccountId != null
            ? originationAccountId.value
            : this.originationAccountId),
        startTime: (startTime != null ? startTime.value : this.startTime),
        endTime: (endTime != null ? endTime.value : this.endTime),
        count: (count != null ? count.value : this.count));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferSweepListRequest {
  TransferSweepListRequest({
    this.clientId,
    this.secret,
    this.startDate,
    this.endDate,
    this.count,
    this.offset,
    this.originatorClientId,
  });

  factory TransferSweepListRequest.fromJson(Map<String, dynamic> json) =>
      _$TransferSweepListRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'start_date')
  final DateTime? startDate;
  @JsonKey(name: 'end_date')
  final DateTime? endDate;
  @JsonKey(name: 'count')
  final int? count;
  @JsonKey(name: 'offset')
  final int? offset;
  @JsonKey(name: 'originator_client_id')
  final String? originatorClientId;
  static const fromJsonFactory = _$TransferSweepListRequestFromJson;
  static const toJsonFactory = _$TransferSweepListRequestToJson;
  Map<String, dynamic> toJson() => _$TransferSweepListRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferSweepListRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.startDate, startDate) ||
                const DeepCollectionEquality()
                    .equals(other.startDate, startDate)) &&
            (identical(other.endDate, endDate) ||
                const DeepCollectionEquality()
                    .equals(other.endDate, endDate)) &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)) &&
            (identical(other.offset, offset) ||
                const DeepCollectionEquality().equals(other.offset, offset)) &&
            (identical(other.originatorClientId, originatorClientId) ||
                const DeepCollectionEquality()
                    .equals(other.originatorClientId, originatorClientId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(startDate) ^
      const DeepCollectionEquality().hash(endDate) ^
      const DeepCollectionEquality().hash(count) ^
      const DeepCollectionEquality().hash(offset) ^
      const DeepCollectionEquality().hash(originatorClientId) ^
      runtimeType.hashCode;
}

extension $TransferSweepListRequestExtension on TransferSweepListRequest {
  TransferSweepListRequest copyWith(
      {String? clientId,
      String? secret,
      DateTime? startDate,
      DateTime? endDate,
      int? count,
      int? offset,
      String? originatorClientId}) {
    return TransferSweepListRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        startDate: startDate ?? this.startDate,
        endDate: endDate ?? this.endDate,
        count: count ?? this.count,
        offset: offset ?? this.offset,
        originatorClientId: originatorClientId ?? this.originatorClientId);
  }

  TransferSweepListRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<DateTime?>? startDate,
      Wrapped<DateTime?>? endDate,
      Wrapped<int?>? count,
      Wrapped<int?>? offset,
      Wrapped<String?>? originatorClientId}) {
    return TransferSweepListRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        startDate: (startDate != null ? startDate.value : this.startDate),
        endDate: (endDate != null ? endDate.value : this.endDate),
        count: (count != null ? count.value : this.count),
        offset: (offset != null ? offset.value : this.offset),
        originatorClientId: (originatorClientId != null
            ? originatorClientId.value
            : this.originatorClientId));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferSweepListResponse {
  TransferSweepListResponse({
    required this.sweeps,
    required this.requestId,
  });

  factory TransferSweepListResponse.fromJson(Map<String, dynamic> json) =>
      _$TransferSweepListResponseFromJson(json);

  @JsonKey(name: 'sweeps', defaultValue: <TransferSweep>[])
  final List<TransferSweep> sweeps;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$TransferSweepListResponseFromJson;
  static const toJsonFactory = _$TransferSweepListResponseToJson;
  Map<String, dynamic> toJson() => _$TransferSweepListResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferSweepListResponse &&
            (identical(other.sweeps, sweeps) ||
                const DeepCollectionEquality().equals(other.sweeps, sweeps)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(sweeps) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $TransferSweepListResponseExtension on TransferSweepListResponse {
  TransferSweepListResponse copyWith(
      {List<TransferSweep>? sweeps, String? requestId}) {
    return TransferSweepListResponse(
        sweeps: sweeps ?? this.sweeps, requestId: requestId ?? this.requestId);
  }

  TransferSweepListResponse copyWithWrapped(
      {Wrapped<List<TransferSweep>>? sweeps, Wrapped<String>? requestId}) {
    return TransferSweepListResponse(
        sweeps: (sweeps != null ? sweeps.value : this.sweeps),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class BankTransferSweepListResponse {
  BankTransferSweepListResponse({
    required this.sweeps,
    required this.requestId,
  });

  factory BankTransferSweepListResponse.fromJson(Map<String, dynamic> json) =>
      _$BankTransferSweepListResponseFromJson(json);

  @JsonKey(name: 'sweeps', defaultValue: <BankTransferSweep>[])
  final List<BankTransferSweep> sweeps;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$BankTransferSweepListResponseFromJson;
  static const toJsonFactory = _$BankTransferSweepListResponseToJson;
  Map<String, dynamic> toJson() => _$BankTransferSweepListResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BankTransferSweepListResponse &&
            (identical(other.sweeps, sweeps) ||
                const DeepCollectionEquality().equals(other.sweeps, sweeps)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(sweeps) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $BankTransferSweepListResponseExtension
    on BankTransferSweepListResponse {
  BankTransferSweepListResponse copyWith(
      {List<BankTransferSweep>? sweeps, String? requestId}) {
    return BankTransferSweepListResponse(
        sweeps: sweeps ?? this.sweeps, requestId: requestId ?? this.requestId);
  }

  BankTransferSweepListResponse copyWithWrapped(
      {Wrapped<List<BankTransferSweep>>? sweeps, Wrapped<String>? requestId}) {
    return BankTransferSweepListResponse(
        sweeps: (sweeps != null ? sweeps.value : this.sweeps),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class BankTransferSweep {
  BankTransferSweep({
    required this.id,
    required this.createdAt,
    required this.amount,
    required this.isoCurrencyCode,
  });

  factory BankTransferSweep.fromJson(Map<String, dynamic> json) =>
      _$BankTransferSweepFromJson(json);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'created_at')
  final DateTime createdAt;
  @JsonKey(name: 'amount')
  final String amount;
  @JsonKey(name: 'iso_currency_code')
  final String isoCurrencyCode;
  static const fromJsonFactory = _$BankTransferSweepFromJson;
  static const toJsonFactory = _$BankTransferSweepToJson;
  Map<String, dynamic> toJson() => _$BankTransferSweepToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BankTransferSweep &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.createdAt, createdAt) ||
                const DeepCollectionEquality()
                    .equals(other.createdAt, createdAt)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(createdAt) ^
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      runtimeType.hashCode;
}

extension $BankTransferSweepExtension on BankTransferSweep {
  BankTransferSweep copyWith(
      {String? id,
      DateTime? createdAt,
      String? amount,
      String? isoCurrencyCode}) {
    return BankTransferSweep(
        id: id ?? this.id,
        createdAt: createdAt ?? this.createdAt,
        amount: amount ?? this.amount,
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode);
  }

  BankTransferSweep copyWithWrapped(
      {Wrapped<String>? id,
      Wrapped<DateTime>? createdAt,
      Wrapped<String>? amount,
      Wrapped<String>? isoCurrencyCode}) {
    return BankTransferSweep(
        id: (id != null ? id.value : this.id),
        createdAt: (createdAt != null ? createdAt.value : this.createdAt),
        amount: (amount != null ? amount.value : this.amount),
        isoCurrencyCode: (isoCurrencyCode != null
            ? isoCurrencyCode.value
            : this.isoCurrencyCode));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferSweep {
  TransferSweep({
    required this.id,
    required this.created,
    required this.amount,
    required this.isoCurrencyCode,
    required this.settled,
  });

  factory TransferSweep.fromJson(Map<String, dynamic> json) =>
      _$TransferSweepFromJson(json);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'created')
  final DateTime created;
  @JsonKey(name: 'amount')
  final String amount;
  @JsonKey(name: 'iso_currency_code')
  final String isoCurrencyCode;
  @JsonKey(name: 'settled', toJson: _dateToJson)
  final DateTime? settled;
  static const fromJsonFactory = _$TransferSweepFromJson;
  static const toJsonFactory = _$TransferSweepToJson;
  Map<String, dynamic> toJson() => _$TransferSweepToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferSweep &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.created, created) ||
                const DeepCollectionEquality()
                    .equals(other.created, created)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)) &&
            (identical(other.settled, settled) ||
                const DeepCollectionEquality().equals(other.settled, settled)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(created) ^
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      const DeepCollectionEquality().hash(settled) ^
      runtimeType.hashCode;
}

extension $TransferSweepExtension on TransferSweep {
  TransferSweep copyWith(
      {String? id,
      DateTime? created,
      String? amount,
      String? isoCurrencyCode,
      DateTime? settled}) {
    return TransferSweep(
        id: id ?? this.id,
        created: created ?? this.created,
        amount: amount ?? this.amount,
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode,
        settled: settled ?? this.settled);
  }

  TransferSweep copyWithWrapped(
      {Wrapped<String>? id,
      Wrapped<DateTime>? created,
      Wrapped<String>? amount,
      Wrapped<String>? isoCurrencyCode,
      Wrapped<DateTime?>? settled}) {
    return TransferSweep(
        id: (id != null ? id.value : this.id),
        created: (created != null ? created.value : this.created),
        amount: (amount != null ? amount.value : this.amount),
        isoCurrencyCode: (isoCurrencyCode != null
            ? isoCurrencyCode.value
            : this.isoCurrencyCode),
        settled: (settled != null ? settled.value : this.settled));
  }
}

@JsonSerializable(explicitToJson: true)
class SimulatedTransferSweep {
  SimulatedTransferSweep({
    required this.id,
    required this.created,
    required this.amount,
    required this.isoCurrencyCode,
    required this.settled,
  });

  factory SimulatedTransferSweep.fromJson(Map<String, dynamic> json) =>
      _$SimulatedTransferSweepFromJson(json);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'created')
  final DateTime created;
  @JsonKey(name: 'amount')
  final String amount;
  @JsonKey(name: 'iso_currency_code')
  final String isoCurrencyCode;
  @JsonKey(name: 'settled', toJson: _dateToJson)
  final DateTime? settled;
  static const fromJsonFactory = _$SimulatedTransferSweepFromJson;
  static const toJsonFactory = _$SimulatedTransferSweepToJson;
  Map<String, dynamic> toJson() => _$SimulatedTransferSweepToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SimulatedTransferSweep &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.created, created) ||
                const DeepCollectionEquality()
                    .equals(other.created, created)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)) &&
            (identical(other.settled, settled) ||
                const DeepCollectionEquality().equals(other.settled, settled)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(created) ^
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      const DeepCollectionEquality().hash(settled) ^
      runtimeType.hashCode;
}

extension $SimulatedTransferSweepExtension on SimulatedTransferSweep {
  SimulatedTransferSweep copyWith(
      {String? id,
      DateTime? created,
      String? amount,
      String? isoCurrencyCode,
      DateTime? settled}) {
    return SimulatedTransferSweep(
        id: id ?? this.id,
        created: created ?? this.created,
        amount: amount ?? this.amount,
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode,
        settled: settled ?? this.settled);
  }

  SimulatedTransferSweep copyWithWrapped(
      {Wrapped<String>? id,
      Wrapped<DateTime>? created,
      Wrapped<String>? amount,
      Wrapped<String>? isoCurrencyCode,
      Wrapped<DateTime?>? settled}) {
    return SimulatedTransferSweep(
        id: (id != null ? id.value : this.id),
        created: (created != null ? created.value : this.created),
        amount: (amount != null ? amount.value : this.amount),
        isoCurrencyCode: (isoCurrencyCode != null
            ? isoCurrencyCode.value
            : this.isoCurrencyCode),
        settled: (settled != null ? settled.value : this.settled));
  }
}

@JsonSerializable(explicitToJson: true)
class BankTransferBalanceGetRequest {
  BankTransferBalanceGetRequest({
    this.clientId,
    this.secret,
    this.originationAccountId,
  });

  factory BankTransferBalanceGetRequest.fromJson(Map<String, dynamic> json) =>
      _$BankTransferBalanceGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'origination_account_id')
  final String? originationAccountId;
  static const fromJsonFactory = _$BankTransferBalanceGetRequestFromJson;
  static const toJsonFactory = _$BankTransferBalanceGetRequestToJson;
  Map<String, dynamic> toJson() => _$BankTransferBalanceGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BankTransferBalanceGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.originationAccountId, originationAccountId) ||
                const DeepCollectionEquality()
                    .equals(other.originationAccountId, originationAccountId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(originationAccountId) ^
      runtimeType.hashCode;
}

extension $BankTransferBalanceGetRequestExtension
    on BankTransferBalanceGetRequest {
  BankTransferBalanceGetRequest copyWith(
      {String? clientId, String? secret, String? originationAccountId}) {
    return BankTransferBalanceGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        originationAccountId:
            originationAccountId ?? this.originationAccountId);
  }

  BankTransferBalanceGetRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String?>? originationAccountId}) {
    return BankTransferBalanceGetRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        originationAccountId: (originationAccountId != null
            ? originationAccountId.value
            : this.originationAccountId));
  }
}

@JsonSerializable(explicitToJson: true)
class BankTransferBalanceGetResponse {
  BankTransferBalanceGetResponse({
    required this.balance,
    required this.originationAccountId,
    required this.requestId,
  });

  factory BankTransferBalanceGetResponse.fromJson(Map<String, dynamic> json) =>
      _$BankTransferBalanceGetResponseFromJson(json);

  @JsonKey(name: 'balance')
  final BankTransferBalance balance;
  @JsonKey(name: 'origination_account_id')
  final String? originationAccountId;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$BankTransferBalanceGetResponseFromJson;
  static const toJsonFactory = _$BankTransferBalanceGetResponseToJson;
  Map<String, dynamic> toJson() => _$BankTransferBalanceGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BankTransferBalanceGetResponse &&
            (identical(other.balance, balance) ||
                const DeepCollectionEquality()
                    .equals(other.balance, balance)) &&
            (identical(other.originationAccountId, originationAccountId) ||
                const DeepCollectionEquality().equals(
                    other.originationAccountId, originationAccountId)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(balance) ^
      const DeepCollectionEquality().hash(originationAccountId) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $BankTransferBalanceGetResponseExtension
    on BankTransferBalanceGetResponse {
  BankTransferBalanceGetResponse copyWith(
      {BankTransferBalance? balance,
      String? originationAccountId,
      String? requestId}) {
    return BankTransferBalanceGetResponse(
        balance: balance ?? this.balance,
        originationAccountId: originationAccountId ?? this.originationAccountId,
        requestId: requestId ?? this.requestId);
  }

  BankTransferBalanceGetResponse copyWithWrapped(
      {Wrapped<BankTransferBalance>? balance,
      Wrapped<String?>? originationAccountId,
      Wrapped<String>? requestId}) {
    return BankTransferBalanceGetResponse(
        balance: (balance != null ? balance.value : this.balance),
        originationAccountId: (originationAccountId != null
            ? originationAccountId.value
            : this.originationAccountId),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class BankTransferBalance {
  BankTransferBalance({
    required this.available,
    required this.transactable,
  });

  factory BankTransferBalance.fromJson(Map<String, dynamic> json) =>
      _$BankTransferBalanceFromJson(json);

  @JsonKey(name: 'available')
  final String available;
  @JsonKey(name: 'transactable')
  final String transactable;
  static const fromJsonFactory = _$BankTransferBalanceFromJson;
  static const toJsonFactory = _$BankTransferBalanceToJson;
  Map<String, dynamic> toJson() => _$BankTransferBalanceToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BankTransferBalance &&
            (identical(other.available, available) ||
                const DeepCollectionEquality()
                    .equals(other.available, available)) &&
            (identical(other.transactable, transactable) ||
                const DeepCollectionEquality()
                    .equals(other.transactable, transactable)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(available) ^
      const DeepCollectionEquality().hash(transactable) ^
      runtimeType.hashCode;
}

extension $BankTransferBalanceExtension on BankTransferBalance {
  BankTransferBalance copyWith({String? available, String? transactable}) {
    return BankTransferBalance(
        available: available ?? this.available,
        transactable: transactable ?? this.transactable);
  }

  BankTransferBalance copyWithWrapped(
      {Wrapped<String>? available, Wrapped<String>? transactable}) {
    return BankTransferBalance(
        available: (available != null ? available.value : this.available),
        transactable:
            (transactable != null ? transactable.value : this.transactable));
  }
}

@JsonSerializable(explicitToJson: true)
class BankTransferMigrateAccountRequest {
  BankTransferMigrateAccountRequest({
    this.clientId,
    this.secret,
    required this.accountNumber,
    required this.routingNumber,
    this.wireRoutingNumber,
    required this.accountType,
  });

  factory BankTransferMigrateAccountRequest.fromJson(
          Map<String, dynamic> json) =>
      _$BankTransferMigrateAccountRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'account_number')
  final String accountNumber;
  @JsonKey(name: 'routing_number')
  final String routingNumber;
  @JsonKey(name: 'wire_routing_number')
  final String? wireRoutingNumber;
  @JsonKey(name: 'account_type')
  final String accountType;
  static const fromJsonFactory = _$BankTransferMigrateAccountRequestFromJson;
  static const toJsonFactory = _$BankTransferMigrateAccountRequestToJson;
  Map<String, dynamic> toJson() =>
      _$BankTransferMigrateAccountRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BankTransferMigrateAccountRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.accountNumber, accountNumber) ||
                const DeepCollectionEquality()
                    .equals(other.accountNumber, accountNumber)) &&
            (identical(other.routingNumber, routingNumber) ||
                const DeepCollectionEquality()
                    .equals(other.routingNumber, routingNumber)) &&
            (identical(other.wireRoutingNumber, wireRoutingNumber) ||
                const DeepCollectionEquality()
                    .equals(other.wireRoutingNumber, wireRoutingNumber)) &&
            (identical(other.accountType, accountType) ||
                const DeepCollectionEquality()
                    .equals(other.accountType, accountType)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(accountNumber) ^
      const DeepCollectionEquality().hash(routingNumber) ^
      const DeepCollectionEquality().hash(wireRoutingNumber) ^
      const DeepCollectionEquality().hash(accountType) ^
      runtimeType.hashCode;
}

extension $BankTransferMigrateAccountRequestExtension
    on BankTransferMigrateAccountRequest {
  BankTransferMigrateAccountRequest copyWith(
      {String? clientId,
      String? secret,
      String? accountNumber,
      String? routingNumber,
      String? wireRoutingNumber,
      String? accountType}) {
    return BankTransferMigrateAccountRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        accountNumber: accountNumber ?? this.accountNumber,
        routingNumber: routingNumber ?? this.routingNumber,
        wireRoutingNumber: wireRoutingNumber ?? this.wireRoutingNumber,
        accountType: accountType ?? this.accountType);
  }

  BankTransferMigrateAccountRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? accountNumber,
      Wrapped<String>? routingNumber,
      Wrapped<String?>? wireRoutingNumber,
      Wrapped<String>? accountType}) {
    return BankTransferMigrateAccountRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        accountNumber:
            (accountNumber != null ? accountNumber.value : this.accountNumber),
        routingNumber:
            (routingNumber != null ? routingNumber.value : this.routingNumber),
        wireRoutingNumber: (wireRoutingNumber != null
            ? wireRoutingNumber.value
            : this.wireRoutingNumber),
        accountType:
            (accountType != null ? accountType.value : this.accountType));
  }
}

@JsonSerializable(explicitToJson: true)
class BankTransferMigrateAccountResponse {
  BankTransferMigrateAccountResponse({
    required this.accessToken,
    required this.accountId,
    required this.requestId,
  });

  factory BankTransferMigrateAccountResponse.fromJson(
          Map<String, dynamic> json) =>
      _$BankTransferMigrateAccountResponseFromJson(json);

  @JsonKey(name: 'access_token')
  final String accessToken;
  @JsonKey(name: 'account_id')
  final String accountId;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$BankTransferMigrateAccountResponseFromJson;
  static const toJsonFactory = _$BankTransferMigrateAccountResponseToJson;
  Map<String, dynamic> toJson() =>
      _$BankTransferMigrateAccountResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BankTransferMigrateAccountResponse &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)) &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accessToken) ^
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $BankTransferMigrateAccountResponseExtension
    on BankTransferMigrateAccountResponse {
  BankTransferMigrateAccountResponse copyWith(
      {String? accessToken, String? accountId, String? requestId}) {
    return BankTransferMigrateAccountResponse(
        accessToken: accessToken ?? this.accessToken,
        accountId: accountId ?? this.accountId,
        requestId: requestId ?? this.requestId);
  }

  BankTransferMigrateAccountResponse copyWithWrapped(
      {Wrapped<String>? accessToken,
      Wrapped<String>? accountId,
      Wrapped<String>? requestId}) {
    return BankTransferMigrateAccountResponse(
        accessToken:
            (accessToken != null ? accessToken.value : this.accessToken),
        accountId: (accountId != null ? accountId.value : this.accountId),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferMigrateAccountRequest {
  TransferMigrateAccountRequest({
    this.clientId,
    this.secret,
    required this.accountNumber,
    required this.routingNumber,
    this.wireRoutingNumber,
    required this.accountType,
  });

  factory TransferMigrateAccountRequest.fromJson(Map<String, dynamic> json) =>
      _$TransferMigrateAccountRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'account_number')
  final String accountNumber;
  @JsonKey(name: 'routing_number')
  final String routingNumber;
  @JsonKey(name: 'wire_routing_number')
  final String? wireRoutingNumber;
  @JsonKey(name: 'account_type')
  final String accountType;
  static const fromJsonFactory = _$TransferMigrateAccountRequestFromJson;
  static const toJsonFactory = _$TransferMigrateAccountRequestToJson;
  Map<String, dynamic> toJson() => _$TransferMigrateAccountRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferMigrateAccountRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.accountNumber, accountNumber) ||
                const DeepCollectionEquality()
                    .equals(other.accountNumber, accountNumber)) &&
            (identical(other.routingNumber, routingNumber) ||
                const DeepCollectionEquality()
                    .equals(other.routingNumber, routingNumber)) &&
            (identical(other.wireRoutingNumber, wireRoutingNumber) ||
                const DeepCollectionEquality()
                    .equals(other.wireRoutingNumber, wireRoutingNumber)) &&
            (identical(other.accountType, accountType) ||
                const DeepCollectionEquality()
                    .equals(other.accountType, accountType)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(accountNumber) ^
      const DeepCollectionEquality().hash(routingNumber) ^
      const DeepCollectionEquality().hash(wireRoutingNumber) ^
      const DeepCollectionEquality().hash(accountType) ^
      runtimeType.hashCode;
}

extension $TransferMigrateAccountRequestExtension
    on TransferMigrateAccountRequest {
  TransferMigrateAccountRequest copyWith(
      {String? clientId,
      String? secret,
      String? accountNumber,
      String? routingNumber,
      String? wireRoutingNumber,
      String? accountType}) {
    return TransferMigrateAccountRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        accountNumber: accountNumber ?? this.accountNumber,
        routingNumber: routingNumber ?? this.routingNumber,
        wireRoutingNumber: wireRoutingNumber ?? this.wireRoutingNumber,
        accountType: accountType ?? this.accountType);
  }

  TransferMigrateAccountRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? accountNumber,
      Wrapped<String>? routingNumber,
      Wrapped<String?>? wireRoutingNumber,
      Wrapped<String>? accountType}) {
    return TransferMigrateAccountRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        accountNumber:
            (accountNumber != null ? accountNumber.value : this.accountNumber),
        routingNumber:
            (routingNumber != null ? routingNumber.value : this.routingNumber),
        wireRoutingNumber: (wireRoutingNumber != null
            ? wireRoutingNumber.value
            : this.wireRoutingNumber),
        accountType:
            (accountType != null ? accountType.value : this.accountType));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferMigrateAccountResponse {
  TransferMigrateAccountResponse({
    required this.accessToken,
    required this.accountId,
    required this.requestId,
  });

  factory TransferMigrateAccountResponse.fromJson(Map<String, dynamic> json) =>
      _$TransferMigrateAccountResponseFromJson(json);

  @JsonKey(name: 'access_token')
  final String accessToken;
  @JsonKey(name: 'account_id')
  final String accountId;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$TransferMigrateAccountResponseFromJson;
  static const toJsonFactory = _$TransferMigrateAccountResponseToJson;
  Map<String, dynamic> toJson() => _$TransferMigrateAccountResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferMigrateAccountResponse &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)) &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accessToken) ^
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $TransferMigrateAccountResponseExtension
    on TransferMigrateAccountResponse {
  TransferMigrateAccountResponse copyWith(
      {String? accessToken, String? accountId, String? requestId}) {
    return TransferMigrateAccountResponse(
        accessToken: accessToken ?? this.accessToken,
        accountId: accountId ?? this.accountId,
        requestId: requestId ?? this.requestId);
  }

  TransferMigrateAccountResponse copyWithWrapped(
      {Wrapped<String>? accessToken,
      Wrapped<String>? accountId,
      Wrapped<String>? requestId}) {
    return TransferMigrateAccountResponse(
        accessToken:
            (accessToken != null ? accessToken.value : this.accessToken),
        accountId: (accountId != null ? accountId.value : this.accountId),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferOriginatorCreateRequest {
  TransferOriginatorCreateRequest({
    this.clientId,
    this.secret,
    required this.companyName,
  });

  factory TransferOriginatorCreateRequest.fromJson(Map<String, dynamic> json) =>
      _$TransferOriginatorCreateRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'company_name')
  final String companyName;
  static const fromJsonFactory = _$TransferOriginatorCreateRequestFromJson;
  static const toJsonFactory = _$TransferOriginatorCreateRequestToJson;
  Map<String, dynamic> toJson() =>
      _$TransferOriginatorCreateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferOriginatorCreateRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.companyName, companyName) ||
                const DeepCollectionEquality()
                    .equals(other.companyName, companyName)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(companyName) ^
      runtimeType.hashCode;
}

extension $TransferOriginatorCreateRequestExtension
    on TransferOriginatorCreateRequest {
  TransferOriginatorCreateRequest copyWith(
      {String? clientId, String? secret, String? companyName}) {
    return TransferOriginatorCreateRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        companyName: companyName ?? this.companyName);
  }

  TransferOriginatorCreateRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? companyName}) {
    return TransferOriginatorCreateRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        companyName:
            (companyName != null ? companyName.value : this.companyName));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferOriginatorCreateResponse {
  TransferOriginatorCreateResponse({
    required this.originatorClientId,
    required this.companyName,
    required this.requestId,
  });

  factory TransferOriginatorCreateResponse.fromJson(
          Map<String, dynamic> json) =>
      _$TransferOriginatorCreateResponseFromJson(json);

  @JsonKey(name: 'originator_client_id')
  final String originatorClientId;
  @JsonKey(name: 'company_name')
  final String companyName;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$TransferOriginatorCreateResponseFromJson;
  static const toJsonFactory = _$TransferOriginatorCreateResponseToJson;
  Map<String, dynamic> toJson() =>
      _$TransferOriginatorCreateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferOriginatorCreateResponse &&
            (identical(other.originatorClientId, originatorClientId) ||
                const DeepCollectionEquality()
                    .equals(other.originatorClientId, originatorClientId)) &&
            (identical(other.companyName, companyName) ||
                const DeepCollectionEquality()
                    .equals(other.companyName, companyName)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(originatorClientId) ^
      const DeepCollectionEquality().hash(companyName) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $TransferOriginatorCreateResponseExtension
    on TransferOriginatorCreateResponse {
  TransferOriginatorCreateResponse copyWith(
      {String? originatorClientId, String? companyName, String? requestId}) {
    return TransferOriginatorCreateResponse(
        originatorClientId: originatorClientId ?? this.originatorClientId,
        companyName: companyName ?? this.companyName,
        requestId: requestId ?? this.requestId);
  }

  TransferOriginatorCreateResponse copyWithWrapped(
      {Wrapped<String>? originatorClientId,
      Wrapped<String>? companyName,
      Wrapped<String>? requestId}) {
    return TransferOriginatorCreateResponse(
        originatorClientId: (originatorClientId != null
            ? originatorClientId.value
            : this.originatorClientId),
        companyName:
            (companyName != null ? companyName.value : this.companyName),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferQuestionnaireCreateRequest {
  TransferQuestionnaireCreateRequest({
    this.clientId,
    this.secret,
    required this.originatorClientId,
    required this.redirectUri,
    required this.disbursementLimits,
    required this.paymentLimits,
    required this.transactionFrequency,
  });

  factory TransferQuestionnaireCreateRequest.fromJson(
          Map<String, dynamic> json) =>
      _$TransferQuestionnaireCreateRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'originator_client_id')
  final String originatorClientId;
  @JsonKey(name: 'redirect_uri')
  final String redirectUri;
  @JsonKey(name: 'disbursement_limits')
  final DisbursementLimits disbursementLimits;
  @JsonKey(name: 'payment_limits')
  final PaymentLimits paymentLimits;
  @JsonKey(
    name: 'transaction_frequency',
    toJson: transactionFrequencyToJson,
    fromJson: transactionFrequencyFromJson,
  )
  final enums.TransactionFrequency transactionFrequency;
  static const fromJsonFactory = _$TransferQuestionnaireCreateRequestFromJson;
  static const toJsonFactory = _$TransferQuestionnaireCreateRequestToJson;
  Map<String, dynamic> toJson() =>
      _$TransferQuestionnaireCreateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferQuestionnaireCreateRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.originatorClientId, originatorClientId) ||
                const DeepCollectionEquality()
                    .equals(other.originatorClientId, originatorClientId)) &&
            (identical(other.redirectUri, redirectUri) ||
                const DeepCollectionEquality()
                    .equals(other.redirectUri, redirectUri)) &&
            (identical(other.disbursementLimits, disbursementLimits) ||
                const DeepCollectionEquality()
                    .equals(other.disbursementLimits, disbursementLimits)) &&
            (identical(other.paymentLimits, paymentLimits) ||
                const DeepCollectionEquality()
                    .equals(other.paymentLimits, paymentLimits)) &&
            (identical(other.transactionFrequency, transactionFrequency) ||
                const DeepCollectionEquality()
                    .equals(other.transactionFrequency, transactionFrequency)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(originatorClientId) ^
      const DeepCollectionEquality().hash(redirectUri) ^
      const DeepCollectionEquality().hash(disbursementLimits) ^
      const DeepCollectionEquality().hash(paymentLimits) ^
      const DeepCollectionEquality().hash(transactionFrequency) ^
      runtimeType.hashCode;
}

extension $TransferQuestionnaireCreateRequestExtension
    on TransferQuestionnaireCreateRequest {
  TransferQuestionnaireCreateRequest copyWith(
      {String? clientId,
      String? secret,
      String? originatorClientId,
      String? redirectUri,
      DisbursementLimits? disbursementLimits,
      PaymentLimits? paymentLimits,
      enums.TransactionFrequency? transactionFrequency}) {
    return TransferQuestionnaireCreateRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        originatorClientId: originatorClientId ?? this.originatorClientId,
        redirectUri: redirectUri ?? this.redirectUri,
        disbursementLimits: disbursementLimits ?? this.disbursementLimits,
        paymentLimits: paymentLimits ?? this.paymentLimits,
        transactionFrequency:
            transactionFrequency ?? this.transactionFrequency);
  }

  TransferQuestionnaireCreateRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? originatorClientId,
      Wrapped<String>? redirectUri,
      Wrapped<DisbursementLimits>? disbursementLimits,
      Wrapped<PaymentLimits>? paymentLimits,
      Wrapped<enums.TransactionFrequency>? transactionFrequency}) {
    return TransferQuestionnaireCreateRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        originatorClientId: (originatorClientId != null
            ? originatorClientId.value
            : this.originatorClientId),
        redirectUri:
            (redirectUri != null ? redirectUri.value : this.redirectUri),
        disbursementLimits: (disbursementLimits != null
            ? disbursementLimits.value
            : this.disbursementLimits),
        paymentLimits:
            (paymentLimits != null ? paymentLimits.value : this.paymentLimits),
        transactionFrequency: (transactionFrequency != null
            ? transactionFrequency.value
            : this.transactionFrequency));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferQuestionnaireCreateResponse {
  TransferQuestionnaireCreateResponse({
    required this.onboardingUrl,
    required this.requestId,
  });

  factory TransferQuestionnaireCreateResponse.fromJson(
          Map<String, dynamic> json) =>
      _$TransferQuestionnaireCreateResponseFromJson(json);

  @JsonKey(name: 'onboarding_url')
  final String onboardingUrl;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$TransferQuestionnaireCreateResponseFromJson;
  static const toJsonFactory = _$TransferQuestionnaireCreateResponseToJson;
  Map<String, dynamic> toJson() =>
      _$TransferQuestionnaireCreateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferQuestionnaireCreateResponse &&
            (identical(other.onboardingUrl, onboardingUrl) ||
                const DeepCollectionEquality()
                    .equals(other.onboardingUrl, onboardingUrl)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(onboardingUrl) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $TransferQuestionnaireCreateResponseExtension
    on TransferQuestionnaireCreateResponse {
  TransferQuestionnaireCreateResponse copyWith(
      {String? onboardingUrl, String? requestId}) {
    return TransferQuestionnaireCreateResponse(
        onboardingUrl: onboardingUrl ?? this.onboardingUrl,
        requestId: requestId ?? this.requestId);
  }

  TransferQuestionnaireCreateResponse copyWithWrapped(
      {Wrapped<String>? onboardingUrl, Wrapped<String>? requestId}) {
    return TransferQuestionnaireCreateResponse(
        onboardingUrl:
            (onboardingUrl != null ? onboardingUrl.value : this.onboardingUrl),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferOriginatorGetRequest {
  TransferOriginatorGetRequest({
    this.clientId,
    this.secret,
    required this.originatorClientId,
  });

  factory TransferOriginatorGetRequest.fromJson(Map<String, dynamic> json) =>
      _$TransferOriginatorGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'originator_client_id')
  final String originatorClientId;
  static const fromJsonFactory = _$TransferOriginatorGetRequestFromJson;
  static const toJsonFactory = _$TransferOriginatorGetRequestToJson;
  Map<String, dynamic> toJson() => _$TransferOriginatorGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferOriginatorGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.originatorClientId, originatorClientId) ||
                const DeepCollectionEquality()
                    .equals(other.originatorClientId, originatorClientId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(originatorClientId) ^
      runtimeType.hashCode;
}

extension $TransferOriginatorGetRequestExtension
    on TransferOriginatorGetRequest {
  TransferOriginatorGetRequest copyWith(
      {String? clientId, String? secret, String? originatorClientId}) {
    return TransferOriginatorGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        originatorClientId: originatorClientId ?? this.originatorClientId);
  }

  TransferOriginatorGetRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? originatorClientId}) {
    return TransferOriginatorGetRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        originatorClientId: (originatorClientId != null
            ? originatorClientId.value
            : this.originatorClientId));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferOriginatorGetResponse {
  TransferOriginatorGetResponse({
    required this.originator,
    required this.requestId,
  });

  factory TransferOriginatorGetResponse.fromJson(Map<String, dynamic> json) =>
      _$TransferOriginatorGetResponseFromJson(json);

  @JsonKey(name: 'originator')
  final Originator originator;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$TransferOriginatorGetResponseFromJson;
  static const toJsonFactory = _$TransferOriginatorGetResponseToJson;
  Map<String, dynamic> toJson() => _$TransferOriginatorGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferOriginatorGetResponse &&
            (identical(other.originator, originator) ||
                const DeepCollectionEquality()
                    .equals(other.originator, originator)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(originator) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $TransferOriginatorGetResponseExtension
    on TransferOriginatorGetResponse {
  TransferOriginatorGetResponse copyWith(
      {Originator? originator, String? requestId}) {
    return TransferOriginatorGetResponse(
        originator: originator ?? this.originator,
        requestId: requestId ?? this.requestId);
  }

  TransferOriginatorGetResponse copyWithWrapped(
      {Wrapped<Originator>? originator, Wrapped<String>? requestId}) {
    return TransferOriginatorGetResponse(
        originator: (originator != null ? originator.value : this.originator),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferOriginatorListRequest {
  TransferOriginatorListRequest({
    this.clientId,
    this.secret,
    this.count,
    this.offset,
  });

  factory TransferOriginatorListRequest.fromJson(Map<String, dynamic> json) =>
      _$TransferOriginatorListRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'count')
  final int? count;
  @JsonKey(name: 'offset')
  final int? offset;
  static const fromJsonFactory = _$TransferOriginatorListRequestFromJson;
  static const toJsonFactory = _$TransferOriginatorListRequestToJson;
  Map<String, dynamic> toJson() => _$TransferOriginatorListRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferOriginatorListRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)) &&
            (identical(other.offset, offset) ||
                const DeepCollectionEquality().equals(other.offset, offset)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(count) ^
      const DeepCollectionEquality().hash(offset) ^
      runtimeType.hashCode;
}

extension $TransferOriginatorListRequestExtension
    on TransferOriginatorListRequest {
  TransferOriginatorListRequest copyWith(
      {String? clientId, String? secret, int? count, int? offset}) {
    return TransferOriginatorListRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        count: count ?? this.count,
        offset: offset ?? this.offset);
  }

  TransferOriginatorListRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<int?>? count,
      Wrapped<int?>? offset}) {
    return TransferOriginatorListRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        count: (count != null ? count.value : this.count),
        offset: (offset != null ? offset.value : this.offset));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferOriginatorListResponse {
  TransferOriginatorListResponse({
    required this.originators,
    required this.requestId,
  });

  factory TransferOriginatorListResponse.fromJson(Map<String, dynamic> json) =>
      _$TransferOriginatorListResponseFromJson(json);

  @JsonKey(name: 'originators', defaultValue: <Originator>[])
  final List<Originator> originators;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$TransferOriginatorListResponseFromJson;
  static const toJsonFactory = _$TransferOriginatorListResponseToJson;
  Map<String, dynamic> toJson() => _$TransferOriginatorListResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferOriginatorListResponse &&
            (identical(other.originators, originators) ||
                const DeepCollectionEquality()
                    .equals(other.originators, originators)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(originators) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $TransferOriginatorListResponseExtension
    on TransferOriginatorListResponse {
  TransferOriginatorListResponse copyWith(
      {List<Originator>? originators, String? requestId}) {
    return TransferOriginatorListResponse(
        originators: originators ?? this.originators,
        requestId: requestId ?? this.requestId);
  }

  TransferOriginatorListResponse copyWithWrapped(
      {Wrapped<List<Originator>>? originators, Wrapped<String>? requestId}) {
    return TransferOriginatorListResponse(
        originators:
            (originators != null ? originators.value : this.originators),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferRepaymentListRequest {
  TransferRepaymentListRequest({
    this.clientId,
    this.secret,
    this.startDate,
    this.endDate,
    this.count,
    this.offset,
  });

  factory TransferRepaymentListRequest.fromJson(Map<String, dynamic> json) =>
      _$TransferRepaymentListRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'start_date')
  final DateTime? startDate;
  @JsonKey(name: 'end_date')
  final DateTime? endDate;
  @JsonKey(name: 'count')
  final int? count;
  @JsonKey(name: 'offset')
  final int? offset;
  static const fromJsonFactory = _$TransferRepaymentListRequestFromJson;
  static const toJsonFactory = _$TransferRepaymentListRequestToJson;
  Map<String, dynamic> toJson() => _$TransferRepaymentListRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferRepaymentListRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.startDate, startDate) ||
                const DeepCollectionEquality()
                    .equals(other.startDate, startDate)) &&
            (identical(other.endDate, endDate) ||
                const DeepCollectionEquality()
                    .equals(other.endDate, endDate)) &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)) &&
            (identical(other.offset, offset) ||
                const DeepCollectionEquality().equals(other.offset, offset)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(startDate) ^
      const DeepCollectionEquality().hash(endDate) ^
      const DeepCollectionEquality().hash(count) ^
      const DeepCollectionEquality().hash(offset) ^
      runtimeType.hashCode;
}

extension $TransferRepaymentListRequestExtension
    on TransferRepaymentListRequest {
  TransferRepaymentListRequest copyWith(
      {String? clientId,
      String? secret,
      DateTime? startDate,
      DateTime? endDate,
      int? count,
      int? offset}) {
    return TransferRepaymentListRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        startDate: startDate ?? this.startDate,
        endDate: endDate ?? this.endDate,
        count: count ?? this.count,
        offset: offset ?? this.offset);
  }

  TransferRepaymentListRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<DateTime?>? startDate,
      Wrapped<DateTime?>? endDate,
      Wrapped<int?>? count,
      Wrapped<int?>? offset}) {
    return TransferRepaymentListRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        startDate: (startDate != null ? startDate.value : this.startDate),
        endDate: (endDate != null ? endDate.value : this.endDate),
        count: (count != null ? count.value : this.count),
        offset: (offset != null ? offset.value : this.offset));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferRepaymentListResponse {
  TransferRepaymentListResponse({
    required this.repayments,
    required this.requestId,
  });

  factory TransferRepaymentListResponse.fromJson(Map<String, dynamic> json) =>
      _$TransferRepaymentListResponseFromJson(json);

  @JsonKey(name: 'repayments', defaultValue: <TransferRepayment>[])
  final List<TransferRepayment> repayments;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$TransferRepaymentListResponseFromJson;
  static const toJsonFactory = _$TransferRepaymentListResponseToJson;
  Map<String, dynamic> toJson() => _$TransferRepaymentListResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferRepaymentListResponse &&
            (identical(other.repayments, repayments) ||
                const DeepCollectionEquality()
                    .equals(other.repayments, repayments)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(repayments) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $TransferRepaymentListResponseExtension
    on TransferRepaymentListResponse {
  TransferRepaymentListResponse copyWith(
      {List<TransferRepayment>? repayments, String? requestId}) {
    return TransferRepaymentListResponse(
        repayments: repayments ?? this.repayments,
        requestId: requestId ?? this.requestId);
  }

  TransferRepaymentListResponse copyWithWrapped(
      {Wrapped<List<TransferRepayment>>? repayments,
      Wrapped<String>? requestId}) {
    return TransferRepaymentListResponse(
        repayments: (repayments != null ? repayments.value : this.repayments),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferRepayment {
  TransferRepayment({
    required this.repaymentId,
    required this.created,
    required this.amount,
    required this.isoCurrencyCode,
  });

  factory TransferRepayment.fromJson(Map<String, dynamic> json) =>
      _$TransferRepaymentFromJson(json);

  @JsonKey(name: 'repayment_id')
  final String repaymentId;
  @JsonKey(name: 'created')
  final DateTime created;
  @JsonKey(name: 'amount')
  final String amount;
  @JsonKey(name: 'iso_currency_code')
  final String isoCurrencyCode;
  static const fromJsonFactory = _$TransferRepaymentFromJson;
  static const toJsonFactory = _$TransferRepaymentToJson;
  Map<String, dynamic> toJson() => _$TransferRepaymentToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferRepayment &&
            (identical(other.repaymentId, repaymentId) ||
                const DeepCollectionEquality()
                    .equals(other.repaymentId, repaymentId)) &&
            (identical(other.created, created) ||
                const DeepCollectionEquality()
                    .equals(other.created, created)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(repaymentId) ^
      const DeepCollectionEquality().hash(created) ^
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      runtimeType.hashCode;
}

extension $TransferRepaymentExtension on TransferRepayment {
  TransferRepayment copyWith(
      {String? repaymentId,
      DateTime? created,
      String? amount,
      String? isoCurrencyCode}) {
    return TransferRepayment(
        repaymentId: repaymentId ?? this.repaymentId,
        created: created ?? this.created,
        amount: amount ?? this.amount,
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode);
  }

  TransferRepayment copyWithWrapped(
      {Wrapped<String>? repaymentId,
      Wrapped<DateTime>? created,
      Wrapped<String>? amount,
      Wrapped<String>? isoCurrencyCode}) {
    return TransferRepayment(
        repaymentId:
            (repaymentId != null ? repaymentId.value : this.repaymentId),
        created: (created != null ? created.value : this.created),
        amount: (amount != null ? amount.value : this.amount),
        isoCurrencyCode: (isoCurrencyCode != null
            ? isoCurrencyCode.value
            : this.isoCurrencyCode));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferRepaymentReturnListRequest {
  TransferRepaymentReturnListRequest({
    this.clientId,
    this.secret,
    required this.repaymentId,
    this.count,
    this.offset,
  });

  factory TransferRepaymentReturnListRequest.fromJson(
          Map<String, dynamic> json) =>
      _$TransferRepaymentReturnListRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'repayment_id')
  final String repaymentId;
  @JsonKey(name: 'count')
  final int? count;
  @JsonKey(name: 'offset')
  final int? offset;
  static const fromJsonFactory = _$TransferRepaymentReturnListRequestFromJson;
  static const toJsonFactory = _$TransferRepaymentReturnListRequestToJson;
  Map<String, dynamic> toJson() =>
      _$TransferRepaymentReturnListRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferRepaymentReturnListRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.repaymentId, repaymentId) ||
                const DeepCollectionEquality()
                    .equals(other.repaymentId, repaymentId)) &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)) &&
            (identical(other.offset, offset) ||
                const DeepCollectionEquality().equals(other.offset, offset)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(repaymentId) ^
      const DeepCollectionEquality().hash(count) ^
      const DeepCollectionEquality().hash(offset) ^
      runtimeType.hashCode;
}

extension $TransferRepaymentReturnListRequestExtension
    on TransferRepaymentReturnListRequest {
  TransferRepaymentReturnListRequest copyWith(
      {String? clientId,
      String? secret,
      String? repaymentId,
      int? count,
      int? offset}) {
    return TransferRepaymentReturnListRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        repaymentId: repaymentId ?? this.repaymentId,
        count: count ?? this.count,
        offset: offset ?? this.offset);
  }

  TransferRepaymentReturnListRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? repaymentId,
      Wrapped<int?>? count,
      Wrapped<int?>? offset}) {
    return TransferRepaymentReturnListRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        repaymentId:
            (repaymentId != null ? repaymentId.value : this.repaymentId),
        count: (count != null ? count.value : this.count),
        offset: (offset != null ? offset.value : this.offset));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferRepaymentReturnListResponse {
  TransferRepaymentReturnListResponse({
    required this.repaymentReturns,
    required this.requestId,
  });

  factory TransferRepaymentReturnListResponse.fromJson(
          Map<String, dynamic> json) =>
      _$TransferRepaymentReturnListResponseFromJson(json);

  @JsonKey(name: 'repayment_returns', defaultValue: <TransferRepaymentReturn>[])
  final List<TransferRepaymentReturn> repaymentReturns;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$TransferRepaymentReturnListResponseFromJson;
  static const toJsonFactory = _$TransferRepaymentReturnListResponseToJson;
  Map<String, dynamic> toJson() =>
      _$TransferRepaymentReturnListResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferRepaymentReturnListResponse &&
            (identical(other.repaymentReturns, repaymentReturns) ||
                const DeepCollectionEquality()
                    .equals(other.repaymentReturns, repaymentReturns)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(repaymentReturns) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $TransferRepaymentReturnListResponseExtension
    on TransferRepaymentReturnListResponse {
  TransferRepaymentReturnListResponse copyWith(
      {List<TransferRepaymentReturn>? repaymentReturns, String? requestId}) {
    return TransferRepaymentReturnListResponse(
        repaymentReturns: repaymentReturns ?? this.repaymentReturns,
        requestId: requestId ?? this.requestId);
  }

  TransferRepaymentReturnListResponse copyWithWrapped(
      {Wrapped<List<TransferRepaymentReturn>>? repaymentReturns,
      Wrapped<String>? requestId}) {
    return TransferRepaymentReturnListResponse(
        repaymentReturns: (repaymentReturns != null
            ? repaymentReturns.value
            : this.repaymentReturns),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferRepaymentReturn {
  TransferRepaymentReturn({
    required this.transferId,
    required this.eventId,
    required this.amount,
    required this.isoCurrencyCode,
  });

  factory TransferRepaymentReturn.fromJson(Map<String, dynamic> json) =>
      _$TransferRepaymentReturnFromJson(json);

  @JsonKey(name: 'transfer_id')
  final String transferId;
  @JsonKey(name: 'event_id')
  final int eventId;
  @JsonKey(name: 'amount')
  final String amount;
  @JsonKey(name: 'iso_currency_code')
  final String isoCurrencyCode;
  static const fromJsonFactory = _$TransferRepaymentReturnFromJson;
  static const toJsonFactory = _$TransferRepaymentReturnToJson;
  Map<String, dynamic> toJson() => _$TransferRepaymentReturnToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferRepaymentReturn &&
            (identical(other.transferId, transferId) ||
                const DeepCollectionEquality()
                    .equals(other.transferId, transferId)) &&
            (identical(other.eventId, eventId) ||
                const DeepCollectionEquality()
                    .equals(other.eventId, eventId)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(transferId) ^
      const DeepCollectionEquality().hash(eventId) ^
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      runtimeType.hashCode;
}

extension $TransferRepaymentReturnExtension on TransferRepaymentReturn {
  TransferRepaymentReturn copyWith(
      {String? transferId,
      int? eventId,
      String? amount,
      String? isoCurrencyCode}) {
    return TransferRepaymentReturn(
        transferId: transferId ?? this.transferId,
        eventId: eventId ?? this.eventId,
        amount: amount ?? this.amount,
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode);
  }

  TransferRepaymentReturn copyWithWrapped(
      {Wrapped<String>? transferId,
      Wrapped<int>? eventId,
      Wrapped<String>? amount,
      Wrapped<String>? isoCurrencyCode}) {
    return TransferRepaymentReturn(
        transferId: (transferId != null ? transferId.value : this.transferId),
        eventId: (eventId != null ? eventId.value : this.eventId),
        amount: (amount != null ? amount.value : this.amount),
        isoCurrencyCode: (isoCurrencyCode != null
            ? isoCurrencyCode.value
            : this.isoCurrencyCode));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferIntentCreateRequest {
  TransferIntentCreateRequest({
    this.clientId,
    this.secret,
    this.accountId,
    required this.mode,
    required this.amount,
    required this.description,
    this.achClass,
    this.originationAccountId,
    required this.user,
    this.metadata,
    this.isoCurrencyCode,
    this.requireGuarantee,
  });

  factory TransferIntentCreateRequest.fromJson(Map<String, dynamic> json) =>
      _$TransferIntentCreateRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'account_id')
  final String? accountId;
  @JsonKey(
    name: 'mode',
    toJson: transferIntentCreateModeToJson,
    fromJson: transferIntentCreateModeFromJson,
  )
  final enums.TransferIntentCreateMode mode;
  @JsonKey(name: 'amount')
  final String amount;
  @JsonKey(name: 'description')
  final String description;
  @JsonKey(
    name: 'ach_class',
    toJson: aCHClassToJson,
    fromJson: aCHClassFromJson,
  )
  final enums.ACHClass? achClass;
  @JsonKey(name: 'origination_account_id')
  final String? originationAccountId;
  @JsonKey(name: 'user')
  final TransferUserInRequest user;
  @JsonKey(name: 'metadata')
  final TransferMetadata? metadata;
  @JsonKey(name: 'iso_currency_code')
  final String? isoCurrencyCode;
  @JsonKey(name: 'require_guarantee', defaultValue: false)
  final bool? requireGuarantee;
  static const fromJsonFactory = _$TransferIntentCreateRequestFromJson;
  static const toJsonFactory = _$TransferIntentCreateRequestToJson;
  Map<String, dynamic> toJson() => _$TransferIntentCreateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferIntentCreateRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.mode, mode) ||
                const DeepCollectionEquality().equals(other.mode, mode)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.achClass, achClass) ||
                const DeepCollectionEquality()
                    .equals(other.achClass, achClass)) &&
            (identical(other.originationAccountId, originationAccountId) ||
                const DeepCollectionEquality().equals(
                    other.originationAccountId, originationAccountId)) &&
            (identical(other.user, user) ||
                const DeepCollectionEquality().equals(other.user, user)) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality()
                    .equals(other.metadata, metadata)) &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)) &&
            (identical(other.requireGuarantee, requireGuarantee) ||
                const DeepCollectionEquality()
                    .equals(other.requireGuarantee, requireGuarantee)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(mode) ^
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(achClass) ^
      const DeepCollectionEquality().hash(originationAccountId) ^
      const DeepCollectionEquality().hash(user) ^
      const DeepCollectionEquality().hash(metadata) ^
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      const DeepCollectionEquality().hash(requireGuarantee) ^
      runtimeType.hashCode;
}

extension $TransferIntentCreateRequestExtension on TransferIntentCreateRequest {
  TransferIntentCreateRequest copyWith(
      {String? clientId,
      String? secret,
      String? accountId,
      enums.TransferIntentCreateMode? mode,
      String? amount,
      String? description,
      enums.ACHClass? achClass,
      String? originationAccountId,
      TransferUserInRequest? user,
      TransferMetadata? metadata,
      String? isoCurrencyCode,
      bool? requireGuarantee}) {
    return TransferIntentCreateRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        accountId: accountId ?? this.accountId,
        mode: mode ?? this.mode,
        amount: amount ?? this.amount,
        description: description ?? this.description,
        achClass: achClass ?? this.achClass,
        originationAccountId: originationAccountId ?? this.originationAccountId,
        user: user ?? this.user,
        metadata: metadata ?? this.metadata,
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode,
        requireGuarantee: requireGuarantee ?? this.requireGuarantee);
  }

  TransferIntentCreateRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String?>? accountId,
      Wrapped<enums.TransferIntentCreateMode>? mode,
      Wrapped<String>? amount,
      Wrapped<String>? description,
      Wrapped<enums.ACHClass?>? achClass,
      Wrapped<String?>? originationAccountId,
      Wrapped<TransferUserInRequest>? user,
      Wrapped<TransferMetadata?>? metadata,
      Wrapped<String?>? isoCurrencyCode,
      Wrapped<bool?>? requireGuarantee}) {
    return TransferIntentCreateRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        accountId: (accountId != null ? accountId.value : this.accountId),
        mode: (mode != null ? mode.value : this.mode),
        amount: (amount != null ? amount.value : this.amount),
        description:
            (description != null ? description.value : this.description),
        achClass: (achClass != null ? achClass.value : this.achClass),
        originationAccountId: (originationAccountId != null
            ? originationAccountId.value
            : this.originationAccountId),
        user: (user != null ? user.value : this.user),
        metadata: (metadata != null ? metadata.value : this.metadata),
        isoCurrencyCode: (isoCurrencyCode != null
            ? isoCurrencyCode.value
            : this.isoCurrencyCode),
        requireGuarantee: (requireGuarantee != null
            ? requireGuarantee.value
            : this.requireGuarantee));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferIntentCreate {
  TransferIntentCreate({
    required this.id,
    required this.created,
    required this.status,
    this.accountId,
    required this.originationAccountId,
    required this.amount,
    required this.mode,
    this.achClass,
    required this.user,
    required this.description,
    this.metadata,
    required this.isoCurrencyCode,
    this.requireGuarantee,
  });

  factory TransferIntentCreate.fromJson(Map<String, dynamic> json) =>
      _$TransferIntentCreateFromJson(json);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'created')
  final DateTime created;
  @JsonKey(
    name: 'status',
    toJson: transferIntentStatusToJson,
    fromJson: transferIntentStatusFromJson,
  )
  final enums.TransferIntentStatus status;
  @JsonKey(name: 'account_id')
  final String? accountId;
  @JsonKey(name: 'origination_account_id')
  final String originationAccountId;
  @JsonKey(name: 'amount')
  final String amount;
  @JsonKey(
    name: 'mode',
    toJson: transferIntentCreateModeToJson,
    fromJson: transferIntentCreateModeFromJson,
  )
  final enums.TransferIntentCreateMode mode;
  @JsonKey(
    name: 'ach_class',
    toJson: aCHClassToJson,
    fromJson: aCHClassFromJson,
  )
  final enums.ACHClass? achClass;
  @JsonKey(name: 'user')
  final TransferUserInResponse user;
  @JsonKey(name: 'description')
  final String description;
  @JsonKey(name: 'metadata')
  final TransferMetadata? metadata;
  @JsonKey(name: 'iso_currency_code')
  final String isoCurrencyCode;
  @JsonKey(name: 'require_guarantee')
  final bool? requireGuarantee;
  static const fromJsonFactory = _$TransferIntentCreateFromJson;
  static const toJsonFactory = _$TransferIntentCreateToJson;
  Map<String, dynamic> toJson() => _$TransferIntentCreateToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferIntentCreate &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.created, created) ||
                const DeepCollectionEquality()
                    .equals(other.created, created)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.originationAccountId, originationAccountId) ||
                const DeepCollectionEquality().equals(
                    other.originationAccountId, originationAccountId)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.mode, mode) ||
                const DeepCollectionEquality().equals(other.mode, mode)) &&
            (identical(other.achClass, achClass) ||
                const DeepCollectionEquality()
                    .equals(other.achClass, achClass)) &&
            (identical(other.user, user) ||
                const DeepCollectionEquality().equals(other.user, user)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality()
                    .equals(other.metadata, metadata)) &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)) &&
            (identical(other.requireGuarantee, requireGuarantee) ||
                const DeepCollectionEquality()
                    .equals(other.requireGuarantee, requireGuarantee)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(created) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(originationAccountId) ^
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(mode) ^
      const DeepCollectionEquality().hash(achClass) ^
      const DeepCollectionEquality().hash(user) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(metadata) ^
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      const DeepCollectionEquality().hash(requireGuarantee) ^
      runtimeType.hashCode;
}

extension $TransferIntentCreateExtension on TransferIntentCreate {
  TransferIntentCreate copyWith(
      {String? id,
      DateTime? created,
      enums.TransferIntentStatus? status,
      String? accountId,
      String? originationAccountId,
      String? amount,
      enums.TransferIntentCreateMode? mode,
      enums.ACHClass? achClass,
      TransferUserInResponse? user,
      String? description,
      TransferMetadata? metadata,
      String? isoCurrencyCode,
      bool? requireGuarantee}) {
    return TransferIntentCreate(
        id: id ?? this.id,
        created: created ?? this.created,
        status: status ?? this.status,
        accountId: accountId ?? this.accountId,
        originationAccountId: originationAccountId ?? this.originationAccountId,
        amount: amount ?? this.amount,
        mode: mode ?? this.mode,
        achClass: achClass ?? this.achClass,
        user: user ?? this.user,
        description: description ?? this.description,
        metadata: metadata ?? this.metadata,
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode,
        requireGuarantee: requireGuarantee ?? this.requireGuarantee);
  }

  TransferIntentCreate copyWithWrapped(
      {Wrapped<String>? id,
      Wrapped<DateTime>? created,
      Wrapped<enums.TransferIntentStatus>? status,
      Wrapped<String?>? accountId,
      Wrapped<String>? originationAccountId,
      Wrapped<String>? amount,
      Wrapped<enums.TransferIntentCreateMode>? mode,
      Wrapped<enums.ACHClass?>? achClass,
      Wrapped<TransferUserInResponse>? user,
      Wrapped<String>? description,
      Wrapped<TransferMetadata?>? metadata,
      Wrapped<String>? isoCurrencyCode,
      Wrapped<bool?>? requireGuarantee}) {
    return TransferIntentCreate(
        id: (id != null ? id.value : this.id),
        created: (created != null ? created.value : this.created),
        status: (status != null ? status.value : this.status),
        accountId: (accountId != null ? accountId.value : this.accountId),
        originationAccountId: (originationAccountId != null
            ? originationAccountId.value
            : this.originationAccountId),
        amount: (amount != null ? amount.value : this.amount),
        mode: (mode != null ? mode.value : this.mode),
        achClass: (achClass != null ? achClass.value : this.achClass),
        user: (user != null ? user.value : this.user),
        description:
            (description != null ? description.value : this.description),
        metadata: (metadata != null ? metadata.value : this.metadata),
        isoCurrencyCode: (isoCurrencyCode != null
            ? isoCurrencyCode.value
            : this.isoCurrencyCode),
        requireGuarantee: (requireGuarantee != null
            ? requireGuarantee.value
            : this.requireGuarantee));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferIntentCreateResponse {
  TransferIntentCreateResponse({
    required this.transferIntent,
    required this.requestId,
  });

  factory TransferIntentCreateResponse.fromJson(Map<String, dynamic> json) =>
      _$TransferIntentCreateResponseFromJson(json);

  @JsonKey(name: 'transfer_intent')
  final TransferIntentCreate transferIntent;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$TransferIntentCreateResponseFromJson;
  static const toJsonFactory = _$TransferIntentCreateResponseToJson;
  Map<String, dynamic> toJson() => _$TransferIntentCreateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferIntentCreateResponse &&
            (identical(other.transferIntent, transferIntent) ||
                const DeepCollectionEquality()
                    .equals(other.transferIntent, transferIntent)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(transferIntent) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $TransferIntentCreateResponseExtension
    on TransferIntentCreateResponse {
  TransferIntentCreateResponse copyWith(
      {TransferIntentCreate? transferIntent, String? requestId}) {
    return TransferIntentCreateResponse(
        transferIntent: transferIntent ?? this.transferIntent,
        requestId: requestId ?? this.requestId);
  }

  TransferIntentCreateResponse copyWithWrapped(
      {Wrapped<TransferIntentCreate>? transferIntent,
      Wrapped<String>? requestId}) {
    return TransferIntentCreateResponse(
        transferIntent: (transferIntent != null
            ? transferIntent.value
            : this.transferIntent),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferIntentGetRequest {
  TransferIntentGetRequest({
    this.clientId,
    this.secret,
    required this.transferIntentId,
  });

  factory TransferIntentGetRequest.fromJson(Map<String, dynamic> json) =>
      _$TransferIntentGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'transfer_intent_id')
  final String transferIntentId;
  static const fromJsonFactory = _$TransferIntentGetRequestFromJson;
  static const toJsonFactory = _$TransferIntentGetRequestToJson;
  Map<String, dynamic> toJson() => _$TransferIntentGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferIntentGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.transferIntentId, transferIntentId) ||
                const DeepCollectionEquality()
                    .equals(other.transferIntentId, transferIntentId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(transferIntentId) ^
      runtimeType.hashCode;
}

extension $TransferIntentGetRequestExtension on TransferIntentGetRequest {
  TransferIntentGetRequest copyWith(
      {String? clientId, String? secret, String? transferIntentId}) {
    return TransferIntentGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        transferIntentId: transferIntentId ?? this.transferIntentId);
  }

  TransferIntentGetRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? transferIntentId}) {
    return TransferIntentGetRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        transferIntentId: (transferIntentId != null
            ? transferIntentId.value
            : this.transferIntentId));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferIntentGet {
  TransferIntentGet({
    required this.id,
    required this.created,
    required this.status,
    required this.transferId,
    required this.failureReason,
    required this.authorizationDecision,
    required this.authorizationDecisionRationale,
    this.accountId,
    required this.originationAccountId,
    required this.amount,
    required this.mode,
    this.achClass,
    required this.user,
    required this.description,
    this.metadata,
    required this.isoCurrencyCode,
    this.requireGuarantee,
    required this.guaranteeDecision,
    required this.guaranteeDecisionRationale,
  });

  factory TransferIntentGet.fromJson(Map<String, dynamic> json) =>
      _$TransferIntentGetFromJson(json);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'created')
  final DateTime created;
  @JsonKey(
    name: 'status',
    toJson: transferIntentStatusToJson,
    fromJson: transferIntentStatusFromJson,
  )
  final enums.TransferIntentStatus status;
  @JsonKey(name: 'transfer_id')
  final String? transferId;
  @JsonKey(name: 'failure_reason')
  final TransferIntentGetFailureReason? failureReason;
  @JsonKey(
    name: 'authorization_decision',
    toJson: transferIntentAuthorizationDecisionToJson,
    fromJson: transferIntentAuthorizationDecisionFromJson,
  )
  final enums.TransferIntentAuthorizationDecision? authorizationDecision;
  @JsonKey(name: 'authorization_decision_rationale')
  final TransferAuthorizationDecisionRationale? authorizationDecisionRationale;
  @JsonKey(name: 'account_id')
  final String? accountId;
  @JsonKey(name: 'origination_account_id')
  final String originationAccountId;
  @JsonKey(name: 'amount')
  final String amount;
  @JsonKey(
    name: 'mode',
    toJson: transferIntentCreateModeToJson,
    fromJson: transferIntentCreateModeFromJson,
  )
  final enums.TransferIntentCreateMode mode;
  @JsonKey(
    name: 'ach_class',
    toJson: aCHClassToJson,
    fromJson: aCHClassFromJson,
  )
  final enums.ACHClass? achClass;
  @JsonKey(name: 'user')
  final TransferUserInResponse user;
  @JsonKey(name: 'description')
  final String description;
  @JsonKey(name: 'metadata')
  final TransferMetadata? metadata;
  @JsonKey(name: 'iso_currency_code')
  final String isoCurrencyCode;
  @JsonKey(name: 'require_guarantee')
  final bool? requireGuarantee;
  @JsonKey(
    name: 'guarantee_decision',
    toJson: transferAuthorizationGuaranteeDecisionToJson,
    fromJson: transferAuthorizationGuaranteeDecisionFromJson,
  )
  final enums.TransferAuthorizationGuaranteeDecision? guaranteeDecision;
  @JsonKey(name: 'guarantee_decision_rationale')
  final TransferAuthorizationGuaranteeDecisionRationale?
      guaranteeDecisionRationale;
  static const fromJsonFactory = _$TransferIntentGetFromJson;
  static const toJsonFactory = _$TransferIntentGetToJson;
  Map<String, dynamic> toJson() => _$TransferIntentGetToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferIntentGet &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.created, created) ||
                const DeepCollectionEquality()
                    .equals(other.created, created)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.transferId, transferId) ||
                const DeepCollectionEquality()
                    .equals(other.transferId, transferId)) &&
            (identical(other.failureReason, failureReason) ||
                const DeepCollectionEquality()
                    .equals(other.failureReason, failureReason)) &&
            (identical(other.authorizationDecision, authorizationDecision) ||
                const DeepCollectionEquality().equals(
                    other.authorizationDecision, authorizationDecision)) &&
            (identical(other.authorizationDecisionRationale, authorizationDecisionRationale) ||
                const DeepCollectionEquality().equals(
                    other.authorizationDecisionRationale,
                    authorizationDecisionRationale)) &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.originationAccountId, originationAccountId) ||
                const DeepCollectionEquality().equals(
                    other.originationAccountId, originationAccountId)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.mode, mode) ||
                const DeepCollectionEquality().equals(other.mode, mode)) &&
            (identical(other.achClass, achClass) ||
                const DeepCollectionEquality()
                    .equals(other.achClass, achClass)) &&
            (identical(other.user, user) ||
                const DeepCollectionEquality().equals(other.user, user)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality()
                    .equals(other.metadata, metadata)) &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)) &&
            (identical(other.requireGuarantee, requireGuarantee) ||
                const DeepCollectionEquality()
                    .equals(other.requireGuarantee, requireGuarantee)) &&
            (identical(other.guaranteeDecision, guaranteeDecision) ||
                const DeepCollectionEquality()
                    .equals(other.guaranteeDecision, guaranteeDecision)) &&
            (identical(other.guaranteeDecisionRationale, guaranteeDecisionRationale) ||
                const DeepCollectionEquality().equals(
                    other.guaranteeDecisionRationale,
                    guaranteeDecisionRationale)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(created) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(transferId) ^
      const DeepCollectionEquality().hash(failureReason) ^
      const DeepCollectionEquality().hash(authorizationDecision) ^
      const DeepCollectionEquality().hash(authorizationDecisionRationale) ^
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(originationAccountId) ^
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(mode) ^
      const DeepCollectionEquality().hash(achClass) ^
      const DeepCollectionEquality().hash(user) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(metadata) ^
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      const DeepCollectionEquality().hash(requireGuarantee) ^
      const DeepCollectionEquality().hash(guaranteeDecision) ^
      const DeepCollectionEquality().hash(guaranteeDecisionRationale) ^
      runtimeType.hashCode;
}

extension $TransferIntentGetExtension on TransferIntentGet {
  TransferIntentGet copyWith(
      {String? id,
      DateTime? created,
      enums.TransferIntentStatus? status,
      String? transferId,
      TransferIntentGetFailureReason? failureReason,
      enums.TransferIntentAuthorizationDecision? authorizationDecision,
      TransferAuthorizationDecisionRationale? authorizationDecisionRationale,
      String? accountId,
      String? originationAccountId,
      String? amount,
      enums.TransferIntentCreateMode? mode,
      enums.ACHClass? achClass,
      TransferUserInResponse? user,
      String? description,
      TransferMetadata? metadata,
      String? isoCurrencyCode,
      bool? requireGuarantee,
      enums.TransferAuthorizationGuaranteeDecision? guaranteeDecision,
      TransferAuthorizationGuaranteeDecisionRationale?
          guaranteeDecisionRationale}) {
    return TransferIntentGet(
        id: id ?? this.id,
        created: created ?? this.created,
        status: status ?? this.status,
        transferId: transferId ?? this.transferId,
        failureReason: failureReason ?? this.failureReason,
        authorizationDecision:
            authorizationDecision ?? this.authorizationDecision,
        authorizationDecisionRationale: authorizationDecisionRationale ??
            this.authorizationDecisionRationale,
        accountId: accountId ?? this.accountId,
        originationAccountId: originationAccountId ?? this.originationAccountId,
        amount: amount ?? this.amount,
        mode: mode ?? this.mode,
        achClass: achClass ?? this.achClass,
        user: user ?? this.user,
        description: description ?? this.description,
        metadata: metadata ?? this.metadata,
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode,
        requireGuarantee: requireGuarantee ?? this.requireGuarantee,
        guaranteeDecision: guaranteeDecision ?? this.guaranteeDecision,
        guaranteeDecisionRationale:
            guaranteeDecisionRationale ?? this.guaranteeDecisionRationale);
  }

  TransferIntentGet copyWithWrapped(
      {Wrapped<String>? id,
      Wrapped<DateTime>? created,
      Wrapped<enums.TransferIntentStatus>? status,
      Wrapped<String?>? transferId,
      Wrapped<TransferIntentGetFailureReason?>? failureReason,
      Wrapped<enums.TransferIntentAuthorizationDecision?>?
          authorizationDecision,
      Wrapped<TransferAuthorizationDecisionRationale?>?
          authorizationDecisionRationale,
      Wrapped<String?>? accountId,
      Wrapped<String>? originationAccountId,
      Wrapped<String>? amount,
      Wrapped<enums.TransferIntentCreateMode>? mode,
      Wrapped<enums.ACHClass?>? achClass,
      Wrapped<TransferUserInResponse>? user,
      Wrapped<String>? description,
      Wrapped<TransferMetadata?>? metadata,
      Wrapped<String>? isoCurrencyCode,
      Wrapped<bool?>? requireGuarantee,
      Wrapped<enums.TransferAuthorizationGuaranteeDecision?>? guaranteeDecision,
      Wrapped<TransferAuthorizationGuaranteeDecisionRationale?>?
          guaranteeDecisionRationale}) {
    return TransferIntentGet(
        id: (id != null ? id.value : this.id),
        created: (created != null ? created.value : this.created),
        status: (status != null ? status.value : this.status),
        transferId: (transferId != null ? transferId.value : this.transferId),
        failureReason:
            (failureReason != null ? failureReason.value : this.failureReason),
        authorizationDecision: (authorizationDecision != null
            ? authorizationDecision.value
            : this.authorizationDecision),
        authorizationDecisionRationale: (authorizationDecisionRationale != null
            ? authorizationDecisionRationale.value
            : this.authorizationDecisionRationale),
        accountId: (accountId != null ? accountId.value : this.accountId),
        originationAccountId: (originationAccountId != null
            ? originationAccountId.value
            : this.originationAccountId),
        amount: (amount != null ? amount.value : this.amount),
        mode: (mode != null ? mode.value : this.mode),
        achClass: (achClass != null ? achClass.value : this.achClass),
        user: (user != null ? user.value : this.user),
        description:
            (description != null ? description.value : this.description),
        metadata: (metadata != null ? metadata.value : this.metadata),
        isoCurrencyCode: (isoCurrencyCode != null
            ? isoCurrencyCode.value
            : this.isoCurrencyCode),
        requireGuarantee: (requireGuarantee != null
            ? requireGuarantee.value
            : this.requireGuarantee),
        guaranteeDecision: (guaranteeDecision != null
            ? guaranteeDecision.value
            : this.guaranteeDecision),
        guaranteeDecisionRationale: (guaranteeDecisionRationale != null
            ? guaranteeDecisionRationale.value
            : this.guaranteeDecisionRationale));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferIntentGetResponse {
  TransferIntentGetResponse({
    required this.transferIntent,
    required this.requestId,
  });

  factory TransferIntentGetResponse.fromJson(Map<String, dynamic> json) =>
      _$TransferIntentGetResponseFromJson(json);

  @JsonKey(name: 'transfer_intent')
  final TransferIntentGet transferIntent;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$TransferIntentGetResponseFromJson;
  static const toJsonFactory = _$TransferIntentGetResponseToJson;
  Map<String, dynamic> toJson() => _$TransferIntentGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferIntentGetResponse &&
            (identical(other.transferIntent, transferIntent) ||
                const DeepCollectionEquality()
                    .equals(other.transferIntent, transferIntent)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(transferIntent) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $TransferIntentGetResponseExtension on TransferIntentGetResponse {
  TransferIntentGetResponse copyWith(
      {TransferIntentGet? transferIntent, String? requestId}) {
    return TransferIntentGetResponse(
        transferIntent: transferIntent ?? this.transferIntent,
        requestId: requestId ?? this.requestId);
  }

  TransferIntentGetResponse copyWithWrapped(
      {Wrapped<TransferIntentGet>? transferIntent,
      Wrapped<String>? requestId}) {
    return TransferIntentGetResponse(
        transferIntent: (transferIntent != null
            ? transferIntent.value
            : this.transferIntent),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferRefundCreateRequest {
  TransferRefundCreateRequest({
    this.clientId,
    this.secret,
    required this.transferId,
    required this.amount,
    required this.idempotencyKey,
  });

  factory TransferRefundCreateRequest.fromJson(Map<String, dynamic> json) =>
      _$TransferRefundCreateRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'transfer_id')
  final String transferId;
  @JsonKey(name: 'amount')
  final String amount;
  @JsonKey(name: 'idempotency_key')
  final String idempotencyKey;
  static const fromJsonFactory = _$TransferRefundCreateRequestFromJson;
  static const toJsonFactory = _$TransferRefundCreateRequestToJson;
  Map<String, dynamic> toJson() => _$TransferRefundCreateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferRefundCreateRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.transferId, transferId) ||
                const DeepCollectionEquality()
                    .equals(other.transferId, transferId)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.idempotencyKey, idempotencyKey) ||
                const DeepCollectionEquality()
                    .equals(other.idempotencyKey, idempotencyKey)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(transferId) ^
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(idempotencyKey) ^
      runtimeType.hashCode;
}

extension $TransferRefundCreateRequestExtension on TransferRefundCreateRequest {
  TransferRefundCreateRequest copyWith(
      {String? clientId,
      String? secret,
      String? transferId,
      String? amount,
      String? idempotencyKey}) {
    return TransferRefundCreateRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        transferId: transferId ?? this.transferId,
        amount: amount ?? this.amount,
        idempotencyKey: idempotencyKey ?? this.idempotencyKey);
  }

  TransferRefundCreateRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? transferId,
      Wrapped<String>? amount,
      Wrapped<String>? idempotencyKey}) {
    return TransferRefundCreateRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        transferId: (transferId != null ? transferId.value : this.transferId),
        amount: (amount != null ? amount.value : this.amount),
        idempotencyKey: (idempotencyKey != null
            ? idempotencyKey.value
            : this.idempotencyKey));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferRefundCreateResponse {
  TransferRefundCreateResponse({
    required this.refund,
    required this.requestId,
  });

  factory TransferRefundCreateResponse.fromJson(Map<String, dynamic> json) =>
      _$TransferRefundCreateResponseFromJson(json);

  @JsonKey(name: 'refund')
  final TransferRefund refund;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$TransferRefundCreateResponseFromJson;
  static const toJsonFactory = _$TransferRefundCreateResponseToJson;
  Map<String, dynamic> toJson() => _$TransferRefundCreateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferRefundCreateResponse &&
            (identical(other.refund, refund) ||
                const DeepCollectionEquality().equals(other.refund, refund)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(refund) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $TransferRefundCreateResponseExtension
    on TransferRefundCreateResponse {
  TransferRefundCreateResponse copyWith(
      {TransferRefund? refund, String? requestId}) {
    return TransferRefundCreateResponse(
        refund: refund ?? this.refund, requestId: requestId ?? this.requestId);
  }

  TransferRefundCreateResponse copyWithWrapped(
      {Wrapped<TransferRefund>? refund, Wrapped<String>? requestId}) {
    return TransferRefundCreateResponse(
        refund: (refund != null ? refund.value : this.refund),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferRefund {
  TransferRefund({
    required this.id,
    required this.transferId,
    required this.amount,
    required this.status,
    required this.created,
  });

  factory TransferRefund.fromJson(Map<String, dynamic> json) =>
      _$TransferRefundFromJson(json);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'transfer_id')
  final String transferId;
  @JsonKey(name: 'amount')
  final String amount;
  @JsonKey(
    name: 'status',
    toJson: transferRefundStatusToJson,
    fromJson: transferRefundStatusFromJson,
  )
  final enums.TransferRefundStatus status;
  @JsonKey(name: 'created')
  final DateTime created;
  static const fromJsonFactory = _$TransferRefundFromJson;
  static const toJsonFactory = _$TransferRefundToJson;
  Map<String, dynamic> toJson() => _$TransferRefundToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferRefund &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.transferId, transferId) ||
                const DeepCollectionEquality()
                    .equals(other.transferId, transferId)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.created, created) ||
                const DeepCollectionEquality().equals(other.created, created)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(transferId) ^
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(created) ^
      runtimeType.hashCode;
}

extension $TransferRefundExtension on TransferRefund {
  TransferRefund copyWith(
      {String? id,
      String? transferId,
      String? amount,
      enums.TransferRefundStatus? status,
      DateTime? created}) {
    return TransferRefund(
        id: id ?? this.id,
        transferId: transferId ?? this.transferId,
        amount: amount ?? this.amount,
        status: status ?? this.status,
        created: created ?? this.created);
  }

  TransferRefund copyWithWrapped(
      {Wrapped<String>? id,
      Wrapped<String>? transferId,
      Wrapped<String>? amount,
      Wrapped<enums.TransferRefundStatus>? status,
      Wrapped<DateTime>? created}) {
    return TransferRefund(
        id: (id != null ? id.value : this.id),
        transferId: (transferId != null ? transferId.value : this.transferId),
        amount: (amount != null ? amount.value : this.amount),
        status: (status != null ? status.value : this.status),
        created: (created != null ? created.value : this.created));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferRefundGetRequest {
  TransferRefundGetRequest({
    this.clientId,
    this.secret,
    required this.refundId,
  });

  factory TransferRefundGetRequest.fromJson(Map<String, dynamic> json) =>
      _$TransferRefundGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'refund_id')
  final String refundId;
  static const fromJsonFactory = _$TransferRefundGetRequestFromJson;
  static const toJsonFactory = _$TransferRefundGetRequestToJson;
  Map<String, dynamic> toJson() => _$TransferRefundGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferRefundGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.refundId, refundId) ||
                const DeepCollectionEquality()
                    .equals(other.refundId, refundId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(refundId) ^
      runtimeType.hashCode;
}

extension $TransferRefundGetRequestExtension on TransferRefundGetRequest {
  TransferRefundGetRequest copyWith(
      {String? clientId, String? secret, String? refundId}) {
    return TransferRefundGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        refundId: refundId ?? this.refundId);
  }

  TransferRefundGetRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? refundId}) {
    return TransferRefundGetRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        refundId: (refundId != null ? refundId.value : this.refundId));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferRefundGetResponse {
  TransferRefundGetResponse({
    required this.refund,
    required this.requestId,
  });

  factory TransferRefundGetResponse.fromJson(Map<String, dynamic> json) =>
      _$TransferRefundGetResponseFromJson(json);

  @JsonKey(name: 'refund')
  final TransferRefund refund;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$TransferRefundGetResponseFromJson;
  static const toJsonFactory = _$TransferRefundGetResponseToJson;
  Map<String, dynamic> toJson() => _$TransferRefundGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferRefundGetResponse &&
            (identical(other.refund, refund) ||
                const DeepCollectionEquality().equals(other.refund, refund)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(refund) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $TransferRefundGetResponseExtension on TransferRefundGetResponse {
  TransferRefundGetResponse copyWith(
      {TransferRefund? refund, String? requestId}) {
    return TransferRefundGetResponse(
        refund: refund ?? this.refund, requestId: requestId ?? this.requestId);
  }

  TransferRefundGetResponse copyWithWrapped(
      {Wrapped<TransferRefund>? refund, Wrapped<String>? requestId}) {
    return TransferRefundGetResponse(
        refund: (refund != null ? refund.value : this.refund),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferRefundCancelRequest {
  TransferRefundCancelRequest({
    this.clientId,
    this.secret,
    required this.refundId,
  });

  factory TransferRefundCancelRequest.fromJson(Map<String, dynamic> json) =>
      _$TransferRefundCancelRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'refund_id')
  final String refundId;
  static const fromJsonFactory = _$TransferRefundCancelRequestFromJson;
  static const toJsonFactory = _$TransferRefundCancelRequestToJson;
  Map<String, dynamic> toJson() => _$TransferRefundCancelRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferRefundCancelRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.refundId, refundId) ||
                const DeepCollectionEquality()
                    .equals(other.refundId, refundId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(refundId) ^
      runtimeType.hashCode;
}

extension $TransferRefundCancelRequestExtension on TransferRefundCancelRequest {
  TransferRefundCancelRequest copyWith(
      {String? clientId, String? secret, String? refundId}) {
    return TransferRefundCancelRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        refundId: refundId ?? this.refundId);
  }

  TransferRefundCancelRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? refundId}) {
    return TransferRefundCancelRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        refundId: (refundId != null ? refundId.value : this.refundId));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferRefundCancelResponse {
  TransferRefundCancelResponse({
    required this.requestId,
  });

  factory TransferRefundCancelResponse.fromJson(Map<String, dynamic> json) =>
      _$TransferRefundCancelResponseFromJson(json);

  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$TransferRefundCancelResponseFromJson;
  static const toJsonFactory = _$TransferRefundCancelResponseToJson;
  Map<String, dynamic> toJson() => _$TransferRefundCancelResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferRefundCancelResponse &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(requestId) ^ runtimeType.hashCode;
}

extension $TransferRefundCancelResponseExtension
    on TransferRefundCancelResponse {
  TransferRefundCancelResponse copyWith({String? requestId}) {
    return TransferRefundCancelResponse(requestId: requestId ?? this.requestId);
  }

  TransferRefundCancelResponse copyWithWrapped({Wrapped<String>? requestId}) {
    return TransferRefundCancelResponse(
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class SandboxBankTransferSimulateRequest {
  SandboxBankTransferSimulateRequest({
    this.clientId,
    this.secret,
    required this.bankTransferId,
    required this.eventType,
    this.failureReason,
  });

  factory SandboxBankTransferSimulateRequest.fromJson(
          Map<String, dynamic> json) =>
      _$SandboxBankTransferSimulateRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'bank_transfer_id')
  final String bankTransferId;
  @JsonKey(name: 'event_type')
  final String eventType;
  @JsonKey(name: 'failure_reason')
  final BankTransferFailure? failureReason;
  static const fromJsonFactory = _$SandboxBankTransferSimulateRequestFromJson;
  static const toJsonFactory = _$SandboxBankTransferSimulateRequestToJson;
  Map<String, dynamic> toJson() =>
      _$SandboxBankTransferSimulateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SandboxBankTransferSimulateRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.bankTransferId, bankTransferId) ||
                const DeepCollectionEquality()
                    .equals(other.bankTransferId, bankTransferId)) &&
            (identical(other.eventType, eventType) ||
                const DeepCollectionEquality()
                    .equals(other.eventType, eventType)) &&
            (identical(other.failureReason, failureReason) ||
                const DeepCollectionEquality()
                    .equals(other.failureReason, failureReason)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(bankTransferId) ^
      const DeepCollectionEquality().hash(eventType) ^
      const DeepCollectionEquality().hash(failureReason) ^
      runtimeType.hashCode;
}

extension $SandboxBankTransferSimulateRequestExtension
    on SandboxBankTransferSimulateRequest {
  SandboxBankTransferSimulateRequest copyWith(
      {String? clientId,
      String? secret,
      String? bankTransferId,
      String? eventType,
      BankTransferFailure? failureReason}) {
    return SandboxBankTransferSimulateRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        bankTransferId: bankTransferId ?? this.bankTransferId,
        eventType: eventType ?? this.eventType,
        failureReason: failureReason ?? this.failureReason);
  }

  SandboxBankTransferSimulateRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? bankTransferId,
      Wrapped<String>? eventType,
      Wrapped<BankTransferFailure?>? failureReason}) {
    return SandboxBankTransferSimulateRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        bankTransferId: (bankTransferId != null
            ? bankTransferId.value
            : this.bankTransferId),
        eventType: (eventType != null ? eventType.value : this.eventType),
        failureReason:
            (failureReason != null ? failureReason.value : this.failureReason));
  }
}

@JsonSerializable(explicitToJson: true)
class SandboxTransferSimulateRequest {
  SandboxTransferSimulateRequest({
    this.clientId,
    this.secret,
    required this.transferId,
    required this.eventType,
    this.failureReason,
  });

  factory SandboxTransferSimulateRequest.fromJson(Map<String, dynamic> json) =>
      _$SandboxTransferSimulateRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'transfer_id')
  final String transferId;
  @JsonKey(name: 'event_type')
  final String eventType;
  @JsonKey(name: 'failure_reason')
  final TransferFailure? failureReason;
  static const fromJsonFactory = _$SandboxTransferSimulateRequestFromJson;
  static const toJsonFactory = _$SandboxTransferSimulateRequestToJson;
  Map<String, dynamic> toJson() => _$SandboxTransferSimulateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SandboxTransferSimulateRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.transferId, transferId) ||
                const DeepCollectionEquality()
                    .equals(other.transferId, transferId)) &&
            (identical(other.eventType, eventType) ||
                const DeepCollectionEquality()
                    .equals(other.eventType, eventType)) &&
            (identical(other.failureReason, failureReason) ||
                const DeepCollectionEquality()
                    .equals(other.failureReason, failureReason)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(transferId) ^
      const DeepCollectionEquality().hash(eventType) ^
      const DeepCollectionEquality().hash(failureReason) ^
      runtimeType.hashCode;
}

extension $SandboxTransferSimulateRequestExtension
    on SandboxTransferSimulateRequest {
  SandboxTransferSimulateRequest copyWith(
      {String? clientId,
      String? secret,
      String? transferId,
      String? eventType,
      TransferFailure? failureReason}) {
    return SandboxTransferSimulateRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        transferId: transferId ?? this.transferId,
        eventType: eventType ?? this.eventType,
        failureReason: failureReason ?? this.failureReason);
  }

  SandboxTransferSimulateRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? transferId,
      Wrapped<String>? eventType,
      Wrapped<TransferFailure?>? failureReason}) {
    return SandboxTransferSimulateRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        transferId: (transferId != null ? transferId.value : this.transferId),
        eventType: (eventType != null ? eventType.value : this.eventType),
        failureReason:
            (failureReason != null ? failureReason.value : this.failureReason));
  }
}

@JsonSerializable(explicitToJson: true)
class SandboxTransferSweepSimulateRequest {
  SandboxTransferSweepSimulateRequest({
    this.clientId,
    this.secret,
  });

  factory SandboxTransferSweepSimulateRequest.fromJson(
          Map<String, dynamic> json) =>
      _$SandboxTransferSweepSimulateRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  static const fromJsonFactory = _$SandboxTransferSweepSimulateRequestFromJson;
  static const toJsonFactory = _$SandboxTransferSweepSimulateRequestToJson;
  Map<String, dynamic> toJson() =>
      _$SandboxTransferSweepSimulateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SandboxTransferSweepSimulateRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      runtimeType.hashCode;
}

extension $SandboxTransferSweepSimulateRequestExtension
    on SandboxTransferSweepSimulateRequest {
  SandboxTransferSweepSimulateRequest copyWith(
      {String? clientId, String? secret}) {
    return SandboxTransferSweepSimulateRequest(
        clientId: clientId ?? this.clientId, secret: secret ?? this.secret);
  }

  SandboxTransferSweepSimulateRequest copyWithWrapped(
      {Wrapped<String?>? clientId, Wrapped<String?>? secret}) {
    return SandboxTransferSweepSimulateRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret));
  }
}

@JsonSerializable(explicitToJson: true)
class SandboxTransferTestClockCreateRequest {
  SandboxTransferTestClockCreateRequest({
    required this.clientId,
    required this.secret,
    required this.frozenTimestamp,
  });

  factory SandboxTransferTestClockCreateRequest.fromJson(
          Map<String, dynamic> json) =>
      _$SandboxTransferTestClockCreateRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String clientId;
  @JsonKey(name: 'secret')
  final String secret;
  @JsonKey(name: 'frozen_timestamp')
  final String frozenTimestamp;
  static const fromJsonFactory =
      _$SandboxTransferTestClockCreateRequestFromJson;
  static const toJsonFactory = _$SandboxTransferTestClockCreateRequestToJson;
  Map<String, dynamic> toJson() =>
      _$SandboxTransferTestClockCreateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SandboxTransferTestClockCreateRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.frozenTimestamp, frozenTimestamp) ||
                const DeepCollectionEquality()
                    .equals(other.frozenTimestamp, frozenTimestamp)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(frozenTimestamp) ^
      runtimeType.hashCode;
}

extension $SandboxTransferTestClockCreateRequestExtension
    on SandboxTransferTestClockCreateRequest {
  SandboxTransferTestClockCreateRequest copyWith(
      {String? clientId, String? secret, String? frozenTimestamp}) {
    return SandboxTransferTestClockCreateRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        frozenTimestamp: frozenTimestamp ?? this.frozenTimestamp);
  }

  SandboxTransferTestClockCreateRequest copyWithWrapped(
      {Wrapped<String>? clientId,
      Wrapped<String>? secret,
      Wrapped<String>? frozenTimestamp}) {
    return SandboxTransferTestClockCreateRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        frozenTimestamp: (frozenTimestamp != null
            ? frozenTimestamp.value
            : this.frozenTimestamp));
  }
}

@JsonSerializable(explicitToJson: true)
class SandboxTransferTestClockAdvanceRequest {
  SandboxTransferTestClockAdvanceRequest({
    required this.clientId,
    required this.secret,
    required this.testClockId,
    required this.newFrozenTimestamp,
  });

  factory SandboxTransferTestClockAdvanceRequest.fromJson(
          Map<String, dynamic> json) =>
      _$SandboxTransferTestClockAdvanceRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String clientId;
  @JsonKey(name: 'secret')
  final String secret;
  @JsonKey(name: 'test_clock_id')
  final String? testClockId;
  @JsonKey(name: 'new_frozen_timestamp')
  final String newFrozenTimestamp;
  static const fromJsonFactory =
      _$SandboxTransferTestClockAdvanceRequestFromJson;
  static const toJsonFactory = _$SandboxTransferTestClockAdvanceRequestToJson;
  Map<String, dynamic> toJson() =>
      _$SandboxTransferTestClockAdvanceRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SandboxTransferTestClockAdvanceRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.testClockId, testClockId) ||
                const DeepCollectionEquality()
                    .equals(other.testClockId, testClockId)) &&
            (identical(other.newFrozenTimestamp, newFrozenTimestamp) ||
                const DeepCollectionEquality()
                    .equals(other.newFrozenTimestamp, newFrozenTimestamp)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(testClockId) ^
      const DeepCollectionEquality().hash(newFrozenTimestamp) ^
      runtimeType.hashCode;
}

extension $SandboxTransferTestClockAdvanceRequestExtension
    on SandboxTransferTestClockAdvanceRequest {
  SandboxTransferTestClockAdvanceRequest copyWith(
      {String? clientId,
      String? secret,
      String? testClockId,
      String? newFrozenTimestamp}) {
    return SandboxTransferTestClockAdvanceRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        testClockId: testClockId ?? this.testClockId,
        newFrozenTimestamp: newFrozenTimestamp ?? this.newFrozenTimestamp);
  }

  SandboxTransferTestClockAdvanceRequest copyWithWrapped(
      {Wrapped<String>? clientId,
      Wrapped<String>? secret,
      Wrapped<String?>? testClockId,
      Wrapped<String>? newFrozenTimestamp}) {
    return SandboxTransferTestClockAdvanceRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        testClockId:
            (testClockId != null ? testClockId.value : this.testClockId),
        newFrozenTimestamp: (newFrozenTimestamp != null
            ? newFrozenTimestamp.value
            : this.newFrozenTimestamp));
  }
}

@JsonSerializable(explicitToJson: true)
class SandboxTransferTestClockGetRequest {
  SandboxTransferTestClockGetRequest({
    required this.clientId,
    required this.secret,
    required this.testClockId,
  });

  factory SandboxTransferTestClockGetRequest.fromJson(
          Map<String, dynamic> json) =>
      _$SandboxTransferTestClockGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String clientId;
  @JsonKey(name: 'secret')
  final String secret;
  @JsonKey(name: 'test_clock_id')
  final String? testClockId;
  static const fromJsonFactory = _$SandboxTransferTestClockGetRequestFromJson;
  static const toJsonFactory = _$SandboxTransferTestClockGetRequestToJson;
  Map<String, dynamic> toJson() =>
      _$SandboxTransferTestClockGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SandboxTransferTestClockGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.testClockId, testClockId) ||
                const DeepCollectionEquality()
                    .equals(other.testClockId, testClockId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(testClockId) ^
      runtimeType.hashCode;
}

extension $SandboxTransferTestClockGetRequestExtension
    on SandboxTransferTestClockGetRequest {
  SandboxTransferTestClockGetRequest copyWith(
      {String? clientId, String? secret, String? testClockId}) {
    return SandboxTransferTestClockGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        testClockId: testClockId ?? this.testClockId);
  }

  SandboxTransferTestClockGetRequest copyWithWrapped(
      {Wrapped<String>? clientId,
      Wrapped<String>? secret,
      Wrapped<String?>? testClockId}) {
    return SandboxTransferTestClockGetRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        testClockId:
            (testClockId != null ? testClockId.value : this.testClockId));
  }
}

@JsonSerializable(explicitToJson: true)
class SandboxBankTransferSimulateResponse {
  SandboxBankTransferSimulateResponse({
    required this.requestId,
  });

  factory SandboxBankTransferSimulateResponse.fromJson(
          Map<String, dynamic> json) =>
      _$SandboxBankTransferSimulateResponseFromJson(json);

  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$SandboxBankTransferSimulateResponseFromJson;
  static const toJsonFactory = _$SandboxBankTransferSimulateResponseToJson;
  Map<String, dynamic> toJson() =>
      _$SandboxBankTransferSimulateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SandboxBankTransferSimulateResponse &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(requestId) ^ runtimeType.hashCode;
}

extension $SandboxBankTransferSimulateResponseExtension
    on SandboxBankTransferSimulateResponse {
  SandboxBankTransferSimulateResponse copyWith({String? requestId}) {
    return SandboxBankTransferSimulateResponse(
        requestId: requestId ?? this.requestId);
  }

  SandboxBankTransferSimulateResponse copyWithWrapped(
      {Wrapped<String>? requestId}) {
    return SandboxBankTransferSimulateResponse(
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class SandboxTransferSimulateResponse {
  SandboxTransferSimulateResponse({
    required this.requestId,
  });

  factory SandboxTransferSimulateResponse.fromJson(Map<String, dynamic> json) =>
      _$SandboxTransferSimulateResponseFromJson(json);

  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$SandboxTransferSimulateResponseFromJson;
  static const toJsonFactory = _$SandboxTransferSimulateResponseToJson;
  Map<String, dynamic> toJson() =>
      _$SandboxTransferSimulateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SandboxTransferSimulateResponse &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(requestId) ^ runtimeType.hashCode;
}

extension $SandboxTransferSimulateResponseExtension
    on SandboxTransferSimulateResponse {
  SandboxTransferSimulateResponse copyWith({String? requestId}) {
    return SandboxTransferSimulateResponse(
        requestId: requestId ?? this.requestId);
  }

  SandboxTransferSimulateResponse copyWithWrapped(
      {Wrapped<String>? requestId}) {
    return SandboxTransferSimulateResponse(
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class SandboxTransferSweepSimulateResponse {
  SandboxTransferSweepSimulateResponse({
    this.sweep,
    required this.requestId,
  });

  factory SandboxTransferSweepSimulateResponse.fromJson(
          Map<String, dynamic> json) =>
      _$SandboxTransferSweepSimulateResponseFromJson(json);

  @JsonKey(name: 'sweep')
  final SimulatedTransferSweep? sweep;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$SandboxTransferSweepSimulateResponseFromJson;
  static const toJsonFactory = _$SandboxTransferSweepSimulateResponseToJson;
  Map<String, dynamic> toJson() =>
      _$SandboxTransferSweepSimulateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SandboxTransferSweepSimulateResponse &&
            (identical(other.sweep, sweep) ||
                const DeepCollectionEquality().equals(other.sweep, sweep)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(sweep) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $SandboxTransferSweepSimulateResponseExtension
    on SandboxTransferSweepSimulateResponse {
  SandboxTransferSweepSimulateResponse copyWith(
      {SimulatedTransferSweep? sweep, String? requestId}) {
    return SandboxTransferSweepSimulateResponse(
        sweep: sweep ?? this.sweep, requestId: requestId ?? this.requestId);
  }

  SandboxTransferSweepSimulateResponse copyWithWrapped(
      {Wrapped<SimulatedTransferSweep?>? sweep, Wrapped<String>? requestId}) {
    return SandboxTransferSweepSimulateResponse(
        sweep: (sweep != null ? sweep.value : this.sweep),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class SandboxTransferTestClockCreateResponse {
  SandboxTransferTestClockCreateResponse({
    required this.testClock,
    required this.requestId,
  });

  factory SandboxTransferTestClockCreateResponse.fromJson(
          Map<String, dynamic> json) =>
      _$SandboxTransferTestClockCreateResponseFromJson(json);

  @JsonKey(name: 'test_clock')
  final TransferTestClock testClock;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory =
      _$SandboxTransferTestClockCreateResponseFromJson;
  static const toJsonFactory = _$SandboxTransferTestClockCreateResponseToJson;
  Map<String, dynamic> toJson() =>
      _$SandboxTransferTestClockCreateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SandboxTransferTestClockCreateResponse &&
            (identical(other.testClock, testClock) ||
                const DeepCollectionEquality()
                    .equals(other.testClock, testClock)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(testClock) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $SandboxTransferTestClockCreateResponseExtension
    on SandboxTransferTestClockCreateResponse {
  SandboxTransferTestClockCreateResponse copyWith(
      {TransferTestClock? testClock, String? requestId}) {
    return SandboxTransferTestClockCreateResponse(
        testClock: testClock ?? this.testClock,
        requestId: requestId ?? this.requestId);
  }

  SandboxTransferTestClockCreateResponse copyWithWrapped(
      {Wrapped<TransferTestClock>? testClock, Wrapped<String>? requestId}) {
    return SandboxTransferTestClockCreateResponse(
        testClock: (testClock != null ? testClock.value : this.testClock),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class SandboxTransferTestClockAdvanceResponse {
  SandboxTransferTestClockAdvanceResponse({
    required this.requestId,
  });

  factory SandboxTransferTestClockAdvanceResponse.fromJson(
          Map<String, dynamic> json) =>
      _$SandboxTransferTestClockAdvanceResponseFromJson(json);

  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory =
      _$SandboxTransferTestClockAdvanceResponseFromJson;
  static const toJsonFactory = _$SandboxTransferTestClockAdvanceResponseToJson;
  Map<String, dynamic> toJson() =>
      _$SandboxTransferTestClockAdvanceResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SandboxTransferTestClockAdvanceResponse &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(requestId) ^ runtimeType.hashCode;
}

extension $SandboxTransferTestClockAdvanceResponseExtension
    on SandboxTransferTestClockAdvanceResponse {
  SandboxTransferTestClockAdvanceResponse copyWith({String? requestId}) {
    return SandboxTransferTestClockAdvanceResponse(
        requestId: requestId ?? this.requestId);
  }

  SandboxTransferTestClockAdvanceResponse copyWithWrapped(
      {Wrapped<String>? requestId}) {
    return SandboxTransferTestClockAdvanceResponse(
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class SandboxTransferTestClockGetResponse {
  SandboxTransferTestClockGetResponse({
    required this.testClock,
    required this.requestId,
  });

  factory SandboxTransferTestClockGetResponse.fromJson(
          Map<String, dynamic> json) =>
      _$SandboxTransferTestClockGetResponseFromJson(json);

  @JsonKey(name: 'test_clock')
  final TransferTestClock testClock;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$SandboxTransferTestClockGetResponseFromJson;
  static const toJsonFactory = _$SandboxTransferTestClockGetResponseToJson;
  Map<String, dynamic> toJson() =>
      _$SandboxTransferTestClockGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SandboxTransferTestClockGetResponse &&
            (identical(other.testClock, testClock) ||
                const DeepCollectionEquality()
                    .equals(other.testClock, testClock)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(testClock) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $SandboxTransferTestClockGetResponseExtension
    on SandboxTransferTestClockGetResponse {
  SandboxTransferTestClockGetResponse copyWith(
      {TransferTestClock? testClock, String? requestId}) {
    return SandboxTransferTestClockGetResponse(
        testClock: testClock ?? this.testClock,
        requestId: requestId ?? this.requestId);
  }

  SandboxTransferTestClockGetResponse copyWithWrapped(
      {Wrapped<TransferTestClock>? testClock, Wrapped<String>? requestId}) {
    return SandboxTransferTestClockGetResponse(
        testClock: (testClock != null ? testClock.value : this.testClock),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class SandboxTransferRepaymentSimulateRequest {
  SandboxTransferRepaymentSimulateRequest({
    this.clientId,
    this.secret,
  });

  factory SandboxTransferRepaymentSimulateRequest.fromJson(
          Map<String, dynamic> json) =>
      _$SandboxTransferRepaymentSimulateRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  static const fromJsonFactory =
      _$SandboxTransferRepaymentSimulateRequestFromJson;
  static const toJsonFactory = _$SandboxTransferRepaymentSimulateRequestToJson;
  Map<String, dynamic> toJson() =>
      _$SandboxTransferRepaymentSimulateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SandboxTransferRepaymentSimulateRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      runtimeType.hashCode;
}

extension $SandboxTransferRepaymentSimulateRequestExtension
    on SandboxTransferRepaymentSimulateRequest {
  SandboxTransferRepaymentSimulateRequest copyWith(
      {String? clientId, String? secret}) {
    return SandboxTransferRepaymentSimulateRequest(
        clientId: clientId ?? this.clientId, secret: secret ?? this.secret);
  }

  SandboxTransferRepaymentSimulateRequest copyWithWrapped(
      {Wrapped<String?>? clientId, Wrapped<String?>? secret}) {
    return SandboxTransferRepaymentSimulateRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret));
  }
}

@JsonSerializable(explicitToJson: true)
class SandboxTransferRepaymentSimulateResponse {
  SandboxTransferRepaymentSimulateResponse({
    required this.requestId,
  });

  factory SandboxTransferRepaymentSimulateResponse.fromJson(
          Map<String, dynamic> json) =>
      _$SandboxTransferRepaymentSimulateResponseFromJson(json);

  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory =
      _$SandboxTransferRepaymentSimulateResponseFromJson;
  static const toJsonFactory = _$SandboxTransferRepaymentSimulateResponseToJson;
  Map<String, dynamic> toJson() =>
      _$SandboxTransferRepaymentSimulateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SandboxTransferRepaymentSimulateResponse &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(requestId) ^ runtimeType.hashCode;
}

extension $SandboxTransferRepaymentSimulateResponseExtension
    on SandboxTransferRepaymentSimulateResponse {
  SandboxTransferRepaymentSimulateResponse copyWith({String? requestId}) {
    return SandboxTransferRepaymentSimulateResponse(
        requestId: requestId ?? this.requestId);
  }

  SandboxTransferRepaymentSimulateResponse copyWithWrapped(
      {Wrapped<String>? requestId}) {
    return SandboxTransferRepaymentSimulateResponse(
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class AccountFiltersResponse {
  AccountFiltersResponse({
    this.depository,
    this.credit,
    this.loan,
    this.investment,
  });

  factory AccountFiltersResponse.fromJson(Map<String, dynamic> json) =>
      _$AccountFiltersResponseFromJson(json);

  @JsonKey(name: 'depository')
  final DepositoryFilter? depository;
  @JsonKey(name: 'credit')
  final CreditFilter? credit;
  @JsonKey(name: 'loan')
  final LoanFilter? loan;
  @JsonKey(name: 'investment')
  final InvestmentFilter? investment;
  static const fromJsonFactory = _$AccountFiltersResponseFromJson;
  static const toJsonFactory = _$AccountFiltersResponseToJson;
  Map<String, dynamic> toJson() => _$AccountFiltersResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AccountFiltersResponse &&
            (identical(other.depository, depository) ||
                const DeepCollectionEquality()
                    .equals(other.depository, depository)) &&
            (identical(other.credit, credit) ||
                const DeepCollectionEquality().equals(other.credit, credit)) &&
            (identical(other.loan, loan) ||
                const DeepCollectionEquality().equals(other.loan, loan)) &&
            (identical(other.investment, investment) ||
                const DeepCollectionEquality()
                    .equals(other.investment, investment)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(depository) ^
      const DeepCollectionEquality().hash(credit) ^
      const DeepCollectionEquality().hash(loan) ^
      const DeepCollectionEquality().hash(investment) ^
      runtimeType.hashCode;
}

extension $AccountFiltersResponseExtension on AccountFiltersResponse {
  AccountFiltersResponse copyWith(
      {DepositoryFilter? depository,
      CreditFilter? credit,
      LoanFilter? loan,
      InvestmentFilter? investment}) {
    return AccountFiltersResponse(
        depository: depository ?? this.depository,
        credit: credit ?? this.credit,
        loan: loan ?? this.loan,
        investment: investment ?? this.investment);
  }

  AccountFiltersResponse copyWithWrapped(
      {Wrapped<DepositoryFilter?>? depository,
      Wrapped<CreditFilter?>? credit,
      Wrapped<LoanFilter?>? loan,
      Wrapped<InvestmentFilter?>? investment}) {
    return AccountFiltersResponse(
        depository: (depository != null ? depository.value : this.depository),
        credit: (credit != null ? credit.value : this.credit),
        loan: (loan != null ? loan.value : this.loan),
        investment: (investment != null ? investment.value : this.investment));
  }
}

@JsonSerializable(explicitToJson: true)
class InstitutionsSearchAccountFilter {
  InstitutionsSearchAccountFilter({
    this.loan,
    this.depository,
    this.credit,
    this.investment,
  });

  factory InstitutionsSearchAccountFilter.fromJson(Map<String, dynamic> json) =>
      _$InstitutionsSearchAccountFilterFromJson(json);

  @JsonKey(
    name: 'loan',
    toJson: accountSubtypeListToJson,
    fromJson: accountSubtypeListFromJson,
  )
  final List<enums.AccountSubtype>? loan;
  @JsonKey(
    name: 'depository',
    toJson: accountSubtypeListToJson,
    fromJson: accountSubtypeListFromJson,
  )
  final List<enums.AccountSubtype>? depository;
  @JsonKey(
    name: 'credit',
    toJson: accountSubtypeListToJson,
    fromJson: accountSubtypeListFromJson,
  )
  final List<enums.AccountSubtype>? credit;
  @JsonKey(
    name: 'investment',
    toJson: accountSubtypeListToJson,
    fromJson: accountSubtypeListFromJson,
  )
  final List<enums.AccountSubtype>? investment;
  static const fromJsonFactory = _$InstitutionsSearchAccountFilterFromJson;
  static const toJsonFactory = _$InstitutionsSearchAccountFilterToJson;
  Map<String, dynamic> toJson() =>
      _$InstitutionsSearchAccountFilterToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InstitutionsSearchAccountFilter &&
            (identical(other.loan, loan) ||
                const DeepCollectionEquality().equals(other.loan, loan)) &&
            (identical(other.depository, depository) ||
                const DeepCollectionEquality()
                    .equals(other.depository, depository)) &&
            (identical(other.credit, credit) ||
                const DeepCollectionEquality().equals(other.credit, credit)) &&
            (identical(other.investment, investment) ||
                const DeepCollectionEquality()
                    .equals(other.investment, investment)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(loan) ^
      const DeepCollectionEquality().hash(depository) ^
      const DeepCollectionEquality().hash(credit) ^
      const DeepCollectionEquality().hash(investment) ^
      runtimeType.hashCode;
}

extension $InstitutionsSearchAccountFilterExtension
    on InstitutionsSearchAccountFilter {
  InstitutionsSearchAccountFilter copyWith(
      {List<enums.AccountSubtype>? loan,
      List<enums.AccountSubtype>? depository,
      List<enums.AccountSubtype>? credit,
      List<enums.AccountSubtype>? investment}) {
    return InstitutionsSearchAccountFilter(
        loan: loan ?? this.loan,
        depository: depository ?? this.depository,
        credit: credit ?? this.credit,
        investment: investment ?? this.investment);
  }

  InstitutionsSearchAccountFilter copyWithWrapped(
      {Wrapped<List<enums.AccountSubtype>?>? loan,
      Wrapped<List<enums.AccountSubtype>?>? depository,
      Wrapped<List<enums.AccountSubtype>?>? credit,
      Wrapped<List<enums.AccountSubtype>?>? investment}) {
    return InstitutionsSearchAccountFilter(
        loan: (loan != null ? loan.value : this.loan),
        depository: (depository != null ? depository.value : this.depository),
        credit: (credit != null ? credit.value : this.credit),
        investment: (investment != null ? investment.value : this.investment));
  }
}

@JsonSerializable(explicitToJson: true)
class AccountIdentity {
  AccountIdentity({
    required this.owners,
    required this.accountId,
    required this.balances,
    required this.mask,
    required this.name,
    required this.officialName,
    required this.type,
    required this.subtype,
    this.verificationStatus,
  });

  factory AccountIdentity.fromJson(Map<String, dynamic> json) =>
      _$AccountIdentityFromJson(json);

  @JsonKey(name: 'owners', defaultValue: <Owner>[])
  final List<Owner> owners;
  @JsonKey(name: 'account_id')
  final String accountId;
  @JsonKey(name: 'balances')
  final AccountBalance balances;
  @JsonKey(name: 'mask')
  final String? mask;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'official_name')
  final String? officialName;
  @JsonKey(
    name: 'type',
    toJson: accountTypeToJson,
    fromJson: accountTypeFromJson,
  )
  final enums.AccountType type;
  @JsonKey(
    name: 'subtype',
    toJson: accountSubtypeToJson,
    fromJson: accountSubtypeFromJson,
  )
  final enums.AccountSubtype? subtype;
  @JsonKey(
    name: 'verification_status',
    toJson: accountIdentityVerificationStatusToJson,
    fromJson: accountIdentityVerificationStatusFromJson,
  )
  final enums.AccountIdentityVerificationStatus? verificationStatus;
  static const fromJsonFactory = _$AccountIdentityFromJson;
  static const toJsonFactory = _$AccountIdentityToJson;
  Map<String, dynamic> toJson() => _$AccountIdentityToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AccountIdentity &&
            (identical(other.owners, owners) ||
                const DeepCollectionEquality().equals(other.owners, owners)) &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.balances, balances) ||
                const DeepCollectionEquality()
                    .equals(other.balances, balances)) &&
            (identical(other.mask, mask) ||
                const DeepCollectionEquality().equals(other.mask, mask)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.officialName, officialName) ||
                const DeepCollectionEquality()
                    .equals(other.officialName, officialName)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.subtype, subtype) ||
                const DeepCollectionEquality()
                    .equals(other.subtype, subtype)) &&
            (identical(other.verificationStatus, verificationStatus) ||
                const DeepCollectionEquality()
                    .equals(other.verificationStatus, verificationStatus)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(owners) ^
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(balances) ^
      const DeepCollectionEquality().hash(mask) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(officialName) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(subtype) ^
      const DeepCollectionEquality().hash(verificationStatus) ^
      runtimeType.hashCode;
}

extension $AccountIdentityExtension on AccountIdentity {
  AccountIdentity copyWith(
      {List<Owner>? owners,
      String? accountId,
      AccountBalance? balances,
      String? mask,
      String? name,
      String? officialName,
      enums.AccountType? type,
      enums.AccountSubtype? subtype,
      enums.AccountIdentityVerificationStatus? verificationStatus}) {
    return AccountIdentity(
        owners: owners ?? this.owners,
        accountId: accountId ?? this.accountId,
        balances: balances ?? this.balances,
        mask: mask ?? this.mask,
        name: name ?? this.name,
        officialName: officialName ?? this.officialName,
        type: type ?? this.type,
        subtype: subtype ?? this.subtype,
        verificationStatus: verificationStatus ?? this.verificationStatus);
  }

  AccountIdentity copyWithWrapped(
      {Wrapped<List<Owner>>? owners,
      Wrapped<String>? accountId,
      Wrapped<AccountBalance>? balances,
      Wrapped<String?>? mask,
      Wrapped<String>? name,
      Wrapped<String?>? officialName,
      Wrapped<enums.AccountType>? type,
      Wrapped<enums.AccountSubtype?>? subtype,
      Wrapped<enums.AccountIdentityVerificationStatus?>? verificationStatus}) {
    return AccountIdentity(
        owners: (owners != null ? owners.value : this.owners),
        accountId: (accountId != null ? accountId.value : this.accountId),
        balances: (balances != null ? balances.value : this.balances),
        mask: (mask != null ? mask.value : this.mask),
        name: (name != null ? name.value : this.name),
        officialName:
            (officialName != null ? officialName.value : this.officialName),
        type: (type != null ? type.value : this.type),
        subtype: (subtype != null ? subtype.value : this.subtype),
        verificationStatus: (verificationStatus != null
            ? verificationStatus.value
            : this.verificationStatus));
  }
}

@JsonSerializable(explicitToJson: true)
class AccountIdentityMatchScore {
  AccountIdentityMatchScore({
    this.legalName,
    this.phoneNumber,
    this.emailAddress,
    this.address,
    required this.accountId,
    required this.balances,
    required this.mask,
    required this.name,
    required this.officialName,
    required this.type,
    required this.subtype,
    this.verificationStatus,
  });

  factory AccountIdentityMatchScore.fromJson(Map<String, dynamic> json) =>
      _$AccountIdentityMatchScoreFromJson(json);

  @JsonKey(name: 'legal_name')
  final NameMatchScore? legalName;
  @JsonKey(name: 'phone_number')
  final PhoneNumberMatchScore? phoneNumber;
  @JsonKey(name: 'email_address')
  final EmailAddressMatchScore? emailAddress;
  @JsonKey(name: 'address')
  final AddressMatchScore? address;
  @JsonKey(name: 'account_id')
  final String accountId;
  @JsonKey(name: 'balances')
  final AccountBalance balances;
  @JsonKey(name: 'mask')
  final String? mask;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'official_name')
  final String? officialName;
  @JsonKey(
    name: 'type',
    toJson: accountTypeToJson,
    fromJson: accountTypeFromJson,
  )
  final enums.AccountType type;
  @JsonKey(
    name: 'subtype',
    toJson: accountSubtypeToJson,
    fromJson: accountSubtypeFromJson,
  )
  final enums.AccountSubtype? subtype;
  @JsonKey(
    name: 'verification_status',
    toJson: accountIdentityMatchScoreVerificationStatusToJson,
    fromJson: accountIdentityMatchScoreVerificationStatusFromJson,
  )
  final enums.AccountIdentityMatchScoreVerificationStatus? verificationStatus;
  static const fromJsonFactory = _$AccountIdentityMatchScoreFromJson;
  static const toJsonFactory = _$AccountIdentityMatchScoreToJson;
  Map<String, dynamic> toJson() => _$AccountIdentityMatchScoreToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AccountIdentityMatchScore &&
            (identical(other.legalName, legalName) ||
                const DeepCollectionEquality()
                    .equals(other.legalName, legalName)) &&
            (identical(other.phoneNumber, phoneNumber) ||
                const DeepCollectionEquality()
                    .equals(other.phoneNumber, phoneNumber)) &&
            (identical(other.emailAddress, emailAddress) ||
                const DeepCollectionEquality()
                    .equals(other.emailAddress, emailAddress)) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality()
                    .equals(other.address, address)) &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.balances, balances) ||
                const DeepCollectionEquality()
                    .equals(other.balances, balances)) &&
            (identical(other.mask, mask) ||
                const DeepCollectionEquality().equals(other.mask, mask)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.officialName, officialName) ||
                const DeepCollectionEquality()
                    .equals(other.officialName, officialName)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.subtype, subtype) ||
                const DeepCollectionEquality()
                    .equals(other.subtype, subtype)) &&
            (identical(other.verificationStatus, verificationStatus) ||
                const DeepCollectionEquality()
                    .equals(other.verificationStatus, verificationStatus)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(legalName) ^
      const DeepCollectionEquality().hash(phoneNumber) ^
      const DeepCollectionEquality().hash(emailAddress) ^
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(balances) ^
      const DeepCollectionEquality().hash(mask) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(officialName) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(subtype) ^
      const DeepCollectionEquality().hash(verificationStatus) ^
      runtimeType.hashCode;
}

extension $AccountIdentityMatchScoreExtension on AccountIdentityMatchScore {
  AccountIdentityMatchScore copyWith(
      {NameMatchScore? legalName,
      PhoneNumberMatchScore? phoneNumber,
      EmailAddressMatchScore? emailAddress,
      AddressMatchScore? address,
      String? accountId,
      AccountBalance? balances,
      String? mask,
      String? name,
      String? officialName,
      enums.AccountType? type,
      enums.AccountSubtype? subtype,
      enums.AccountIdentityMatchScoreVerificationStatus? verificationStatus}) {
    return AccountIdentityMatchScore(
        legalName: legalName ?? this.legalName,
        phoneNumber: phoneNumber ?? this.phoneNumber,
        emailAddress: emailAddress ?? this.emailAddress,
        address: address ?? this.address,
        accountId: accountId ?? this.accountId,
        balances: balances ?? this.balances,
        mask: mask ?? this.mask,
        name: name ?? this.name,
        officialName: officialName ?? this.officialName,
        type: type ?? this.type,
        subtype: subtype ?? this.subtype,
        verificationStatus: verificationStatus ?? this.verificationStatus);
  }

  AccountIdentityMatchScore copyWithWrapped(
      {Wrapped<NameMatchScore?>? legalName,
      Wrapped<PhoneNumberMatchScore?>? phoneNumber,
      Wrapped<EmailAddressMatchScore?>? emailAddress,
      Wrapped<AddressMatchScore?>? address,
      Wrapped<String>? accountId,
      Wrapped<AccountBalance>? balances,
      Wrapped<String?>? mask,
      Wrapped<String>? name,
      Wrapped<String?>? officialName,
      Wrapped<enums.AccountType>? type,
      Wrapped<enums.AccountSubtype?>? subtype,
      Wrapped<enums.AccountIdentityMatchScoreVerificationStatus?>?
          verificationStatus}) {
    return AccountIdentityMatchScore(
        legalName: (legalName != null ? legalName.value : this.legalName),
        phoneNumber:
            (phoneNumber != null ? phoneNumber.value : this.phoneNumber),
        emailAddress:
            (emailAddress != null ? emailAddress.value : this.emailAddress),
        address: (address != null ? address.value : this.address),
        accountId: (accountId != null ? accountId.value : this.accountId),
        balances: (balances != null ? balances.value : this.balances),
        mask: (mask != null ? mask.value : this.mask),
        name: (name != null ? name.value : this.name),
        officialName:
            (officialName != null ? officialName.value : this.officialName),
        type: (type != null ? type.value : this.type),
        subtype: (subtype != null ? subtype.value : this.subtype),
        verificationStatus: (verificationStatus != null
            ? verificationStatus.value
            : this.verificationStatus));
  }
}

@JsonSerializable(explicitToJson: true)
class NameMatchScore {
  NameMatchScore({
    this.score,
    this.isFirstNameOrLastNameMatch,
    this.isNicknameMatch,
    this.isBusinessNameDetected,
  });

  factory NameMatchScore.fromJson(Map<String, dynamic> json) =>
      _$NameMatchScoreFromJson(json);

  @JsonKey(name: 'score')
  final int? score;
  @JsonKey(name: 'is_first_name_or_last_name_match')
  final bool? isFirstNameOrLastNameMatch;
  @JsonKey(name: 'is_nickname_match')
  final bool? isNicknameMatch;
  @JsonKey(name: 'is_business_name_detected')
  final bool? isBusinessNameDetected;
  static const fromJsonFactory = _$NameMatchScoreFromJson;
  static const toJsonFactory = _$NameMatchScoreToJson;
  Map<String, dynamic> toJson() => _$NameMatchScoreToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is NameMatchScore &&
            (identical(other.score, score) ||
                const DeepCollectionEquality().equals(other.score, score)) &&
            (identical(other.isFirstNameOrLastNameMatch,
                    isFirstNameOrLastNameMatch) ||
                const DeepCollectionEquality().equals(
                    other.isFirstNameOrLastNameMatch,
                    isFirstNameOrLastNameMatch)) &&
            (identical(other.isNicknameMatch, isNicknameMatch) ||
                const DeepCollectionEquality()
                    .equals(other.isNicknameMatch, isNicknameMatch)) &&
            (identical(other.isBusinessNameDetected, isBusinessNameDetected) ||
                const DeepCollectionEquality().equals(
                    other.isBusinessNameDetected, isBusinessNameDetected)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(score) ^
      const DeepCollectionEquality().hash(isFirstNameOrLastNameMatch) ^
      const DeepCollectionEquality().hash(isNicknameMatch) ^
      const DeepCollectionEquality().hash(isBusinessNameDetected) ^
      runtimeType.hashCode;
}

extension $NameMatchScoreExtension on NameMatchScore {
  NameMatchScore copyWith(
      {int? score,
      bool? isFirstNameOrLastNameMatch,
      bool? isNicknameMatch,
      bool? isBusinessNameDetected}) {
    return NameMatchScore(
        score: score ?? this.score,
        isFirstNameOrLastNameMatch:
            isFirstNameOrLastNameMatch ?? this.isFirstNameOrLastNameMatch,
        isNicknameMatch: isNicknameMatch ?? this.isNicknameMatch,
        isBusinessNameDetected:
            isBusinessNameDetected ?? this.isBusinessNameDetected);
  }

  NameMatchScore copyWithWrapped(
      {Wrapped<int?>? score,
      Wrapped<bool?>? isFirstNameOrLastNameMatch,
      Wrapped<bool?>? isNicknameMatch,
      Wrapped<bool?>? isBusinessNameDetected}) {
    return NameMatchScore(
        score: (score != null ? score.value : this.score),
        isFirstNameOrLastNameMatch: (isFirstNameOrLastNameMatch != null
            ? isFirstNameOrLastNameMatch.value
            : this.isFirstNameOrLastNameMatch),
        isNicknameMatch: (isNicknameMatch != null
            ? isNicknameMatch.value
            : this.isNicknameMatch),
        isBusinessNameDetected: (isBusinessNameDetected != null
            ? isBusinessNameDetected.value
            : this.isBusinessNameDetected));
  }
}

@JsonSerializable(explicitToJson: true)
class PhoneNumberMatchScore {
  PhoneNumberMatchScore({
    this.score,
  });

  factory PhoneNumberMatchScore.fromJson(Map<String, dynamic> json) =>
      _$PhoneNumberMatchScoreFromJson(json);

  @JsonKey(name: 'score')
  final int? score;
  static const fromJsonFactory = _$PhoneNumberMatchScoreFromJson;
  static const toJsonFactory = _$PhoneNumberMatchScoreToJson;
  Map<String, dynamic> toJson() => _$PhoneNumberMatchScoreToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PhoneNumberMatchScore &&
            (identical(other.score, score) ||
                const DeepCollectionEquality().equals(other.score, score)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(score) ^ runtimeType.hashCode;
}

extension $PhoneNumberMatchScoreExtension on PhoneNumberMatchScore {
  PhoneNumberMatchScore copyWith({int? score}) {
    return PhoneNumberMatchScore(score: score ?? this.score);
  }

  PhoneNumberMatchScore copyWithWrapped({Wrapped<int?>? score}) {
    return PhoneNumberMatchScore(
        score: (score != null ? score.value : this.score));
  }
}

@JsonSerializable(explicitToJson: true)
class EmailAddressMatchScore {
  EmailAddressMatchScore({
    this.score,
  });

  factory EmailAddressMatchScore.fromJson(Map<String, dynamic> json) =>
      _$EmailAddressMatchScoreFromJson(json);

  @JsonKey(name: 'score')
  final int? score;
  static const fromJsonFactory = _$EmailAddressMatchScoreFromJson;
  static const toJsonFactory = _$EmailAddressMatchScoreToJson;
  Map<String, dynamic> toJson() => _$EmailAddressMatchScoreToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is EmailAddressMatchScore &&
            (identical(other.score, score) ||
                const DeepCollectionEquality().equals(other.score, score)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(score) ^ runtimeType.hashCode;
}

extension $EmailAddressMatchScoreExtension on EmailAddressMatchScore {
  EmailAddressMatchScore copyWith({int? score}) {
    return EmailAddressMatchScore(score: score ?? this.score);
  }

  EmailAddressMatchScore copyWithWrapped({Wrapped<int?>? score}) {
    return EmailAddressMatchScore(
        score: (score != null ? score.value : this.score));
  }
}

@JsonSerializable(explicitToJson: true)
class AddressMatchScore {
  AddressMatchScore({
    this.score,
    this.isPostalCodeMatch,
  });

  factory AddressMatchScore.fromJson(Map<String, dynamic> json) =>
      _$AddressMatchScoreFromJson(json);

  @JsonKey(name: 'score')
  final int? score;
  @JsonKey(name: 'is_postal_code_match')
  final bool? isPostalCodeMatch;
  static const fromJsonFactory = _$AddressMatchScoreFromJson;
  static const toJsonFactory = _$AddressMatchScoreToJson;
  Map<String, dynamic> toJson() => _$AddressMatchScoreToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AddressMatchScore &&
            (identical(other.score, score) ||
                const DeepCollectionEquality().equals(other.score, score)) &&
            (identical(other.isPostalCodeMatch, isPostalCodeMatch) ||
                const DeepCollectionEquality()
                    .equals(other.isPostalCodeMatch, isPostalCodeMatch)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(score) ^
      const DeepCollectionEquality().hash(isPostalCodeMatch) ^
      runtimeType.hashCode;
}

extension $AddressMatchScoreExtension on AddressMatchScore {
  AddressMatchScore copyWith({int? score, bool? isPostalCodeMatch}) {
    return AddressMatchScore(
        score: score ?? this.score,
        isPostalCodeMatch: isPostalCodeMatch ?? this.isPostalCodeMatch);
  }

  AddressMatchScore copyWithWrapped(
      {Wrapped<int?>? score, Wrapped<bool?>? isPostalCodeMatch}) {
    return AddressMatchScore(
        score: (score != null ? score.value : this.score),
        isPostalCodeMatch: (isPostalCodeMatch != null
            ? isPostalCodeMatch.value
            : this.isPostalCodeMatch));
  }
}

@JsonSerializable(explicitToJson: true)
class DepositoryFilter {
  DepositoryFilter({
    required this.accountSubtypes,
  });

  factory DepositoryFilter.fromJson(Map<String, dynamic> json) =>
      _$DepositoryFilterFromJson(json);

  @JsonKey(name: 'account_subtypes')
  final List<String> accountSubtypes;
  static const fromJsonFactory = _$DepositoryFilterFromJson;
  static const toJsonFactory = _$DepositoryFilterToJson;
  Map<String, dynamic> toJson() => _$DepositoryFilterToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is DepositoryFilter &&
            (identical(other.accountSubtypes, accountSubtypes) ||
                const DeepCollectionEquality()
                    .equals(other.accountSubtypes, accountSubtypes)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountSubtypes) ^
      runtimeType.hashCode;
}

extension $DepositoryFilterExtension on DepositoryFilter {
  DepositoryFilter copyWith({List<String>? accountSubtypes}) {
    return DepositoryFilter(
        accountSubtypes: accountSubtypes ?? this.accountSubtypes);
  }

  DepositoryFilter copyWithWrapped({Wrapped<List<String>>? accountSubtypes}) {
    return DepositoryFilter(
        accountSubtypes: (accountSubtypes != null
            ? accountSubtypes.value
            : this.accountSubtypes));
  }
}

@JsonSerializable(explicitToJson: true)
class CreditFilter {
  CreditFilter({
    required this.accountSubtypes,
  });

  factory CreditFilter.fromJson(Map<String, dynamic> json) =>
      _$CreditFilterFromJson(json);

  @JsonKey(name: 'account_subtypes')
  final List<String> accountSubtypes;
  static const fromJsonFactory = _$CreditFilterFromJson;
  static const toJsonFactory = _$CreditFilterToJson;
  Map<String, dynamic> toJson() => _$CreditFilterToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CreditFilter &&
            (identical(other.accountSubtypes, accountSubtypes) ||
                const DeepCollectionEquality()
                    .equals(other.accountSubtypes, accountSubtypes)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountSubtypes) ^
      runtimeType.hashCode;
}

extension $CreditFilterExtension on CreditFilter {
  CreditFilter copyWith({List<String>? accountSubtypes}) {
    return CreditFilter(
        accountSubtypes: accountSubtypes ?? this.accountSubtypes);
  }

  CreditFilter copyWithWrapped({Wrapped<List<String>>? accountSubtypes}) {
    return CreditFilter(
        accountSubtypes: (accountSubtypes != null
            ? accountSubtypes.value
            : this.accountSubtypes));
  }
}

@JsonSerializable(explicitToJson: true)
class LoanFilter {
  LoanFilter({
    required this.accountSubtypes,
  });

  factory LoanFilter.fromJson(Map<String, dynamic> json) =>
      _$LoanFilterFromJson(json);

  @JsonKey(name: 'account_subtypes')
  final List<String> accountSubtypes;
  static const fromJsonFactory = _$LoanFilterFromJson;
  static const toJsonFactory = _$LoanFilterToJson;
  Map<String, dynamic> toJson() => _$LoanFilterToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LoanFilter &&
            (identical(other.accountSubtypes, accountSubtypes) ||
                const DeepCollectionEquality()
                    .equals(other.accountSubtypes, accountSubtypes)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountSubtypes) ^
      runtimeType.hashCode;
}

extension $LoanFilterExtension on LoanFilter {
  LoanFilter copyWith({List<String>? accountSubtypes}) {
    return LoanFilter(accountSubtypes: accountSubtypes ?? this.accountSubtypes);
  }

  LoanFilter copyWithWrapped({Wrapped<List<String>>? accountSubtypes}) {
    return LoanFilter(
        accountSubtypes: (accountSubtypes != null
            ? accountSubtypes.value
            : this.accountSubtypes));
  }
}

@JsonSerializable(explicitToJson: true)
class InvestmentFilter {
  InvestmentFilter({
    required this.accountSubtypes,
  });

  factory InvestmentFilter.fromJson(Map<String, dynamic> json) =>
      _$InvestmentFilterFromJson(json);

  @JsonKey(name: 'account_subtypes')
  final List<String> accountSubtypes;
  static const fromJsonFactory = _$InvestmentFilterFromJson;
  static const toJsonFactory = _$InvestmentFilterToJson;
  Map<String, dynamic> toJson() => _$InvestmentFilterToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvestmentFilter &&
            (identical(other.accountSubtypes, accountSubtypes) ||
                const DeepCollectionEquality()
                    .equals(other.accountSubtypes, accountSubtypes)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountSubtypes) ^
      runtimeType.hashCode;
}

extension $InvestmentFilterExtension on InvestmentFilter {
  InvestmentFilter copyWith({List<String>? accountSubtypes}) {
    return InvestmentFilter(
        accountSubtypes: accountSubtypes ?? this.accountSubtypes);
  }

  InvestmentFilter copyWithWrapped({Wrapped<List<String>>? accountSubtypes}) {
    return InvestmentFilter(
        accountSubtypes: (accountSubtypes != null
            ? accountSubtypes.value
            : this.accountSubtypes));
  }
}

typedef DepositoryAccountSubtypes = List<String>;
typedef CreditAccountSubtypes = List<String>;
typedef LoanAccountSubtypes = List<String>;
typedef InvestmentAccountSubtypes = List<String>;

@JsonSerializable(explicitToJson: true)
class EmployersSearchRequest {
  EmployersSearchRequest({
    this.clientId,
    this.secret,
    required this.query,
    required this.products,
  });

  factory EmployersSearchRequest.fromJson(Map<String, dynamic> json) =>
      _$EmployersSearchRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'query')
  final String query;
  @JsonKey(name: 'products', defaultValue: <String>[])
  final List<String> products;
  static const fromJsonFactory = _$EmployersSearchRequestFromJson;
  static const toJsonFactory = _$EmployersSearchRequestToJson;
  Map<String, dynamic> toJson() => _$EmployersSearchRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is EmployersSearchRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.query, query) ||
                const DeepCollectionEquality().equals(other.query, query)) &&
            (identical(other.products, products) ||
                const DeepCollectionEquality()
                    .equals(other.products, products)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(query) ^
      const DeepCollectionEquality().hash(products) ^
      runtimeType.hashCode;
}

extension $EmployersSearchRequestExtension on EmployersSearchRequest {
  EmployersSearchRequest copyWith(
      {String? clientId,
      String? secret,
      String? query,
      List<String>? products}) {
    return EmployersSearchRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        query: query ?? this.query,
        products: products ?? this.products);
  }

  EmployersSearchRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? query,
      Wrapped<List<String>>? products}) {
    return EmployersSearchRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        query: (query != null ? query.value : this.query),
        products: (products != null ? products.value : this.products));
  }
}

@JsonSerializable(explicitToJson: true)
class EmployersSearchResponse {
  EmployersSearchResponse({
    required this.employers,
    required this.requestId,
  });

  factory EmployersSearchResponse.fromJson(Map<String, dynamic> json) =>
      _$EmployersSearchResponseFromJson(json);

  @JsonKey(name: 'employers', defaultValue: <Employer>[])
  final List<Employer> employers;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$EmployersSearchResponseFromJson;
  static const toJsonFactory = _$EmployersSearchResponseToJson;
  Map<String, dynamic> toJson() => _$EmployersSearchResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is EmployersSearchResponse &&
            (identical(other.employers, employers) ||
                const DeepCollectionEquality()
                    .equals(other.employers, employers)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(employers) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $EmployersSearchResponseExtension on EmployersSearchResponse {
  EmployersSearchResponse copyWith(
      {List<Employer>? employers, String? requestId}) {
    return EmployersSearchResponse(
        employers: employers ?? this.employers,
        requestId: requestId ?? this.requestId);
  }

  EmployersSearchResponse copyWithWrapped(
      {Wrapped<List<Employer>>? employers, Wrapped<String>? requestId}) {
    return EmployersSearchResponse(
        employers: (employers != null ? employers.value : this.employers),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class Employer {
  Employer({
    required this.employerId,
    required this.name,
    required this.address,
    required this.confidenceScore,
  });

  factory Employer.fromJson(Map<String, dynamic> json) =>
      _$EmployerFromJson(json);

  @JsonKey(name: 'employer_id')
  final String employerId;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'address')
  final AddressDataNullable? address;
  @JsonKey(name: 'confidence_score')
  final double confidenceScore;
  static const fromJsonFactory = _$EmployerFromJson;
  static const toJsonFactory = _$EmployerToJson;
  Map<String, dynamic> toJson() => _$EmployerToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Employer &&
            (identical(other.employerId, employerId) ||
                const DeepCollectionEquality()
                    .equals(other.employerId, employerId)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality()
                    .equals(other.address, address)) &&
            (identical(other.confidenceScore, confidenceScore) ||
                const DeepCollectionEquality()
                    .equals(other.confidenceScore, confidenceScore)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(employerId) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(confidenceScore) ^
      runtimeType.hashCode;
}

extension $EmployerExtension on Employer {
  Employer copyWith(
      {String? employerId,
      String? name,
      AddressDataNullable? address,
      double? confidenceScore}) {
    return Employer(
        employerId: employerId ?? this.employerId,
        name: name ?? this.name,
        address: address ?? this.address,
        confidenceScore: confidenceScore ?? this.confidenceScore);
  }

  Employer copyWithWrapped(
      {Wrapped<String>? employerId,
      Wrapped<String>? name,
      Wrapped<AddressDataNullable?>? address,
      Wrapped<double>? confidenceScore}) {
    return Employer(
        employerId: (employerId != null ? employerId.value : this.employerId),
        name: (name != null ? name.value : this.name),
        address: (address != null ? address.value : this.address),
        confidenceScore: (confidenceScore != null
            ? confidenceScore.value
            : this.confidenceScore));
  }
}

@JsonSerializable(explicitToJson: true)
class IncomeVerificationCreateRequest {
  IncomeVerificationCreateRequest({
    this.clientId,
    this.secret,
    required this.webhook,
    this.precheckId,
    this.options,
  });

  factory IncomeVerificationCreateRequest.fromJson(Map<String, dynamic> json) =>
      _$IncomeVerificationCreateRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'webhook')
  final String webhook;
  @JsonKey(name: 'precheck_id')
  final String? precheckId;
  @JsonKey(name: 'options')
  final IncomeVerificationCreateRequestOptions? options;
  static const fromJsonFactory = _$IncomeVerificationCreateRequestFromJson;
  static const toJsonFactory = _$IncomeVerificationCreateRequestToJson;
  Map<String, dynamic> toJson() =>
      _$IncomeVerificationCreateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IncomeVerificationCreateRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.webhook, webhook) ||
                const DeepCollectionEquality()
                    .equals(other.webhook, webhook)) &&
            (identical(other.precheckId, precheckId) ||
                const DeepCollectionEquality()
                    .equals(other.precheckId, precheckId)) &&
            (identical(other.options, options) ||
                const DeepCollectionEquality().equals(other.options, options)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(webhook) ^
      const DeepCollectionEquality().hash(precheckId) ^
      const DeepCollectionEquality().hash(options) ^
      runtimeType.hashCode;
}

extension $IncomeVerificationCreateRequestExtension
    on IncomeVerificationCreateRequest {
  IncomeVerificationCreateRequest copyWith(
      {String? clientId,
      String? secret,
      String? webhook,
      String? precheckId,
      IncomeVerificationCreateRequestOptions? options}) {
    return IncomeVerificationCreateRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        webhook: webhook ?? this.webhook,
        precheckId: precheckId ?? this.precheckId,
        options: options ?? this.options);
  }

  IncomeVerificationCreateRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? webhook,
      Wrapped<String?>? precheckId,
      Wrapped<IncomeVerificationCreateRequestOptions?>? options}) {
    return IncomeVerificationCreateRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        webhook: (webhook != null ? webhook.value : this.webhook),
        precheckId: (precheckId != null ? precheckId.value : this.precheckId),
        options: (options != null ? options.value : this.options));
  }
}

@JsonSerializable(explicitToJson: true)
class IncomeVerificationCreateRequestOptions {
  IncomeVerificationCreateRequestOptions({
    this.accessTokens,
  });

  factory IncomeVerificationCreateRequestOptions.fromJson(
          Map<String, dynamic> json) =>
      _$IncomeVerificationCreateRequestOptionsFromJson(json);

  @JsonKey(name: 'access_tokens', defaultValue: <String>[])
  final List<String>? accessTokens;
  static const fromJsonFactory =
      _$IncomeVerificationCreateRequestOptionsFromJson;
  static const toJsonFactory = _$IncomeVerificationCreateRequestOptionsToJson;
  Map<String, dynamic> toJson() =>
      _$IncomeVerificationCreateRequestOptionsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IncomeVerificationCreateRequestOptions &&
            (identical(other.accessTokens, accessTokens) ||
                const DeepCollectionEquality()
                    .equals(other.accessTokens, accessTokens)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accessTokens) ^ runtimeType.hashCode;
}

extension $IncomeVerificationCreateRequestOptionsExtension
    on IncomeVerificationCreateRequestOptions {
  IncomeVerificationCreateRequestOptions copyWith(
      {List<String>? accessTokens}) {
    return IncomeVerificationCreateRequestOptions(
        accessTokens: accessTokens ?? this.accessTokens);
  }

  IncomeVerificationCreateRequestOptions copyWithWrapped(
      {Wrapped<List<String>?>? accessTokens}) {
    return IncomeVerificationCreateRequestOptions(
        accessTokens:
            (accessTokens != null ? accessTokens.value : this.accessTokens));
  }
}

@JsonSerializable(explicitToJson: true)
class IncomeVerificationCreateResponse {
  IncomeVerificationCreateResponse({
    required this.incomeVerificationId,
    required this.requestId,
  });

  factory IncomeVerificationCreateResponse.fromJson(
          Map<String, dynamic> json) =>
      _$IncomeVerificationCreateResponseFromJson(json);

  @JsonKey(name: 'income_verification_id')
  final String incomeVerificationId;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$IncomeVerificationCreateResponseFromJson;
  static const toJsonFactory = _$IncomeVerificationCreateResponseToJson;
  Map<String, dynamic> toJson() =>
      _$IncomeVerificationCreateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IncomeVerificationCreateResponse &&
            (identical(other.incomeVerificationId, incomeVerificationId) ||
                const DeepCollectionEquality().equals(
                    other.incomeVerificationId, incomeVerificationId)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(incomeVerificationId) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $IncomeVerificationCreateResponseExtension
    on IncomeVerificationCreateResponse {
  IncomeVerificationCreateResponse copyWith(
      {String? incomeVerificationId, String? requestId}) {
    return IncomeVerificationCreateResponse(
        incomeVerificationId: incomeVerificationId ?? this.incomeVerificationId,
        requestId: requestId ?? this.requestId);
  }

  IncomeVerificationCreateResponse copyWithWrapped(
      {Wrapped<String>? incomeVerificationId, Wrapped<String>? requestId}) {
    return IncomeVerificationCreateResponse(
        incomeVerificationId: (incomeVerificationId != null
            ? incomeVerificationId.value
            : this.incomeVerificationId),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class IncomeVerificationPrecheckRequest {
  IncomeVerificationPrecheckRequest({
    this.clientId,
    this.secret,
    this.user,
    this.employer,
    this.payrollInstitution,
    this.transactionsAccessToken,
    this.transactionsAccessTokens,
    this.usMilitaryInfo,
  });

  factory IncomeVerificationPrecheckRequest.fromJson(
          Map<String, dynamic> json) =>
      _$IncomeVerificationPrecheckRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'user')
  final IncomeVerificationPrecheckUser? user;
  @JsonKey(name: 'employer')
  final IncomeVerificationPrecheckEmployer? employer;
  @JsonKey(name: 'payroll_institution')
  final IncomeVerificationPrecheckPayrollInstitution? payrollInstitution;
  @JsonKey(name: 'transactions_access_token')
  final String? transactionsAccessToken;
  @JsonKey(name: 'transactions_access_tokens', defaultValue: <String>[])
  final List<String>? transactionsAccessTokens;
  @JsonKey(name: 'us_military_info')
  final IncomeVerificationPrecheckMilitaryInfo? usMilitaryInfo;
  static const fromJsonFactory = _$IncomeVerificationPrecheckRequestFromJson;
  static const toJsonFactory = _$IncomeVerificationPrecheckRequestToJson;
  Map<String, dynamic> toJson() =>
      _$IncomeVerificationPrecheckRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IncomeVerificationPrecheckRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.user, user) ||
                const DeepCollectionEquality().equals(other.user, user)) &&
            (identical(other.employer, employer) ||
                const DeepCollectionEquality()
                    .equals(other.employer, employer)) &&
            (identical(other.payrollInstitution, payrollInstitution) ||
                const DeepCollectionEquality()
                    .equals(other.payrollInstitution, payrollInstitution)) &&
            (identical(
                    other.transactionsAccessToken, transactionsAccessToken) ||
                const DeepCollectionEquality().equals(
                    other.transactionsAccessToken, transactionsAccessToken)) &&
            (identical(
                    other.transactionsAccessTokens, transactionsAccessTokens) ||
                const DeepCollectionEquality().equals(
                    other.transactionsAccessTokens,
                    transactionsAccessTokens)) &&
            (identical(other.usMilitaryInfo, usMilitaryInfo) ||
                const DeepCollectionEquality()
                    .equals(other.usMilitaryInfo, usMilitaryInfo)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(user) ^
      const DeepCollectionEquality().hash(employer) ^
      const DeepCollectionEquality().hash(payrollInstitution) ^
      const DeepCollectionEquality().hash(transactionsAccessToken) ^
      const DeepCollectionEquality().hash(transactionsAccessTokens) ^
      const DeepCollectionEquality().hash(usMilitaryInfo) ^
      runtimeType.hashCode;
}

extension $IncomeVerificationPrecheckRequestExtension
    on IncomeVerificationPrecheckRequest {
  IncomeVerificationPrecheckRequest copyWith(
      {String? clientId,
      String? secret,
      IncomeVerificationPrecheckUser? user,
      IncomeVerificationPrecheckEmployer? employer,
      IncomeVerificationPrecheckPayrollInstitution? payrollInstitution,
      String? transactionsAccessToken,
      List<String>? transactionsAccessTokens,
      IncomeVerificationPrecheckMilitaryInfo? usMilitaryInfo}) {
    return IncomeVerificationPrecheckRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        user: user ?? this.user,
        employer: employer ?? this.employer,
        payrollInstitution: payrollInstitution ?? this.payrollInstitution,
        transactionsAccessToken:
            transactionsAccessToken ?? this.transactionsAccessToken,
        transactionsAccessTokens:
            transactionsAccessTokens ?? this.transactionsAccessTokens,
        usMilitaryInfo: usMilitaryInfo ?? this.usMilitaryInfo);
  }

  IncomeVerificationPrecheckRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<IncomeVerificationPrecheckUser?>? user,
      Wrapped<IncomeVerificationPrecheckEmployer?>? employer,
      Wrapped<IncomeVerificationPrecheckPayrollInstitution?>?
          payrollInstitution,
      Wrapped<String?>? transactionsAccessToken,
      Wrapped<List<String>?>? transactionsAccessTokens,
      Wrapped<IncomeVerificationPrecheckMilitaryInfo?>? usMilitaryInfo}) {
    return IncomeVerificationPrecheckRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        user: (user != null ? user.value : this.user),
        employer: (employer != null ? employer.value : this.employer),
        payrollInstitution: (payrollInstitution != null
            ? payrollInstitution.value
            : this.payrollInstitution),
        transactionsAccessToken: (transactionsAccessToken != null
            ? transactionsAccessToken.value
            : this.transactionsAccessToken),
        transactionsAccessTokens: (transactionsAccessTokens != null
            ? transactionsAccessTokens.value
            : this.transactionsAccessTokens),
        usMilitaryInfo: (usMilitaryInfo != null
            ? usMilitaryInfo.value
            : this.usMilitaryInfo));
  }
}

@JsonSerializable(explicitToJson: true)
class IncomeVerificationPrecheckEmployer {
  IncomeVerificationPrecheckEmployer({
    this.name,
    this.address,
    this.taxId,
    this.url,
  });

  factory IncomeVerificationPrecheckEmployer.fromJson(
          Map<String, dynamic> json) =>
      _$IncomeVerificationPrecheckEmployerFromJson(json);

  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'address')
  final IncomeVerificationPrecheckEmployerAddress? address;
  @JsonKey(name: 'tax_id')
  final String? taxId;
  @JsonKey(name: 'url')
  final String? url;
  static const fromJsonFactory = _$IncomeVerificationPrecheckEmployerFromJson;
  static const toJsonFactory = _$IncomeVerificationPrecheckEmployerToJson;
  Map<String, dynamic> toJson() =>
      _$IncomeVerificationPrecheckEmployerToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IncomeVerificationPrecheckEmployer &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality()
                    .equals(other.address, address)) &&
            (identical(other.taxId, taxId) ||
                const DeepCollectionEquality().equals(other.taxId, taxId)) &&
            (identical(other.url, url) ||
                const DeepCollectionEquality().equals(other.url, url)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(taxId) ^
      const DeepCollectionEquality().hash(url) ^
      runtimeType.hashCode;
}

extension $IncomeVerificationPrecheckEmployerExtension
    on IncomeVerificationPrecheckEmployer {
  IncomeVerificationPrecheckEmployer copyWith(
      {String? name,
      IncomeVerificationPrecheckEmployerAddress? address,
      String? taxId,
      String? url}) {
    return IncomeVerificationPrecheckEmployer(
        name: name ?? this.name,
        address: address ?? this.address,
        taxId: taxId ?? this.taxId,
        url: url ?? this.url);
  }

  IncomeVerificationPrecheckEmployer copyWithWrapped(
      {Wrapped<String?>? name,
      Wrapped<IncomeVerificationPrecheckEmployerAddress?>? address,
      Wrapped<String?>? taxId,
      Wrapped<String?>? url}) {
    return IncomeVerificationPrecheckEmployer(
        name: (name != null ? name.value : this.name),
        address: (address != null ? address.value : this.address),
        taxId: (taxId != null ? taxId.value : this.taxId),
        url: (url != null ? url.value : this.url));
  }
}

@JsonSerializable(explicitToJson: true)
class IncomeVerificationPrecheckEmployerAddress {
  IncomeVerificationPrecheckEmployerAddress({
    this.city,
    this.country,
    this.postalCode,
    this.region,
    this.street,
  });

  factory IncomeVerificationPrecheckEmployerAddress.fromJson(
          Map<String, dynamic> json) =>
      _$IncomeVerificationPrecheckEmployerAddressFromJson(json);

  @JsonKey(name: 'city')
  final String? city;
  @JsonKey(name: 'country')
  final String? country;
  @JsonKey(name: 'postal_code')
  final String? postalCode;
  @JsonKey(name: 'region')
  final String? region;
  @JsonKey(name: 'street')
  final String? street;
  static const fromJsonFactory =
      _$IncomeVerificationPrecheckEmployerAddressFromJson;
  static const toJsonFactory =
      _$IncomeVerificationPrecheckEmployerAddressToJson;
  Map<String, dynamic> toJson() =>
      _$IncomeVerificationPrecheckEmployerAddressToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IncomeVerificationPrecheckEmployerAddress &&
            (identical(other.city, city) ||
                const DeepCollectionEquality().equals(other.city, city)) &&
            (identical(other.country, country) ||
                const DeepCollectionEquality()
                    .equals(other.country, country)) &&
            (identical(other.postalCode, postalCode) ||
                const DeepCollectionEquality()
                    .equals(other.postalCode, postalCode)) &&
            (identical(other.region, region) ||
                const DeepCollectionEquality().equals(other.region, region)) &&
            (identical(other.street, street) ||
                const DeepCollectionEquality().equals(other.street, street)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(city) ^
      const DeepCollectionEquality().hash(country) ^
      const DeepCollectionEquality().hash(postalCode) ^
      const DeepCollectionEquality().hash(region) ^
      const DeepCollectionEquality().hash(street) ^
      runtimeType.hashCode;
}

extension $IncomeVerificationPrecheckEmployerAddressExtension
    on IncomeVerificationPrecheckEmployerAddress {
  IncomeVerificationPrecheckEmployerAddress copyWith(
      {String? city,
      String? country,
      String? postalCode,
      String? region,
      String? street}) {
    return IncomeVerificationPrecheckEmployerAddress(
        city: city ?? this.city,
        country: country ?? this.country,
        postalCode: postalCode ?? this.postalCode,
        region: region ?? this.region,
        street: street ?? this.street);
  }

  IncomeVerificationPrecheckEmployerAddress copyWithWrapped(
      {Wrapped<String?>? city,
      Wrapped<String?>? country,
      Wrapped<String?>? postalCode,
      Wrapped<String?>? region,
      Wrapped<String?>? street}) {
    return IncomeVerificationPrecheckEmployerAddress(
        city: (city != null ? city.value : this.city),
        country: (country != null ? country.value : this.country),
        postalCode: (postalCode != null ? postalCode.value : this.postalCode),
        region: (region != null ? region.value : this.region),
        street: (street != null ? street.value : this.street));
  }
}

@JsonSerializable(explicitToJson: true)
class IncomeVerificationPrecheckPayrollInstitution {
  IncomeVerificationPrecheckPayrollInstitution({
    this.name,
  });

  factory IncomeVerificationPrecheckPayrollInstitution.fromJson(
          Map<String, dynamic> json) =>
      _$IncomeVerificationPrecheckPayrollInstitutionFromJson(json);

  @JsonKey(name: 'name')
  final String? name;
  static const fromJsonFactory =
      _$IncomeVerificationPrecheckPayrollInstitutionFromJson;
  static const toJsonFactory =
      _$IncomeVerificationPrecheckPayrollInstitutionToJson;
  Map<String, dynamic> toJson() =>
      _$IncomeVerificationPrecheckPayrollInstitutionToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IncomeVerificationPrecheckPayrollInstitution &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^ runtimeType.hashCode;
}

extension $IncomeVerificationPrecheckPayrollInstitutionExtension
    on IncomeVerificationPrecheckPayrollInstitution {
  IncomeVerificationPrecheckPayrollInstitution copyWith({String? name}) {
    return IncomeVerificationPrecheckPayrollInstitution(
        name: name ?? this.name);
  }

  IncomeVerificationPrecheckPayrollInstitution copyWithWrapped(
      {Wrapped<String?>? name}) {
    return IncomeVerificationPrecheckPayrollInstitution(
        name: (name != null ? name.value : this.name));
  }
}

@JsonSerializable(explicitToJson: true)
class IncomeVerificationPrecheckEmployerAddressData {
  IncomeVerificationPrecheckEmployerAddressData({
    this.city,
    this.country,
    this.postalCode,
    this.region,
    this.street,
  });

  factory IncomeVerificationPrecheckEmployerAddressData.fromJson(
          Map<String, dynamic> json) =>
      _$IncomeVerificationPrecheckEmployerAddressDataFromJson(json);

  @JsonKey(name: 'city')
  final String? city;
  @JsonKey(name: 'country')
  final String? country;
  @JsonKey(name: 'postal_code')
  final String? postalCode;
  @JsonKey(name: 'region')
  final String? region;
  @JsonKey(name: 'street')
  final String? street;
  static const fromJsonFactory =
      _$IncomeVerificationPrecheckEmployerAddressDataFromJson;
  static const toJsonFactory =
      _$IncomeVerificationPrecheckEmployerAddressDataToJson;
  Map<String, dynamic> toJson() =>
      _$IncomeVerificationPrecheckEmployerAddressDataToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IncomeVerificationPrecheckEmployerAddressData &&
            (identical(other.city, city) ||
                const DeepCollectionEquality().equals(other.city, city)) &&
            (identical(other.country, country) ||
                const DeepCollectionEquality()
                    .equals(other.country, country)) &&
            (identical(other.postalCode, postalCode) ||
                const DeepCollectionEquality()
                    .equals(other.postalCode, postalCode)) &&
            (identical(other.region, region) ||
                const DeepCollectionEquality().equals(other.region, region)) &&
            (identical(other.street, street) ||
                const DeepCollectionEquality().equals(other.street, street)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(city) ^
      const DeepCollectionEquality().hash(country) ^
      const DeepCollectionEquality().hash(postalCode) ^
      const DeepCollectionEquality().hash(region) ^
      const DeepCollectionEquality().hash(street) ^
      runtimeType.hashCode;
}

extension $IncomeVerificationPrecheckEmployerAddressDataExtension
    on IncomeVerificationPrecheckEmployerAddressData {
  IncomeVerificationPrecheckEmployerAddressData copyWith(
      {String? city,
      String? country,
      String? postalCode,
      String? region,
      String? street}) {
    return IncomeVerificationPrecheckEmployerAddressData(
        city: city ?? this.city,
        country: country ?? this.country,
        postalCode: postalCode ?? this.postalCode,
        region: region ?? this.region,
        street: street ?? this.street);
  }

  IncomeVerificationPrecheckEmployerAddressData copyWithWrapped(
      {Wrapped<String?>? city,
      Wrapped<String?>? country,
      Wrapped<String?>? postalCode,
      Wrapped<String?>? region,
      Wrapped<String?>? street}) {
    return IncomeVerificationPrecheckEmployerAddressData(
        city: (city != null ? city.value : this.city),
        country: (country != null ? country.value : this.country),
        postalCode: (postalCode != null ? postalCode.value : this.postalCode),
        region: (region != null ? region.value : this.region),
        street: (street != null ? street.value : this.street));
  }
}

@JsonSerializable(explicitToJson: true)
class IncomeVerificationPrecheckMilitaryInfo {
  IncomeVerificationPrecheckMilitaryInfo({
    this.isActiveDuty,
    this.branch,
  });

  factory IncomeVerificationPrecheckMilitaryInfo.fromJson(
          Map<String, dynamic> json) =>
      _$IncomeVerificationPrecheckMilitaryInfoFromJson(json);

  @JsonKey(name: 'is_active_duty')
  final bool? isActiveDuty;
  @JsonKey(name: 'branch')
  final String? branch;
  static const fromJsonFactory =
      _$IncomeVerificationPrecheckMilitaryInfoFromJson;
  static const toJsonFactory = _$IncomeVerificationPrecheckMilitaryInfoToJson;
  Map<String, dynamic> toJson() =>
      _$IncomeVerificationPrecheckMilitaryInfoToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IncomeVerificationPrecheckMilitaryInfo &&
            (identical(other.isActiveDuty, isActiveDuty) ||
                const DeepCollectionEquality()
                    .equals(other.isActiveDuty, isActiveDuty)) &&
            (identical(other.branch, branch) ||
                const DeepCollectionEquality().equals(other.branch, branch)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(isActiveDuty) ^
      const DeepCollectionEquality().hash(branch) ^
      runtimeType.hashCode;
}

extension $IncomeVerificationPrecheckMilitaryInfoExtension
    on IncomeVerificationPrecheckMilitaryInfo {
  IncomeVerificationPrecheckMilitaryInfo copyWith(
      {bool? isActiveDuty, String? branch}) {
    return IncomeVerificationPrecheckMilitaryInfo(
        isActiveDuty: isActiveDuty ?? this.isActiveDuty,
        branch: branch ?? this.branch);
  }

  IncomeVerificationPrecheckMilitaryInfo copyWithWrapped(
      {Wrapped<bool?>? isActiveDuty, Wrapped<String?>? branch}) {
    return IncomeVerificationPrecheckMilitaryInfo(
        isActiveDuty:
            (isActiveDuty != null ? isActiveDuty.value : this.isActiveDuty),
        branch: (branch != null ? branch.value : this.branch));
  }
}

@JsonSerializable(explicitToJson: true)
class IncomeVerificationPrecheckUser {
  IncomeVerificationPrecheckUser({
    this.firstName,
    this.lastName,
    this.emailAddress,
    this.homeAddress,
  });

  factory IncomeVerificationPrecheckUser.fromJson(Map<String, dynamic> json) =>
      _$IncomeVerificationPrecheckUserFromJson(json);

  @JsonKey(name: 'first_name')
  final String? firstName;
  @JsonKey(name: 'last_name')
  final String? lastName;
  @JsonKey(name: 'email_address')
  final String? emailAddress;
  @JsonKey(name: 'home_address')
  final SignalAddressData? homeAddress;
  static const fromJsonFactory = _$IncomeVerificationPrecheckUserFromJson;
  static const toJsonFactory = _$IncomeVerificationPrecheckUserToJson;
  Map<String, dynamic> toJson() => _$IncomeVerificationPrecheckUserToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IncomeVerificationPrecheckUser &&
            (identical(other.firstName, firstName) ||
                const DeepCollectionEquality()
                    .equals(other.firstName, firstName)) &&
            (identical(other.lastName, lastName) ||
                const DeepCollectionEquality()
                    .equals(other.lastName, lastName)) &&
            (identical(other.emailAddress, emailAddress) ||
                const DeepCollectionEquality()
                    .equals(other.emailAddress, emailAddress)) &&
            (identical(other.homeAddress, homeAddress) ||
                const DeepCollectionEquality()
                    .equals(other.homeAddress, homeAddress)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(firstName) ^
      const DeepCollectionEquality().hash(lastName) ^
      const DeepCollectionEquality().hash(emailAddress) ^
      const DeepCollectionEquality().hash(homeAddress) ^
      runtimeType.hashCode;
}

extension $IncomeVerificationPrecheckUserExtension
    on IncomeVerificationPrecheckUser {
  IncomeVerificationPrecheckUser copyWith(
      {String? firstName,
      String? lastName,
      String? emailAddress,
      SignalAddressData? homeAddress}) {
    return IncomeVerificationPrecheckUser(
        firstName: firstName ?? this.firstName,
        lastName: lastName ?? this.lastName,
        emailAddress: emailAddress ?? this.emailAddress,
        homeAddress: homeAddress ?? this.homeAddress);
  }

  IncomeVerificationPrecheckUser copyWithWrapped(
      {Wrapped<String?>? firstName,
      Wrapped<String?>? lastName,
      Wrapped<String?>? emailAddress,
      Wrapped<SignalAddressData?>? homeAddress}) {
    return IncomeVerificationPrecheckUser(
        firstName: (firstName != null ? firstName.value : this.firstName),
        lastName: (lastName != null ? lastName.value : this.lastName),
        emailAddress:
            (emailAddress != null ? emailAddress.value : this.emailAddress),
        homeAddress:
            (homeAddress != null ? homeAddress.value : this.homeAddress));
  }
}

@JsonSerializable(explicitToJson: true)
class IncomeVerificationPrecheckResponse {
  IncomeVerificationPrecheckResponse({
    required this.precheckId,
    required this.requestId,
    required this.confidence,
  });

  factory IncomeVerificationPrecheckResponse.fromJson(
          Map<String, dynamic> json) =>
      _$IncomeVerificationPrecheckResponseFromJson(json);

  @JsonKey(name: 'precheck_id')
  final String precheckId;
  @JsonKey(name: 'request_id')
  final String requestId;
  @JsonKey(
    name: 'confidence',
    toJson: incomeVerificationPrecheckConfidenceToJson,
    fromJson: incomeVerificationPrecheckConfidenceFromJson,
  )
  final enums.IncomeVerificationPrecheckConfidence confidence;
  static const fromJsonFactory = _$IncomeVerificationPrecheckResponseFromJson;
  static const toJsonFactory = _$IncomeVerificationPrecheckResponseToJson;
  Map<String, dynamic> toJson() =>
      _$IncomeVerificationPrecheckResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IncomeVerificationPrecheckResponse &&
            (identical(other.precheckId, precheckId) ||
                const DeepCollectionEquality()
                    .equals(other.precheckId, precheckId)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)) &&
            (identical(other.confidence, confidence) ||
                const DeepCollectionEquality()
                    .equals(other.confidence, confidence)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(precheckId) ^
      const DeepCollectionEquality().hash(requestId) ^
      const DeepCollectionEquality().hash(confidence) ^
      runtimeType.hashCode;
}

extension $IncomeVerificationPrecheckResponseExtension
    on IncomeVerificationPrecheckResponse {
  IncomeVerificationPrecheckResponse copyWith(
      {String? precheckId,
      String? requestId,
      enums.IncomeVerificationPrecheckConfidence? confidence}) {
    return IncomeVerificationPrecheckResponse(
        precheckId: precheckId ?? this.precheckId,
        requestId: requestId ?? this.requestId,
        confidence: confidence ?? this.confidence);
  }

  IncomeVerificationPrecheckResponse copyWithWrapped(
      {Wrapped<String>? precheckId,
      Wrapped<String>? requestId,
      Wrapped<enums.IncomeVerificationPrecheckConfidence>? confidence}) {
    return IncomeVerificationPrecheckResponse(
        precheckId: (precheckId != null ? precheckId.value : this.precheckId),
        requestId: (requestId != null ? requestId.value : this.requestId),
        confidence: (confidence != null ? confidence.value : this.confidence));
  }
}

@JsonSerializable(explicitToJson: true)
class LinkTokenCreateRequestIncomeVerification {
  LinkTokenCreateRequestIncomeVerification({
    this.incomeVerificationId,
    this.assetReportId,
    this.precheckId,
    this.accessTokens,
    this.incomeSourceTypes,
    this.bankIncome,
    this.payrollIncome,
    this.statedIncomeSources,
  });

  factory LinkTokenCreateRequestIncomeVerification.fromJson(
          Map<String, dynamic> json) =>
      _$LinkTokenCreateRequestIncomeVerificationFromJson(json);

  @JsonKey(name: 'income_verification_id')
  final String? incomeVerificationId;
  @JsonKey(name: 'asset_report_id')
  final String? assetReportId;
  @JsonKey(name: 'precheck_id')
  final String? precheckId;
  @JsonKey(name: 'access_tokens', defaultValue: <String>[])
  final List<String>? accessTokens;
  @JsonKey(
    name: 'income_source_types',
    toJson: incomeVerificationSourceTypeListToJson,
    fromJson: incomeVerificationSourceTypeListFromJson,
  )
  final List<enums.IncomeVerificationSourceType>? incomeSourceTypes;
  @JsonKey(name: 'bank_income')
  final LinkTokenCreateRequestIncomeVerificationBankIncome? bankIncome;
  @JsonKey(name: 'payroll_income')
  final LinkTokenCreateRequestIncomeVerificationPayrollIncome? payrollIncome;
  @JsonKey(
      name: 'stated_income_sources',
      defaultValue: <LinkTokenCreateRequestUserStatedIncomeSource>[])
  final List<LinkTokenCreateRequestUserStatedIncomeSource>? statedIncomeSources;
  static const fromJsonFactory =
      _$LinkTokenCreateRequestIncomeVerificationFromJson;
  static const toJsonFactory = _$LinkTokenCreateRequestIncomeVerificationToJson;
  Map<String, dynamic> toJson() =>
      _$LinkTokenCreateRequestIncomeVerificationToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LinkTokenCreateRequestIncomeVerification &&
            (identical(other.incomeVerificationId, incomeVerificationId) ||
                const DeepCollectionEquality().equals(
                    other.incomeVerificationId, incomeVerificationId)) &&
            (identical(other.assetReportId, assetReportId) ||
                const DeepCollectionEquality()
                    .equals(other.assetReportId, assetReportId)) &&
            (identical(other.precheckId, precheckId) ||
                const DeepCollectionEquality()
                    .equals(other.precheckId, precheckId)) &&
            (identical(other.accessTokens, accessTokens) ||
                const DeepCollectionEquality()
                    .equals(other.accessTokens, accessTokens)) &&
            (identical(other.incomeSourceTypes, incomeSourceTypes) ||
                const DeepCollectionEquality()
                    .equals(other.incomeSourceTypes, incomeSourceTypes)) &&
            (identical(other.bankIncome, bankIncome) ||
                const DeepCollectionEquality()
                    .equals(other.bankIncome, bankIncome)) &&
            (identical(other.payrollIncome, payrollIncome) ||
                const DeepCollectionEquality()
                    .equals(other.payrollIncome, payrollIncome)) &&
            (identical(other.statedIncomeSources, statedIncomeSources) ||
                const DeepCollectionEquality()
                    .equals(other.statedIncomeSources, statedIncomeSources)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(incomeVerificationId) ^
      const DeepCollectionEquality().hash(assetReportId) ^
      const DeepCollectionEquality().hash(precheckId) ^
      const DeepCollectionEquality().hash(accessTokens) ^
      const DeepCollectionEquality().hash(incomeSourceTypes) ^
      const DeepCollectionEquality().hash(bankIncome) ^
      const DeepCollectionEquality().hash(payrollIncome) ^
      const DeepCollectionEquality().hash(statedIncomeSources) ^
      runtimeType.hashCode;
}

extension $LinkTokenCreateRequestIncomeVerificationExtension
    on LinkTokenCreateRequestIncomeVerification {
  LinkTokenCreateRequestIncomeVerification copyWith(
      {String? incomeVerificationId,
      String? assetReportId,
      String? precheckId,
      List<String>? accessTokens,
      List<enums.IncomeVerificationSourceType>? incomeSourceTypes,
      LinkTokenCreateRequestIncomeVerificationBankIncome? bankIncome,
      LinkTokenCreateRequestIncomeVerificationPayrollIncome? payrollIncome,
      List<LinkTokenCreateRequestUserStatedIncomeSource>?
          statedIncomeSources}) {
    return LinkTokenCreateRequestIncomeVerification(
        incomeVerificationId: incomeVerificationId ?? this.incomeVerificationId,
        assetReportId: assetReportId ?? this.assetReportId,
        precheckId: precheckId ?? this.precheckId,
        accessTokens: accessTokens ?? this.accessTokens,
        incomeSourceTypes: incomeSourceTypes ?? this.incomeSourceTypes,
        bankIncome: bankIncome ?? this.bankIncome,
        payrollIncome: payrollIncome ?? this.payrollIncome,
        statedIncomeSources: statedIncomeSources ?? this.statedIncomeSources);
  }

  LinkTokenCreateRequestIncomeVerification copyWithWrapped(
      {Wrapped<String?>? incomeVerificationId,
      Wrapped<String?>? assetReportId,
      Wrapped<String?>? precheckId,
      Wrapped<List<String>?>? accessTokens,
      Wrapped<List<enums.IncomeVerificationSourceType>?>? incomeSourceTypes,
      Wrapped<LinkTokenCreateRequestIncomeVerificationBankIncome?>? bankIncome,
      Wrapped<LinkTokenCreateRequestIncomeVerificationPayrollIncome?>?
          payrollIncome,
      Wrapped<List<LinkTokenCreateRequestUserStatedIncomeSource>?>?
          statedIncomeSources}) {
    return LinkTokenCreateRequestIncomeVerification(
        incomeVerificationId: (incomeVerificationId != null
            ? incomeVerificationId.value
            : this.incomeVerificationId),
        assetReportId:
            (assetReportId != null ? assetReportId.value : this.assetReportId),
        precheckId: (precheckId != null ? precheckId.value : this.precheckId),
        accessTokens:
            (accessTokens != null ? accessTokens.value : this.accessTokens),
        incomeSourceTypes: (incomeSourceTypes != null
            ? incomeSourceTypes.value
            : this.incomeSourceTypes),
        bankIncome: (bankIncome != null ? bankIncome.value : this.bankIncome),
        payrollIncome:
            (payrollIncome != null ? payrollIncome.value : this.payrollIncome),
        statedIncomeSources: (statedIncomeSources != null
            ? statedIncomeSources.value
            : this.statedIncomeSources));
  }
}

@JsonSerializable(explicitToJson: true)
class LinkTokenCreateRequestIncomeVerificationBankIncome {
  LinkTokenCreateRequestIncomeVerificationBankIncome({
    this.daysRequested,
    this.enableMultipleItems,
  });

  factory LinkTokenCreateRequestIncomeVerificationBankIncome.fromJson(
          Map<String, dynamic> json) =>
      _$LinkTokenCreateRequestIncomeVerificationBankIncomeFromJson(json);

  @JsonKey(name: 'days_requested')
  final int? daysRequested;
  @JsonKey(name: 'enable_multiple_items', defaultValue: false)
  final bool? enableMultipleItems;
  static const fromJsonFactory =
      _$LinkTokenCreateRequestIncomeVerificationBankIncomeFromJson;
  static const toJsonFactory =
      _$LinkTokenCreateRequestIncomeVerificationBankIncomeToJson;
  Map<String, dynamic> toJson() =>
      _$LinkTokenCreateRequestIncomeVerificationBankIncomeToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LinkTokenCreateRequestIncomeVerificationBankIncome &&
            (identical(other.daysRequested, daysRequested) ||
                const DeepCollectionEquality()
                    .equals(other.daysRequested, daysRequested)) &&
            (identical(other.enableMultipleItems, enableMultipleItems) ||
                const DeepCollectionEquality()
                    .equals(other.enableMultipleItems, enableMultipleItems)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(daysRequested) ^
      const DeepCollectionEquality().hash(enableMultipleItems) ^
      runtimeType.hashCode;
}

extension $LinkTokenCreateRequestIncomeVerificationBankIncomeExtension
    on LinkTokenCreateRequestIncomeVerificationBankIncome {
  LinkTokenCreateRequestIncomeVerificationBankIncome copyWith(
      {int? daysRequested, bool? enableMultipleItems}) {
    return LinkTokenCreateRequestIncomeVerificationBankIncome(
        daysRequested: daysRequested ?? this.daysRequested,
        enableMultipleItems: enableMultipleItems ?? this.enableMultipleItems);
  }

  LinkTokenCreateRequestIncomeVerificationBankIncome copyWithWrapped(
      {Wrapped<int?>? daysRequested, Wrapped<bool?>? enableMultipleItems}) {
    return LinkTokenCreateRequestIncomeVerificationBankIncome(
        daysRequested:
            (daysRequested != null ? daysRequested.value : this.daysRequested),
        enableMultipleItems: (enableMultipleItems != null
            ? enableMultipleItems.value
            : this.enableMultipleItems));
  }
}

@JsonSerializable(explicitToJson: true)
class LinkTokenCreateRequestIncomeVerificationPayrollIncome {
  LinkTokenCreateRequestIncomeVerificationPayrollIncome({
    this.flowTypes,
    this.isUpdateMode,
  });

  factory LinkTokenCreateRequestIncomeVerificationPayrollIncome.fromJson(
          Map<String, dynamic> json) =>
      _$LinkTokenCreateRequestIncomeVerificationPayrollIncomeFromJson(json);

  @JsonKey(
    name: 'flow_types',
    toJson: incomeVerificationPayrollFlowTypeListToJson,
    fromJson: incomeVerificationPayrollFlowTypeListFromJson,
  )
  final List<enums.IncomeVerificationPayrollFlowType>? flowTypes;
  @JsonKey(name: 'is_update_mode')
  final bool? isUpdateMode;
  static const fromJsonFactory =
      _$LinkTokenCreateRequestIncomeVerificationPayrollIncomeFromJson;
  static const toJsonFactory =
      _$LinkTokenCreateRequestIncomeVerificationPayrollIncomeToJson;
  Map<String, dynamic> toJson() =>
      _$LinkTokenCreateRequestIncomeVerificationPayrollIncomeToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LinkTokenCreateRequestIncomeVerificationPayrollIncome &&
            (identical(other.flowTypes, flowTypes) ||
                const DeepCollectionEquality()
                    .equals(other.flowTypes, flowTypes)) &&
            (identical(other.isUpdateMode, isUpdateMode) ||
                const DeepCollectionEquality()
                    .equals(other.isUpdateMode, isUpdateMode)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(flowTypes) ^
      const DeepCollectionEquality().hash(isUpdateMode) ^
      runtimeType.hashCode;
}

extension $LinkTokenCreateRequestIncomeVerificationPayrollIncomeExtension
    on LinkTokenCreateRequestIncomeVerificationPayrollIncome {
  LinkTokenCreateRequestIncomeVerificationPayrollIncome copyWith(
      {List<enums.IncomeVerificationPayrollFlowType>? flowTypes,
      bool? isUpdateMode}) {
    return LinkTokenCreateRequestIncomeVerificationPayrollIncome(
        flowTypes: flowTypes ?? this.flowTypes,
        isUpdateMode: isUpdateMode ?? this.isUpdateMode);
  }

  LinkTokenCreateRequestIncomeVerificationPayrollIncome copyWithWrapped(
      {Wrapped<List<enums.IncomeVerificationPayrollFlowType>?>? flowTypes,
      Wrapped<bool?>? isUpdateMode}) {
    return LinkTokenCreateRequestIncomeVerificationPayrollIncome(
        flowTypes: (flowTypes != null ? flowTypes.value : this.flowTypes),
        isUpdateMode:
            (isUpdateMode != null ? isUpdateMode.value : this.isUpdateMode));
  }
}

@JsonSerializable(explicitToJson: true)
class IncomeVerificationStatusWebhook {
  IncomeVerificationStatusWebhook({
    required this.webhookType,
    required this.webhookCode,
    required this.itemId,
    this.userId,
    required this.verificationStatus,
    required this.environment,
  });

  factory IncomeVerificationStatusWebhook.fromJson(Map<String, dynamic> json) =>
      _$IncomeVerificationStatusWebhookFromJson(json);

  @JsonKey(name: 'webhook_type')
  final String webhookType;
  @JsonKey(name: 'webhook_code')
  final String webhookCode;
  @JsonKey(name: 'item_id')
  final String itemId;
  @JsonKey(name: 'user_id')
  final String? userId;
  @JsonKey(name: 'verification_status')
  final String verificationStatus;
  @JsonKey(
    name: 'environment',
    toJson: webhookEnvironmentValuesToJson,
    fromJson: webhookEnvironmentValuesFromJson,
  )
  final enums.WebhookEnvironmentValues environment;
  static const fromJsonFactory = _$IncomeVerificationStatusWebhookFromJson;
  static const toJsonFactory = _$IncomeVerificationStatusWebhookToJson;
  Map<String, dynamic> toJson() =>
      _$IncomeVerificationStatusWebhookToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IncomeVerificationStatusWebhook &&
            (identical(other.webhookType, webhookType) ||
                const DeepCollectionEquality()
                    .equals(other.webhookType, webhookType)) &&
            (identical(other.webhookCode, webhookCode) ||
                const DeepCollectionEquality()
                    .equals(other.webhookCode, webhookCode)) &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)) &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)) &&
            (identical(other.verificationStatus, verificationStatus) ||
                const DeepCollectionEquality()
                    .equals(other.verificationStatus, verificationStatus)) &&
            (identical(other.environment, environment) ||
                const DeepCollectionEquality()
                    .equals(other.environment, environment)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(webhookType) ^
      const DeepCollectionEquality().hash(webhookCode) ^
      const DeepCollectionEquality().hash(itemId) ^
      const DeepCollectionEquality().hash(userId) ^
      const DeepCollectionEquality().hash(verificationStatus) ^
      const DeepCollectionEquality().hash(environment) ^
      runtimeType.hashCode;
}

extension $IncomeVerificationStatusWebhookExtension
    on IncomeVerificationStatusWebhook {
  IncomeVerificationStatusWebhook copyWith(
      {String? webhookType,
      String? webhookCode,
      String? itemId,
      String? userId,
      String? verificationStatus,
      enums.WebhookEnvironmentValues? environment}) {
    return IncomeVerificationStatusWebhook(
        webhookType: webhookType ?? this.webhookType,
        webhookCode: webhookCode ?? this.webhookCode,
        itemId: itemId ?? this.itemId,
        userId: userId ?? this.userId,
        verificationStatus: verificationStatus ?? this.verificationStatus,
        environment: environment ?? this.environment);
  }

  IncomeVerificationStatusWebhook copyWithWrapped(
      {Wrapped<String>? webhookType,
      Wrapped<String>? webhookCode,
      Wrapped<String>? itemId,
      Wrapped<String?>? userId,
      Wrapped<String>? verificationStatus,
      Wrapped<enums.WebhookEnvironmentValues>? environment}) {
    return IncomeVerificationStatusWebhook(
        webhookType:
            (webhookType != null ? webhookType.value : this.webhookType),
        webhookCode:
            (webhookCode != null ? webhookCode.value : this.webhookCode),
        itemId: (itemId != null ? itemId.value : this.itemId),
        userId: (userId != null ? userId.value : this.userId),
        verificationStatus: (verificationStatus != null
            ? verificationStatus.value
            : this.verificationStatus),
        environment:
            (environment != null ? environment.value : this.environment));
  }
}

@JsonSerializable(explicitToJson: true)
class IncomeSummary {
  IncomeSummary({
    required this.employerName,
    required this.employeeName,
    required this.ytdGrossIncome,
    required this.ytdNetIncome,
    required this.payFrequency,
    required this.projectedWage,
    required this.verifiedTransaction,
  });

  factory IncomeSummary.fromJson(Map<String, dynamic> json) =>
      _$IncomeSummaryFromJson(json);

  @JsonKey(name: 'employer_name')
  final EmployerIncomeSummaryFieldString employerName;
  @JsonKey(name: 'employee_name')
  final EmployeeIncomeSummaryFieldString employeeName;
  @JsonKey(name: 'ytd_gross_income')
  final YTDGrossIncomeSummaryFieldNumber ytdGrossIncome;
  @JsonKey(name: 'ytd_net_income')
  final YTDNetIncomeSummaryFieldNumber ytdNetIncome;
  @JsonKey(name: 'pay_frequency')
  final PayFrequency? payFrequency;
  @JsonKey(name: 'projected_wage')
  final ProjectedIncomeSummaryFieldNumber projectedWage;
  @JsonKey(name: 'verified_transaction')
  final TransactionData? verifiedTransaction;
  static const fromJsonFactory = _$IncomeSummaryFromJson;
  static const toJsonFactory = _$IncomeSummaryToJson;
  Map<String, dynamic> toJson() => _$IncomeSummaryToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IncomeSummary &&
            (identical(other.employerName, employerName) ||
                const DeepCollectionEquality()
                    .equals(other.employerName, employerName)) &&
            (identical(other.employeeName, employeeName) ||
                const DeepCollectionEquality()
                    .equals(other.employeeName, employeeName)) &&
            (identical(other.ytdGrossIncome, ytdGrossIncome) ||
                const DeepCollectionEquality()
                    .equals(other.ytdGrossIncome, ytdGrossIncome)) &&
            (identical(other.ytdNetIncome, ytdNetIncome) ||
                const DeepCollectionEquality()
                    .equals(other.ytdNetIncome, ytdNetIncome)) &&
            (identical(other.payFrequency, payFrequency) ||
                const DeepCollectionEquality()
                    .equals(other.payFrequency, payFrequency)) &&
            (identical(other.projectedWage, projectedWage) ||
                const DeepCollectionEquality()
                    .equals(other.projectedWage, projectedWage)) &&
            (identical(other.verifiedTransaction, verifiedTransaction) ||
                const DeepCollectionEquality()
                    .equals(other.verifiedTransaction, verifiedTransaction)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(employerName) ^
      const DeepCollectionEquality().hash(employeeName) ^
      const DeepCollectionEquality().hash(ytdGrossIncome) ^
      const DeepCollectionEquality().hash(ytdNetIncome) ^
      const DeepCollectionEquality().hash(payFrequency) ^
      const DeepCollectionEquality().hash(projectedWage) ^
      const DeepCollectionEquality().hash(verifiedTransaction) ^
      runtimeType.hashCode;
}

extension $IncomeSummaryExtension on IncomeSummary {
  IncomeSummary copyWith(
      {EmployerIncomeSummaryFieldString? employerName,
      EmployeeIncomeSummaryFieldString? employeeName,
      YTDGrossIncomeSummaryFieldNumber? ytdGrossIncome,
      YTDNetIncomeSummaryFieldNumber? ytdNetIncome,
      PayFrequency? payFrequency,
      ProjectedIncomeSummaryFieldNumber? projectedWage,
      TransactionData? verifiedTransaction}) {
    return IncomeSummary(
        employerName: employerName ?? this.employerName,
        employeeName: employeeName ?? this.employeeName,
        ytdGrossIncome: ytdGrossIncome ?? this.ytdGrossIncome,
        ytdNetIncome: ytdNetIncome ?? this.ytdNetIncome,
        payFrequency: payFrequency ?? this.payFrequency,
        projectedWage: projectedWage ?? this.projectedWage,
        verifiedTransaction: verifiedTransaction ?? this.verifiedTransaction);
  }

  IncomeSummary copyWithWrapped(
      {Wrapped<EmployerIncomeSummaryFieldString>? employerName,
      Wrapped<EmployeeIncomeSummaryFieldString>? employeeName,
      Wrapped<YTDGrossIncomeSummaryFieldNumber>? ytdGrossIncome,
      Wrapped<YTDNetIncomeSummaryFieldNumber>? ytdNetIncome,
      Wrapped<PayFrequency?>? payFrequency,
      Wrapped<ProjectedIncomeSummaryFieldNumber>? projectedWage,
      Wrapped<TransactionData?>? verifiedTransaction}) {
    return IncomeSummary(
        employerName:
            (employerName != null ? employerName.value : this.employerName),
        employeeName:
            (employeeName != null ? employeeName.value : this.employeeName),
        ytdGrossIncome: (ytdGrossIncome != null
            ? ytdGrossIncome.value
            : this.ytdGrossIncome),
        ytdNetIncome:
            (ytdNetIncome != null ? ytdNetIncome.value : this.ytdNetIncome),
        payFrequency:
            (payFrequency != null ? payFrequency.value : this.payFrequency),
        projectedWage:
            (projectedWage != null ? projectedWage.value : this.projectedWage),
        verifiedTransaction: (verifiedTransaction != null
            ? verifiedTransaction.value
            : this.verifiedTransaction));
  }
}

@JsonSerializable(explicitToJson: true)
class TransactionData {
  TransactionData({
    required this.description,
    required this.amount,
    required this.date,
    required this.accountId,
    required this.transactionId,
  });

  factory TransactionData.fromJson(Map<String, dynamic> json) =>
      _$TransactionDataFromJson(json);

  @JsonKey(name: 'description')
  final String description;
  @JsonKey(name: 'amount')
  final double amount;
  @JsonKey(name: 'date', toJson: _dateToJson)
  final DateTime date;
  @JsonKey(name: 'account_id')
  final String accountId;
  @JsonKey(name: 'transaction_id')
  final String transactionId;
  static const fromJsonFactory = _$TransactionDataFromJson;
  static const toJsonFactory = _$TransactionDataToJson;
  Map<String, dynamic> toJson() => _$TransactionDataToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransactionData &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.date, date) ||
                const DeepCollectionEquality().equals(other.date, date)) &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.transactionId, transactionId) ||
                const DeepCollectionEquality()
                    .equals(other.transactionId, transactionId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(date) ^
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(transactionId) ^
      runtimeType.hashCode;
}

extension $TransactionDataExtension on TransactionData {
  TransactionData copyWith(
      {String? description,
      double? amount,
      DateTime? date,
      String? accountId,
      String? transactionId}) {
    return TransactionData(
        description: description ?? this.description,
        amount: amount ?? this.amount,
        date: date ?? this.date,
        accountId: accountId ?? this.accountId,
        transactionId: transactionId ?? this.transactionId);
  }

  TransactionData copyWithWrapped(
      {Wrapped<String>? description,
      Wrapped<double>? amount,
      Wrapped<DateTime>? date,
      Wrapped<String>? accountId,
      Wrapped<String>? transactionId}) {
    return TransactionData(
        description:
            (description != null ? description.value : this.description),
        amount: (amount != null ? amount.value : this.amount),
        date: (date != null ? date.value : this.date),
        accountId: (accountId != null ? accountId.value : this.accountId),
        transactionId:
            (transactionId != null ? transactionId.value : this.transactionId));
  }
}

@JsonSerializable(explicitToJson: true)
class IncomeSummaryFieldString {
  IncomeSummaryFieldString({
    required this.value,
    required this.verificationStatus,
  });

  factory IncomeSummaryFieldString.fromJson(Map<String, dynamic> json) =>
      _$IncomeSummaryFieldStringFromJson(json);

  @JsonKey(name: 'value')
  final String value;
  @JsonKey(
    name: 'verification_status',
    toJson: verificationStatusToJson,
    fromJson: verificationStatusFromJson,
  )
  final enums.VerificationStatus verificationStatus;
  static const fromJsonFactory = _$IncomeSummaryFieldStringFromJson;
  static const toJsonFactory = _$IncomeSummaryFieldStringToJson;
  Map<String, dynamic> toJson() => _$IncomeSummaryFieldStringToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IncomeSummaryFieldString &&
            (identical(other.value, value) ||
                const DeepCollectionEquality().equals(other.value, value)) &&
            (identical(other.verificationStatus, verificationStatus) ||
                const DeepCollectionEquality()
                    .equals(other.verificationStatus, verificationStatus)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(value) ^
      const DeepCollectionEquality().hash(verificationStatus) ^
      runtimeType.hashCode;
}

extension $IncomeSummaryFieldStringExtension on IncomeSummaryFieldString {
  IncomeSummaryFieldString copyWith(
      {String? value, enums.VerificationStatus? verificationStatus}) {
    return IncomeSummaryFieldString(
        value: value ?? this.value,
        verificationStatus: verificationStatus ?? this.verificationStatus);
  }

  IncomeSummaryFieldString copyWithWrapped(
      {Wrapped<String>? value,
      Wrapped<enums.VerificationStatus>? verificationStatus}) {
    return IncomeSummaryFieldString(
        value: (value != null ? value.value : this.value),
        verificationStatus: (verificationStatus != null
            ? verificationStatus.value
            : this.verificationStatus));
  }
}

@JsonSerializable(explicitToJson: true)
class EmployerIncomeSummaryFieldString {
  EmployerIncomeSummaryFieldString({
    required this.value,
    required this.verificationStatus,
  });

  factory EmployerIncomeSummaryFieldString.fromJson(
          Map<String, dynamic> json) =>
      _$EmployerIncomeSummaryFieldStringFromJson(json);

  @JsonKey(name: 'value')
  final String value;
  @JsonKey(
    name: 'verification_status',
    toJson: verificationStatusToJson,
    fromJson: verificationStatusFromJson,
  )
  final enums.VerificationStatus verificationStatus;
  static const fromJsonFactory = _$EmployerIncomeSummaryFieldStringFromJson;
  static const toJsonFactory = _$EmployerIncomeSummaryFieldStringToJson;
  Map<String, dynamic> toJson() =>
      _$EmployerIncomeSummaryFieldStringToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is EmployerIncomeSummaryFieldString &&
            (identical(other.value, value) ||
                const DeepCollectionEquality().equals(other.value, value)) &&
            (identical(other.verificationStatus, verificationStatus) ||
                const DeepCollectionEquality()
                    .equals(other.verificationStatus, verificationStatus)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(value) ^
      const DeepCollectionEquality().hash(verificationStatus) ^
      runtimeType.hashCode;
}

extension $EmployerIncomeSummaryFieldStringExtension
    on EmployerIncomeSummaryFieldString {
  EmployerIncomeSummaryFieldString copyWith(
      {String? value, enums.VerificationStatus? verificationStatus}) {
    return EmployerIncomeSummaryFieldString(
        value: value ?? this.value,
        verificationStatus: verificationStatus ?? this.verificationStatus);
  }

  EmployerIncomeSummaryFieldString copyWithWrapped(
      {Wrapped<String>? value,
      Wrapped<enums.VerificationStatus>? verificationStatus}) {
    return EmployerIncomeSummaryFieldString(
        value: (value != null ? value.value : this.value),
        verificationStatus: (verificationStatus != null
            ? verificationStatus.value
            : this.verificationStatus));
  }
}

@JsonSerializable(explicitToJson: true)
class EmployeeIncomeSummaryFieldString {
  EmployeeIncomeSummaryFieldString({
    required this.value,
    required this.verificationStatus,
  });

  factory EmployeeIncomeSummaryFieldString.fromJson(
          Map<String, dynamic> json) =>
      _$EmployeeIncomeSummaryFieldStringFromJson(json);

  @JsonKey(name: 'value')
  final String value;
  @JsonKey(
    name: 'verification_status',
    toJson: verificationStatusToJson,
    fromJson: verificationStatusFromJson,
  )
  final enums.VerificationStatus verificationStatus;
  static const fromJsonFactory = _$EmployeeIncomeSummaryFieldStringFromJson;
  static const toJsonFactory = _$EmployeeIncomeSummaryFieldStringToJson;
  Map<String, dynamic> toJson() =>
      _$EmployeeIncomeSummaryFieldStringToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is EmployeeIncomeSummaryFieldString &&
            (identical(other.value, value) ||
                const DeepCollectionEquality().equals(other.value, value)) &&
            (identical(other.verificationStatus, verificationStatus) ||
                const DeepCollectionEquality()
                    .equals(other.verificationStatus, verificationStatus)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(value) ^
      const DeepCollectionEquality().hash(verificationStatus) ^
      runtimeType.hashCode;
}

extension $EmployeeIncomeSummaryFieldStringExtension
    on EmployeeIncomeSummaryFieldString {
  EmployeeIncomeSummaryFieldString copyWith(
      {String? value, enums.VerificationStatus? verificationStatus}) {
    return EmployeeIncomeSummaryFieldString(
        value: value ?? this.value,
        verificationStatus: verificationStatus ?? this.verificationStatus);
  }

  EmployeeIncomeSummaryFieldString copyWithWrapped(
      {Wrapped<String>? value,
      Wrapped<enums.VerificationStatus>? verificationStatus}) {
    return EmployeeIncomeSummaryFieldString(
        value: (value != null ? value.value : this.value),
        verificationStatus: (verificationStatus != null
            ? verificationStatus.value
            : this.verificationStatus));
  }
}

@JsonSerializable(explicitToJson: true)
class IncomeSummaryFieldNumber {
  IncomeSummaryFieldNumber({
    required this.value,
    required this.verificationStatus,
  });

  factory IncomeSummaryFieldNumber.fromJson(Map<String, dynamic> json) =>
      _$IncomeSummaryFieldNumberFromJson(json);

  @JsonKey(name: 'value')
  final double value;
  @JsonKey(
    name: 'verification_status',
    toJson: verificationStatusToJson,
    fromJson: verificationStatusFromJson,
  )
  final enums.VerificationStatus verificationStatus;
  static const fromJsonFactory = _$IncomeSummaryFieldNumberFromJson;
  static const toJsonFactory = _$IncomeSummaryFieldNumberToJson;
  Map<String, dynamic> toJson() => _$IncomeSummaryFieldNumberToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IncomeSummaryFieldNumber &&
            (identical(other.value, value) ||
                const DeepCollectionEquality().equals(other.value, value)) &&
            (identical(other.verificationStatus, verificationStatus) ||
                const DeepCollectionEquality()
                    .equals(other.verificationStatus, verificationStatus)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(value) ^
      const DeepCollectionEquality().hash(verificationStatus) ^
      runtimeType.hashCode;
}

extension $IncomeSummaryFieldNumberExtension on IncomeSummaryFieldNumber {
  IncomeSummaryFieldNumber copyWith(
      {double? value, enums.VerificationStatus? verificationStatus}) {
    return IncomeSummaryFieldNumber(
        value: value ?? this.value,
        verificationStatus: verificationStatus ?? this.verificationStatus);
  }

  IncomeSummaryFieldNumber copyWithWrapped(
      {Wrapped<double>? value,
      Wrapped<enums.VerificationStatus>? verificationStatus}) {
    return IncomeSummaryFieldNumber(
        value: (value != null ? value.value : this.value),
        verificationStatus: (verificationStatus != null
            ? verificationStatus.value
            : this.verificationStatus));
  }
}

@JsonSerializable(explicitToJson: true)
class YTDGrossIncomeSummaryFieldNumber {
  YTDGrossIncomeSummaryFieldNumber({
    required this.value,
    required this.verificationStatus,
  });

  factory YTDGrossIncomeSummaryFieldNumber.fromJson(
          Map<String, dynamic> json) =>
      _$YTDGrossIncomeSummaryFieldNumberFromJson(json);

  @JsonKey(name: 'value')
  final double value;
  @JsonKey(
    name: 'verification_status',
    toJson: verificationStatusToJson,
    fromJson: verificationStatusFromJson,
  )
  final enums.VerificationStatus verificationStatus;
  static const fromJsonFactory = _$YTDGrossIncomeSummaryFieldNumberFromJson;
  static const toJsonFactory = _$YTDGrossIncomeSummaryFieldNumberToJson;
  Map<String, dynamic> toJson() =>
      _$YTDGrossIncomeSummaryFieldNumberToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is YTDGrossIncomeSummaryFieldNumber &&
            (identical(other.value, value) ||
                const DeepCollectionEquality().equals(other.value, value)) &&
            (identical(other.verificationStatus, verificationStatus) ||
                const DeepCollectionEquality()
                    .equals(other.verificationStatus, verificationStatus)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(value) ^
      const DeepCollectionEquality().hash(verificationStatus) ^
      runtimeType.hashCode;
}

extension $YTDGrossIncomeSummaryFieldNumberExtension
    on YTDGrossIncomeSummaryFieldNumber {
  YTDGrossIncomeSummaryFieldNumber copyWith(
      {double? value, enums.VerificationStatus? verificationStatus}) {
    return YTDGrossIncomeSummaryFieldNumber(
        value: value ?? this.value,
        verificationStatus: verificationStatus ?? this.verificationStatus);
  }

  YTDGrossIncomeSummaryFieldNumber copyWithWrapped(
      {Wrapped<double>? value,
      Wrapped<enums.VerificationStatus>? verificationStatus}) {
    return YTDGrossIncomeSummaryFieldNumber(
        value: (value != null ? value.value : this.value),
        verificationStatus: (verificationStatus != null
            ? verificationStatus.value
            : this.verificationStatus));
  }
}

@JsonSerializable(explicitToJson: true)
class YTDNetIncomeSummaryFieldNumber {
  YTDNetIncomeSummaryFieldNumber({
    required this.value,
    required this.verificationStatus,
  });

  factory YTDNetIncomeSummaryFieldNumber.fromJson(Map<String, dynamic> json) =>
      _$YTDNetIncomeSummaryFieldNumberFromJson(json);

  @JsonKey(name: 'value')
  final double value;
  @JsonKey(
    name: 'verification_status',
    toJson: verificationStatusToJson,
    fromJson: verificationStatusFromJson,
  )
  final enums.VerificationStatus verificationStatus;
  static const fromJsonFactory = _$YTDNetIncomeSummaryFieldNumberFromJson;
  static const toJsonFactory = _$YTDNetIncomeSummaryFieldNumberToJson;
  Map<String, dynamic> toJson() => _$YTDNetIncomeSummaryFieldNumberToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is YTDNetIncomeSummaryFieldNumber &&
            (identical(other.value, value) ||
                const DeepCollectionEquality().equals(other.value, value)) &&
            (identical(other.verificationStatus, verificationStatus) ||
                const DeepCollectionEquality()
                    .equals(other.verificationStatus, verificationStatus)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(value) ^
      const DeepCollectionEquality().hash(verificationStatus) ^
      runtimeType.hashCode;
}

extension $YTDNetIncomeSummaryFieldNumberExtension
    on YTDNetIncomeSummaryFieldNumber {
  YTDNetIncomeSummaryFieldNumber copyWith(
      {double? value, enums.VerificationStatus? verificationStatus}) {
    return YTDNetIncomeSummaryFieldNumber(
        value: value ?? this.value,
        verificationStatus: verificationStatus ?? this.verificationStatus);
  }

  YTDNetIncomeSummaryFieldNumber copyWithWrapped(
      {Wrapped<double>? value,
      Wrapped<enums.VerificationStatus>? verificationStatus}) {
    return YTDNetIncomeSummaryFieldNumber(
        value: (value != null ? value.value : this.value),
        verificationStatus: (verificationStatus != null
            ? verificationStatus.value
            : this.verificationStatus));
  }
}

@JsonSerializable(explicitToJson: true)
class ProjectedIncomeSummaryFieldNumber {
  ProjectedIncomeSummaryFieldNumber({
    required this.value,
    required this.verificationStatus,
  });

  factory ProjectedIncomeSummaryFieldNumber.fromJson(
          Map<String, dynamic> json) =>
      _$ProjectedIncomeSummaryFieldNumberFromJson(json);

  @JsonKey(name: 'value')
  final double value;
  @JsonKey(
    name: 'verification_status',
    toJson: verificationStatusToJson,
    fromJson: verificationStatusFromJson,
  )
  final enums.VerificationStatus verificationStatus;
  static const fromJsonFactory = _$ProjectedIncomeSummaryFieldNumberFromJson;
  static const toJsonFactory = _$ProjectedIncomeSummaryFieldNumberToJson;
  Map<String, dynamic> toJson() =>
      _$ProjectedIncomeSummaryFieldNumberToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ProjectedIncomeSummaryFieldNumber &&
            (identical(other.value, value) ||
                const DeepCollectionEquality().equals(other.value, value)) &&
            (identical(other.verificationStatus, verificationStatus) ||
                const DeepCollectionEquality()
                    .equals(other.verificationStatus, verificationStatus)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(value) ^
      const DeepCollectionEquality().hash(verificationStatus) ^
      runtimeType.hashCode;
}

extension $ProjectedIncomeSummaryFieldNumberExtension
    on ProjectedIncomeSummaryFieldNumber {
  ProjectedIncomeSummaryFieldNumber copyWith(
      {double? value, enums.VerificationStatus? verificationStatus}) {
    return ProjectedIncomeSummaryFieldNumber(
        value: value ?? this.value,
        verificationStatus: verificationStatus ?? this.verificationStatus);
  }

  ProjectedIncomeSummaryFieldNumber copyWithWrapped(
      {Wrapped<double>? value,
      Wrapped<enums.VerificationStatus>? verificationStatus}) {
    return ProjectedIncomeSummaryFieldNumber(
        value: (value != null ? value.value : this.value),
        verificationStatus: (verificationStatus != null
            ? verificationStatus.value
            : this.verificationStatus));
  }
}

@JsonSerializable(explicitToJson: true)
class PayFrequency {
  PayFrequency({
    required this.value,
    required this.verificationStatus,
  });

  factory PayFrequency.fromJson(Map<String, dynamic> json) =>
      _$PayFrequencyFromJson(json);

  @JsonKey(
    name: 'value',
    toJson: payFrequencyValueToJson,
    fromJson: payFrequencyValueFromJson,
  )
  final enums.PayFrequencyValue value;
  @JsonKey(
    name: 'verification_status',
    toJson: verificationStatusToJson,
    fromJson: verificationStatusFromJson,
  )
  final enums.VerificationStatus verificationStatus;
  static const fromJsonFactory = _$PayFrequencyFromJson;
  static const toJsonFactory = _$PayFrequencyToJson;
  Map<String, dynamic> toJson() => _$PayFrequencyToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PayFrequency &&
            (identical(other.value, value) ||
                const DeepCollectionEquality().equals(other.value, value)) &&
            (identical(other.verificationStatus, verificationStatus) ||
                const DeepCollectionEquality()
                    .equals(other.verificationStatus, verificationStatus)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(value) ^
      const DeepCollectionEquality().hash(verificationStatus) ^
      runtimeType.hashCode;
}

extension $PayFrequencyExtension on PayFrequency {
  PayFrequency copyWith(
      {enums.PayFrequencyValue? value,
      enums.VerificationStatus? verificationStatus}) {
    return PayFrequency(
        value: value ?? this.value,
        verificationStatus: verificationStatus ?? this.verificationStatus);
  }

  PayFrequency copyWithWrapped(
      {Wrapped<enums.PayFrequencyValue>? value,
      Wrapped<enums.VerificationStatus>? verificationStatus}) {
    return PayFrequency(
        value: (value != null ? value.value : this.value),
        verificationStatus: (verificationStatus != null
            ? verificationStatus.value
            : this.verificationStatus));
  }
}

@JsonSerializable(explicitToJson: true)
class IncomeVerificationPaystubsGetRequest {
  IncomeVerificationPaystubsGetRequest({
    this.clientId,
    this.secret,
    this.incomeVerificationId,
    this.accessToken,
  });

  factory IncomeVerificationPaystubsGetRequest.fromJson(
          Map<String, dynamic> json) =>
      _$IncomeVerificationPaystubsGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'income_verification_id')
  final String? incomeVerificationId;
  @JsonKey(name: 'access_token')
  final String? accessToken;
  static const fromJsonFactory = _$IncomeVerificationPaystubsGetRequestFromJson;
  static const toJsonFactory = _$IncomeVerificationPaystubsGetRequestToJson;
  Map<String, dynamic> toJson() =>
      _$IncomeVerificationPaystubsGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IncomeVerificationPaystubsGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.incomeVerificationId, incomeVerificationId) ||
                const DeepCollectionEquality().equals(
                    other.incomeVerificationId, incomeVerificationId)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(incomeVerificationId) ^
      const DeepCollectionEquality().hash(accessToken) ^
      runtimeType.hashCode;
}

extension $IncomeVerificationPaystubsGetRequestExtension
    on IncomeVerificationPaystubsGetRequest {
  IncomeVerificationPaystubsGetRequest copyWith(
      {String? clientId,
      String? secret,
      String? incomeVerificationId,
      String? accessToken}) {
    return IncomeVerificationPaystubsGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        incomeVerificationId: incomeVerificationId ?? this.incomeVerificationId,
        accessToken: accessToken ?? this.accessToken);
  }

  IncomeVerificationPaystubsGetRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String?>? incomeVerificationId,
      Wrapped<String?>? accessToken}) {
    return IncomeVerificationPaystubsGetRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        incomeVerificationId: (incomeVerificationId != null
            ? incomeVerificationId.value
            : this.incomeVerificationId),
        accessToken:
            (accessToken != null ? accessToken.value : this.accessToken));
  }
}

@JsonSerializable(explicitToJson: true)
class IncomeVerificationPaystubsGetResponse {
  IncomeVerificationPaystubsGetResponse({
    this.documentMetadata,
    required this.paystubs,
    this.error,
    required this.requestId,
  });

  factory IncomeVerificationPaystubsGetResponse.fromJson(
          Map<String, dynamic> json) =>
      _$IncomeVerificationPaystubsGetResponseFromJson(json);

  @JsonKey(name: 'document_metadata', defaultValue: <DocumentMetadata>[])
  final List<DocumentMetadata>? documentMetadata;
  @JsonKey(name: 'paystubs', defaultValue: <Paystub>[])
  final List<Paystub> paystubs;
  @JsonKey(name: 'error')
  final PlaidError? error;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory =
      _$IncomeVerificationPaystubsGetResponseFromJson;
  static const toJsonFactory = _$IncomeVerificationPaystubsGetResponseToJson;
  Map<String, dynamic> toJson() =>
      _$IncomeVerificationPaystubsGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IncomeVerificationPaystubsGetResponse &&
            (identical(other.documentMetadata, documentMetadata) ||
                const DeepCollectionEquality()
                    .equals(other.documentMetadata, documentMetadata)) &&
            (identical(other.paystubs, paystubs) ||
                const DeepCollectionEquality()
                    .equals(other.paystubs, paystubs)) &&
            (identical(other.error, error) ||
                const DeepCollectionEquality().equals(other.error, error)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(documentMetadata) ^
      const DeepCollectionEquality().hash(paystubs) ^
      const DeepCollectionEquality().hash(error) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $IncomeVerificationPaystubsGetResponseExtension
    on IncomeVerificationPaystubsGetResponse {
  IncomeVerificationPaystubsGetResponse copyWith(
      {List<DocumentMetadata>? documentMetadata,
      List<Paystub>? paystubs,
      PlaidError? error,
      String? requestId}) {
    return IncomeVerificationPaystubsGetResponse(
        documentMetadata: documentMetadata ?? this.documentMetadata,
        paystubs: paystubs ?? this.paystubs,
        error: error ?? this.error,
        requestId: requestId ?? this.requestId);
  }

  IncomeVerificationPaystubsGetResponse copyWithWrapped(
      {Wrapped<List<DocumentMetadata>?>? documentMetadata,
      Wrapped<List<Paystub>>? paystubs,
      Wrapped<PlaidError?>? error,
      Wrapped<String>? requestId}) {
    return IncomeVerificationPaystubsGetResponse(
        documentMetadata: (documentMetadata != null
            ? documentMetadata.value
            : this.documentMetadata),
        paystubs: (paystubs != null ? paystubs.value : this.paystubs),
        error: (error != null ? error.value : this.error),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class DocumentMetadata {
  DocumentMetadata({
    this.name,
    this.status,
    this.docId,
    this.docType,
  });

  factory DocumentMetadata.fromJson(Map<String, dynamic> json) =>
      _$DocumentMetadataFromJson(json);

  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'status')
  final String? status;
  @JsonKey(name: 'doc_id')
  final String? docId;
  @JsonKey(
    name: 'doc_type',
    toJson: docTypeToJson,
    fromJson: docTypeFromJson,
  )
  final enums.DocType? docType;
  static const fromJsonFactory = _$DocumentMetadataFromJson;
  static const toJsonFactory = _$DocumentMetadataToJson;
  Map<String, dynamic> toJson() => _$DocumentMetadataToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is DocumentMetadata &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.docId, docId) ||
                const DeepCollectionEquality().equals(other.docId, docId)) &&
            (identical(other.docType, docType) ||
                const DeepCollectionEquality().equals(other.docType, docType)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(docId) ^
      const DeepCollectionEquality().hash(docType) ^
      runtimeType.hashCode;
}

extension $DocumentMetadataExtension on DocumentMetadata {
  DocumentMetadata copyWith(
      {String? name, String? status, String? docId, enums.DocType? docType}) {
    return DocumentMetadata(
        name: name ?? this.name,
        status: status ?? this.status,
        docId: docId ?? this.docId,
        docType: docType ?? this.docType);
  }

  DocumentMetadata copyWithWrapped(
      {Wrapped<String?>? name,
      Wrapped<String?>? status,
      Wrapped<String?>? docId,
      Wrapped<enums.DocType?>? docType}) {
    return DocumentMetadata(
        name: (name != null ? name.value : this.name),
        status: (status != null ? status.value : this.status),
        docId: (docId != null ? docId.value : this.docId),
        docType: (docType != null ? docType.value : this.docType));
  }
}

@JsonSerializable(explicitToJson: true)
class Paystub {
  Paystub({
    required this.deductions,
    required this.docId,
    required this.earnings,
    required this.employee,
    required this.employer,
    this.employmentDetails,
    required this.netPay,
    required this.payPeriodDetails,
    this.paystubDetails,
    this.incomeBreakdown,
    this.ytdEarnings,
  });

  factory Paystub.fromJson(Map<String, dynamic> json) =>
      _$PaystubFromJson(json);

  @JsonKey(name: 'deductions')
  final Deductions deductions;
  @JsonKey(name: 'doc_id')
  final String docId;
  @JsonKey(name: 'earnings')
  final Earnings earnings;
  @JsonKey(name: 'employee')
  final Employee employee;
  @JsonKey(name: 'employer')
  final PaystubEmployer employer;
  @JsonKey(name: 'employment_details')
  final EmploymentDetails? employmentDetails;
  @JsonKey(name: 'net_pay')
  final NetPay netPay;
  @JsonKey(name: 'pay_period_details')
  final PayPeriodDetails payPeriodDetails;
  @JsonKey(name: 'paystub_details')
  final PaystubDetails? paystubDetails;
  @JsonKey(name: 'income_breakdown', defaultValue: <IncomeBreakdown>[])
  final List<IncomeBreakdown>? incomeBreakdown;
  @JsonKey(name: 'ytd_earnings')
  final PaystubYTDDetails? ytdEarnings;
  static const fromJsonFactory = _$PaystubFromJson;
  static const toJsonFactory = _$PaystubToJson;
  Map<String, dynamic> toJson() => _$PaystubToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Paystub &&
            (identical(other.deductions, deductions) ||
                const DeepCollectionEquality()
                    .equals(other.deductions, deductions)) &&
            (identical(other.docId, docId) ||
                const DeepCollectionEquality().equals(other.docId, docId)) &&
            (identical(other.earnings, earnings) ||
                const DeepCollectionEquality()
                    .equals(other.earnings, earnings)) &&
            (identical(other.employee, employee) ||
                const DeepCollectionEquality()
                    .equals(other.employee, employee)) &&
            (identical(other.employer, employer) ||
                const DeepCollectionEquality()
                    .equals(other.employer, employer)) &&
            (identical(other.employmentDetails, employmentDetails) ||
                const DeepCollectionEquality()
                    .equals(other.employmentDetails, employmentDetails)) &&
            (identical(other.netPay, netPay) ||
                const DeepCollectionEquality().equals(other.netPay, netPay)) &&
            (identical(other.payPeriodDetails, payPeriodDetails) ||
                const DeepCollectionEquality()
                    .equals(other.payPeriodDetails, payPeriodDetails)) &&
            (identical(other.paystubDetails, paystubDetails) ||
                const DeepCollectionEquality()
                    .equals(other.paystubDetails, paystubDetails)) &&
            (identical(other.incomeBreakdown, incomeBreakdown) ||
                const DeepCollectionEquality()
                    .equals(other.incomeBreakdown, incomeBreakdown)) &&
            (identical(other.ytdEarnings, ytdEarnings) ||
                const DeepCollectionEquality()
                    .equals(other.ytdEarnings, ytdEarnings)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(deductions) ^
      const DeepCollectionEquality().hash(docId) ^
      const DeepCollectionEquality().hash(earnings) ^
      const DeepCollectionEquality().hash(employee) ^
      const DeepCollectionEquality().hash(employer) ^
      const DeepCollectionEquality().hash(employmentDetails) ^
      const DeepCollectionEquality().hash(netPay) ^
      const DeepCollectionEquality().hash(payPeriodDetails) ^
      const DeepCollectionEquality().hash(paystubDetails) ^
      const DeepCollectionEquality().hash(incomeBreakdown) ^
      const DeepCollectionEquality().hash(ytdEarnings) ^
      runtimeType.hashCode;
}

extension $PaystubExtension on Paystub {
  Paystub copyWith(
      {Deductions? deductions,
      String? docId,
      Earnings? earnings,
      Employee? employee,
      PaystubEmployer? employer,
      EmploymentDetails? employmentDetails,
      NetPay? netPay,
      PayPeriodDetails? payPeriodDetails,
      PaystubDetails? paystubDetails,
      List<IncomeBreakdown>? incomeBreakdown,
      PaystubYTDDetails? ytdEarnings}) {
    return Paystub(
        deductions: deductions ?? this.deductions,
        docId: docId ?? this.docId,
        earnings: earnings ?? this.earnings,
        employee: employee ?? this.employee,
        employer: employer ?? this.employer,
        employmentDetails: employmentDetails ?? this.employmentDetails,
        netPay: netPay ?? this.netPay,
        payPeriodDetails: payPeriodDetails ?? this.payPeriodDetails,
        paystubDetails: paystubDetails ?? this.paystubDetails,
        incomeBreakdown: incomeBreakdown ?? this.incomeBreakdown,
        ytdEarnings: ytdEarnings ?? this.ytdEarnings);
  }

  Paystub copyWithWrapped(
      {Wrapped<Deductions>? deductions,
      Wrapped<String>? docId,
      Wrapped<Earnings>? earnings,
      Wrapped<Employee>? employee,
      Wrapped<PaystubEmployer>? employer,
      Wrapped<EmploymentDetails?>? employmentDetails,
      Wrapped<NetPay>? netPay,
      Wrapped<PayPeriodDetails>? payPeriodDetails,
      Wrapped<PaystubDetails?>? paystubDetails,
      Wrapped<List<IncomeBreakdown>?>? incomeBreakdown,
      Wrapped<PaystubYTDDetails?>? ytdEarnings}) {
    return Paystub(
        deductions: (deductions != null ? deductions.value : this.deductions),
        docId: (docId != null ? docId.value : this.docId),
        earnings: (earnings != null ? earnings.value : this.earnings),
        employee: (employee != null ? employee.value : this.employee),
        employer: (employer != null ? employer.value : this.employer),
        employmentDetails: (employmentDetails != null
            ? employmentDetails.value
            : this.employmentDetails),
        netPay: (netPay != null ? netPay.value : this.netPay),
        payPeriodDetails: (payPeriodDetails != null
            ? payPeriodDetails.value
            : this.payPeriodDetails),
        paystubDetails: (paystubDetails != null
            ? paystubDetails.value
            : this.paystubDetails),
        incomeBreakdown: (incomeBreakdown != null
            ? incomeBreakdown.value
            : this.incomeBreakdown),
        ytdEarnings:
            (ytdEarnings != null ? ytdEarnings.value : this.ytdEarnings));
  }
}

@JsonSerializable(explicitToJson: true)
class Deductions {
  Deductions({
    this.subtotals,
    required this.breakdown,
    this.totals,
    required this.total,
  });

  factory Deductions.fromJson(Map<String, dynamic> json) =>
      _$DeductionsFromJson(json);

  @JsonKey(name: 'subtotals', defaultValue: <Total>[])
  final List<Total>? subtotals;
  @JsonKey(name: 'breakdown', defaultValue: <DeductionsBreakdown>[])
  final List<DeductionsBreakdown> breakdown;
  @JsonKey(name: 'totals', defaultValue: <Total>[])
  final List<Total>? totals;
  @JsonKey(name: 'total')
  final DeductionsTotal total;
  static const fromJsonFactory = _$DeductionsFromJson;
  static const toJsonFactory = _$DeductionsToJson;
  Map<String, dynamic> toJson() => _$DeductionsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Deductions &&
            (identical(other.subtotals, subtotals) ||
                const DeepCollectionEquality()
                    .equals(other.subtotals, subtotals)) &&
            (identical(other.breakdown, breakdown) ||
                const DeepCollectionEquality()
                    .equals(other.breakdown, breakdown)) &&
            (identical(other.totals, totals) ||
                const DeepCollectionEquality().equals(other.totals, totals)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(subtotals) ^
      const DeepCollectionEquality().hash(breakdown) ^
      const DeepCollectionEquality().hash(totals) ^
      const DeepCollectionEquality().hash(total) ^
      runtimeType.hashCode;
}

extension $DeductionsExtension on Deductions {
  Deductions copyWith(
      {List<Total>? subtotals,
      List<DeductionsBreakdown>? breakdown,
      List<Total>? totals,
      DeductionsTotal? total}) {
    return Deductions(
        subtotals: subtotals ?? this.subtotals,
        breakdown: breakdown ?? this.breakdown,
        totals: totals ?? this.totals,
        total: total ?? this.total);
  }

  Deductions copyWithWrapped(
      {Wrapped<List<Total>?>? subtotals,
      Wrapped<List<DeductionsBreakdown>>? breakdown,
      Wrapped<List<Total>?>? totals,
      Wrapped<DeductionsTotal>? total}) {
    return Deductions(
        subtotals: (subtotals != null ? subtotals.value : this.subtotals),
        breakdown: (breakdown != null ? breakdown.value : this.breakdown),
        totals: (totals != null ? totals.value : this.totals),
        total: (total != null ? total.value : this.total));
  }
}

@JsonSerializable(explicitToJson: true)
class DeductionsBreakdown {
  DeductionsBreakdown({
    this.currentAmount,
    this.description,
    this.isoCurrencyCode,
    this.unofficialCurrencyCode,
    this.ytdAmount,
  });

  factory DeductionsBreakdown.fromJson(Map<String, dynamic> json) =>
      _$DeductionsBreakdownFromJson(json);

  @JsonKey(name: 'current_amount')
  final double? currentAmount;
  @JsonKey(name: 'description')
  final String? description;
  @JsonKey(name: 'iso_currency_code')
  final String? isoCurrencyCode;
  @JsonKey(name: 'unofficial_currency_code')
  final String? unofficialCurrencyCode;
  @JsonKey(name: 'ytd_amount')
  final double? ytdAmount;
  static const fromJsonFactory = _$DeductionsBreakdownFromJson;
  static const toJsonFactory = _$DeductionsBreakdownToJson;
  Map<String, dynamic> toJson() => _$DeductionsBreakdownToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is DeductionsBreakdown &&
            (identical(other.currentAmount, currentAmount) ||
                const DeepCollectionEquality()
                    .equals(other.currentAmount, currentAmount)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)) &&
            (identical(other.unofficialCurrencyCode, unofficialCurrencyCode) ||
                const DeepCollectionEquality().equals(
                    other.unofficialCurrencyCode, unofficialCurrencyCode)) &&
            (identical(other.ytdAmount, ytdAmount) ||
                const DeepCollectionEquality()
                    .equals(other.ytdAmount, ytdAmount)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(currentAmount) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      const DeepCollectionEquality().hash(unofficialCurrencyCode) ^
      const DeepCollectionEquality().hash(ytdAmount) ^
      runtimeType.hashCode;
}

extension $DeductionsBreakdownExtension on DeductionsBreakdown {
  DeductionsBreakdown copyWith(
      {double? currentAmount,
      String? description,
      String? isoCurrencyCode,
      String? unofficialCurrencyCode,
      double? ytdAmount}) {
    return DeductionsBreakdown(
        currentAmount: currentAmount ?? this.currentAmount,
        description: description ?? this.description,
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode,
        unofficialCurrencyCode:
            unofficialCurrencyCode ?? this.unofficialCurrencyCode,
        ytdAmount: ytdAmount ?? this.ytdAmount);
  }

  DeductionsBreakdown copyWithWrapped(
      {Wrapped<double?>? currentAmount,
      Wrapped<String?>? description,
      Wrapped<String?>? isoCurrencyCode,
      Wrapped<String?>? unofficialCurrencyCode,
      Wrapped<double?>? ytdAmount}) {
    return DeductionsBreakdown(
        currentAmount:
            (currentAmount != null ? currentAmount.value : this.currentAmount),
        description:
            (description != null ? description.value : this.description),
        isoCurrencyCode: (isoCurrencyCode != null
            ? isoCurrencyCode.value
            : this.isoCurrencyCode),
        unofficialCurrencyCode: (unofficialCurrencyCode != null
            ? unofficialCurrencyCode.value
            : this.unofficialCurrencyCode),
        ytdAmount: (ytdAmount != null ? ytdAmount.value : this.ytdAmount));
  }
}

@JsonSerializable(explicitToJson: true)
class DeductionsTotal {
  DeductionsTotal({
    this.currentAmount,
    this.isoCurrencyCode,
    this.unofficialCurrencyCode,
    this.ytdAmount,
  });

  factory DeductionsTotal.fromJson(Map<String, dynamic> json) =>
      _$DeductionsTotalFromJson(json);

  @JsonKey(name: 'current_amount')
  final double? currentAmount;
  @JsonKey(name: 'iso_currency_code')
  final String? isoCurrencyCode;
  @JsonKey(name: 'unofficial_currency_code')
  final String? unofficialCurrencyCode;
  @JsonKey(name: 'ytd_amount')
  final double? ytdAmount;
  static const fromJsonFactory = _$DeductionsTotalFromJson;
  static const toJsonFactory = _$DeductionsTotalToJson;
  Map<String, dynamic> toJson() => _$DeductionsTotalToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is DeductionsTotal &&
            (identical(other.currentAmount, currentAmount) ||
                const DeepCollectionEquality()
                    .equals(other.currentAmount, currentAmount)) &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)) &&
            (identical(other.unofficialCurrencyCode, unofficialCurrencyCode) ||
                const DeepCollectionEquality().equals(
                    other.unofficialCurrencyCode, unofficialCurrencyCode)) &&
            (identical(other.ytdAmount, ytdAmount) ||
                const DeepCollectionEquality()
                    .equals(other.ytdAmount, ytdAmount)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(currentAmount) ^
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      const DeepCollectionEquality().hash(unofficialCurrencyCode) ^
      const DeepCollectionEquality().hash(ytdAmount) ^
      runtimeType.hashCode;
}

extension $DeductionsTotalExtension on DeductionsTotal {
  DeductionsTotal copyWith(
      {double? currentAmount,
      String? isoCurrencyCode,
      String? unofficialCurrencyCode,
      double? ytdAmount}) {
    return DeductionsTotal(
        currentAmount: currentAmount ?? this.currentAmount,
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode,
        unofficialCurrencyCode:
            unofficialCurrencyCode ?? this.unofficialCurrencyCode,
        ytdAmount: ytdAmount ?? this.ytdAmount);
  }

  DeductionsTotal copyWithWrapped(
      {Wrapped<double?>? currentAmount,
      Wrapped<String?>? isoCurrencyCode,
      Wrapped<String?>? unofficialCurrencyCode,
      Wrapped<double?>? ytdAmount}) {
    return DeductionsTotal(
        currentAmount:
            (currentAmount != null ? currentAmount.value : this.currentAmount),
        isoCurrencyCode: (isoCurrencyCode != null
            ? isoCurrencyCode.value
            : this.isoCurrencyCode),
        unofficialCurrencyCode: (unofficialCurrencyCode != null
            ? unofficialCurrencyCode.value
            : this.unofficialCurrencyCode),
        ytdAmount: (ytdAmount != null ? ytdAmount.value : this.ytdAmount));
  }
}

@JsonSerializable(explicitToJson: true)
class Total {
  Total({
    this.canonicalDescription,
    this.description,
    this.currentPay,
    this.ytdPay,
  });

  factory Total.fromJson(Map<String, dynamic> json) => _$TotalFromJson(json);

  @JsonKey(
    name: 'canonical_description',
    toJson: totalCanonicalDescriptionToJson,
    fromJson: totalCanonicalDescriptionFromJson,
  )
  final enums.TotalCanonicalDescription? canonicalDescription;
  @JsonKey(name: 'description')
  final String? description;
  @JsonKey(name: 'current_pay')
  final Pay? currentPay;
  @JsonKey(name: 'ytd_pay')
  final Pay? ytdPay;
  static const fromJsonFactory = _$TotalFromJson;
  static const toJsonFactory = _$TotalToJson;
  Map<String, dynamic> toJson() => _$TotalToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Total &&
            (identical(other.canonicalDescription, canonicalDescription) ||
                const DeepCollectionEquality().equals(
                    other.canonicalDescription, canonicalDescription)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.currentPay, currentPay) ||
                const DeepCollectionEquality()
                    .equals(other.currentPay, currentPay)) &&
            (identical(other.ytdPay, ytdPay) ||
                const DeepCollectionEquality().equals(other.ytdPay, ytdPay)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(canonicalDescription) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(currentPay) ^
      const DeepCollectionEquality().hash(ytdPay) ^
      runtimeType.hashCode;
}

extension $TotalExtension on Total {
  Total copyWith(
      {enums.TotalCanonicalDescription? canonicalDescription,
      String? description,
      Pay? currentPay,
      Pay? ytdPay}) {
    return Total(
        canonicalDescription: canonicalDescription ?? this.canonicalDescription,
        description: description ?? this.description,
        currentPay: currentPay ?? this.currentPay,
        ytdPay: ytdPay ?? this.ytdPay);
  }

  Total copyWithWrapped(
      {Wrapped<enums.TotalCanonicalDescription?>? canonicalDescription,
      Wrapped<String?>? description,
      Wrapped<Pay?>? currentPay,
      Wrapped<Pay?>? ytdPay}) {
    return Total(
        canonicalDescription: (canonicalDescription != null
            ? canonicalDescription.value
            : this.canonicalDescription),
        description:
            (description != null ? description.value : this.description),
        currentPay: (currentPay != null ? currentPay.value : this.currentPay),
        ytdPay: (ytdPay != null ? ytdPay.value : this.ytdPay));
  }
}

@JsonSerializable(explicitToJson: true)
class Pay {
  Pay({
    this.amount,
    this.currency,
  });

  factory Pay.fromJson(Map<String, dynamic> json) => _$PayFromJson(json);

  @JsonKey(name: 'amount')
  final double? amount;
  @JsonKey(name: 'currency')
  final String? currency;
  static const fromJsonFactory = _$PayFromJson;
  static const toJsonFactory = _$PayToJson;
  Map<String, dynamic> toJson() => _$PayToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Pay &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.currency, currency) ||
                const DeepCollectionEquality()
                    .equals(other.currency, currency)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(currency) ^
      runtimeType.hashCode;
}

extension $PayExtension on Pay {
  Pay copyWith({double? amount, String? currency}) {
    return Pay(
        amount: amount ?? this.amount, currency: currency ?? this.currency);
  }

  Pay copyWithWrapped({Wrapped<double?>? amount, Wrapped<String?>? currency}) {
    return Pay(
        amount: (amount != null ? amount.value : this.amount),
        currency: (currency != null ? currency.value : this.currency));
  }
}

@JsonSerializable(explicitToJson: true)
class Earnings {
  Earnings({
    this.subtotals,
    this.totals,
    this.breakdown,
    this.total,
  });

  factory Earnings.fromJson(Map<String, dynamic> json) =>
      _$EarningsFromJson(json);

  @JsonKey(name: 'subtotals', defaultValue: <EarningsTotal>[])
  final List<EarningsTotal>? subtotals;
  @JsonKey(name: 'totals', defaultValue: <EarningsTotal>[])
  final List<EarningsTotal>? totals;
  @JsonKey(name: 'breakdown', defaultValue: <EarningsBreakdown>[])
  final List<EarningsBreakdown>? breakdown;
  @JsonKey(name: 'total')
  final EarningsTotal? total;
  static const fromJsonFactory = _$EarningsFromJson;
  static const toJsonFactory = _$EarningsToJson;
  Map<String, dynamic> toJson() => _$EarningsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Earnings &&
            (identical(other.subtotals, subtotals) ||
                const DeepCollectionEquality()
                    .equals(other.subtotals, subtotals)) &&
            (identical(other.totals, totals) ||
                const DeepCollectionEquality().equals(other.totals, totals)) &&
            (identical(other.breakdown, breakdown) ||
                const DeepCollectionEquality()
                    .equals(other.breakdown, breakdown)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(subtotals) ^
      const DeepCollectionEquality().hash(totals) ^
      const DeepCollectionEquality().hash(breakdown) ^
      const DeepCollectionEquality().hash(total) ^
      runtimeType.hashCode;
}

extension $EarningsExtension on Earnings {
  Earnings copyWith(
      {List<EarningsTotal>? subtotals,
      List<EarningsTotal>? totals,
      List<EarningsBreakdown>? breakdown,
      EarningsTotal? total}) {
    return Earnings(
        subtotals: subtotals ?? this.subtotals,
        totals: totals ?? this.totals,
        breakdown: breakdown ?? this.breakdown,
        total: total ?? this.total);
  }

  Earnings copyWithWrapped(
      {Wrapped<List<EarningsTotal>?>? subtotals,
      Wrapped<List<EarningsTotal>?>? totals,
      Wrapped<List<EarningsBreakdown>?>? breakdown,
      Wrapped<EarningsTotal?>? total}) {
    return Earnings(
        subtotals: (subtotals != null ? subtotals.value : this.subtotals),
        totals: (totals != null ? totals.value : this.totals),
        breakdown: (breakdown != null ? breakdown.value : this.breakdown),
        total: (total != null ? total.value : this.total));
  }
}

@JsonSerializable(explicitToJson: true)
class EarningsBreakdown {
  EarningsBreakdown({
    this.canonicalDescription,
    this.currentAmount,
    this.description,
    this.hours,
    this.isoCurrencyCode,
    this.rate,
    this.unofficialCurrencyCode,
    this.ytdAmount,
  });

  factory EarningsBreakdown.fromJson(Map<String, dynamic> json) =>
      _$EarningsBreakdownFromJson(json);

  @JsonKey(
    name: 'canonical_description',
    toJson: earningsBreakdownCanonicalDescriptionToJson,
    fromJson: earningsBreakdownCanonicalDescriptionFromJson,
  )
  final enums.EarningsBreakdownCanonicalDescription? canonicalDescription;
  @JsonKey(name: 'current_amount')
  final double? currentAmount;
  @JsonKey(name: 'description')
  final String? description;
  @JsonKey(name: 'hours')
  final double? hours;
  @JsonKey(name: 'iso_currency_code')
  final String? isoCurrencyCode;
  @JsonKey(name: 'rate')
  final double? rate;
  @JsonKey(name: 'unofficial_currency_code')
  final String? unofficialCurrencyCode;
  @JsonKey(name: 'ytd_amount')
  final double? ytdAmount;
  static const fromJsonFactory = _$EarningsBreakdownFromJson;
  static const toJsonFactory = _$EarningsBreakdownToJson;
  Map<String, dynamic> toJson() => _$EarningsBreakdownToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is EarningsBreakdown &&
            (identical(other.canonicalDescription, canonicalDescription) ||
                const DeepCollectionEquality().equals(
                    other.canonicalDescription, canonicalDescription)) &&
            (identical(other.currentAmount, currentAmount) ||
                const DeepCollectionEquality()
                    .equals(other.currentAmount, currentAmount)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.hours, hours) ||
                const DeepCollectionEquality().equals(other.hours, hours)) &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)) &&
            (identical(other.rate, rate) ||
                const DeepCollectionEquality().equals(other.rate, rate)) &&
            (identical(other.unofficialCurrencyCode, unofficialCurrencyCode) ||
                const DeepCollectionEquality().equals(
                    other.unofficialCurrencyCode, unofficialCurrencyCode)) &&
            (identical(other.ytdAmount, ytdAmount) ||
                const DeepCollectionEquality()
                    .equals(other.ytdAmount, ytdAmount)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(canonicalDescription) ^
      const DeepCollectionEquality().hash(currentAmount) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(hours) ^
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      const DeepCollectionEquality().hash(rate) ^
      const DeepCollectionEquality().hash(unofficialCurrencyCode) ^
      const DeepCollectionEquality().hash(ytdAmount) ^
      runtimeType.hashCode;
}

extension $EarningsBreakdownExtension on EarningsBreakdown {
  EarningsBreakdown copyWith(
      {enums.EarningsBreakdownCanonicalDescription? canonicalDescription,
      double? currentAmount,
      String? description,
      double? hours,
      String? isoCurrencyCode,
      double? rate,
      String? unofficialCurrencyCode,
      double? ytdAmount}) {
    return EarningsBreakdown(
        canonicalDescription: canonicalDescription ?? this.canonicalDescription,
        currentAmount: currentAmount ?? this.currentAmount,
        description: description ?? this.description,
        hours: hours ?? this.hours,
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode,
        rate: rate ?? this.rate,
        unofficialCurrencyCode:
            unofficialCurrencyCode ?? this.unofficialCurrencyCode,
        ytdAmount: ytdAmount ?? this.ytdAmount);
  }

  EarningsBreakdown copyWithWrapped(
      {Wrapped<enums.EarningsBreakdownCanonicalDescription?>?
          canonicalDescription,
      Wrapped<double?>? currentAmount,
      Wrapped<String?>? description,
      Wrapped<double?>? hours,
      Wrapped<String?>? isoCurrencyCode,
      Wrapped<double?>? rate,
      Wrapped<String?>? unofficialCurrencyCode,
      Wrapped<double?>? ytdAmount}) {
    return EarningsBreakdown(
        canonicalDescription: (canonicalDescription != null
            ? canonicalDescription.value
            : this.canonicalDescription),
        currentAmount:
            (currentAmount != null ? currentAmount.value : this.currentAmount),
        description:
            (description != null ? description.value : this.description),
        hours: (hours != null ? hours.value : this.hours),
        isoCurrencyCode: (isoCurrencyCode != null
            ? isoCurrencyCode.value
            : this.isoCurrencyCode),
        rate: (rate != null ? rate.value : this.rate),
        unofficialCurrencyCode: (unofficialCurrencyCode != null
            ? unofficialCurrencyCode.value
            : this.unofficialCurrencyCode),
        ytdAmount: (ytdAmount != null ? ytdAmount.value : this.ytdAmount));
  }
}

@JsonSerializable(explicitToJson: true)
class EarningsTotal {
  EarningsTotal({
    this.currentAmount,
    this.currentPay,
    this.ytdPay,
    this.hours,
    this.isoCurrencyCode,
    this.unofficialCurrencyCode,
    this.ytdAmount,
  });

  factory EarningsTotal.fromJson(Map<String, dynamic> json) =>
      _$EarningsTotalFromJson(json);

  @JsonKey(name: 'current_amount')
  final double? currentAmount;
  @JsonKey(name: 'current_pay')
  final Pay? currentPay;
  @JsonKey(name: 'ytd_pay')
  final Pay? ytdPay;
  @JsonKey(name: 'hours')
  final double? hours;
  @JsonKey(name: 'iso_currency_code')
  final String? isoCurrencyCode;
  @JsonKey(name: 'unofficial_currency_code')
  final String? unofficialCurrencyCode;
  @JsonKey(name: 'ytd_amount')
  final double? ytdAmount;
  static const fromJsonFactory = _$EarningsTotalFromJson;
  static const toJsonFactory = _$EarningsTotalToJson;
  Map<String, dynamic> toJson() => _$EarningsTotalToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is EarningsTotal &&
            (identical(other.currentAmount, currentAmount) ||
                const DeepCollectionEquality()
                    .equals(other.currentAmount, currentAmount)) &&
            (identical(other.currentPay, currentPay) ||
                const DeepCollectionEquality()
                    .equals(other.currentPay, currentPay)) &&
            (identical(other.ytdPay, ytdPay) ||
                const DeepCollectionEquality().equals(other.ytdPay, ytdPay)) &&
            (identical(other.hours, hours) ||
                const DeepCollectionEquality().equals(other.hours, hours)) &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)) &&
            (identical(other.unofficialCurrencyCode, unofficialCurrencyCode) ||
                const DeepCollectionEquality().equals(
                    other.unofficialCurrencyCode, unofficialCurrencyCode)) &&
            (identical(other.ytdAmount, ytdAmount) ||
                const DeepCollectionEquality()
                    .equals(other.ytdAmount, ytdAmount)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(currentAmount) ^
      const DeepCollectionEquality().hash(currentPay) ^
      const DeepCollectionEquality().hash(ytdPay) ^
      const DeepCollectionEquality().hash(hours) ^
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      const DeepCollectionEquality().hash(unofficialCurrencyCode) ^
      const DeepCollectionEquality().hash(ytdAmount) ^
      runtimeType.hashCode;
}

extension $EarningsTotalExtension on EarningsTotal {
  EarningsTotal copyWith(
      {double? currentAmount,
      Pay? currentPay,
      Pay? ytdPay,
      double? hours,
      String? isoCurrencyCode,
      String? unofficialCurrencyCode,
      double? ytdAmount}) {
    return EarningsTotal(
        currentAmount: currentAmount ?? this.currentAmount,
        currentPay: currentPay ?? this.currentPay,
        ytdPay: ytdPay ?? this.ytdPay,
        hours: hours ?? this.hours,
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode,
        unofficialCurrencyCode:
            unofficialCurrencyCode ?? this.unofficialCurrencyCode,
        ytdAmount: ytdAmount ?? this.ytdAmount);
  }

  EarningsTotal copyWithWrapped(
      {Wrapped<double?>? currentAmount,
      Wrapped<Pay?>? currentPay,
      Wrapped<Pay?>? ytdPay,
      Wrapped<double?>? hours,
      Wrapped<String?>? isoCurrencyCode,
      Wrapped<String?>? unofficialCurrencyCode,
      Wrapped<double?>? ytdAmount}) {
    return EarningsTotal(
        currentAmount:
            (currentAmount != null ? currentAmount.value : this.currentAmount),
        currentPay: (currentPay != null ? currentPay.value : this.currentPay),
        ytdPay: (ytdPay != null ? ytdPay.value : this.ytdPay),
        hours: (hours != null ? hours.value : this.hours),
        isoCurrencyCode: (isoCurrencyCode != null
            ? isoCurrencyCode.value
            : this.isoCurrencyCode),
        unofficialCurrencyCode: (unofficialCurrencyCode != null
            ? unofficialCurrencyCode.value
            : this.unofficialCurrencyCode),
        ytdAmount: (ytdAmount != null ? ytdAmount.value : this.ytdAmount));
  }
}

@JsonSerializable(explicitToJson: true)
class EmploymentDetails {
  EmploymentDetails({
    this.annualSalary,
    this.hireDate,
  });

  factory EmploymentDetails.fromJson(Map<String, dynamic> json) =>
      _$EmploymentDetailsFromJson(json);

  @JsonKey(name: 'annual_salary')
  final Pay? annualSalary;
  @JsonKey(name: 'hire_date', toJson: _dateToJson)
  final DateTime? hireDate;
  static const fromJsonFactory = _$EmploymentDetailsFromJson;
  static const toJsonFactory = _$EmploymentDetailsToJson;
  Map<String, dynamic> toJson() => _$EmploymentDetailsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is EmploymentDetails &&
            (identical(other.annualSalary, annualSalary) ||
                const DeepCollectionEquality()
                    .equals(other.annualSalary, annualSalary)) &&
            (identical(other.hireDate, hireDate) ||
                const DeepCollectionEquality()
                    .equals(other.hireDate, hireDate)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(annualSalary) ^
      const DeepCollectionEquality().hash(hireDate) ^
      runtimeType.hashCode;
}

extension $EmploymentDetailsExtension on EmploymentDetails {
  EmploymentDetails copyWith({Pay? annualSalary, DateTime? hireDate}) {
    return EmploymentDetails(
        annualSalary: annualSalary ?? this.annualSalary,
        hireDate: hireDate ?? this.hireDate);
  }

  EmploymentDetails copyWithWrapped(
      {Wrapped<Pay?>? annualSalary, Wrapped<DateTime?>? hireDate}) {
    return EmploymentDetails(
        annualSalary:
            (annualSalary != null ? annualSalary.value : this.annualSalary),
        hireDate: (hireDate != null ? hireDate.value : this.hireDate));
  }
}

@JsonSerializable(explicitToJson: true)
class NetPay {
  NetPay({
    this.currentAmount,
    this.description,
    this.isoCurrencyCode,
    this.unofficialCurrencyCode,
    this.ytdAmount,
    this.total,
  });

  factory NetPay.fromJson(Map<String, dynamic> json) => _$NetPayFromJson(json);

  @JsonKey(name: 'current_amount')
  final double? currentAmount;
  @JsonKey(name: 'description')
  final String? description;
  @JsonKey(name: 'iso_currency_code')
  final String? isoCurrencyCode;
  @JsonKey(name: 'unofficial_currency_code')
  final String? unofficialCurrencyCode;
  @JsonKey(name: 'ytd_amount')
  final double? ytdAmount;
  @JsonKey(name: 'total')
  final Total? total;
  static const fromJsonFactory = _$NetPayFromJson;
  static const toJsonFactory = _$NetPayToJson;
  Map<String, dynamic> toJson() => _$NetPayToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is NetPay &&
            (identical(other.currentAmount, currentAmount) ||
                const DeepCollectionEquality()
                    .equals(other.currentAmount, currentAmount)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)) &&
            (identical(other.unofficialCurrencyCode, unofficialCurrencyCode) ||
                const DeepCollectionEquality().equals(
                    other.unofficialCurrencyCode, unofficialCurrencyCode)) &&
            (identical(other.ytdAmount, ytdAmount) ||
                const DeepCollectionEquality()
                    .equals(other.ytdAmount, ytdAmount)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(currentAmount) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      const DeepCollectionEquality().hash(unofficialCurrencyCode) ^
      const DeepCollectionEquality().hash(ytdAmount) ^
      const DeepCollectionEquality().hash(total) ^
      runtimeType.hashCode;
}

extension $NetPayExtension on NetPay {
  NetPay copyWith(
      {double? currentAmount,
      String? description,
      String? isoCurrencyCode,
      String? unofficialCurrencyCode,
      double? ytdAmount,
      Total? total}) {
    return NetPay(
        currentAmount: currentAmount ?? this.currentAmount,
        description: description ?? this.description,
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode,
        unofficialCurrencyCode:
            unofficialCurrencyCode ?? this.unofficialCurrencyCode,
        ytdAmount: ytdAmount ?? this.ytdAmount,
        total: total ?? this.total);
  }

  NetPay copyWithWrapped(
      {Wrapped<double?>? currentAmount,
      Wrapped<String?>? description,
      Wrapped<String?>? isoCurrencyCode,
      Wrapped<String?>? unofficialCurrencyCode,
      Wrapped<double?>? ytdAmount,
      Wrapped<Total?>? total}) {
    return NetPay(
        currentAmount:
            (currentAmount != null ? currentAmount.value : this.currentAmount),
        description:
            (description != null ? description.value : this.description),
        isoCurrencyCode: (isoCurrencyCode != null
            ? isoCurrencyCode.value
            : this.isoCurrencyCode),
        unofficialCurrencyCode: (unofficialCurrencyCode != null
            ? unofficialCurrencyCode.value
            : this.unofficialCurrencyCode),
        ytdAmount: (ytdAmount != null ? ytdAmount.value : this.ytdAmount),
        total: (total != null ? total.value : this.total));
  }
}

@JsonSerializable(explicitToJson: true)
class PaystubDetails {
  PaystubDetails({
    this.payPeriodStartDate,
    this.payPeriodEndDate,
    this.payDate,
    this.paystubProvider,
    this.payFrequency,
  });

  factory PaystubDetails.fromJson(Map<String, dynamic> json) =>
      _$PaystubDetailsFromJson(json);

  @JsonKey(name: 'pay_period_start_date', toJson: _dateToJson)
  final DateTime? payPeriodStartDate;
  @JsonKey(name: 'pay_period_end_date', toJson: _dateToJson)
  final DateTime? payPeriodEndDate;
  @JsonKey(name: 'pay_date', toJson: _dateToJson)
  final DateTime? payDate;
  @JsonKey(name: 'paystub_provider')
  final String? paystubProvider;
  @JsonKey(
    name: 'pay_frequency',
    toJson: paystubPayFrequencyToJson,
    fromJson: paystubPayFrequencyFromJson,
  )
  final enums.PaystubPayFrequency? payFrequency;
  static const fromJsonFactory = _$PaystubDetailsFromJson;
  static const toJsonFactory = _$PaystubDetailsToJson;
  Map<String, dynamic> toJson() => _$PaystubDetailsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaystubDetails &&
            (identical(other.payPeriodStartDate, payPeriodStartDate) ||
                const DeepCollectionEquality()
                    .equals(other.payPeriodStartDate, payPeriodStartDate)) &&
            (identical(other.payPeriodEndDate, payPeriodEndDate) ||
                const DeepCollectionEquality()
                    .equals(other.payPeriodEndDate, payPeriodEndDate)) &&
            (identical(other.payDate, payDate) ||
                const DeepCollectionEquality()
                    .equals(other.payDate, payDate)) &&
            (identical(other.paystubProvider, paystubProvider) ||
                const DeepCollectionEquality()
                    .equals(other.paystubProvider, paystubProvider)) &&
            (identical(other.payFrequency, payFrequency) ||
                const DeepCollectionEquality()
                    .equals(other.payFrequency, payFrequency)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(payPeriodStartDate) ^
      const DeepCollectionEquality().hash(payPeriodEndDate) ^
      const DeepCollectionEquality().hash(payDate) ^
      const DeepCollectionEquality().hash(paystubProvider) ^
      const DeepCollectionEquality().hash(payFrequency) ^
      runtimeType.hashCode;
}

extension $PaystubDetailsExtension on PaystubDetails {
  PaystubDetails copyWith(
      {DateTime? payPeriodStartDate,
      DateTime? payPeriodEndDate,
      DateTime? payDate,
      String? paystubProvider,
      enums.PaystubPayFrequency? payFrequency}) {
    return PaystubDetails(
        payPeriodStartDate: payPeriodStartDate ?? this.payPeriodStartDate,
        payPeriodEndDate: payPeriodEndDate ?? this.payPeriodEndDate,
        payDate: payDate ?? this.payDate,
        paystubProvider: paystubProvider ?? this.paystubProvider,
        payFrequency: payFrequency ?? this.payFrequency);
  }

  PaystubDetails copyWithWrapped(
      {Wrapped<DateTime?>? payPeriodStartDate,
      Wrapped<DateTime?>? payPeriodEndDate,
      Wrapped<DateTime?>? payDate,
      Wrapped<String?>? paystubProvider,
      Wrapped<enums.PaystubPayFrequency?>? payFrequency}) {
    return PaystubDetails(
        payPeriodStartDate: (payPeriodStartDate != null
            ? payPeriodStartDate.value
            : this.payPeriodStartDate),
        payPeriodEndDate: (payPeriodEndDate != null
            ? payPeriodEndDate.value
            : this.payPeriodEndDate),
        payDate: (payDate != null ? payDate.value : this.payDate),
        paystubProvider: (paystubProvider != null
            ? paystubProvider.value
            : this.paystubProvider),
        payFrequency:
            (payFrequency != null ? payFrequency.value : this.payFrequency));
  }
}

@JsonSerializable(explicitToJson: true)
class IncomeBreakdown {
  IncomeBreakdown({
    required this.type,
    required this.rate,
    required this.hours,
    required this.total,
  });

  factory IncomeBreakdown.fromJson(Map<String, dynamic> json) =>
      _$IncomeBreakdownFromJson(json);

  @JsonKey(
    name: 'type',
    toJson: incomeBreakdownTypeToJson,
    fromJson: incomeBreakdownTypeFromJson,
  )
  final enums.IncomeBreakdownType? type;
  @JsonKey(name: 'rate')
  final double? rate;
  @JsonKey(name: 'hours')
  final double? hours;
  @JsonKey(name: 'total')
  final double? total;
  static const fromJsonFactory = _$IncomeBreakdownFromJson;
  static const toJsonFactory = _$IncomeBreakdownToJson;
  Map<String, dynamic> toJson() => _$IncomeBreakdownToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IncomeBreakdown &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.rate, rate) ||
                const DeepCollectionEquality().equals(other.rate, rate)) &&
            (identical(other.hours, hours) ||
                const DeepCollectionEquality().equals(other.hours, hours)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(rate) ^
      const DeepCollectionEquality().hash(hours) ^
      const DeepCollectionEquality().hash(total) ^
      runtimeType.hashCode;
}

extension $IncomeBreakdownExtension on IncomeBreakdown {
  IncomeBreakdown copyWith(
      {enums.IncomeBreakdownType? type,
      double? rate,
      double? hours,
      double? total}) {
    return IncomeBreakdown(
        type: type ?? this.type,
        rate: rate ?? this.rate,
        hours: hours ?? this.hours,
        total: total ?? this.total);
  }

  IncomeBreakdown copyWithWrapped(
      {Wrapped<enums.IncomeBreakdownType?>? type,
      Wrapped<double?>? rate,
      Wrapped<double?>? hours,
      Wrapped<double?>? total}) {
    return IncomeBreakdown(
        type: (type != null ? type.value : this.type),
        rate: (rate != null ? rate.value : this.rate),
        hours: (hours != null ? hours.value : this.hours),
        total: (total != null ? total.value : this.total));
  }
}

@JsonSerializable(explicitToJson: true)
class Employee {
  Employee({
    required this.address,
    required this.name,
    this.maritalStatus,
    this.taxpayerId,
  });

  factory Employee.fromJson(Map<String, dynamic> json) =>
      _$EmployeeFromJson(json);

  @JsonKey(name: 'address')
  final PaystubAddress address;
  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'marital_status')
  final String? maritalStatus;
  @JsonKey(name: 'taxpayer_id')
  final TaxpayerID? taxpayerId;
  static const fromJsonFactory = _$EmployeeFromJson;
  static const toJsonFactory = _$EmployeeToJson;
  Map<String, dynamic> toJson() => _$EmployeeToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Employee &&
            (identical(other.address, address) ||
                const DeepCollectionEquality()
                    .equals(other.address, address)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.maritalStatus, maritalStatus) ||
                const DeepCollectionEquality()
                    .equals(other.maritalStatus, maritalStatus)) &&
            (identical(other.taxpayerId, taxpayerId) ||
                const DeepCollectionEquality()
                    .equals(other.taxpayerId, taxpayerId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(maritalStatus) ^
      const DeepCollectionEquality().hash(taxpayerId) ^
      runtimeType.hashCode;
}

extension $EmployeeExtension on Employee {
  Employee copyWith(
      {PaystubAddress? address,
      String? name,
      String? maritalStatus,
      TaxpayerID? taxpayerId}) {
    return Employee(
        address: address ?? this.address,
        name: name ?? this.name,
        maritalStatus: maritalStatus ?? this.maritalStatus,
        taxpayerId: taxpayerId ?? this.taxpayerId);
  }

  Employee copyWithWrapped(
      {Wrapped<PaystubAddress>? address,
      Wrapped<String?>? name,
      Wrapped<String?>? maritalStatus,
      Wrapped<TaxpayerID?>? taxpayerId}) {
    return Employee(
        address: (address != null ? address.value : this.address),
        name: (name != null ? name.value : this.name),
        maritalStatus:
            (maritalStatus != null ? maritalStatus.value : this.maritalStatus),
        taxpayerId: (taxpayerId != null ? taxpayerId.value : this.taxpayerId));
  }
}

@JsonSerializable(explicitToJson: true)
class TaxpayerID {
  TaxpayerID({
    this.idType,
    this.idMask,
    this.last4Digits,
  });

  factory TaxpayerID.fromJson(Map<String, dynamic> json) =>
      _$TaxpayerIDFromJson(json);

  @JsonKey(name: 'id_type')
  final String? idType;
  @JsonKey(name: 'id_mask')
  final String? idMask;
  @JsonKey(name: 'last_4_digits')
  final String? last4Digits;
  static const fromJsonFactory = _$TaxpayerIDFromJson;
  static const toJsonFactory = _$TaxpayerIDToJson;
  Map<String, dynamic> toJson() => _$TaxpayerIDToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TaxpayerID &&
            (identical(other.idType, idType) ||
                const DeepCollectionEquality().equals(other.idType, idType)) &&
            (identical(other.idMask, idMask) ||
                const DeepCollectionEquality().equals(other.idMask, idMask)) &&
            (identical(other.last4Digits, last4Digits) ||
                const DeepCollectionEquality()
                    .equals(other.last4Digits, last4Digits)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(idType) ^
      const DeepCollectionEquality().hash(idMask) ^
      const DeepCollectionEquality().hash(last4Digits) ^
      runtimeType.hashCode;
}

extension $TaxpayerIDExtension on TaxpayerID {
  TaxpayerID copyWith({String? idType, String? idMask, String? last4Digits}) {
    return TaxpayerID(
        idType: idType ?? this.idType,
        idMask: idMask ?? this.idMask,
        last4Digits: last4Digits ?? this.last4Digits);
  }

  TaxpayerID copyWithWrapped(
      {Wrapped<String?>? idType,
      Wrapped<String?>? idMask,
      Wrapped<String?>? last4Digits}) {
    return TaxpayerID(
        idType: (idType != null ? idType.value : this.idType),
        idMask: (idMask != null ? idMask.value : this.idMask),
        last4Digits:
            (last4Digits != null ? last4Digits.value : this.last4Digits));
  }
}

@JsonSerializable(explicitToJson: true)
class PaystubEmployer {
  PaystubEmployer({
    this.address,
    required this.name,
  });

  factory PaystubEmployer.fromJson(Map<String, dynamic> json) =>
      _$PaystubEmployerFromJson(json);

  @JsonKey(name: 'address')
  final PaystubAddress? address;
  @JsonKey(name: 'name')
  final String? name;
  static const fromJsonFactory = _$PaystubEmployerFromJson;
  static const toJsonFactory = _$PaystubEmployerToJson;
  Map<String, dynamic> toJson() => _$PaystubEmployerToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaystubEmployer &&
            (identical(other.address, address) ||
                const DeepCollectionEquality()
                    .equals(other.address, address)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(name) ^
      runtimeType.hashCode;
}

extension $PaystubEmployerExtension on PaystubEmployer {
  PaystubEmployer copyWith({PaystubAddress? address, String? name}) {
    return PaystubEmployer(
        address: address ?? this.address, name: name ?? this.name);
  }

  PaystubEmployer copyWithWrapped(
      {Wrapped<PaystubAddress?>? address, Wrapped<String?>? name}) {
    return PaystubEmployer(
        address: (address != null ? address.value : this.address),
        name: (name != null ? name.value : this.name));
  }
}

@JsonSerializable(explicitToJson: true)
class PaystubAddress {
  PaystubAddress({
    this.city,
    this.country,
    this.postalCode,
    this.region,
    this.street,
    this.line1,
    this.line2,
    this.stateCode,
  });

  factory PaystubAddress.fromJson(Map<String, dynamic> json) =>
      _$PaystubAddressFromJson(json);

  @JsonKey(name: 'city')
  final String? city;
  @JsonKey(name: 'country')
  final String? country;
  @JsonKey(name: 'postal_code')
  final String? postalCode;
  @JsonKey(name: 'region')
  final String? region;
  @JsonKey(name: 'street')
  final String? street;
  @JsonKey(name: 'line1')
  final String? line1;
  @JsonKey(name: 'line2')
  final String? line2;
  @JsonKey(name: 'state_code')
  final String? stateCode;
  static const fromJsonFactory = _$PaystubAddressFromJson;
  static const toJsonFactory = _$PaystubAddressToJson;
  Map<String, dynamic> toJson() => _$PaystubAddressToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaystubAddress &&
            (identical(other.city, city) ||
                const DeepCollectionEquality().equals(other.city, city)) &&
            (identical(other.country, country) ||
                const DeepCollectionEquality()
                    .equals(other.country, country)) &&
            (identical(other.postalCode, postalCode) ||
                const DeepCollectionEquality()
                    .equals(other.postalCode, postalCode)) &&
            (identical(other.region, region) ||
                const DeepCollectionEquality().equals(other.region, region)) &&
            (identical(other.street, street) ||
                const DeepCollectionEquality().equals(other.street, street)) &&
            (identical(other.line1, line1) ||
                const DeepCollectionEquality().equals(other.line1, line1)) &&
            (identical(other.line2, line2) ||
                const DeepCollectionEquality().equals(other.line2, line2)) &&
            (identical(other.stateCode, stateCode) ||
                const DeepCollectionEquality()
                    .equals(other.stateCode, stateCode)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(city) ^
      const DeepCollectionEquality().hash(country) ^
      const DeepCollectionEquality().hash(postalCode) ^
      const DeepCollectionEquality().hash(region) ^
      const DeepCollectionEquality().hash(street) ^
      const DeepCollectionEquality().hash(line1) ^
      const DeepCollectionEquality().hash(line2) ^
      const DeepCollectionEquality().hash(stateCode) ^
      runtimeType.hashCode;
}

extension $PaystubAddressExtension on PaystubAddress {
  PaystubAddress copyWith(
      {String? city,
      String? country,
      String? postalCode,
      String? region,
      String? street,
      String? line1,
      String? line2,
      String? stateCode}) {
    return PaystubAddress(
        city: city ?? this.city,
        country: country ?? this.country,
        postalCode: postalCode ?? this.postalCode,
        region: region ?? this.region,
        street: street ?? this.street,
        line1: line1 ?? this.line1,
        line2: line2 ?? this.line2,
        stateCode: stateCode ?? this.stateCode);
  }

  PaystubAddress copyWithWrapped(
      {Wrapped<String?>? city,
      Wrapped<String?>? country,
      Wrapped<String?>? postalCode,
      Wrapped<String?>? region,
      Wrapped<String?>? street,
      Wrapped<String?>? line1,
      Wrapped<String?>? line2,
      Wrapped<String?>? stateCode}) {
    return PaystubAddress(
        city: (city != null ? city.value : this.city),
        country: (country != null ? country.value : this.country),
        postalCode: (postalCode != null ? postalCode.value : this.postalCode),
        region: (region != null ? region.value : this.region),
        street: (street != null ? street.value : this.street),
        line1: (line1 != null ? line1.value : this.line1),
        line2: (line2 != null ? line2.value : this.line2),
        stateCode: (stateCode != null ? stateCode.value : this.stateCode));
  }
}

@JsonSerializable(explicitToJson: true)
class PayPeriodDetails {
  PayPeriodDetails({
    this.checkAmount,
    this.distributionBreakdown,
    this.endDate,
    this.grossEarnings,
    this.payDate,
    this.payFrequency,
    this.payDay,
    this.startDate,
  });

  factory PayPeriodDetails.fromJson(Map<String, dynamic> json) =>
      _$PayPeriodDetailsFromJson(json);

  @JsonKey(name: 'check_amount')
  final double? checkAmount;
  @JsonKey(
      name: 'distribution_breakdown', defaultValue: <DistributionBreakdown>[])
  final List<DistributionBreakdown>? distributionBreakdown;
  @JsonKey(name: 'end_date', toJson: _dateToJson)
  final DateTime? endDate;
  @JsonKey(name: 'gross_earnings')
  final double? grossEarnings;
  @JsonKey(name: 'pay_date', toJson: _dateToJson)
  final DateTime? payDate;
  @JsonKey(
    name: 'pay_frequency',
    toJson: payPeriodDetailsPayFrequencyToJson,
    fromJson: payPeriodDetailsPayFrequencyFromJson,
  )
  final enums.PayPeriodDetailsPayFrequency? payFrequency;
  @JsonKey(name: 'pay_day', toJson: _dateToJson)
  final DateTime? payDay;
  @JsonKey(name: 'start_date', toJson: _dateToJson)
  final DateTime? startDate;
  static const fromJsonFactory = _$PayPeriodDetailsFromJson;
  static const toJsonFactory = _$PayPeriodDetailsToJson;
  Map<String, dynamic> toJson() => _$PayPeriodDetailsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PayPeriodDetails &&
            (identical(other.checkAmount, checkAmount) ||
                const DeepCollectionEquality()
                    .equals(other.checkAmount, checkAmount)) &&
            (identical(other.distributionBreakdown, distributionBreakdown) ||
                const DeepCollectionEquality().equals(
                    other.distributionBreakdown, distributionBreakdown)) &&
            (identical(other.endDate, endDate) ||
                const DeepCollectionEquality()
                    .equals(other.endDate, endDate)) &&
            (identical(other.grossEarnings, grossEarnings) ||
                const DeepCollectionEquality()
                    .equals(other.grossEarnings, grossEarnings)) &&
            (identical(other.payDate, payDate) ||
                const DeepCollectionEquality()
                    .equals(other.payDate, payDate)) &&
            (identical(other.payFrequency, payFrequency) ||
                const DeepCollectionEquality()
                    .equals(other.payFrequency, payFrequency)) &&
            (identical(other.payDay, payDay) ||
                const DeepCollectionEquality().equals(other.payDay, payDay)) &&
            (identical(other.startDate, startDate) ||
                const DeepCollectionEquality()
                    .equals(other.startDate, startDate)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(checkAmount) ^
      const DeepCollectionEquality().hash(distributionBreakdown) ^
      const DeepCollectionEquality().hash(endDate) ^
      const DeepCollectionEquality().hash(grossEarnings) ^
      const DeepCollectionEquality().hash(payDate) ^
      const DeepCollectionEquality().hash(payFrequency) ^
      const DeepCollectionEquality().hash(payDay) ^
      const DeepCollectionEquality().hash(startDate) ^
      runtimeType.hashCode;
}

extension $PayPeriodDetailsExtension on PayPeriodDetails {
  PayPeriodDetails copyWith(
      {double? checkAmount,
      List<DistributionBreakdown>? distributionBreakdown,
      DateTime? endDate,
      double? grossEarnings,
      DateTime? payDate,
      enums.PayPeriodDetailsPayFrequency? payFrequency,
      DateTime? payDay,
      DateTime? startDate}) {
    return PayPeriodDetails(
        checkAmount: checkAmount ?? this.checkAmount,
        distributionBreakdown:
            distributionBreakdown ?? this.distributionBreakdown,
        endDate: endDate ?? this.endDate,
        grossEarnings: grossEarnings ?? this.grossEarnings,
        payDate: payDate ?? this.payDate,
        payFrequency: payFrequency ?? this.payFrequency,
        payDay: payDay ?? this.payDay,
        startDate: startDate ?? this.startDate);
  }

  PayPeriodDetails copyWithWrapped(
      {Wrapped<double?>? checkAmount,
      Wrapped<List<DistributionBreakdown>?>? distributionBreakdown,
      Wrapped<DateTime?>? endDate,
      Wrapped<double?>? grossEarnings,
      Wrapped<DateTime?>? payDate,
      Wrapped<enums.PayPeriodDetailsPayFrequency?>? payFrequency,
      Wrapped<DateTime?>? payDay,
      Wrapped<DateTime?>? startDate}) {
    return PayPeriodDetails(
        checkAmount:
            (checkAmount != null ? checkAmount.value : this.checkAmount),
        distributionBreakdown: (distributionBreakdown != null
            ? distributionBreakdown.value
            : this.distributionBreakdown),
        endDate: (endDate != null ? endDate.value : this.endDate),
        grossEarnings:
            (grossEarnings != null ? grossEarnings.value : this.grossEarnings),
        payDate: (payDate != null ? payDate.value : this.payDate),
        payFrequency:
            (payFrequency != null ? payFrequency.value : this.payFrequency),
        payDay: (payDay != null ? payDay.value : this.payDay),
        startDate: (startDate != null ? startDate.value : this.startDate));
  }
}

@JsonSerializable(explicitToJson: true)
class DistributionBreakdown {
  DistributionBreakdown({
    this.accountName,
    this.bankName,
    this.currentAmount,
    this.isoCurrencyCode,
    this.mask,
    this.type,
    this.unofficialCurrencyCode,
    this.currentPay,
  });

  factory DistributionBreakdown.fromJson(Map<String, dynamic> json) =>
      _$DistributionBreakdownFromJson(json);

  @JsonKey(name: 'account_name')
  final String? accountName;
  @JsonKey(name: 'bank_name')
  final String? bankName;
  @JsonKey(name: 'current_amount')
  final double? currentAmount;
  @JsonKey(name: 'iso_currency_code')
  final String? isoCurrencyCode;
  @JsonKey(name: 'mask')
  final String? mask;
  @JsonKey(name: 'type')
  final String? type;
  @JsonKey(name: 'unofficial_currency_code')
  final String? unofficialCurrencyCode;
  @JsonKey(name: 'current_pay')
  final Pay? currentPay;
  static const fromJsonFactory = _$DistributionBreakdownFromJson;
  static const toJsonFactory = _$DistributionBreakdownToJson;
  Map<String, dynamic> toJson() => _$DistributionBreakdownToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is DistributionBreakdown &&
            (identical(other.accountName, accountName) ||
                const DeepCollectionEquality()
                    .equals(other.accountName, accountName)) &&
            (identical(other.bankName, bankName) ||
                const DeepCollectionEquality()
                    .equals(other.bankName, bankName)) &&
            (identical(other.currentAmount, currentAmount) ||
                const DeepCollectionEquality()
                    .equals(other.currentAmount, currentAmount)) &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)) &&
            (identical(other.mask, mask) ||
                const DeepCollectionEquality().equals(other.mask, mask)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.unofficialCurrencyCode, unofficialCurrencyCode) ||
                const DeepCollectionEquality().equals(
                    other.unofficialCurrencyCode, unofficialCurrencyCode)) &&
            (identical(other.currentPay, currentPay) ||
                const DeepCollectionEquality()
                    .equals(other.currentPay, currentPay)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountName) ^
      const DeepCollectionEquality().hash(bankName) ^
      const DeepCollectionEquality().hash(currentAmount) ^
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      const DeepCollectionEquality().hash(mask) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(unofficialCurrencyCode) ^
      const DeepCollectionEquality().hash(currentPay) ^
      runtimeType.hashCode;
}

extension $DistributionBreakdownExtension on DistributionBreakdown {
  DistributionBreakdown copyWith(
      {String? accountName,
      String? bankName,
      double? currentAmount,
      String? isoCurrencyCode,
      String? mask,
      String? type,
      String? unofficialCurrencyCode,
      Pay? currentPay}) {
    return DistributionBreakdown(
        accountName: accountName ?? this.accountName,
        bankName: bankName ?? this.bankName,
        currentAmount: currentAmount ?? this.currentAmount,
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode,
        mask: mask ?? this.mask,
        type: type ?? this.type,
        unofficialCurrencyCode:
            unofficialCurrencyCode ?? this.unofficialCurrencyCode,
        currentPay: currentPay ?? this.currentPay);
  }

  DistributionBreakdown copyWithWrapped(
      {Wrapped<String?>? accountName,
      Wrapped<String?>? bankName,
      Wrapped<double?>? currentAmount,
      Wrapped<String?>? isoCurrencyCode,
      Wrapped<String?>? mask,
      Wrapped<String?>? type,
      Wrapped<String?>? unofficialCurrencyCode,
      Wrapped<Pay?>? currentPay}) {
    return DistributionBreakdown(
        accountName:
            (accountName != null ? accountName.value : this.accountName),
        bankName: (bankName != null ? bankName.value : this.bankName),
        currentAmount:
            (currentAmount != null ? currentAmount.value : this.currentAmount),
        isoCurrencyCode: (isoCurrencyCode != null
            ? isoCurrencyCode.value
            : this.isoCurrencyCode),
        mask: (mask != null ? mask.value : this.mask),
        type: (type != null ? type.value : this.type),
        unofficialCurrencyCode: (unofficialCurrencyCode != null
            ? unofficialCurrencyCode.value
            : this.unofficialCurrencyCode),
        currentPay: (currentPay != null ? currentPay.value : this.currentPay));
  }
}

@JsonSerializable(explicitToJson: true)
class PaystubDeduction {
  PaystubDeduction({
    required this.type,
    required this.isPretax,
    required this.total,
  });

  factory PaystubDeduction.fromJson(Map<String, dynamic> json) =>
      _$PaystubDeductionFromJson(json);

  @JsonKey(name: 'type')
  final String? type;
  @JsonKey(name: 'is_pretax')
  final bool? isPretax;
  @JsonKey(name: 'total')
  final double? total;
  static const fromJsonFactory = _$PaystubDeductionFromJson;
  static const toJsonFactory = _$PaystubDeductionToJson;
  Map<String, dynamic> toJson() => _$PaystubDeductionToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaystubDeduction &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.isPretax, isPretax) ||
                const DeepCollectionEquality()
                    .equals(other.isPretax, isPretax)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(isPretax) ^
      const DeepCollectionEquality().hash(total) ^
      runtimeType.hashCode;
}

extension $PaystubDeductionExtension on PaystubDeduction {
  PaystubDeduction copyWith({String? type, bool? isPretax, double? total}) {
    return PaystubDeduction(
        type: type ?? this.type,
        isPretax: isPretax ?? this.isPretax,
        total: total ?? this.total);
  }

  PaystubDeduction copyWithWrapped(
      {Wrapped<String?>? type,
      Wrapped<bool?>? isPretax,
      Wrapped<double?>? total}) {
    return PaystubDeduction(
        type: (type != null ? type.value : this.type),
        isPretax: (isPretax != null ? isPretax.value : this.isPretax),
        total: (total != null ? total.value : this.total));
  }
}

@JsonSerializable(explicitToJson: true)
class PaystubYTDDetails {
  PaystubYTDDetails({
    this.grossEarnings,
    this.netEarnings,
  });

  factory PaystubYTDDetails.fromJson(Map<String, dynamic> json) =>
      _$PaystubYTDDetailsFromJson(json);

  @JsonKey(name: 'gross_earnings')
  final double? grossEarnings;
  @JsonKey(name: 'net_earnings')
  final double? netEarnings;
  static const fromJsonFactory = _$PaystubYTDDetailsFromJson;
  static const toJsonFactory = _$PaystubYTDDetailsToJson;
  Map<String, dynamic> toJson() => _$PaystubYTDDetailsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaystubYTDDetails &&
            (identical(other.grossEarnings, grossEarnings) ||
                const DeepCollectionEquality()
                    .equals(other.grossEarnings, grossEarnings)) &&
            (identical(other.netEarnings, netEarnings) ||
                const DeepCollectionEquality()
                    .equals(other.netEarnings, netEarnings)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(grossEarnings) ^
      const DeepCollectionEquality().hash(netEarnings) ^
      runtimeType.hashCode;
}

extension $PaystubYTDDetailsExtension on PaystubYTDDetails {
  PaystubYTDDetails copyWith({double? grossEarnings, double? netEarnings}) {
    return PaystubYTDDetails(
        grossEarnings: grossEarnings ?? this.grossEarnings,
        netEarnings: netEarnings ?? this.netEarnings);
  }

  PaystubYTDDetails copyWithWrapped(
      {Wrapped<double?>? grossEarnings, Wrapped<double?>? netEarnings}) {
    return PaystubYTDDetails(
        grossEarnings:
            (grossEarnings != null ? grossEarnings.value : this.grossEarnings),
        netEarnings:
            (netEarnings != null ? netEarnings.value : this.netEarnings));
  }
}

@JsonSerializable(explicitToJson: true)
class IncomeVerificationDocumentsDownloadRequest {
  IncomeVerificationDocumentsDownloadRequest({
    this.clientId,
    this.secret,
    this.incomeVerificationId,
    this.accessToken,
    this.documentId,
  });

  factory IncomeVerificationDocumentsDownloadRequest.fromJson(
          Map<String, dynamic> json) =>
      _$IncomeVerificationDocumentsDownloadRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'income_verification_id')
  final String? incomeVerificationId;
  @JsonKey(name: 'access_token')
  final String? accessToken;
  @JsonKey(name: 'document_id')
  final String? documentId;
  static const fromJsonFactory =
      _$IncomeVerificationDocumentsDownloadRequestFromJson;
  static const toJsonFactory =
      _$IncomeVerificationDocumentsDownloadRequestToJson;
  Map<String, dynamic> toJson() =>
      _$IncomeVerificationDocumentsDownloadRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IncomeVerificationDocumentsDownloadRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.incomeVerificationId, incomeVerificationId) ||
                const DeepCollectionEquality().equals(
                    other.incomeVerificationId, incomeVerificationId)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)) &&
            (identical(other.documentId, documentId) ||
                const DeepCollectionEquality()
                    .equals(other.documentId, documentId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(incomeVerificationId) ^
      const DeepCollectionEquality().hash(accessToken) ^
      const DeepCollectionEquality().hash(documentId) ^
      runtimeType.hashCode;
}

extension $IncomeVerificationDocumentsDownloadRequestExtension
    on IncomeVerificationDocumentsDownloadRequest {
  IncomeVerificationDocumentsDownloadRequest copyWith(
      {String? clientId,
      String? secret,
      String? incomeVerificationId,
      String? accessToken,
      String? documentId}) {
    return IncomeVerificationDocumentsDownloadRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        incomeVerificationId: incomeVerificationId ?? this.incomeVerificationId,
        accessToken: accessToken ?? this.accessToken,
        documentId: documentId ?? this.documentId);
  }

  IncomeVerificationDocumentsDownloadRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String?>? incomeVerificationId,
      Wrapped<String?>? accessToken,
      Wrapped<String?>? documentId}) {
    return IncomeVerificationDocumentsDownloadRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        incomeVerificationId: (incomeVerificationId != null
            ? incomeVerificationId.value
            : this.incomeVerificationId),
        accessToken:
            (accessToken != null ? accessToken.value : this.accessToken),
        documentId: (documentId != null ? documentId.value : this.documentId));
  }
}

@JsonSerializable(explicitToJson: true)
class IncomeVerificationTaxformsGetRequest {
  IncomeVerificationTaxformsGetRequest({
    this.clientId,
    this.secret,
    this.incomeVerificationId,
    this.accessToken,
  });

  factory IncomeVerificationTaxformsGetRequest.fromJson(
          Map<String, dynamic> json) =>
      _$IncomeVerificationTaxformsGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'income_verification_id')
  final String? incomeVerificationId;
  @JsonKey(name: 'access_token')
  final String? accessToken;
  static const fromJsonFactory = _$IncomeVerificationTaxformsGetRequestFromJson;
  static const toJsonFactory = _$IncomeVerificationTaxformsGetRequestToJson;
  Map<String, dynamic> toJson() =>
      _$IncomeVerificationTaxformsGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IncomeVerificationTaxformsGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.incomeVerificationId, incomeVerificationId) ||
                const DeepCollectionEquality().equals(
                    other.incomeVerificationId, incomeVerificationId)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(incomeVerificationId) ^
      const DeepCollectionEquality().hash(accessToken) ^
      runtimeType.hashCode;
}

extension $IncomeVerificationTaxformsGetRequestExtension
    on IncomeVerificationTaxformsGetRequest {
  IncomeVerificationTaxformsGetRequest copyWith(
      {String? clientId,
      String? secret,
      String? incomeVerificationId,
      String? accessToken}) {
    return IncomeVerificationTaxformsGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        incomeVerificationId: incomeVerificationId ?? this.incomeVerificationId,
        accessToken: accessToken ?? this.accessToken);
  }

  IncomeVerificationTaxformsGetRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String?>? incomeVerificationId,
      Wrapped<String?>? accessToken}) {
    return IncomeVerificationTaxformsGetRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        incomeVerificationId: (incomeVerificationId != null
            ? incomeVerificationId.value
            : this.incomeVerificationId),
        accessToken:
            (accessToken != null ? accessToken.value : this.accessToken));
  }
}

@JsonSerializable(explicitToJson: true)
class IncomeVerificationTaxformsGetResponse {
  IncomeVerificationTaxformsGetResponse({
    this.requestId,
    required this.documentMetadata,
    required this.taxforms,
    this.error,
  });

  factory IncomeVerificationTaxformsGetResponse.fromJson(
          Map<String, dynamic> json) =>
      _$IncomeVerificationTaxformsGetResponseFromJson(json);

  @JsonKey(name: 'request_id')
  final String? requestId;
  @JsonKey(name: 'document_metadata', defaultValue: <DocumentMetadata>[])
  final List<DocumentMetadata> documentMetadata;
  @JsonKey(name: 'taxforms', defaultValue: <Taxform>[])
  final List<Taxform> taxforms;
  @JsonKey(name: 'error')
  final PlaidError? error;
  static const fromJsonFactory =
      _$IncomeVerificationTaxformsGetResponseFromJson;
  static const toJsonFactory = _$IncomeVerificationTaxformsGetResponseToJson;
  Map<String, dynamic> toJson() =>
      _$IncomeVerificationTaxformsGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IncomeVerificationTaxformsGetResponse &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)) &&
            (identical(other.documentMetadata, documentMetadata) ||
                const DeepCollectionEquality()
                    .equals(other.documentMetadata, documentMetadata)) &&
            (identical(other.taxforms, taxforms) ||
                const DeepCollectionEquality()
                    .equals(other.taxforms, taxforms)) &&
            (identical(other.error, error) ||
                const DeepCollectionEquality().equals(other.error, error)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(requestId) ^
      const DeepCollectionEquality().hash(documentMetadata) ^
      const DeepCollectionEquality().hash(taxforms) ^
      const DeepCollectionEquality().hash(error) ^
      runtimeType.hashCode;
}

extension $IncomeVerificationTaxformsGetResponseExtension
    on IncomeVerificationTaxformsGetResponse {
  IncomeVerificationTaxformsGetResponse copyWith(
      {String? requestId,
      List<DocumentMetadata>? documentMetadata,
      List<Taxform>? taxforms,
      PlaidError? error}) {
    return IncomeVerificationTaxformsGetResponse(
        requestId: requestId ?? this.requestId,
        documentMetadata: documentMetadata ?? this.documentMetadata,
        taxforms: taxforms ?? this.taxforms,
        error: error ?? this.error);
  }

  IncomeVerificationTaxformsGetResponse copyWithWrapped(
      {Wrapped<String?>? requestId,
      Wrapped<List<DocumentMetadata>>? documentMetadata,
      Wrapped<List<Taxform>>? taxforms,
      Wrapped<PlaidError?>? error}) {
    return IncomeVerificationTaxformsGetResponse(
        requestId: (requestId != null ? requestId.value : this.requestId),
        documentMetadata: (documentMetadata != null
            ? documentMetadata.value
            : this.documentMetadata),
        taxforms: (taxforms != null ? taxforms.value : this.taxforms),
        error: (error != null ? error.value : this.error));
  }
}

@JsonSerializable(explicitToJson: true)
class Taxform {
  Taxform({
    this.docId,
    required this.documentType,
    this.w2,
  });

  factory Taxform.fromJson(Map<String, dynamic> json) =>
      _$TaxformFromJson(json);

  @JsonKey(name: 'doc_id')
  final String? docId;
  @JsonKey(name: 'document_type')
  final String documentType;
  @JsonKey(name: 'w2')
  final W2? w2;
  static const fromJsonFactory = _$TaxformFromJson;
  static const toJsonFactory = _$TaxformToJson;
  Map<String, dynamic> toJson() => _$TaxformToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Taxform &&
            (identical(other.docId, docId) ||
                const DeepCollectionEquality().equals(other.docId, docId)) &&
            (identical(other.documentType, documentType) ||
                const DeepCollectionEquality()
                    .equals(other.documentType, documentType)) &&
            (identical(other.w2, w2) ||
                const DeepCollectionEquality().equals(other.w2, w2)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(docId) ^
      const DeepCollectionEquality().hash(documentType) ^
      const DeepCollectionEquality().hash(w2) ^
      runtimeType.hashCode;
}

extension $TaxformExtension on Taxform {
  Taxform copyWith({String? docId, String? documentType, W2? w2}) {
    return Taxform(
        docId: docId ?? this.docId,
        documentType: documentType ?? this.documentType,
        w2: w2 ?? this.w2);
  }

  Taxform copyWithWrapped(
      {Wrapped<String?>? docId,
      Wrapped<String>? documentType,
      Wrapped<W2?>? w2}) {
    return Taxform(
        docId: (docId != null ? docId.value : this.docId),
        documentType:
            (documentType != null ? documentType.value : this.documentType),
        w2: (w2 != null ? w2.value : this.w2));
  }
}

@JsonSerializable(explicitToJson: true)
class W2 {
  W2({
    this.employer,
    this.employee,
    this.taxYear,
    this.employerIdNumber,
    this.wagesTipsOtherComp,
    this.federalIncomeTaxWithheld,
    this.socialSecurityWages,
    this.socialSecurityTaxWithheld,
    this.medicareWagesAndTips,
    this.medicareTaxWithheld,
    this.socialSecurityTips,
    this.allocatedTips,
    this.box9,
    this.dependentCareBenefits,
    this.nonqualifiedPlans,
    this.box12,
    this.statutoryEmployee,
    this.retirementPlan,
    this.thirdPartySickPay,
    this.other,
    this.stateAndLocalWages,
  });

  factory W2.fromJson(Map<String, dynamic> json) => _$W2FromJson(json);

  @JsonKey(name: 'employer')
  final PaystubEmployer? employer;
  @JsonKey(name: 'employee')
  final Employee? employee;
  @JsonKey(name: 'tax_year')
  final String? taxYear;
  @JsonKey(name: 'employer_id_number')
  final String? employerIdNumber;
  @JsonKey(name: 'wages_tips_other_comp')
  final String? wagesTipsOtherComp;
  @JsonKey(name: 'federal_income_tax_withheld')
  final String? federalIncomeTaxWithheld;
  @JsonKey(name: 'social_security_wages')
  final String? socialSecurityWages;
  @JsonKey(name: 'social_security_tax_withheld')
  final String? socialSecurityTaxWithheld;
  @JsonKey(name: 'medicare_wages_and_tips')
  final String? medicareWagesAndTips;
  @JsonKey(name: 'medicare_tax_withheld')
  final String? medicareTaxWithheld;
  @JsonKey(name: 'social_security_tips')
  final String? socialSecurityTips;
  @JsonKey(name: 'allocated_tips')
  final String? allocatedTips;
  @JsonKey(name: 'box_9')
  final String? box9;
  @JsonKey(name: 'dependent_care_benefits')
  final String? dependentCareBenefits;
  @JsonKey(name: 'nonqualified_plans')
  final String? nonqualifiedPlans;
  @JsonKey(name: 'box_12', defaultValue: <W2Box12>[])
  final List<W2Box12>? box12;
  @JsonKey(name: 'statutory_employee')
  final String? statutoryEmployee;
  @JsonKey(name: 'retirement_plan')
  final String? retirementPlan;
  @JsonKey(name: 'third_party_sick_pay')
  final String? thirdPartySickPay;
  @JsonKey(name: 'other')
  final String? other;
  @JsonKey(
      name: 'state_and_local_wages', defaultValue: <W2StateAndLocalWages>[])
  final List<W2StateAndLocalWages>? stateAndLocalWages;
  static const fromJsonFactory = _$W2FromJson;
  static const toJsonFactory = _$W2ToJson;
  Map<String, dynamic> toJson() => _$W2ToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is W2 &&
            (identical(other.employer, employer) ||
                const DeepCollectionEquality()
                    .equals(other.employer, employer)) &&
            (identical(other.employee, employee) ||
                const DeepCollectionEquality()
                    .equals(other.employee, employee)) &&
            (identical(other.taxYear, taxYear) ||
                const DeepCollectionEquality()
                    .equals(other.taxYear, taxYear)) &&
            (identical(other.employerIdNumber, employerIdNumber) ||
                const DeepCollectionEquality()
                    .equals(other.employerIdNumber, employerIdNumber)) &&
            (identical(other.wagesTipsOtherComp, wagesTipsOtherComp) ||
                const DeepCollectionEquality()
                    .equals(other.wagesTipsOtherComp, wagesTipsOtherComp)) &&
            (identical(other.federalIncomeTaxWithheld, federalIncomeTaxWithheld) ||
                const DeepCollectionEquality().equals(
                    other.federalIncomeTaxWithheld,
                    federalIncomeTaxWithheld)) &&
            (identical(other.socialSecurityWages, socialSecurityWages) ||
                const DeepCollectionEquality()
                    .equals(other.socialSecurityWages, socialSecurityWages)) &&
            (identical(other.socialSecurityTaxWithheld, socialSecurityTaxWithheld) ||
                const DeepCollectionEquality().equals(
                    other.socialSecurityTaxWithheld,
                    socialSecurityTaxWithheld)) &&
            (identical(other.medicareWagesAndTips, medicareWagesAndTips) ||
                const DeepCollectionEquality().equals(
                    other.medicareWagesAndTips, medicareWagesAndTips)) &&
            (identical(other.medicareTaxWithheld, medicareTaxWithheld) ||
                const DeepCollectionEquality()
                    .equals(other.medicareTaxWithheld, medicareTaxWithheld)) &&
            (identical(other.socialSecurityTips, socialSecurityTips) ||
                const DeepCollectionEquality()
                    .equals(other.socialSecurityTips, socialSecurityTips)) &&
            (identical(other.allocatedTips, allocatedTips) ||
                const DeepCollectionEquality()
                    .equals(other.allocatedTips, allocatedTips)) &&
            (identical(other.box9, box9) ||
                const DeepCollectionEquality().equals(other.box9, box9)) &&
            (identical(other.dependentCareBenefits, dependentCareBenefits) ||
                const DeepCollectionEquality().equals(
                    other.dependentCareBenefits, dependentCareBenefits)) &&
            (identical(other.nonqualifiedPlans, nonqualifiedPlans) ||
                const DeepCollectionEquality()
                    .equals(other.nonqualifiedPlans, nonqualifiedPlans)) &&
            (identical(other.box12, box12) || const DeepCollectionEquality().equals(other.box12, box12)) &&
            (identical(other.statutoryEmployee, statutoryEmployee) || const DeepCollectionEquality().equals(other.statutoryEmployee, statutoryEmployee)) &&
            (identical(other.retirementPlan, retirementPlan) || const DeepCollectionEquality().equals(other.retirementPlan, retirementPlan)) &&
            (identical(other.thirdPartySickPay, thirdPartySickPay) || const DeepCollectionEquality().equals(other.thirdPartySickPay, thirdPartySickPay)) &&
            (identical(other.other, other) || const DeepCollectionEquality().equals(other.other, other)) &&
            (identical(other.stateAndLocalWages, stateAndLocalWages) || const DeepCollectionEquality().equals(other.stateAndLocalWages, stateAndLocalWages)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(employer) ^
      const DeepCollectionEquality().hash(employee) ^
      const DeepCollectionEquality().hash(taxYear) ^
      const DeepCollectionEquality().hash(employerIdNumber) ^
      const DeepCollectionEquality().hash(wagesTipsOtherComp) ^
      const DeepCollectionEquality().hash(federalIncomeTaxWithheld) ^
      const DeepCollectionEquality().hash(socialSecurityWages) ^
      const DeepCollectionEquality().hash(socialSecurityTaxWithheld) ^
      const DeepCollectionEquality().hash(medicareWagesAndTips) ^
      const DeepCollectionEquality().hash(medicareTaxWithheld) ^
      const DeepCollectionEquality().hash(socialSecurityTips) ^
      const DeepCollectionEquality().hash(allocatedTips) ^
      const DeepCollectionEquality().hash(box9) ^
      const DeepCollectionEquality().hash(dependentCareBenefits) ^
      const DeepCollectionEquality().hash(nonqualifiedPlans) ^
      const DeepCollectionEquality().hash(box12) ^
      const DeepCollectionEquality().hash(statutoryEmployee) ^
      const DeepCollectionEquality().hash(retirementPlan) ^
      const DeepCollectionEquality().hash(thirdPartySickPay) ^
      const DeepCollectionEquality().hash(other) ^
      const DeepCollectionEquality().hash(stateAndLocalWages) ^
      runtimeType.hashCode;
}

extension $W2Extension on W2 {
  W2 copyWith(
      {PaystubEmployer? employer,
      Employee? employee,
      String? taxYear,
      String? employerIdNumber,
      String? wagesTipsOtherComp,
      String? federalIncomeTaxWithheld,
      String? socialSecurityWages,
      String? socialSecurityTaxWithheld,
      String? medicareWagesAndTips,
      String? medicareTaxWithheld,
      String? socialSecurityTips,
      String? allocatedTips,
      String? box9,
      String? dependentCareBenefits,
      String? nonqualifiedPlans,
      List<W2Box12>? box12,
      String? statutoryEmployee,
      String? retirementPlan,
      String? thirdPartySickPay,
      String? other,
      List<W2StateAndLocalWages>? stateAndLocalWages}) {
    return W2(
        employer: employer ?? this.employer,
        employee: employee ?? this.employee,
        taxYear: taxYear ?? this.taxYear,
        employerIdNumber: employerIdNumber ?? this.employerIdNumber,
        wagesTipsOtherComp: wagesTipsOtherComp ?? this.wagesTipsOtherComp,
        federalIncomeTaxWithheld:
            federalIncomeTaxWithheld ?? this.federalIncomeTaxWithheld,
        socialSecurityWages: socialSecurityWages ?? this.socialSecurityWages,
        socialSecurityTaxWithheld:
            socialSecurityTaxWithheld ?? this.socialSecurityTaxWithheld,
        medicareWagesAndTips: medicareWagesAndTips ?? this.medicareWagesAndTips,
        medicareTaxWithheld: medicareTaxWithheld ?? this.medicareTaxWithheld,
        socialSecurityTips: socialSecurityTips ?? this.socialSecurityTips,
        allocatedTips: allocatedTips ?? this.allocatedTips,
        box9: box9 ?? this.box9,
        dependentCareBenefits:
            dependentCareBenefits ?? this.dependentCareBenefits,
        nonqualifiedPlans: nonqualifiedPlans ?? this.nonqualifiedPlans,
        box12: box12 ?? this.box12,
        statutoryEmployee: statutoryEmployee ?? this.statutoryEmployee,
        retirementPlan: retirementPlan ?? this.retirementPlan,
        thirdPartySickPay: thirdPartySickPay ?? this.thirdPartySickPay,
        other: other ?? this.other,
        stateAndLocalWages: stateAndLocalWages ?? this.stateAndLocalWages);
  }

  W2 copyWithWrapped(
      {Wrapped<PaystubEmployer?>? employer,
      Wrapped<Employee?>? employee,
      Wrapped<String?>? taxYear,
      Wrapped<String?>? employerIdNumber,
      Wrapped<String?>? wagesTipsOtherComp,
      Wrapped<String?>? federalIncomeTaxWithheld,
      Wrapped<String?>? socialSecurityWages,
      Wrapped<String?>? socialSecurityTaxWithheld,
      Wrapped<String?>? medicareWagesAndTips,
      Wrapped<String?>? medicareTaxWithheld,
      Wrapped<String?>? socialSecurityTips,
      Wrapped<String?>? allocatedTips,
      Wrapped<String?>? box9,
      Wrapped<String?>? dependentCareBenefits,
      Wrapped<String?>? nonqualifiedPlans,
      Wrapped<List<W2Box12>?>? box12,
      Wrapped<String?>? statutoryEmployee,
      Wrapped<String?>? retirementPlan,
      Wrapped<String?>? thirdPartySickPay,
      Wrapped<String?>? other,
      Wrapped<List<W2StateAndLocalWages>?>? stateAndLocalWages}) {
    return W2(
        employer: (employer != null ? employer.value : this.employer),
        employee: (employee != null ? employee.value : this.employee),
        taxYear: (taxYear != null ? taxYear.value : this.taxYear),
        employerIdNumber: (employerIdNumber != null
            ? employerIdNumber.value
            : this.employerIdNumber),
        wagesTipsOtherComp: (wagesTipsOtherComp != null
            ? wagesTipsOtherComp.value
            : this.wagesTipsOtherComp),
        federalIncomeTaxWithheld: (federalIncomeTaxWithheld != null
            ? federalIncomeTaxWithheld.value
            : this.federalIncomeTaxWithheld),
        socialSecurityWages: (socialSecurityWages != null
            ? socialSecurityWages.value
            : this.socialSecurityWages),
        socialSecurityTaxWithheld: (socialSecurityTaxWithheld != null
            ? socialSecurityTaxWithheld.value
            : this.socialSecurityTaxWithheld),
        medicareWagesAndTips: (medicareWagesAndTips != null
            ? medicareWagesAndTips.value
            : this.medicareWagesAndTips),
        medicareTaxWithheld: (medicareTaxWithheld != null
            ? medicareTaxWithheld.value
            : this.medicareTaxWithheld),
        socialSecurityTips: (socialSecurityTips != null
            ? socialSecurityTips.value
            : this.socialSecurityTips),
        allocatedTips:
            (allocatedTips != null ? allocatedTips.value : this.allocatedTips),
        box9: (box9 != null ? box9.value : this.box9),
        dependentCareBenefits: (dependentCareBenefits != null
            ? dependentCareBenefits.value
            : this.dependentCareBenefits),
        nonqualifiedPlans: (nonqualifiedPlans != null
            ? nonqualifiedPlans.value
            : this.nonqualifiedPlans),
        box12: (box12 != null ? box12.value : this.box12),
        statutoryEmployee: (statutoryEmployee != null
            ? statutoryEmployee.value
            : this.statutoryEmployee),
        retirementPlan: (retirementPlan != null
            ? retirementPlan.value
            : this.retirementPlan),
        thirdPartySickPay: (thirdPartySickPay != null
            ? thirdPartySickPay.value
            : this.thirdPartySickPay),
        other: (other != null ? other.value : this.other),
        stateAndLocalWages: (stateAndLocalWages != null
            ? stateAndLocalWages.value
            : this.stateAndLocalWages));
  }
}

@JsonSerializable(explicitToJson: true)
class W2Box12 {
  W2Box12({
    this.code,
    this.amount,
  });

  factory W2Box12.fromJson(Map<String, dynamic> json) =>
      _$W2Box12FromJson(json);

  @JsonKey(name: 'code')
  final String? code;
  @JsonKey(name: 'amount')
  final String? amount;
  static const fromJsonFactory = _$W2Box12FromJson;
  static const toJsonFactory = _$W2Box12ToJson;
  Map<String, dynamic> toJson() => _$W2Box12ToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is W2Box12 &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(amount) ^
      runtimeType.hashCode;
}

extension $W2Box12Extension on W2Box12 {
  W2Box12 copyWith({String? code, String? amount}) {
    return W2Box12(code: code ?? this.code, amount: amount ?? this.amount);
  }

  W2Box12 copyWithWrapped({Wrapped<String?>? code, Wrapped<String?>? amount}) {
    return W2Box12(
        code: (code != null ? code.value : this.code),
        amount: (amount != null ? amount.value : this.amount));
  }
}

@JsonSerializable(explicitToJson: true)
class W2StateAndLocalWages {
  W2StateAndLocalWages({
    this.state,
    this.employerStateIdNumber,
    this.stateWagesTips,
    this.stateIncomeTax,
    this.localWagesTips,
    this.localIncomeTax,
    this.localityName,
  });

  factory W2StateAndLocalWages.fromJson(Map<String, dynamic> json) =>
      _$W2StateAndLocalWagesFromJson(json);

  @JsonKey(name: 'state')
  final String? state;
  @JsonKey(name: 'employer_state_id_number')
  final String? employerStateIdNumber;
  @JsonKey(name: 'state_wages_tips')
  final String? stateWagesTips;
  @JsonKey(name: 'state_income_tax')
  final String? stateIncomeTax;
  @JsonKey(name: 'local_wages_tips')
  final String? localWagesTips;
  @JsonKey(name: 'local_income_tax')
  final String? localIncomeTax;
  @JsonKey(name: 'locality_name')
  final String? localityName;
  static const fromJsonFactory = _$W2StateAndLocalWagesFromJson;
  static const toJsonFactory = _$W2StateAndLocalWagesToJson;
  Map<String, dynamic> toJson() => _$W2StateAndLocalWagesToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is W2StateAndLocalWages &&
            (identical(other.state, state) ||
                const DeepCollectionEquality().equals(other.state, state)) &&
            (identical(other.employerStateIdNumber, employerStateIdNumber) ||
                const DeepCollectionEquality().equals(
                    other.employerStateIdNumber, employerStateIdNumber)) &&
            (identical(other.stateWagesTips, stateWagesTips) ||
                const DeepCollectionEquality()
                    .equals(other.stateWagesTips, stateWagesTips)) &&
            (identical(other.stateIncomeTax, stateIncomeTax) ||
                const DeepCollectionEquality()
                    .equals(other.stateIncomeTax, stateIncomeTax)) &&
            (identical(other.localWagesTips, localWagesTips) ||
                const DeepCollectionEquality()
                    .equals(other.localWagesTips, localWagesTips)) &&
            (identical(other.localIncomeTax, localIncomeTax) ||
                const DeepCollectionEquality()
                    .equals(other.localIncomeTax, localIncomeTax)) &&
            (identical(other.localityName, localityName) ||
                const DeepCollectionEquality()
                    .equals(other.localityName, localityName)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(state) ^
      const DeepCollectionEquality().hash(employerStateIdNumber) ^
      const DeepCollectionEquality().hash(stateWagesTips) ^
      const DeepCollectionEquality().hash(stateIncomeTax) ^
      const DeepCollectionEquality().hash(localWagesTips) ^
      const DeepCollectionEquality().hash(localIncomeTax) ^
      const DeepCollectionEquality().hash(localityName) ^
      runtimeType.hashCode;
}

extension $W2StateAndLocalWagesExtension on W2StateAndLocalWages {
  W2StateAndLocalWages copyWith(
      {String? state,
      String? employerStateIdNumber,
      String? stateWagesTips,
      String? stateIncomeTax,
      String? localWagesTips,
      String? localIncomeTax,
      String? localityName}) {
    return W2StateAndLocalWages(
        state: state ?? this.state,
        employerStateIdNumber:
            employerStateIdNumber ?? this.employerStateIdNumber,
        stateWagesTips: stateWagesTips ?? this.stateWagesTips,
        stateIncomeTax: stateIncomeTax ?? this.stateIncomeTax,
        localWagesTips: localWagesTips ?? this.localWagesTips,
        localIncomeTax: localIncomeTax ?? this.localIncomeTax,
        localityName: localityName ?? this.localityName);
  }

  W2StateAndLocalWages copyWithWrapped(
      {Wrapped<String?>? state,
      Wrapped<String?>? employerStateIdNumber,
      Wrapped<String?>? stateWagesTips,
      Wrapped<String?>? stateIncomeTax,
      Wrapped<String?>? localWagesTips,
      Wrapped<String?>? localIncomeTax,
      Wrapped<String?>? localityName}) {
    return W2StateAndLocalWages(
        state: (state != null ? state.value : this.state),
        employerStateIdNumber: (employerStateIdNumber != null
            ? employerStateIdNumber.value
            : this.employerStateIdNumber),
        stateWagesTips: (stateWagesTips != null
            ? stateWagesTips.value
            : this.stateWagesTips),
        stateIncomeTax: (stateIncomeTax != null
            ? stateIncomeTax.value
            : this.stateIncomeTax),
        localWagesTips: (localWagesTips != null
            ? localWagesTips.value
            : this.localWagesTips),
        localIncomeTax: (localIncomeTax != null
            ? localIncomeTax.value
            : this.localIncomeTax),
        localityName:
            (localityName != null ? localityName.value : this.localityName));
  }
}

@JsonSerializable(explicitToJson: true)
class IncomeVerificationWebhookStatus {
  IncomeVerificationWebhookStatus({
    required this.id,
  });

  factory IncomeVerificationWebhookStatus.fromJson(Map<String, dynamic> json) =>
      _$IncomeVerificationWebhookStatusFromJson(json);

  @JsonKey(name: 'id')
  final String id;
  static const fromJsonFactory = _$IncomeVerificationWebhookStatusFromJson;
  static const toJsonFactory = _$IncomeVerificationWebhookStatusToJson;
  Map<String, dynamic> toJson() =>
      _$IncomeVerificationWebhookStatusToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IncomeVerificationWebhookStatus &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^ runtimeType.hashCode;
}

extension $IncomeVerificationWebhookStatusExtension
    on IncomeVerificationWebhookStatus {
  IncomeVerificationWebhookStatus copyWith({String? id}) {
    return IncomeVerificationWebhookStatus(id: id ?? this.id);
  }

  IncomeVerificationWebhookStatus copyWithWrapped({Wrapped<String>? id}) {
    return IncomeVerificationWebhookStatus(
        id: (id != null ? id.value : this.id));
  }
}

@JsonSerializable(explicitToJson: true)
class EmploymentVerificationGetRequest {
  EmploymentVerificationGetRequest({
    this.clientId,
    this.secret,
    required this.accessToken,
  });

  factory EmploymentVerificationGetRequest.fromJson(
          Map<String, dynamic> json) =>
      _$EmploymentVerificationGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'access_token')
  final String accessToken;
  static const fromJsonFactory = _$EmploymentVerificationGetRequestFromJson;
  static const toJsonFactory = _$EmploymentVerificationGetRequestToJson;
  Map<String, dynamic> toJson() =>
      _$EmploymentVerificationGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is EmploymentVerificationGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(accessToken) ^
      runtimeType.hashCode;
}

extension $EmploymentVerificationGetRequestExtension
    on EmploymentVerificationGetRequest {
  EmploymentVerificationGetRequest copyWith(
      {String? clientId, String? secret, String? accessToken}) {
    return EmploymentVerificationGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        accessToken: accessToken ?? this.accessToken);
  }

  EmploymentVerificationGetRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? accessToken}) {
    return EmploymentVerificationGetRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        accessToken:
            (accessToken != null ? accessToken.value : this.accessToken));
  }
}

@JsonSerializable(explicitToJson: true)
class EmploymentVerificationGetResponse {
  EmploymentVerificationGetResponse({
    required this.employments,
    required this.requestId,
  });

  factory EmploymentVerificationGetResponse.fromJson(
          Map<String, dynamic> json) =>
      _$EmploymentVerificationGetResponseFromJson(json);

  @JsonKey(name: 'employments', defaultValue: <EmploymentVerification>[])
  final List<EmploymentVerification> employments;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$EmploymentVerificationGetResponseFromJson;
  static const toJsonFactory = _$EmploymentVerificationGetResponseToJson;
  Map<String, dynamic> toJson() =>
      _$EmploymentVerificationGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is EmploymentVerificationGetResponse &&
            (identical(other.employments, employments) ||
                const DeepCollectionEquality()
                    .equals(other.employments, employments)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(employments) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $EmploymentVerificationGetResponseExtension
    on EmploymentVerificationGetResponse {
  EmploymentVerificationGetResponse copyWith(
      {List<EmploymentVerification>? employments, String? requestId}) {
    return EmploymentVerificationGetResponse(
        employments: employments ?? this.employments,
        requestId: requestId ?? this.requestId);
  }

  EmploymentVerificationGetResponse copyWithWrapped(
      {Wrapped<List<EmploymentVerification>>? employments,
      Wrapped<String>? requestId}) {
    return EmploymentVerificationGetResponse(
        employments:
            (employments != null ? employments.value : this.employments),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class EmploymentVerification {
  EmploymentVerification({
    this.status,
    this.startDate,
    this.endDate,
    this.employer,
    this.title,
    this.platformIds,
  });

  factory EmploymentVerification.fromJson(Map<String, dynamic> json) =>
      _$EmploymentVerificationFromJson(json);

  @JsonKey(
    name: 'status',
    toJson: employmentVerificationStatusToJson,
    fromJson: employmentVerificationStatusFromJson,
  )
  final enums.EmploymentVerificationStatus? status;
  @JsonKey(name: 'start_date', toJson: _dateToJson)
  final DateTime? startDate;
  @JsonKey(name: 'end_date', toJson: _dateToJson)
  final DateTime? endDate;
  @JsonKey(name: 'employer')
  final EmployerVerification? employer;
  @JsonKey(name: 'title')
  final String? title;
  @JsonKey(name: 'platform_ids')
  final PlatformIds? platformIds;
  static const fromJsonFactory = _$EmploymentVerificationFromJson;
  static const toJsonFactory = _$EmploymentVerificationToJson;
  Map<String, dynamic> toJson() => _$EmploymentVerificationToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is EmploymentVerification &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.startDate, startDate) ||
                const DeepCollectionEquality()
                    .equals(other.startDate, startDate)) &&
            (identical(other.endDate, endDate) ||
                const DeepCollectionEquality()
                    .equals(other.endDate, endDate)) &&
            (identical(other.employer, employer) ||
                const DeepCollectionEquality()
                    .equals(other.employer, employer)) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.platformIds, platformIds) ||
                const DeepCollectionEquality()
                    .equals(other.platformIds, platformIds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(startDate) ^
      const DeepCollectionEquality().hash(endDate) ^
      const DeepCollectionEquality().hash(employer) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(platformIds) ^
      runtimeType.hashCode;
}

extension $EmploymentVerificationExtension on EmploymentVerification {
  EmploymentVerification copyWith(
      {enums.EmploymentVerificationStatus? status,
      DateTime? startDate,
      DateTime? endDate,
      EmployerVerification? employer,
      String? title,
      PlatformIds? platformIds}) {
    return EmploymentVerification(
        status: status ?? this.status,
        startDate: startDate ?? this.startDate,
        endDate: endDate ?? this.endDate,
        employer: employer ?? this.employer,
        title: title ?? this.title,
        platformIds: platformIds ?? this.platformIds);
  }

  EmploymentVerification copyWithWrapped(
      {Wrapped<enums.EmploymentVerificationStatus?>? status,
      Wrapped<DateTime?>? startDate,
      Wrapped<DateTime?>? endDate,
      Wrapped<EmployerVerification?>? employer,
      Wrapped<String?>? title,
      Wrapped<PlatformIds?>? platformIds}) {
    return EmploymentVerification(
        status: (status != null ? status.value : this.status),
        startDate: (startDate != null ? startDate.value : this.startDate),
        endDate: (endDate != null ? endDate.value : this.endDate),
        employer: (employer != null ? employer.value : this.employer),
        title: (title != null ? title.value : this.title),
        platformIds:
            (platformIds != null ? platformIds.value : this.platformIds));
  }
}

@JsonSerializable(explicitToJson: true)
class EmployerVerification {
  EmployerVerification({
    this.name,
  });

  factory EmployerVerification.fromJson(Map<String, dynamic> json) =>
      _$EmployerVerificationFromJson(json);

  @JsonKey(name: 'name')
  final String? name;
  static const fromJsonFactory = _$EmployerVerificationFromJson;
  static const toJsonFactory = _$EmployerVerificationToJson;
  Map<String, dynamic> toJson() => _$EmployerVerificationToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is EmployerVerification &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^ runtimeType.hashCode;
}

extension $EmployerVerificationExtension on EmployerVerification {
  EmployerVerification copyWith({String? name}) {
    return EmployerVerification(name: name ?? this.name);
  }

  EmployerVerification copyWithWrapped({Wrapped<String?>? name}) {
    return EmployerVerification(name: (name != null ? name.value : this.name));
  }
}

@JsonSerializable(explicitToJson: true)
class PlatformIds {
  PlatformIds({
    this.employeeId,
    this.payrollId,
    this.positionId,
  });

  factory PlatformIds.fromJson(Map<String, dynamic> json) =>
      _$PlatformIdsFromJson(json);

  @JsonKey(name: 'employee_id')
  final String? employeeId;
  @JsonKey(name: 'payroll_id')
  final String? payrollId;
  @JsonKey(name: 'position_id')
  final String? positionId;
  static const fromJsonFactory = _$PlatformIdsFromJson;
  static const toJsonFactory = _$PlatformIdsToJson;
  Map<String, dynamic> toJson() => _$PlatformIdsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PlatformIds &&
            (identical(other.employeeId, employeeId) ||
                const DeepCollectionEquality()
                    .equals(other.employeeId, employeeId)) &&
            (identical(other.payrollId, payrollId) ||
                const DeepCollectionEquality()
                    .equals(other.payrollId, payrollId)) &&
            (identical(other.positionId, positionId) ||
                const DeepCollectionEquality()
                    .equals(other.positionId, positionId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(employeeId) ^
      const DeepCollectionEquality().hash(payrollId) ^
      const DeepCollectionEquality().hash(positionId) ^
      runtimeType.hashCode;
}

extension $PlatformIdsExtension on PlatformIds {
  PlatformIds copyWith(
      {String? employeeId, String? payrollId, String? positionId}) {
    return PlatformIds(
        employeeId: employeeId ?? this.employeeId,
        payrollId: payrollId ?? this.payrollId,
        positionId: positionId ?? this.positionId);
  }

  PlatformIds copyWithWrapped(
      {Wrapped<String?>? employeeId,
      Wrapped<String?>? payrollId,
      Wrapped<String?>? positionId}) {
    return PlatformIds(
        employeeId: (employeeId != null ? employeeId.value : this.employeeId),
        payrollId: (payrollId != null ? payrollId.value : this.payrollId),
        positionId: (positionId != null ? positionId.value : this.positionId));
  }
}

@JsonSerializable(explicitToJson: true)
class HealthIncident {
  HealthIncident({
    required this.startDate,
    this.endDate,
    required this.title,
    required this.incidentUpdates,
  });

  factory HealthIncident.fromJson(Map<String, dynamic> json) =>
      _$HealthIncidentFromJson(json);

  @JsonKey(name: 'start_date')
  final DateTime startDate;
  @JsonKey(name: 'end_date')
  final DateTime? endDate;
  @JsonKey(name: 'title')
  final String title;
  @JsonKey(name: 'incident_updates', defaultValue: <IncidentUpdate>[])
  final List<IncidentUpdate> incidentUpdates;
  static const fromJsonFactory = _$HealthIncidentFromJson;
  static const toJsonFactory = _$HealthIncidentToJson;
  Map<String, dynamic> toJson() => _$HealthIncidentToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is HealthIncident &&
            (identical(other.startDate, startDate) ||
                const DeepCollectionEquality()
                    .equals(other.startDate, startDate)) &&
            (identical(other.endDate, endDate) ||
                const DeepCollectionEquality()
                    .equals(other.endDate, endDate)) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.incidentUpdates, incidentUpdates) ||
                const DeepCollectionEquality()
                    .equals(other.incidentUpdates, incidentUpdates)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(startDate) ^
      const DeepCollectionEquality().hash(endDate) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(incidentUpdates) ^
      runtimeType.hashCode;
}

extension $HealthIncidentExtension on HealthIncident {
  HealthIncident copyWith(
      {DateTime? startDate,
      DateTime? endDate,
      String? title,
      List<IncidentUpdate>? incidentUpdates}) {
    return HealthIncident(
        startDate: startDate ?? this.startDate,
        endDate: endDate ?? this.endDate,
        title: title ?? this.title,
        incidentUpdates: incidentUpdates ?? this.incidentUpdates);
  }

  HealthIncident copyWithWrapped(
      {Wrapped<DateTime>? startDate,
      Wrapped<DateTime?>? endDate,
      Wrapped<String>? title,
      Wrapped<List<IncidentUpdate>>? incidentUpdates}) {
    return HealthIncident(
        startDate: (startDate != null ? startDate.value : this.startDate),
        endDate: (endDate != null ? endDate.value : this.endDate),
        title: (title != null ? title.value : this.title),
        incidentUpdates: (incidentUpdates != null
            ? incidentUpdates.value
            : this.incidentUpdates));
  }
}

@JsonSerializable(explicitToJson: true)
class IncidentUpdate {
  IncidentUpdate({
    this.description,
    this.status,
    this.updatedDate,
  });

  factory IncidentUpdate.fromJson(Map<String, dynamic> json) =>
      _$IncidentUpdateFromJson(json);

  @JsonKey(name: 'description')
  final String? description;
  @JsonKey(
    name: 'status',
    toJson: incidentUpdateStatusToJson,
    fromJson: incidentUpdateStatusFromJson,
  )
  final enums.IncidentUpdateStatus? status;
  @JsonKey(name: 'updated_date')
  final DateTime? updatedDate;
  static const fromJsonFactory = _$IncidentUpdateFromJson;
  static const toJsonFactory = _$IncidentUpdateToJson;
  Map<String, dynamic> toJson() => _$IncidentUpdateToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IncidentUpdate &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.updatedDate, updatedDate) ||
                const DeepCollectionEquality()
                    .equals(other.updatedDate, updatedDate)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(updatedDate) ^
      runtimeType.hashCode;
}

extension $IncidentUpdateExtension on IncidentUpdate {
  IncidentUpdate copyWith(
      {String? description,
      enums.IncidentUpdateStatus? status,
      DateTime? updatedDate}) {
    return IncidentUpdate(
        description: description ?? this.description,
        status: status ?? this.status,
        updatedDate: updatedDate ?? this.updatedDate);
  }

  IncidentUpdate copyWithWrapped(
      {Wrapped<String?>? description,
      Wrapped<enums.IncidentUpdateStatus?>? status,
      Wrapped<DateTime?>? updatedDate}) {
    return IncidentUpdate(
        description:
            (description != null ? description.value : this.description),
        status: (status != null ? status.value : this.status),
        updatedDate:
            (updatedDate != null ? updatedDate.value : this.updatedDate));
  }
}

@JsonSerializable(explicitToJson: true)
class DepositSwitchAltCreateRequest {
  DepositSwitchAltCreateRequest({
    this.clientId,
    this.secret,
    required this.targetAccount,
    required this.targetUser,
    this.options,
    this.countryCode,
  });

  factory DepositSwitchAltCreateRequest.fromJson(Map<String, dynamic> json) =>
      _$DepositSwitchAltCreateRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'target_account')
  final DepositSwitchTargetAccount targetAccount;
  @JsonKey(name: 'target_user')
  final DepositSwitchTargetUser targetUser;
  @JsonKey(name: 'options')
  final DepositSwitchCreateRequestOptions? options;
  @JsonKey(
    name: 'country_code',
    toJson: depositSwitchAltCreateRequestCountryCodeToJson,
    fromJson: depositSwitchAltCreateRequestCountryCodeFromJson,
  )
  final enums.DepositSwitchAltCreateRequestCountryCode? countryCode;
  static const fromJsonFactory = _$DepositSwitchAltCreateRequestFromJson;
  static const toJsonFactory = _$DepositSwitchAltCreateRequestToJson;
  Map<String, dynamic> toJson() => _$DepositSwitchAltCreateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is DepositSwitchAltCreateRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.targetAccount, targetAccount) ||
                const DeepCollectionEquality()
                    .equals(other.targetAccount, targetAccount)) &&
            (identical(other.targetUser, targetUser) ||
                const DeepCollectionEquality()
                    .equals(other.targetUser, targetUser)) &&
            (identical(other.options, options) ||
                const DeepCollectionEquality()
                    .equals(other.options, options)) &&
            (identical(other.countryCode, countryCode) ||
                const DeepCollectionEquality()
                    .equals(other.countryCode, countryCode)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(targetAccount) ^
      const DeepCollectionEquality().hash(targetUser) ^
      const DeepCollectionEquality().hash(options) ^
      const DeepCollectionEquality().hash(countryCode) ^
      runtimeType.hashCode;
}

extension $DepositSwitchAltCreateRequestExtension
    on DepositSwitchAltCreateRequest {
  DepositSwitchAltCreateRequest copyWith(
      {String? clientId,
      String? secret,
      DepositSwitchTargetAccount? targetAccount,
      DepositSwitchTargetUser? targetUser,
      DepositSwitchCreateRequestOptions? options,
      enums.DepositSwitchAltCreateRequestCountryCode? countryCode}) {
    return DepositSwitchAltCreateRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        targetAccount: targetAccount ?? this.targetAccount,
        targetUser: targetUser ?? this.targetUser,
        options: options ?? this.options,
        countryCode: countryCode ?? this.countryCode);
  }

  DepositSwitchAltCreateRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<DepositSwitchTargetAccount>? targetAccount,
      Wrapped<DepositSwitchTargetUser>? targetUser,
      Wrapped<DepositSwitchCreateRequestOptions?>? options,
      Wrapped<enums.DepositSwitchAltCreateRequestCountryCode?>? countryCode}) {
    return DepositSwitchAltCreateRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        targetAccount:
            (targetAccount != null ? targetAccount.value : this.targetAccount),
        targetUser: (targetUser != null ? targetUser.value : this.targetUser),
        options: (options != null ? options.value : this.options),
        countryCode:
            (countryCode != null ? countryCode.value : this.countryCode));
  }
}

@JsonSerializable(explicitToJson: true)
class DepositSwitchAltCreateResponse {
  DepositSwitchAltCreateResponse({
    required this.depositSwitchId,
    required this.requestId,
  });

  factory DepositSwitchAltCreateResponse.fromJson(Map<String, dynamic> json) =>
      _$DepositSwitchAltCreateResponseFromJson(json);

  @JsonKey(name: 'deposit_switch_id')
  final String depositSwitchId;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$DepositSwitchAltCreateResponseFromJson;
  static const toJsonFactory = _$DepositSwitchAltCreateResponseToJson;
  Map<String, dynamic> toJson() => _$DepositSwitchAltCreateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is DepositSwitchAltCreateResponse &&
            (identical(other.depositSwitchId, depositSwitchId) ||
                const DeepCollectionEquality()
                    .equals(other.depositSwitchId, depositSwitchId)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(depositSwitchId) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $DepositSwitchAltCreateResponseExtension
    on DepositSwitchAltCreateResponse {
  DepositSwitchAltCreateResponse copyWith(
      {String? depositSwitchId, String? requestId}) {
    return DepositSwitchAltCreateResponse(
        depositSwitchId: depositSwitchId ?? this.depositSwitchId,
        requestId: requestId ?? this.requestId);
  }

  DepositSwitchAltCreateResponse copyWithWrapped(
      {Wrapped<String>? depositSwitchId, Wrapped<String>? requestId}) {
    return DepositSwitchAltCreateResponse(
        depositSwitchId: (depositSwitchId != null
            ? depositSwitchId.value
            : this.depositSwitchId),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class DepositSwitchTargetAccount {
  DepositSwitchTargetAccount({
    required this.accountNumber,
    required this.routingNumber,
    required this.accountName,
    required this.accountSubtype,
  });

  factory DepositSwitchTargetAccount.fromJson(Map<String, dynamic> json) =>
      _$DepositSwitchTargetAccountFromJson(json);

  @JsonKey(name: 'account_number')
  final String accountNumber;
  @JsonKey(name: 'routing_number')
  final String routingNumber;
  @JsonKey(name: 'account_name')
  final String accountName;
  @JsonKey(
    name: 'account_subtype',
    toJson: depositSwitchTargetAccountAccountSubtypeToJson,
    fromJson: depositSwitchTargetAccountAccountSubtypeFromJson,
  )
  final enums.DepositSwitchTargetAccountAccountSubtype accountSubtype;
  static const fromJsonFactory = _$DepositSwitchTargetAccountFromJson;
  static const toJsonFactory = _$DepositSwitchTargetAccountToJson;
  Map<String, dynamic> toJson() => _$DepositSwitchTargetAccountToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is DepositSwitchTargetAccount &&
            (identical(other.accountNumber, accountNumber) ||
                const DeepCollectionEquality()
                    .equals(other.accountNumber, accountNumber)) &&
            (identical(other.routingNumber, routingNumber) ||
                const DeepCollectionEquality()
                    .equals(other.routingNumber, routingNumber)) &&
            (identical(other.accountName, accountName) ||
                const DeepCollectionEquality()
                    .equals(other.accountName, accountName)) &&
            (identical(other.accountSubtype, accountSubtype) ||
                const DeepCollectionEquality()
                    .equals(other.accountSubtype, accountSubtype)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountNumber) ^
      const DeepCollectionEquality().hash(routingNumber) ^
      const DeepCollectionEquality().hash(accountName) ^
      const DeepCollectionEquality().hash(accountSubtype) ^
      runtimeType.hashCode;
}

extension $DepositSwitchTargetAccountExtension on DepositSwitchTargetAccount {
  DepositSwitchTargetAccount copyWith(
      {String? accountNumber,
      String? routingNumber,
      String? accountName,
      enums.DepositSwitchTargetAccountAccountSubtype? accountSubtype}) {
    return DepositSwitchTargetAccount(
        accountNumber: accountNumber ?? this.accountNumber,
        routingNumber: routingNumber ?? this.routingNumber,
        accountName: accountName ?? this.accountName,
        accountSubtype: accountSubtype ?? this.accountSubtype);
  }

  DepositSwitchTargetAccount copyWithWrapped(
      {Wrapped<String>? accountNumber,
      Wrapped<String>? routingNumber,
      Wrapped<String>? accountName,
      Wrapped<enums.DepositSwitchTargetAccountAccountSubtype>?
          accountSubtype}) {
    return DepositSwitchTargetAccount(
        accountNumber:
            (accountNumber != null ? accountNumber.value : this.accountNumber),
        routingNumber:
            (routingNumber != null ? routingNumber.value : this.routingNumber),
        accountName:
            (accountName != null ? accountName.value : this.accountName),
        accountSubtype: (accountSubtype != null
            ? accountSubtype.value
            : this.accountSubtype));
  }
}

@JsonSerializable(explicitToJson: true)
class DepositSwitchTargetUser {
  DepositSwitchTargetUser({
    required this.givenName,
    required this.familyName,
    required this.phone,
    required this.email,
    this.address,
    this.taxPayerId,
  });

  factory DepositSwitchTargetUser.fromJson(Map<String, dynamic> json) =>
      _$DepositSwitchTargetUserFromJson(json);

  @JsonKey(name: 'given_name')
  final String givenName;
  @JsonKey(name: 'family_name')
  final String familyName;
  @JsonKey(name: 'phone')
  final String phone;
  @JsonKey(name: 'email')
  final String email;
  @JsonKey(name: 'address')
  final DepositSwitchAddressData? address;
  @JsonKey(name: 'tax_payer_id')
  final String? taxPayerId;
  static const fromJsonFactory = _$DepositSwitchTargetUserFromJson;
  static const toJsonFactory = _$DepositSwitchTargetUserToJson;
  Map<String, dynamic> toJson() => _$DepositSwitchTargetUserToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is DepositSwitchTargetUser &&
            (identical(other.givenName, givenName) ||
                const DeepCollectionEquality()
                    .equals(other.givenName, givenName)) &&
            (identical(other.familyName, familyName) ||
                const DeepCollectionEquality()
                    .equals(other.familyName, familyName)) &&
            (identical(other.phone, phone) ||
                const DeepCollectionEquality().equals(other.phone, phone)) &&
            (identical(other.email, email) ||
                const DeepCollectionEquality().equals(other.email, email)) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality()
                    .equals(other.address, address)) &&
            (identical(other.taxPayerId, taxPayerId) ||
                const DeepCollectionEquality()
                    .equals(other.taxPayerId, taxPayerId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(givenName) ^
      const DeepCollectionEquality().hash(familyName) ^
      const DeepCollectionEquality().hash(phone) ^
      const DeepCollectionEquality().hash(email) ^
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(taxPayerId) ^
      runtimeType.hashCode;
}

extension $DepositSwitchTargetUserExtension on DepositSwitchTargetUser {
  DepositSwitchTargetUser copyWith(
      {String? givenName,
      String? familyName,
      String? phone,
      String? email,
      DepositSwitchAddressData? address,
      String? taxPayerId}) {
    return DepositSwitchTargetUser(
        givenName: givenName ?? this.givenName,
        familyName: familyName ?? this.familyName,
        phone: phone ?? this.phone,
        email: email ?? this.email,
        address: address ?? this.address,
        taxPayerId: taxPayerId ?? this.taxPayerId);
  }

  DepositSwitchTargetUser copyWithWrapped(
      {Wrapped<String>? givenName,
      Wrapped<String>? familyName,
      Wrapped<String>? phone,
      Wrapped<String>? email,
      Wrapped<DepositSwitchAddressData?>? address,
      Wrapped<String?>? taxPayerId}) {
    return DepositSwitchTargetUser(
        givenName: (givenName != null ? givenName.value : this.givenName),
        familyName: (familyName != null ? familyName.value : this.familyName),
        phone: (phone != null ? phone.value : this.phone),
        email: (email != null ? email.value : this.email),
        address: (address != null ? address.value : this.address),
        taxPayerId: (taxPayerId != null ? taxPayerId.value : this.taxPayerId));
  }
}

@JsonSerializable(explicitToJson: true)
class DepositSwitchAddressData {
  DepositSwitchAddressData({
    required this.city,
    required this.region,
    required this.street,
    required this.postalCode,
    required this.country,
  });

  factory DepositSwitchAddressData.fromJson(Map<String, dynamic> json) =>
      _$DepositSwitchAddressDataFromJson(json);

  @JsonKey(name: 'city')
  final String city;
  @JsonKey(name: 'region')
  final String region;
  @JsonKey(name: 'street')
  final String street;
  @JsonKey(name: 'postal_code')
  final String postalCode;
  @JsonKey(name: 'country')
  final String country;
  static const fromJsonFactory = _$DepositSwitchAddressDataFromJson;
  static const toJsonFactory = _$DepositSwitchAddressDataToJson;
  Map<String, dynamic> toJson() => _$DepositSwitchAddressDataToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is DepositSwitchAddressData &&
            (identical(other.city, city) ||
                const DeepCollectionEquality().equals(other.city, city)) &&
            (identical(other.region, region) ||
                const DeepCollectionEquality().equals(other.region, region)) &&
            (identical(other.street, street) ||
                const DeepCollectionEquality().equals(other.street, street)) &&
            (identical(other.postalCode, postalCode) ||
                const DeepCollectionEquality()
                    .equals(other.postalCode, postalCode)) &&
            (identical(other.country, country) ||
                const DeepCollectionEquality().equals(other.country, country)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(city) ^
      const DeepCollectionEquality().hash(region) ^
      const DeepCollectionEquality().hash(street) ^
      const DeepCollectionEquality().hash(postalCode) ^
      const DeepCollectionEquality().hash(country) ^
      runtimeType.hashCode;
}

extension $DepositSwitchAddressDataExtension on DepositSwitchAddressData {
  DepositSwitchAddressData copyWith(
      {String? city,
      String? region,
      String? street,
      String? postalCode,
      String? country}) {
    return DepositSwitchAddressData(
        city: city ?? this.city,
        region: region ?? this.region,
        street: street ?? this.street,
        postalCode: postalCode ?? this.postalCode,
        country: country ?? this.country);
  }

  DepositSwitchAddressData copyWithWrapped(
      {Wrapped<String>? city,
      Wrapped<String>? region,
      Wrapped<String>? street,
      Wrapped<String>? postalCode,
      Wrapped<String>? country}) {
    return DepositSwitchAddressData(
        city: (city != null ? city.value : this.city),
        region: (region != null ? region.value : this.region),
        street: (street != null ? street.value : this.street),
        postalCode: (postalCode != null ? postalCode.value : this.postalCode),
        country: (country != null ? country.value : this.country));
  }
}

@JsonSerializable(explicitToJson: true)
class CreditBankIncomeGetRequest {
  CreditBankIncomeGetRequest({
    this.clientId,
    this.secret,
    this.userToken,
    this.options,
  });

  factory CreditBankIncomeGetRequest.fromJson(Map<String, dynamic> json) =>
      _$CreditBankIncomeGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'user_token')
  final String? userToken;
  @JsonKey(name: 'options')
  final CreditBankIncomeGetRequestOptions? options;
  static const fromJsonFactory = _$CreditBankIncomeGetRequestFromJson;
  static const toJsonFactory = _$CreditBankIncomeGetRequestToJson;
  Map<String, dynamic> toJson() => _$CreditBankIncomeGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CreditBankIncomeGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.userToken, userToken) ||
                const DeepCollectionEquality()
                    .equals(other.userToken, userToken)) &&
            (identical(other.options, options) ||
                const DeepCollectionEquality().equals(other.options, options)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(userToken) ^
      const DeepCollectionEquality().hash(options) ^
      runtimeType.hashCode;
}

extension $CreditBankIncomeGetRequestExtension on CreditBankIncomeGetRequest {
  CreditBankIncomeGetRequest copyWith(
      {String? clientId,
      String? secret,
      String? userToken,
      CreditBankIncomeGetRequestOptions? options}) {
    return CreditBankIncomeGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        userToken: userToken ?? this.userToken,
        options: options ?? this.options);
  }

  CreditBankIncomeGetRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String?>? userToken,
      Wrapped<CreditBankIncomeGetRequestOptions?>? options}) {
    return CreditBankIncomeGetRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        userToken: (userToken != null ? userToken.value : this.userToken),
        options: (options != null ? options.value : this.options));
  }
}

@JsonSerializable(explicitToJson: true)
class CreditBankIncomeGetRequestOptions {
  CreditBankIncomeGetRequestOptions({
    this.count,
  });

  factory CreditBankIncomeGetRequestOptions.fromJson(
          Map<String, dynamic> json) =>
      _$CreditBankIncomeGetRequestOptionsFromJson(json);

  @JsonKey(name: 'count')
  final int? count;
  static const fromJsonFactory = _$CreditBankIncomeGetRequestOptionsFromJson;
  static const toJsonFactory = _$CreditBankIncomeGetRequestOptionsToJson;
  Map<String, dynamic> toJson() =>
      _$CreditBankIncomeGetRequestOptionsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CreditBankIncomeGetRequestOptions &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(count) ^ runtimeType.hashCode;
}

extension $CreditBankIncomeGetRequestOptionsExtension
    on CreditBankIncomeGetRequestOptions {
  CreditBankIncomeGetRequestOptions copyWith({int? count}) {
    return CreditBankIncomeGetRequestOptions(count: count ?? this.count);
  }

  CreditBankIncomeGetRequestOptions copyWithWrapped({Wrapped<int?>? count}) {
    return CreditBankIncomeGetRequestOptions(
        count: (count != null ? count.value : this.count));
  }
}

@JsonSerializable(explicitToJson: true)
class CreditBankIncomeGetResponse {
  CreditBankIncomeGetResponse({
    this.bankIncome,
    required this.requestId,
  });

  factory CreditBankIncomeGetResponse.fromJson(Map<String, dynamic> json) =>
      _$CreditBankIncomeGetResponseFromJson(json);

  @JsonKey(name: 'bank_income', defaultValue: <CreditBankIncome>[])
  final List<CreditBankIncome>? bankIncome;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$CreditBankIncomeGetResponseFromJson;
  static const toJsonFactory = _$CreditBankIncomeGetResponseToJson;
  Map<String, dynamic> toJson() => _$CreditBankIncomeGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CreditBankIncomeGetResponse &&
            (identical(other.bankIncome, bankIncome) ||
                const DeepCollectionEquality()
                    .equals(other.bankIncome, bankIncome)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(bankIncome) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $CreditBankIncomeGetResponseExtension on CreditBankIncomeGetResponse {
  CreditBankIncomeGetResponse copyWith(
      {List<CreditBankIncome>? bankIncome, String? requestId}) {
    return CreditBankIncomeGetResponse(
        bankIncome: bankIncome ?? this.bankIncome,
        requestId: requestId ?? this.requestId);
  }

  CreditBankIncomeGetResponse copyWithWrapped(
      {Wrapped<List<CreditBankIncome>?>? bankIncome,
      Wrapped<String>? requestId}) {
    return CreditBankIncomeGetResponse(
        bankIncome: (bankIncome != null ? bankIncome.value : this.bankIncome),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class CreditBankIncomePDFGetRequest {
  CreditBankIncomePDFGetRequest({
    this.clientId,
    this.secret,
    required this.userToken,
  });

  factory CreditBankIncomePDFGetRequest.fromJson(Map<String, dynamic> json) =>
      _$CreditBankIncomePDFGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'user_token')
  final String userToken;
  static const fromJsonFactory = _$CreditBankIncomePDFGetRequestFromJson;
  static const toJsonFactory = _$CreditBankIncomePDFGetRequestToJson;
  Map<String, dynamic> toJson() => _$CreditBankIncomePDFGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CreditBankIncomePDFGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.userToken, userToken) ||
                const DeepCollectionEquality()
                    .equals(other.userToken, userToken)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(userToken) ^
      runtimeType.hashCode;
}

extension $CreditBankIncomePDFGetRequestExtension
    on CreditBankIncomePDFGetRequest {
  CreditBankIncomePDFGetRequest copyWith(
      {String? clientId, String? secret, String? userToken}) {
    return CreditBankIncomePDFGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        userToken: userToken ?? this.userToken);
  }

  CreditBankIncomePDFGetRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? userToken}) {
    return CreditBankIncomePDFGetRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        userToken: (userToken != null ? userToken.value : this.userToken));
  }
}

@JsonSerializable(explicitToJson: true)
class CreditBankIncome {
  CreditBankIncome({
    this.bankIncomeId,
    this.generatedTime,
    this.daysRequested,
    this.items,
    this.bankIncomeSummary,
    this.warnings,
  });

  factory CreditBankIncome.fromJson(Map<String, dynamic> json) =>
      _$CreditBankIncomeFromJson(json);

  @JsonKey(name: 'bank_income_id')
  final String? bankIncomeId;
  @JsonKey(name: 'generated_time')
  final DateTime? generatedTime;
  @JsonKey(name: 'days_requested')
  final int? daysRequested;
  @JsonKey(name: 'items', defaultValue: <CreditBankIncomeItem>[])
  final List<CreditBankIncomeItem>? items;
  @JsonKey(name: 'bank_income_summary')
  final CreditBankIncomeSummary? bankIncomeSummary;
  @JsonKey(name: 'warnings', defaultValue: <CreditBankIncomeWarning>[])
  final List<CreditBankIncomeWarning>? warnings;
  static const fromJsonFactory = _$CreditBankIncomeFromJson;
  static const toJsonFactory = _$CreditBankIncomeToJson;
  Map<String, dynamic> toJson() => _$CreditBankIncomeToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CreditBankIncome &&
            (identical(other.bankIncomeId, bankIncomeId) ||
                const DeepCollectionEquality()
                    .equals(other.bankIncomeId, bankIncomeId)) &&
            (identical(other.generatedTime, generatedTime) ||
                const DeepCollectionEquality()
                    .equals(other.generatedTime, generatedTime)) &&
            (identical(other.daysRequested, daysRequested) ||
                const DeepCollectionEquality()
                    .equals(other.daysRequested, daysRequested)) &&
            (identical(other.items, items) ||
                const DeepCollectionEquality().equals(other.items, items)) &&
            (identical(other.bankIncomeSummary, bankIncomeSummary) ||
                const DeepCollectionEquality()
                    .equals(other.bankIncomeSummary, bankIncomeSummary)) &&
            (identical(other.warnings, warnings) ||
                const DeepCollectionEquality()
                    .equals(other.warnings, warnings)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(bankIncomeId) ^
      const DeepCollectionEquality().hash(generatedTime) ^
      const DeepCollectionEquality().hash(daysRequested) ^
      const DeepCollectionEquality().hash(items) ^
      const DeepCollectionEquality().hash(bankIncomeSummary) ^
      const DeepCollectionEquality().hash(warnings) ^
      runtimeType.hashCode;
}

extension $CreditBankIncomeExtension on CreditBankIncome {
  CreditBankIncome copyWith(
      {String? bankIncomeId,
      DateTime? generatedTime,
      int? daysRequested,
      List<CreditBankIncomeItem>? items,
      CreditBankIncomeSummary? bankIncomeSummary,
      List<CreditBankIncomeWarning>? warnings}) {
    return CreditBankIncome(
        bankIncomeId: bankIncomeId ?? this.bankIncomeId,
        generatedTime: generatedTime ?? this.generatedTime,
        daysRequested: daysRequested ?? this.daysRequested,
        items: items ?? this.items,
        bankIncomeSummary: bankIncomeSummary ?? this.bankIncomeSummary,
        warnings: warnings ?? this.warnings);
  }

  CreditBankIncome copyWithWrapped(
      {Wrapped<String?>? bankIncomeId,
      Wrapped<DateTime?>? generatedTime,
      Wrapped<int?>? daysRequested,
      Wrapped<List<CreditBankIncomeItem>?>? items,
      Wrapped<CreditBankIncomeSummary?>? bankIncomeSummary,
      Wrapped<List<CreditBankIncomeWarning>?>? warnings}) {
    return CreditBankIncome(
        bankIncomeId:
            (bankIncomeId != null ? bankIncomeId.value : this.bankIncomeId),
        generatedTime:
            (generatedTime != null ? generatedTime.value : this.generatedTime),
        daysRequested:
            (daysRequested != null ? daysRequested.value : this.daysRequested),
        items: (items != null ? items.value : this.items),
        bankIncomeSummary: (bankIncomeSummary != null
            ? bankIncomeSummary.value
            : this.bankIncomeSummary),
        warnings: (warnings != null ? warnings.value : this.warnings));
  }
}

@JsonSerializable(explicitToJson: true)
class CreditBankIncomeItem {
  CreditBankIncomeItem({
    this.bankIncomeAccounts,
    this.bankIncomeSources,
    this.lastUpdatedTime,
    this.institutionId,
    this.institutionName,
    this.itemId,
  });

  factory CreditBankIncomeItem.fromJson(Map<String, dynamic> json) =>
      _$CreditBankIncomeItemFromJson(json);

  @JsonKey(
      name: 'bank_income_accounts', defaultValue: <CreditBankIncomeAccount>[])
  final List<CreditBankIncomeAccount>? bankIncomeAccounts;
  @JsonKey(
      name: 'bank_income_sources', defaultValue: <CreditBankIncomeSource>[])
  final List<CreditBankIncomeSource>? bankIncomeSources;
  @JsonKey(name: 'last_updated_time')
  final DateTime? lastUpdatedTime;
  @JsonKey(name: 'institution_id')
  final String? institutionId;
  @JsonKey(name: 'institution_name')
  final String? institutionName;
  @JsonKey(name: 'item_id')
  final String? itemId;
  static const fromJsonFactory = _$CreditBankIncomeItemFromJson;
  static const toJsonFactory = _$CreditBankIncomeItemToJson;
  Map<String, dynamic> toJson() => _$CreditBankIncomeItemToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CreditBankIncomeItem &&
            (identical(other.bankIncomeAccounts, bankIncomeAccounts) ||
                const DeepCollectionEquality()
                    .equals(other.bankIncomeAccounts, bankIncomeAccounts)) &&
            (identical(other.bankIncomeSources, bankIncomeSources) ||
                const DeepCollectionEquality()
                    .equals(other.bankIncomeSources, bankIncomeSources)) &&
            (identical(other.lastUpdatedTime, lastUpdatedTime) ||
                const DeepCollectionEquality()
                    .equals(other.lastUpdatedTime, lastUpdatedTime)) &&
            (identical(other.institutionId, institutionId) ||
                const DeepCollectionEquality()
                    .equals(other.institutionId, institutionId)) &&
            (identical(other.institutionName, institutionName) ||
                const DeepCollectionEquality()
                    .equals(other.institutionName, institutionName)) &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(bankIncomeAccounts) ^
      const DeepCollectionEquality().hash(bankIncomeSources) ^
      const DeepCollectionEquality().hash(lastUpdatedTime) ^
      const DeepCollectionEquality().hash(institutionId) ^
      const DeepCollectionEquality().hash(institutionName) ^
      const DeepCollectionEquality().hash(itemId) ^
      runtimeType.hashCode;
}

extension $CreditBankIncomeItemExtension on CreditBankIncomeItem {
  CreditBankIncomeItem copyWith(
      {List<CreditBankIncomeAccount>? bankIncomeAccounts,
      List<CreditBankIncomeSource>? bankIncomeSources,
      DateTime? lastUpdatedTime,
      String? institutionId,
      String? institutionName,
      String? itemId}) {
    return CreditBankIncomeItem(
        bankIncomeAccounts: bankIncomeAccounts ?? this.bankIncomeAccounts,
        bankIncomeSources: bankIncomeSources ?? this.bankIncomeSources,
        lastUpdatedTime: lastUpdatedTime ?? this.lastUpdatedTime,
        institutionId: institutionId ?? this.institutionId,
        institutionName: institutionName ?? this.institutionName,
        itemId: itemId ?? this.itemId);
  }

  CreditBankIncomeItem copyWithWrapped(
      {Wrapped<List<CreditBankIncomeAccount>?>? bankIncomeAccounts,
      Wrapped<List<CreditBankIncomeSource>?>? bankIncomeSources,
      Wrapped<DateTime?>? lastUpdatedTime,
      Wrapped<String?>? institutionId,
      Wrapped<String?>? institutionName,
      Wrapped<String?>? itemId}) {
    return CreditBankIncomeItem(
        bankIncomeAccounts: (bankIncomeAccounts != null
            ? bankIncomeAccounts.value
            : this.bankIncomeAccounts),
        bankIncomeSources: (bankIncomeSources != null
            ? bankIncomeSources.value
            : this.bankIncomeSources),
        lastUpdatedTime: (lastUpdatedTime != null
            ? lastUpdatedTime.value
            : this.lastUpdatedTime),
        institutionId:
            (institutionId != null ? institutionId.value : this.institutionId),
        institutionName: (institutionName != null
            ? institutionName.value
            : this.institutionName),
        itemId: (itemId != null ? itemId.value : this.itemId));
  }
}

@JsonSerializable(explicitToJson: true)
class CreditBankIncomeAccount {
  CreditBankIncomeAccount({
    this.accountId,
    this.mask,
    this.name,
    this.officialName,
    this.subtype,
    this.type,
    this.owners,
  });

  factory CreditBankIncomeAccount.fromJson(Map<String, dynamic> json) =>
      _$CreditBankIncomeAccountFromJson(json);

  @JsonKey(name: 'account_id')
  final String? accountId;
  @JsonKey(name: 'mask')
  final String? mask;
  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'official_name')
  final String? officialName;
  @JsonKey(
    name: 'subtype',
    toJson: depositoryAccountSubtypeToJson,
    fromJson: depositoryAccountSubtypeFromJson,
  )
  final enums.DepositoryAccountSubtype? subtype;
  @JsonKey(
    name: 'type',
    toJson: creditBankIncomeAccountTypeToJson,
    fromJson: creditBankIncomeAccountTypeFromJson,
  )
  final enums.CreditBankIncomeAccountType? type;
  @JsonKey(name: 'owners', defaultValue: <Owner>[])
  final List<Owner>? owners;
  static const fromJsonFactory = _$CreditBankIncomeAccountFromJson;
  static const toJsonFactory = _$CreditBankIncomeAccountToJson;
  Map<String, dynamic> toJson() => _$CreditBankIncomeAccountToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CreditBankIncomeAccount &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.mask, mask) ||
                const DeepCollectionEquality().equals(other.mask, mask)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.officialName, officialName) ||
                const DeepCollectionEquality()
                    .equals(other.officialName, officialName)) &&
            (identical(other.subtype, subtype) ||
                const DeepCollectionEquality()
                    .equals(other.subtype, subtype)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.owners, owners) ||
                const DeepCollectionEquality().equals(other.owners, owners)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(mask) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(officialName) ^
      const DeepCollectionEquality().hash(subtype) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(owners) ^
      runtimeType.hashCode;
}

extension $CreditBankIncomeAccountExtension on CreditBankIncomeAccount {
  CreditBankIncomeAccount copyWith(
      {String? accountId,
      String? mask,
      String? name,
      String? officialName,
      enums.DepositoryAccountSubtype? subtype,
      enums.CreditBankIncomeAccountType? type,
      List<Owner>? owners}) {
    return CreditBankIncomeAccount(
        accountId: accountId ?? this.accountId,
        mask: mask ?? this.mask,
        name: name ?? this.name,
        officialName: officialName ?? this.officialName,
        subtype: subtype ?? this.subtype,
        type: type ?? this.type,
        owners: owners ?? this.owners);
  }

  CreditBankIncomeAccount copyWithWrapped(
      {Wrapped<String?>? accountId,
      Wrapped<String?>? mask,
      Wrapped<String?>? name,
      Wrapped<String?>? officialName,
      Wrapped<enums.DepositoryAccountSubtype?>? subtype,
      Wrapped<enums.CreditBankIncomeAccountType?>? type,
      Wrapped<List<Owner>?>? owners}) {
    return CreditBankIncomeAccount(
        accountId: (accountId != null ? accountId.value : this.accountId),
        mask: (mask != null ? mask.value : this.mask),
        name: (name != null ? name.value : this.name),
        officialName:
            (officialName != null ? officialName.value : this.officialName),
        subtype: (subtype != null ? subtype.value : this.subtype),
        type: (type != null ? type.value : this.type),
        owners: (owners != null ? owners.value : this.owners));
  }
}

@JsonSerializable(explicitToJson: true)
class CreditBankIncomeSource {
  CreditBankIncomeSource({
    this.incomeSourceId,
    this.incomeDescription,
    this.incomeCategory,
    this.accountId,
    this.startDate,
    this.endDate,
    this.payFrequency,
    this.totalAmount,
    this.transactionCount,
    this.historicalSummary,
  });

  factory CreditBankIncomeSource.fromJson(Map<String, dynamic> json) =>
      _$CreditBankIncomeSourceFromJson(json);

  @JsonKey(name: 'income_source_id')
  final String? incomeSourceId;
  @JsonKey(name: 'income_description')
  final String? incomeDescription;
  @JsonKey(
    name: 'income_category',
    toJson: creditBankIncomeCategoryToJson,
    fromJson: creditBankIncomeCategoryFromJson,
  )
  final enums.CreditBankIncomeCategory? incomeCategory;
  @JsonKey(name: 'account_id')
  final String? accountId;
  @JsonKey(name: 'start_date', toJson: _dateToJson)
  final DateTime? startDate;
  @JsonKey(name: 'end_date', toJson: _dateToJson)
  final DateTime? endDate;
  @JsonKey(
    name: 'pay_frequency',
    toJson: creditBankIncomePayFrequencyToJson,
    fromJson: creditBankIncomePayFrequencyFromJson,
  )
  final enums.CreditBankIncomePayFrequency? payFrequency;
  @JsonKey(name: 'total_amount')
  final double? totalAmount;
  @JsonKey(name: 'transaction_count')
  final int? transactionCount;
  @JsonKey(
      name: 'historical_summary',
      defaultValue: <CreditBankIncomeHistoricalSummary>[])
  final List<CreditBankIncomeHistoricalSummary>? historicalSummary;
  static const fromJsonFactory = _$CreditBankIncomeSourceFromJson;
  static const toJsonFactory = _$CreditBankIncomeSourceToJson;
  Map<String, dynamic> toJson() => _$CreditBankIncomeSourceToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CreditBankIncomeSource &&
            (identical(other.incomeSourceId, incomeSourceId) ||
                const DeepCollectionEquality()
                    .equals(other.incomeSourceId, incomeSourceId)) &&
            (identical(other.incomeDescription, incomeDescription) ||
                const DeepCollectionEquality()
                    .equals(other.incomeDescription, incomeDescription)) &&
            (identical(other.incomeCategory, incomeCategory) ||
                const DeepCollectionEquality()
                    .equals(other.incomeCategory, incomeCategory)) &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.startDate, startDate) ||
                const DeepCollectionEquality()
                    .equals(other.startDate, startDate)) &&
            (identical(other.endDate, endDate) ||
                const DeepCollectionEquality()
                    .equals(other.endDate, endDate)) &&
            (identical(other.payFrequency, payFrequency) ||
                const DeepCollectionEquality()
                    .equals(other.payFrequency, payFrequency)) &&
            (identical(other.totalAmount, totalAmount) ||
                const DeepCollectionEquality()
                    .equals(other.totalAmount, totalAmount)) &&
            (identical(other.transactionCount, transactionCount) ||
                const DeepCollectionEquality()
                    .equals(other.transactionCount, transactionCount)) &&
            (identical(other.historicalSummary, historicalSummary) ||
                const DeepCollectionEquality()
                    .equals(other.historicalSummary, historicalSummary)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(incomeSourceId) ^
      const DeepCollectionEquality().hash(incomeDescription) ^
      const DeepCollectionEquality().hash(incomeCategory) ^
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(startDate) ^
      const DeepCollectionEquality().hash(endDate) ^
      const DeepCollectionEquality().hash(payFrequency) ^
      const DeepCollectionEquality().hash(totalAmount) ^
      const DeepCollectionEquality().hash(transactionCount) ^
      const DeepCollectionEquality().hash(historicalSummary) ^
      runtimeType.hashCode;
}

extension $CreditBankIncomeSourceExtension on CreditBankIncomeSource {
  CreditBankIncomeSource copyWith(
      {String? incomeSourceId,
      String? incomeDescription,
      enums.CreditBankIncomeCategory? incomeCategory,
      String? accountId,
      DateTime? startDate,
      DateTime? endDate,
      enums.CreditBankIncomePayFrequency? payFrequency,
      double? totalAmount,
      int? transactionCount,
      List<CreditBankIncomeHistoricalSummary>? historicalSummary}) {
    return CreditBankIncomeSource(
        incomeSourceId: incomeSourceId ?? this.incomeSourceId,
        incomeDescription: incomeDescription ?? this.incomeDescription,
        incomeCategory: incomeCategory ?? this.incomeCategory,
        accountId: accountId ?? this.accountId,
        startDate: startDate ?? this.startDate,
        endDate: endDate ?? this.endDate,
        payFrequency: payFrequency ?? this.payFrequency,
        totalAmount: totalAmount ?? this.totalAmount,
        transactionCount: transactionCount ?? this.transactionCount,
        historicalSummary: historicalSummary ?? this.historicalSummary);
  }

  CreditBankIncomeSource copyWithWrapped(
      {Wrapped<String?>? incomeSourceId,
      Wrapped<String?>? incomeDescription,
      Wrapped<enums.CreditBankIncomeCategory?>? incomeCategory,
      Wrapped<String?>? accountId,
      Wrapped<DateTime?>? startDate,
      Wrapped<DateTime?>? endDate,
      Wrapped<enums.CreditBankIncomePayFrequency?>? payFrequency,
      Wrapped<double?>? totalAmount,
      Wrapped<int?>? transactionCount,
      Wrapped<List<CreditBankIncomeHistoricalSummary>?>? historicalSummary}) {
    return CreditBankIncomeSource(
        incomeSourceId: (incomeSourceId != null
            ? incomeSourceId.value
            : this.incomeSourceId),
        incomeDescription: (incomeDescription != null
            ? incomeDescription.value
            : this.incomeDescription),
        incomeCategory: (incomeCategory != null
            ? incomeCategory.value
            : this.incomeCategory),
        accountId: (accountId != null ? accountId.value : this.accountId),
        startDate: (startDate != null ? startDate.value : this.startDate),
        endDate: (endDate != null ? endDate.value : this.endDate),
        payFrequency:
            (payFrequency != null ? payFrequency.value : this.payFrequency),
        totalAmount:
            (totalAmount != null ? totalAmount.value : this.totalAmount),
        transactionCount: (transactionCount != null
            ? transactionCount.value
            : this.transactionCount),
        historicalSummary: (historicalSummary != null
            ? historicalSummary.value
            : this.historicalSummary));
  }
}

@JsonSerializable(explicitToJson: true)
class CreditBankIncomeSummary {
  CreditBankIncomeSummary({
    this.totalAmount,
    this.isoCurrencyCode,
    this.unofficialCurrencyCode,
    this.startDate,
    this.endDate,
    this.incomeSourcesCount,
    this.incomeCategoriesCount,
    this.incomeTransactionsCount,
    this.historicalSummary,
  });

  factory CreditBankIncomeSummary.fromJson(Map<String, dynamic> json) =>
      _$CreditBankIncomeSummaryFromJson(json);

  @JsonKey(name: 'total_amount')
  final double? totalAmount;
  @JsonKey(name: 'iso_currency_code')
  final String? isoCurrencyCode;
  @JsonKey(name: 'unofficial_currency_code')
  final String? unofficialCurrencyCode;
  @JsonKey(name: 'start_date', toJson: _dateToJson)
  final DateTime? startDate;
  @JsonKey(name: 'end_date', toJson: _dateToJson)
  final DateTime? endDate;
  @JsonKey(name: 'income_sources_count')
  final int? incomeSourcesCount;
  @JsonKey(name: 'income_categories_count')
  final int? incomeCategoriesCount;
  @JsonKey(name: 'income_transactions_count')
  final int? incomeTransactionsCount;
  @JsonKey(
      name: 'historical_summary',
      defaultValue: <CreditBankIncomeHistoricalSummary>[])
  final List<CreditBankIncomeHistoricalSummary>? historicalSummary;
  static const fromJsonFactory = _$CreditBankIncomeSummaryFromJson;
  static const toJsonFactory = _$CreditBankIncomeSummaryToJson;
  Map<String, dynamic> toJson() => _$CreditBankIncomeSummaryToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CreditBankIncomeSummary &&
            (identical(other.totalAmount, totalAmount) ||
                const DeepCollectionEquality()
                    .equals(other.totalAmount, totalAmount)) &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)) &&
            (identical(other.unofficialCurrencyCode, unofficialCurrencyCode) ||
                const DeepCollectionEquality().equals(
                    other.unofficialCurrencyCode, unofficialCurrencyCode)) &&
            (identical(other.startDate, startDate) ||
                const DeepCollectionEquality()
                    .equals(other.startDate, startDate)) &&
            (identical(other.endDate, endDate) ||
                const DeepCollectionEquality()
                    .equals(other.endDate, endDate)) &&
            (identical(other.incomeSourcesCount, incomeSourcesCount) ||
                const DeepCollectionEquality()
                    .equals(other.incomeSourcesCount, incomeSourcesCount)) &&
            (identical(other.incomeCategoriesCount, incomeCategoriesCount) ||
                const DeepCollectionEquality().equals(
                    other.incomeCategoriesCount, incomeCategoriesCount)) &&
            (identical(
                    other.incomeTransactionsCount, incomeTransactionsCount) ||
                const DeepCollectionEquality().equals(
                    other.incomeTransactionsCount, incomeTransactionsCount)) &&
            (identical(other.historicalSummary, historicalSummary) ||
                const DeepCollectionEquality()
                    .equals(other.historicalSummary, historicalSummary)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(totalAmount) ^
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      const DeepCollectionEquality().hash(unofficialCurrencyCode) ^
      const DeepCollectionEquality().hash(startDate) ^
      const DeepCollectionEquality().hash(endDate) ^
      const DeepCollectionEquality().hash(incomeSourcesCount) ^
      const DeepCollectionEquality().hash(incomeCategoriesCount) ^
      const DeepCollectionEquality().hash(incomeTransactionsCount) ^
      const DeepCollectionEquality().hash(historicalSummary) ^
      runtimeType.hashCode;
}

extension $CreditBankIncomeSummaryExtension on CreditBankIncomeSummary {
  CreditBankIncomeSummary copyWith(
      {double? totalAmount,
      String? isoCurrencyCode,
      String? unofficialCurrencyCode,
      DateTime? startDate,
      DateTime? endDate,
      int? incomeSourcesCount,
      int? incomeCategoriesCount,
      int? incomeTransactionsCount,
      List<CreditBankIncomeHistoricalSummary>? historicalSummary}) {
    return CreditBankIncomeSummary(
        totalAmount: totalAmount ?? this.totalAmount,
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode,
        unofficialCurrencyCode:
            unofficialCurrencyCode ?? this.unofficialCurrencyCode,
        startDate: startDate ?? this.startDate,
        endDate: endDate ?? this.endDate,
        incomeSourcesCount: incomeSourcesCount ?? this.incomeSourcesCount,
        incomeCategoriesCount:
            incomeCategoriesCount ?? this.incomeCategoriesCount,
        incomeTransactionsCount:
            incomeTransactionsCount ?? this.incomeTransactionsCount,
        historicalSummary: historicalSummary ?? this.historicalSummary);
  }

  CreditBankIncomeSummary copyWithWrapped(
      {Wrapped<double?>? totalAmount,
      Wrapped<String?>? isoCurrencyCode,
      Wrapped<String?>? unofficialCurrencyCode,
      Wrapped<DateTime?>? startDate,
      Wrapped<DateTime?>? endDate,
      Wrapped<int?>? incomeSourcesCount,
      Wrapped<int?>? incomeCategoriesCount,
      Wrapped<int?>? incomeTransactionsCount,
      Wrapped<List<CreditBankIncomeHistoricalSummary>?>? historicalSummary}) {
    return CreditBankIncomeSummary(
        totalAmount:
            (totalAmount != null ? totalAmount.value : this.totalAmount),
        isoCurrencyCode: (isoCurrencyCode != null
            ? isoCurrencyCode.value
            : this.isoCurrencyCode),
        unofficialCurrencyCode: (unofficialCurrencyCode != null
            ? unofficialCurrencyCode.value
            : this.unofficialCurrencyCode),
        startDate: (startDate != null ? startDate.value : this.startDate),
        endDate: (endDate != null ? endDate.value : this.endDate),
        incomeSourcesCount: (incomeSourcesCount != null
            ? incomeSourcesCount.value
            : this.incomeSourcesCount),
        incomeCategoriesCount: (incomeCategoriesCount != null
            ? incomeCategoriesCount.value
            : this.incomeCategoriesCount),
        incomeTransactionsCount: (incomeTransactionsCount != null
            ? incomeTransactionsCount.value
            : this.incomeTransactionsCount),
        historicalSummary: (historicalSummary != null
            ? historicalSummary.value
            : this.historicalSummary));
  }
}

@JsonSerializable(explicitToJson: true)
class CreditBankIncomeHistoricalSummary {
  CreditBankIncomeHistoricalSummary({
    this.totalAmount,
    this.isoCurrencyCode,
    this.unofficialCurrencyCode,
    this.startDate,
    this.endDate,
    this.transactions,
  });

  factory CreditBankIncomeHistoricalSummary.fromJson(
          Map<String, dynamic> json) =>
      _$CreditBankIncomeHistoricalSummaryFromJson(json);

  @JsonKey(name: 'total_amount')
  final double? totalAmount;
  @JsonKey(name: 'iso_currency_code')
  final String? isoCurrencyCode;
  @JsonKey(name: 'unofficial_currency_code')
  final String? unofficialCurrencyCode;
  @JsonKey(name: 'start_date', toJson: _dateToJson)
  final DateTime? startDate;
  @JsonKey(name: 'end_date', toJson: _dateToJson)
  final DateTime? endDate;
  @JsonKey(name: 'transactions', defaultValue: <CreditBankIncomeTransaction>[])
  final List<CreditBankIncomeTransaction>? transactions;
  static const fromJsonFactory = _$CreditBankIncomeHistoricalSummaryFromJson;
  static const toJsonFactory = _$CreditBankIncomeHistoricalSummaryToJson;
  Map<String, dynamic> toJson() =>
      _$CreditBankIncomeHistoricalSummaryToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CreditBankIncomeHistoricalSummary &&
            (identical(other.totalAmount, totalAmount) ||
                const DeepCollectionEquality()
                    .equals(other.totalAmount, totalAmount)) &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)) &&
            (identical(other.unofficialCurrencyCode, unofficialCurrencyCode) ||
                const DeepCollectionEquality().equals(
                    other.unofficialCurrencyCode, unofficialCurrencyCode)) &&
            (identical(other.startDate, startDate) ||
                const DeepCollectionEquality()
                    .equals(other.startDate, startDate)) &&
            (identical(other.endDate, endDate) ||
                const DeepCollectionEquality()
                    .equals(other.endDate, endDate)) &&
            (identical(other.transactions, transactions) ||
                const DeepCollectionEquality()
                    .equals(other.transactions, transactions)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(totalAmount) ^
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      const DeepCollectionEquality().hash(unofficialCurrencyCode) ^
      const DeepCollectionEquality().hash(startDate) ^
      const DeepCollectionEquality().hash(endDate) ^
      const DeepCollectionEquality().hash(transactions) ^
      runtimeType.hashCode;
}

extension $CreditBankIncomeHistoricalSummaryExtension
    on CreditBankIncomeHistoricalSummary {
  CreditBankIncomeHistoricalSummary copyWith(
      {double? totalAmount,
      String? isoCurrencyCode,
      String? unofficialCurrencyCode,
      DateTime? startDate,
      DateTime? endDate,
      List<CreditBankIncomeTransaction>? transactions}) {
    return CreditBankIncomeHistoricalSummary(
        totalAmount: totalAmount ?? this.totalAmount,
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode,
        unofficialCurrencyCode:
            unofficialCurrencyCode ?? this.unofficialCurrencyCode,
        startDate: startDate ?? this.startDate,
        endDate: endDate ?? this.endDate,
        transactions: transactions ?? this.transactions);
  }

  CreditBankIncomeHistoricalSummary copyWithWrapped(
      {Wrapped<double?>? totalAmount,
      Wrapped<String?>? isoCurrencyCode,
      Wrapped<String?>? unofficialCurrencyCode,
      Wrapped<DateTime?>? startDate,
      Wrapped<DateTime?>? endDate,
      Wrapped<List<CreditBankIncomeTransaction>?>? transactions}) {
    return CreditBankIncomeHistoricalSummary(
        totalAmount:
            (totalAmount != null ? totalAmount.value : this.totalAmount),
        isoCurrencyCode: (isoCurrencyCode != null
            ? isoCurrencyCode.value
            : this.isoCurrencyCode),
        unofficialCurrencyCode: (unofficialCurrencyCode != null
            ? unofficialCurrencyCode.value
            : this.unofficialCurrencyCode),
        startDate: (startDate != null ? startDate.value : this.startDate),
        endDate: (endDate != null ? endDate.value : this.endDate),
        transactions:
            (transactions != null ? transactions.value : this.transactions));
  }
}

@JsonSerializable(explicitToJson: true)
class CreditBankIncomeTransaction {
  CreditBankIncomeTransaction({
    this.amount,
    this.date,
    this.name,
    this.originalDescription,
    this.pending,
    this.transactionId,
    this.checkNumber,
    this.isoCurrencyCode,
    this.unofficialCurrencyCode,
  });

  factory CreditBankIncomeTransaction.fromJson(Map<String, dynamic> json) =>
      _$CreditBankIncomeTransactionFromJson(json);

  @JsonKey(name: 'amount')
  final double? amount;
  @JsonKey(name: 'date', toJson: _dateToJson)
  final DateTime? date;
  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'original_description')
  final String? originalDescription;
  @JsonKey(name: 'pending')
  final bool? pending;
  @JsonKey(name: 'transaction_id')
  final String? transactionId;
  @JsonKey(name: 'check_number')
  final String? checkNumber;
  @JsonKey(name: 'iso_currency_code')
  final String? isoCurrencyCode;
  @JsonKey(name: 'unofficial_currency_code')
  final String? unofficialCurrencyCode;
  static const fromJsonFactory = _$CreditBankIncomeTransactionFromJson;
  static const toJsonFactory = _$CreditBankIncomeTransactionToJson;
  Map<String, dynamic> toJson() => _$CreditBankIncomeTransactionToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CreditBankIncomeTransaction &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.date, date) ||
                const DeepCollectionEquality().equals(other.date, date)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.originalDescription, originalDescription) ||
                const DeepCollectionEquality()
                    .equals(other.originalDescription, originalDescription)) &&
            (identical(other.pending, pending) ||
                const DeepCollectionEquality()
                    .equals(other.pending, pending)) &&
            (identical(other.transactionId, transactionId) ||
                const DeepCollectionEquality()
                    .equals(other.transactionId, transactionId)) &&
            (identical(other.checkNumber, checkNumber) ||
                const DeepCollectionEquality()
                    .equals(other.checkNumber, checkNumber)) &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)) &&
            (identical(other.unofficialCurrencyCode, unofficialCurrencyCode) ||
                const DeepCollectionEquality().equals(
                    other.unofficialCurrencyCode, unofficialCurrencyCode)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(date) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(originalDescription) ^
      const DeepCollectionEquality().hash(pending) ^
      const DeepCollectionEquality().hash(transactionId) ^
      const DeepCollectionEquality().hash(checkNumber) ^
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      const DeepCollectionEquality().hash(unofficialCurrencyCode) ^
      runtimeType.hashCode;
}

extension $CreditBankIncomeTransactionExtension on CreditBankIncomeTransaction {
  CreditBankIncomeTransaction copyWith(
      {double? amount,
      DateTime? date,
      String? name,
      String? originalDescription,
      bool? pending,
      String? transactionId,
      String? checkNumber,
      String? isoCurrencyCode,
      String? unofficialCurrencyCode}) {
    return CreditBankIncomeTransaction(
        amount: amount ?? this.amount,
        date: date ?? this.date,
        name: name ?? this.name,
        originalDescription: originalDescription ?? this.originalDescription,
        pending: pending ?? this.pending,
        transactionId: transactionId ?? this.transactionId,
        checkNumber: checkNumber ?? this.checkNumber,
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode,
        unofficialCurrencyCode:
            unofficialCurrencyCode ?? this.unofficialCurrencyCode);
  }

  CreditBankIncomeTransaction copyWithWrapped(
      {Wrapped<double?>? amount,
      Wrapped<DateTime?>? date,
      Wrapped<String?>? name,
      Wrapped<String?>? originalDescription,
      Wrapped<bool?>? pending,
      Wrapped<String?>? transactionId,
      Wrapped<String?>? checkNumber,
      Wrapped<String?>? isoCurrencyCode,
      Wrapped<String?>? unofficialCurrencyCode}) {
    return CreditBankIncomeTransaction(
        amount: (amount != null ? amount.value : this.amount),
        date: (date != null ? date.value : this.date),
        name: (name != null ? name.value : this.name),
        originalDescription: (originalDescription != null
            ? originalDescription.value
            : this.originalDescription),
        pending: (pending != null ? pending.value : this.pending),
        transactionId:
            (transactionId != null ? transactionId.value : this.transactionId),
        checkNumber:
            (checkNumber != null ? checkNumber.value : this.checkNumber),
        isoCurrencyCode: (isoCurrencyCode != null
            ? isoCurrencyCode.value
            : this.isoCurrencyCode),
        unofficialCurrencyCode: (unofficialCurrencyCode != null
            ? unofficialCurrencyCode.value
            : this.unofficialCurrencyCode));
  }
}

@JsonSerializable(explicitToJson: true)
class CreditBankIncomeRefreshRequest {
  CreditBankIncomeRefreshRequest({
    this.clientId,
    this.secret,
    required this.userToken,
    this.options,
  });

  factory CreditBankIncomeRefreshRequest.fromJson(Map<String, dynamic> json) =>
      _$CreditBankIncomeRefreshRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'user_token')
  final String userToken;
  @JsonKey(name: 'options')
  final CreditBankIncomeRefreshRequestOptions? options;
  static const fromJsonFactory = _$CreditBankIncomeRefreshRequestFromJson;
  static const toJsonFactory = _$CreditBankIncomeRefreshRequestToJson;
  Map<String, dynamic> toJson() => _$CreditBankIncomeRefreshRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CreditBankIncomeRefreshRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.userToken, userToken) ||
                const DeepCollectionEquality()
                    .equals(other.userToken, userToken)) &&
            (identical(other.options, options) ||
                const DeepCollectionEquality().equals(other.options, options)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(userToken) ^
      const DeepCollectionEquality().hash(options) ^
      runtimeType.hashCode;
}

extension $CreditBankIncomeRefreshRequestExtension
    on CreditBankIncomeRefreshRequest {
  CreditBankIncomeRefreshRequest copyWith(
      {String? clientId,
      String? secret,
      String? userToken,
      CreditBankIncomeRefreshRequestOptions? options}) {
    return CreditBankIncomeRefreshRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        userToken: userToken ?? this.userToken,
        options: options ?? this.options);
  }

  CreditBankIncomeRefreshRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? userToken,
      Wrapped<CreditBankIncomeRefreshRequestOptions?>? options}) {
    return CreditBankIncomeRefreshRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        userToken: (userToken != null ? userToken.value : this.userToken),
        options: (options != null ? options.value : this.options));
  }
}

@JsonSerializable(explicitToJson: true)
class CreditBankIncomeRefreshRequestOptions {
  CreditBankIncomeRefreshRequestOptions({
    this.daysRequested,
    this.webhook,
  });

  factory CreditBankIncomeRefreshRequestOptions.fromJson(
          Map<String, dynamic> json) =>
      _$CreditBankIncomeRefreshRequestOptionsFromJson(json);

  @JsonKey(name: 'days_requested')
  final int? daysRequested;
  @JsonKey(name: 'webhook')
  final String? webhook;
  static const fromJsonFactory =
      _$CreditBankIncomeRefreshRequestOptionsFromJson;
  static const toJsonFactory = _$CreditBankIncomeRefreshRequestOptionsToJson;
  Map<String, dynamic> toJson() =>
      _$CreditBankIncomeRefreshRequestOptionsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CreditBankIncomeRefreshRequestOptions &&
            (identical(other.daysRequested, daysRequested) ||
                const DeepCollectionEquality()
                    .equals(other.daysRequested, daysRequested)) &&
            (identical(other.webhook, webhook) ||
                const DeepCollectionEquality().equals(other.webhook, webhook)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(daysRequested) ^
      const DeepCollectionEquality().hash(webhook) ^
      runtimeType.hashCode;
}

extension $CreditBankIncomeRefreshRequestOptionsExtension
    on CreditBankIncomeRefreshRequestOptions {
  CreditBankIncomeRefreshRequestOptions copyWith(
      {int? daysRequested, String? webhook}) {
    return CreditBankIncomeRefreshRequestOptions(
        daysRequested: daysRequested ?? this.daysRequested,
        webhook: webhook ?? this.webhook);
  }

  CreditBankIncomeRefreshRequestOptions copyWithWrapped(
      {Wrapped<int?>? daysRequested, Wrapped<String?>? webhook}) {
    return CreditBankIncomeRefreshRequestOptions(
        daysRequested:
            (daysRequested != null ? daysRequested.value : this.daysRequested),
        webhook: (webhook != null ? webhook.value : this.webhook));
  }
}

@JsonSerializable(explicitToJson: true)
class CreditBankIncomeRefreshResponse {
  CreditBankIncomeRefreshResponse({
    required this.requestId,
  });

  factory CreditBankIncomeRefreshResponse.fromJson(Map<String, dynamic> json) =>
      _$CreditBankIncomeRefreshResponseFromJson(json);

  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$CreditBankIncomeRefreshResponseFromJson;
  static const toJsonFactory = _$CreditBankIncomeRefreshResponseToJson;
  Map<String, dynamic> toJson() =>
      _$CreditBankIncomeRefreshResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CreditBankIncomeRefreshResponse &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(requestId) ^ runtimeType.hashCode;
}

extension $CreditBankIncomeRefreshResponseExtension
    on CreditBankIncomeRefreshResponse {
  CreditBankIncomeRefreshResponse copyWith({String? requestId}) {
    return CreditBankIncomeRefreshResponse(
        requestId: requestId ?? this.requestId);
  }

  CreditBankIncomeRefreshResponse copyWithWrapped(
      {Wrapped<String>? requestId}) {
    return CreditBankIncomeRefreshResponse(
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class CreditPayrollIncomeRiskSignalsGetRequest {
  CreditPayrollIncomeRiskSignalsGetRequest({
    this.clientId,
    this.secret,
    this.userToken,
  });

  factory CreditPayrollIncomeRiskSignalsGetRequest.fromJson(
          Map<String, dynamic> json) =>
      _$CreditPayrollIncomeRiskSignalsGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'user_token')
  final String? userToken;
  static const fromJsonFactory =
      _$CreditPayrollIncomeRiskSignalsGetRequestFromJson;
  static const toJsonFactory = _$CreditPayrollIncomeRiskSignalsGetRequestToJson;
  Map<String, dynamic> toJson() =>
      _$CreditPayrollIncomeRiskSignalsGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CreditPayrollIncomeRiskSignalsGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.userToken, userToken) ||
                const DeepCollectionEquality()
                    .equals(other.userToken, userToken)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(userToken) ^
      runtimeType.hashCode;
}

extension $CreditPayrollIncomeRiskSignalsGetRequestExtension
    on CreditPayrollIncomeRiskSignalsGetRequest {
  CreditPayrollIncomeRiskSignalsGetRequest copyWith(
      {String? clientId, String? secret, String? userToken}) {
    return CreditPayrollIncomeRiskSignalsGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        userToken: userToken ?? this.userToken);
  }

  CreditPayrollIncomeRiskSignalsGetRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String?>? userToken}) {
    return CreditPayrollIncomeRiskSignalsGetRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        userToken: (userToken != null ? userToken.value : this.userToken));
  }
}

@JsonSerializable(explicitToJson: true)
class CreditPayrollIncomeRiskSignalsGetResponse {
  CreditPayrollIncomeRiskSignalsGetResponse({
    required this.items,
    this.error,
    required this.requestId,
  });

  factory CreditPayrollIncomeRiskSignalsGetResponse.fromJson(
          Map<String, dynamic> json) =>
      _$CreditPayrollIncomeRiskSignalsGetResponseFromJson(json);

  @JsonKey(name: 'items', defaultValue: <PayrollRiskSignalsItem>[])
  final List<PayrollRiskSignalsItem> items;
  @JsonKey(name: 'error')
  final PlaidError? error;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory =
      _$CreditPayrollIncomeRiskSignalsGetResponseFromJson;
  static const toJsonFactory =
      _$CreditPayrollIncomeRiskSignalsGetResponseToJson;
  Map<String, dynamic> toJson() =>
      _$CreditPayrollIncomeRiskSignalsGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CreditPayrollIncomeRiskSignalsGetResponse &&
            (identical(other.items, items) ||
                const DeepCollectionEquality().equals(other.items, items)) &&
            (identical(other.error, error) ||
                const DeepCollectionEquality().equals(other.error, error)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(items) ^
      const DeepCollectionEquality().hash(error) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $CreditPayrollIncomeRiskSignalsGetResponseExtension
    on CreditPayrollIncomeRiskSignalsGetResponse {
  CreditPayrollIncomeRiskSignalsGetResponse copyWith(
      {List<PayrollRiskSignalsItem>? items,
      PlaidError? error,
      String? requestId}) {
    return CreditPayrollIncomeRiskSignalsGetResponse(
        items: items ?? this.items,
        error: error ?? this.error,
        requestId: requestId ?? this.requestId);
  }

  CreditPayrollIncomeRiskSignalsGetResponse copyWithWrapped(
      {Wrapped<List<PayrollRiskSignalsItem>>? items,
      Wrapped<PlaidError?>? error,
      Wrapped<String>? requestId}) {
    return CreditPayrollIncomeRiskSignalsGetResponse(
        items: (items != null ? items.value : this.items),
        error: (error != null ? error.value : this.error),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class PayrollRiskSignalsItem {
  PayrollRiskSignalsItem({
    required this.itemId,
    required this.verificationRiskSignals,
  });

  factory PayrollRiskSignalsItem.fromJson(Map<String, dynamic> json) =>
      _$PayrollRiskSignalsItemFromJson(json);

  @JsonKey(name: 'item_id')
  final String itemId;
  @JsonKey(
      name: 'verification_risk_signals',
      defaultValue: <DocumentRiskSignalsObject>[])
  final List<DocumentRiskSignalsObject> verificationRiskSignals;
  static const fromJsonFactory = _$PayrollRiskSignalsItemFromJson;
  static const toJsonFactory = _$PayrollRiskSignalsItemToJson;
  Map<String, dynamic> toJson() => _$PayrollRiskSignalsItemToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PayrollRiskSignalsItem &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)) &&
            (identical(
                    other.verificationRiskSignals, verificationRiskSignals) ||
                const DeepCollectionEquality().equals(
                    other.verificationRiskSignals, verificationRiskSignals)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(itemId) ^
      const DeepCollectionEquality().hash(verificationRiskSignals) ^
      runtimeType.hashCode;
}

extension $PayrollRiskSignalsItemExtension on PayrollRiskSignalsItem {
  PayrollRiskSignalsItem copyWith(
      {String? itemId,
      List<DocumentRiskSignalsObject>? verificationRiskSignals}) {
    return PayrollRiskSignalsItem(
        itemId: itemId ?? this.itemId,
        verificationRiskSignals:
            verificationRiskSignals ?? this.verificationRiskSignals);
  }

  PayrollRiskSignalsItem copyWithWrapped(
      {Wrapped<String>? itemId,
      Wrapped<List<DocumentRiskSignalsObject>>? verificationRiskSignals}) {
    return PayrollRiskSignalsItem(
        itemId: (itemId != null ? itemId.value : this.itemId),
        verificationRiskSignals: (verificationRiskSignals != null
            ? verificationRiskSignals.value
            : this.verificationRiskSignals));
  }
}

@JsonSerializable(explicitToJson: true)
class DocumentRiskSignalsObject {
  DocumentRiskSignalsObject({
    required this.accountId,
    required this.singleDocumentRiskSignals,
    required this.multiDocumentRiskSignals,
  });

  factory DocumentRiskSignalsObject.fromJson(Map<String, dynamic> json) =>
      _$DocumentRiskSignalsObjectFromJson(json);

  @JsonKey(name: 'account_id')
  final String? accountId;
  @JsonKey(
      name: 'single_document_risk_signals',
      defaultValue: <SingleDocumentRiskSignal>[])
  final List<SingleDocumentRiskSignal> singleDocumentRiskSignals;
  @JsonKey(
      name: 'multi_document_risk_signals',
      defaultValue: <MultiDocumentRiskSignal>[])
  final List<MultiDocumentRiskSignal> multiDocumentRiskSignals;
  static const fromJsonFactory = _$DocumentRiskSignalsObjectFromJson;
  static const toJsonFactory = _$DocumentRiskSignalsObjectToJson;
  Map<String, dynamic> toJson() => _$DocumentRiskSignalsObjectToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is DocumentRiskSignalsObject &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.singleDocumentRiskSignals,
                    singleDocumentRiskSignals) ||
                const DeepCollectionEquality().equals(
                    other.singleDocumentRiskSignals,
                    singleDocumentRiskSignals)) &&
            (identical(
                    other.multiDocumentRiskSignals, multiDocumentRiskSignals) ||
                const DeepCollectionEquality().equals(
                    other.multiDocumentRiskSignals, multiDocumentRiskSignals)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(singleDocumentRiskSignals) ^
      const DeepCollectionEquality().hash(multiDocumentRiskSignals) ^
      runtimeType.hashCode;
}

extension $DocumentRiskSignalsObjectExtension on DocumentRiskSignalsObject {
  DocumentRiskSignalsObject copyWith(
      {String? accountId,
      List<SingleDocumentRiskSignal>? singleDocumentRiskSignals,
      List<MultiDocumentRiskSignal>? multiDocumentRiskSignals}) {
    return DocumentRiskSignalsObject(
        accountId: accountId ?? this.accountId,
        singleDocumentRiskSignals:
            singleDocumentRiskSignals ?? this.singleDocumentRiskSignals,
        multiDocumentRiskSignals:
            multiDocumentRiskSignals ?? this.multiDocumentRiskSignals);
  }

  DocumentRiskSignalsObject copyWithWrapped(
      {Wrapped<String?>? accountId,
      Wrapped<List<SingleDocumentRiskSignal>>? singleDocumentRiskSignals,
      Wrapped<List<MultiDocumentRiskSignal>>? multiDocumentRiskSignals}) {
    return DocumentRiskSignalsObject(
        accountId: (accountId != null ? accountId.value : this.accountId),
        singleDocumentRiskSignals: (singleDocumentRiskSignals != null
            ? singleDocumentRiskSignals.value
            : this.singleDocumentRiskSignals),
        multiDocumentRiskSignals: (multiDocumentRiskSignals != null
            ? multiDocumentRiskSignals.value
            : this.multiDocumentRiskSignals));
  }
}

@JsonSerializable(explicitToJson: true)
class RiskSignalDocumentReference {
  RiskSignalDocumentReference({
    this.documentId,
    this.documentName,
  });

  factory RiskSignalDocumentReference.fromJson(Map<String, dynamic> json) =>
      _$RiskSignalDocumentReferenceFromJson(json);

  @JsonKey(name: 'document_id')
  final String? documentId;
  @JsonKey(name: 'document_name')
  final String? documentName;
  static const fromJsonFactory = _$RiskSignalDocumentReferenceFromJson;
  static const toJsonFactory = _$RiskSignalDocumentReferenceToJson;
  Map<String, dynamic> toJson() => _$RiskSignalDocumentReferenceToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is RiskSignalDocumentReference &&
            (identical(other.documentId, documentId) ||
                const DeepCollectionEquality()
                    .equals(other.documentId, documentId)) &&
            (identical(other.documentName, documentName) ||
                const DeepCollectionEquality()
                    .equals(other.documentName, documentName)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(documentId) ^
      const DeepCollectionEquality().hash(documentName) ^
      runtimeType.hashCode;
}

extension $RiskSignalDocumentReferenceExtension on RiskSignalDocumentReference {
  RiskSignalDocumentReference copyWith(
      {String? documentId, String? documentName}) {
    return RiskSignalDocumentReference(
        documentId: documentId ?? this.documentId,
        documentName: documentName ?? this.documentName);
  }

  RiskSignalDocumentReference copyWithWrapped(
      {Wrapped<String?>? documentId, Wrapped<String?>? documentName}) {
    return RiskSignalDocumentReference(
        documentId: (documentId != null ? documentId.value : this.documentId),
        documentName:
            (documentName != null ? documentName.value : this.documentName));
  }
}

@JsonSerializable(explicitToJson: true)
class DocumentRiskSummary {
  DocumentRiskSummary({
    required this.riskScore,
  });

  factory DocumentRiskSummary.fromJson(Map<String, dynamic> json) =>
      _$DocumentRiskSummaryFromJson(json);

  @JsonKey(name: 'risk_score')
  final double? riskScore;
  static const fromJsonFactory = _$DocumentRiskSummaryFromJson;
  static const toJsonFactory = _$DocumentRiskSummaryToJson;
  Map<String, dynamic> toJson() => _$DocumentRiskSummaryToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is DocumentRiskSummary &&
            (identical(other.riskScore, riskScore) ||
                const DeepCollectionEquality()
                    .equals(other.riskScore, riskScore)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(riskScore) ^ runtimeType.hashCode;
}

extension $DocumentRiskSummaryExtension on DocumentRiskSummary {
  DocumentRiskSummary copyWith({double? riskScore}) {
    return DocumentRiskSummary(riskScore: riskScore ?? this.riskScore);
  }

  DocumentRiskSummary copyWithWrapped({Wrapped<double?>? riskScore}) {
    return DocumentRiskSummary(
        riskScore: (riskScore != null ? riskScore.value : this.riskScore));
  }
}

@JsonSerializable(explicitToJson: true)
class SingleDocumentRiskSignal {
  SingleDocumentRiskSignal({
    required this.documentReference,
    required this.riskSignals,
    required this.riskSummary,
  });

  factory SingleDocumentRiskSignal.fromJson(Map<String, dynamic> json) =>
      _$SingleDocumentRiskSignalFromJson(json);

  @JsonKey(name: 'document_reference')
  final RiskSignalDocumentReference documentReference;
  @JsonKey(name: 'risk_signals', defaultValue: <DocumentRiskSignal>[])
  final List<DocumentRiskSignal> riskSignals;
  @JsonKey(name: 'risk_summary')
  final DocumentRiskSummary riskSummary;
  static const fromJsonFactory = _$SingleDocumentRiskSignalFromJson;
  static const toJsonFactory = _$SingleDocumentRiskSignalToJson;
  Map<String, dynamic> toJson() => _$SingleDocumentRiskSignalToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SingleDocumentRiskSignal &&
            (identical(other.documentReference, documentReference) ||
                const DeepCollectionEquality()
                    .equals(other.documentReference, documentReference)) &&
            (identical(other.riskSignals, riskSignals) ||
                const DeepCollectionEquality()
                    .equals(other.riskSignals, riskSignals)) &&
            (identical(other.riskSummary, riskSummary) ||
                const DeepCollectionEquality()
                    .equals(other.riskSummary, riskSummary)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(documentReference) ^
      const DeepCollectionEquality().hash(riskSignals) ^
      const DeepCollectionEquality().hash(riskSummary) ^
      runtimeType.hashCode;
}

extension $SingleDocumentRiskSignalExtension on SingleDocumentRiskSignal {
  SingleDocumentRiskSignal copyWith(
      {RiskSignalDocumentReference? documentReference,
      List<DocumentRiskSignal>? riskSignals,
      DocumentRiskSummary? riskSummary}) {
    return SingleDocumentRiskSignal(
        documentReference: documentReference ?? this.documentReference,
        riskSignals: riskSignals ?? this.riskSignals,
        riskSummary: riskSummary ?? this.riskSummary);
  }

  SingleDocumentRiskSignal copyWithWrapped(
      {Wrapped<RiskSignalDocumentReference>? documentReference,
      Wrapped<List<DocumentRiskSignal>>? riskSignals,
      Wrapped<DocumentRiskSummary>? riskSummary}) {
    return SingleDocumentRiskSignal(
        documentReference: (documentReference != null
            ? documentReference.value
            : this.documentReference),
        riskSignals:
            (riskSignals != null ? riskSignals.value : this.riskSignals),
        riskSummary:
            (riskSummary != null ? riskSummary.value : this.riskSummary));
  }
}

@JsonSerializable(explicitToJson: true)
class MultiDocumentRiskSignal {
  MultiDocumentRiskSignal({
    required this.documentReferences,
    required this.riskSignals,
  });

  factory MultiDocumentRiskSignal.fromJson(Map<String, dynamic> json) =>
      _$MultiDocumentRiskSignalFromJson(json);

  @JsonKey(
      name: 'document_references',
      defaultValue: <RiskSignalDocumentReference>[])
  final List<RiskSignalDocumentReference> documentReferences;
  @JsonKey(name: 'risk_signals', defaultValue: <DocumentRiskSignal>[])
  final List<DocumentRiskSignal> riskSignals;
  static const fromJsonFactory = _$MultiDocumentRiskSignalFromJson;
  static const toJsonFactory = _$MultiDocumentRiskSignalToJson;
  Map<String, dynamic> toJson() => _$MultiDocumentRiskSignalToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is MultiDocumentRiskSignal &&
            (identical(other.documentReferences, documentReferences) ||
                const DeepCollectionEquality()
                    .equals(other.documentReferences, documentReferences)) &&
            (identical(other.riskSignals, riskSignals) ||
                const DeepCollectionEquality()
                    .equals(other.riskSignals, riskSignals)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(documentReferences) ^
      const DeepCollectionEquality().hash(riskSignals) ^
      runtimeType.hashCode;
}

extension $MultiDocumentRiskSignalExtension on MultiDocumentRiskSignal {
  MultiDocumentRiskSignal copyWith(
      {List<RiskSignalDocumentReference>? documentReferences,
      List<DocumentRiskSignal>? riskSignals}) {
    return MultiDocumentRiskSignal(
        documentReferences: documentReferences ?? this.documentReferences,
        riskSignals: riskSignals ?? this.riskSignals);
  }

  MultiDocumentRiskSignal copyWithWrapped(
      {Wrapped<List<RiskSignalDocumentReference>>? documentReferences,
      Wrapped<List<DocumentRiskSignal>>? riskSignals}) {
    return MultiDocumentRiskSignal(
        documentReferences: (documentReferences != null
            ? documentReferences.value
            : this.documentReferences),
        riskSignals:
            (riskSignals != null ? riskSignals.value : this.riskSignals));
  }
}

@JsonSerializable(explicitToJson: true)
class CreditAuditCopyTokenCreateRequest {
  CreditAuditCopyTokenCreateRequest({
    this.clientId,
    this.secret,
    required this.reportTokens,
  });

  factory CreditAuditCopyTokenCreateRequest.fromJson(
          Map<String, dynamic> json) =>
      _$CreditAuditCopyTokenCreateRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'report_tokens', defaultValue: <String>[])
  final List<String> reportTokens;
  static const fromJsonFactory = _$CreditAuditCopyTokenCreateRequestFromJson;
  static const toJsonFactory = _$CreditAuditCopyTokenCreateRequestToJson;
  Map<String, dynamic> toJson() =>
      _$CreditAuditCopyTokenCreateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CreditAuditCopyTokenCreateRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.reportTokens, reportTokens) ||
                const DeepCollectionEquality()
                    .equals(other.reportTokens, reportTokens)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(reportTokens) ^
      runtimeType.hashCode;
}

extension $CreditAuditCopyTokenCreateRequestExtension
    on CreditAuditCopyTokenCreateRequest {
  CreditAuditCopyTokenCreateRequest copyWith(
      {String? clientId, String? secret, List<String>? reportTokens}) {
    return CreditAuditCopyTokenCreateRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        reportTokens: reportTokens ?? this.reportTokens);
  }

  CreditAuditCopyTokenCreateRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<List<String>>? reportTokens}) {
    return CreditAuditCopyTokenCreateRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        reportTokens:
            (reportTokens != null ? reportTokens.value : this.reportTokens));
  }
}

@JsonSerializable(explicitToJson: true)
class CreditAuditCopyTokenCreateResponse {
  CreditAuditCopyTokenCreateResponse({
    required this.auditCopyToken,
    required this.requestId,
  });

  factory CreditAuditCopyTokenCreateResponse.fromJson(
          Map<String, dynamic> json) =>
      _$CreditAuditCopyTokenCreateResponseFromJson(json);

  @JsonKey(name: 'audit_copy_token')
  final String auditCopyToken;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$CreditAuditCopyTokenCreateResponseFromJson;
  static const toJsonFactory = _$CreditAuditCopyTokenCreateResponseToJson;
  Map<String, dynamic> toJson() =>
      _$CreditAuditCopyTokenCreateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CreditAuditCopyTokenCreateResponse &&
            (identical(other.auditCopyToken, auditCopyToken) ||
                const DeepCollectionEquality()
                    .equals(other.auditCopyToken, auditCopyToken)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(auditCopyToken) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $CreditAuditCopyTokenCreateResponseExtension
    on CreditAuditCopyTokenCreateResponse {
  CreditAuditCopyTokenCreateResponse copyWith(
      {String? auditCopyToken, String? requestId}) {
    return CreditAuditCopyTokenCreateResponse(
        auditCopyToken: auditCopyToken ?? this.auditCopyToken,
        requestId: requestId ?? this.requestId);
  }

  CreditAuditCopyTokenCreateResponse copyWithWrapped(
      {Wrapped<String>? auditCopyToken, Wrapped<String>? requestId}) {
    return CreditAuditCopyTokenCreateResponse(
        auditCopyToken: (auditCopyToken != null
            ? auditCopyToken.value
            : this.auditCopyToken),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class CreditAuditCopyTokenRemoveRequest {
  CreditAuditCopyTokenRemoveRequest({
    this.clientId,
    this.secret,
    required this.auditCopyToken,
  });

  factory CreditAuditCopyTokenRemoveRequest.fromJson(
          Map<String, dynamic> json) =>
      _$CreditAuditCopyTokenRemoveRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'audit_copy_token')
  final String auditCopyToken;
  static const fromJsonFactory = _$CreditAuditCopyTokenRemoveRequestFromJson;
  static const toJsonFactory = _$CreditAuditCopyTokenRemoveRequestToJson;
  Map<String, dynamic> toJson() =>
      _$CreditAuditCopyTokenRemoveRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CreditAuditCopyTokenRemoveRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.auditCopyToken, auditCopyToken) ||
                const DeepCollectionEquality()
                    .equals(other.auditCopyToken, auditCopyToken)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(auditCopyToken) ^
      runtimeType.hashCode;
}

extension $CreditAuditCopyTokenRemoveRequestExtension
    on CreditAuditCopyTokenRemoveRequest {
  CreditAuditCopyTokenRemoveRequest copyWith(
      {String? clientId, String? secret, String? auditCopyToken}) {
    return CreditAuditCopyTokenRemoveRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        auditCopyToken: auditCopyToken ?? this.auditCopyToken);
  }

  CreditAuditCopyTokenRemoveRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? auditCopyToken}) {
    return CreditAuditCopyTokenRemoveRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        auditCopyToken: (auditCopyToken != null
            ? auditCopyToken.value
            : this.auditCopyToken));
  }
}

@JsonSerializable(explicitToJson: true)
class CreditAuditCopyTokenRemoveResponse {
  CreditAuditCopyTokenRemoveResponse({
    required this.removed,
    required this.requestId,
  });

  factory CreditAuditCopyTokenRemoveResponse.fromJson(
          Map<String, dynamic> json) =>
      _$CreditAuditCopyTokenRemoveResponseFromJson(json);

  @JsonKey(name: 'removed')
  final bool removed;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$CreditAuditCopyTokenRemoveResponseFromJson;
  static const toJsonFactory = _$CreditAuditCopyTokenRemoveResponseToJson;
  Map<String, dynamic> toJson() =>
      _$CreditAuditCopyTokenRemoveResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CreditAuditCopyTokenRemoveResponse &&
            (identical(other.removed, removed) ||
                const DeepCollectionEquality()
                    .equals(other.removed, removed)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(removed) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $CreditAuditCopyTokenRemoveResponseExtension
    on CreditAuditCopyTokenRemoveResponse {
  CreditAuditCopyTokenRemoveResponse copyWith(
      {bool? removed, String? requestId}) {
    return CreditAuditCopyTokenRemoveResponse(
        removed: removed ?? this.removed,
        requestId: requestId ?? this.requestId);
  }

  CreditAuditCopyTokenRemoveResponse copyWithWrapped(
      {Wrapped<bool>? removed, Wrapped<String>? requestId}) {
    return CreditAuditCopyTokenRemoveResponse(
        removed: (removed != null ? removed.value : this.removed),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class CreditPayrollIncomeGetRequest {
  CreditPayrollIncomeGetRequest({
    this.clientId,
    this.secret,
    this.userToken,
  });

  factory CreditPayrollIncomeGetRequest.fromJson(Map<String, dynamic> json) =>
      _$CreditPayrollIncomeGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'user_token')
  final String? userToken;
  static const fromJsonFactory = _$CreditPayrollIncomeGetRequestFromJson;
  static const toJsonFactory = _$CreditPayrollIncomeGetRequestToJson;
  Map<String, dynamic> toJson() => _$CreditPayrollIncomeGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CreditPayrollIncomeGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.userToken, userToken) ||
                const DeepCollectionEquality()
                    .equals(other.userToken, userToken)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(userToken) ^
      runtimeType.hashCode;
}

extension $CreditPayrollIncomeGetRequestExtension
    on CreditPayrollIncomeGetRequest {
  CreditPayrollIncomeGetRequest copyWith(
      {String? clientId, String? secret, String? userToken}) {
    return CreditPayrollIncomeGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        userToken: userToken ?? this.userToken);
  }

  CreditPayrollIncomeGetRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String?>? userToken}) {
    return CreditPayrollIncomeGetRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        userToken: (userToken != null ? userToken.value : this.userToken));
  }
}

@JsonSerializable(explicitToJson: true)
class CreditPayrollIncomeGetResponse {
  CreditPayrollIncomeGetResponse({
    required this.items,
    this.error,
    required this.requestId,
  });

  factory CreditPayrollIncomeGetResponse.fromJson(Map<String, dynamic> json) =>
      _$CreditPayrollIncomeGetResponseFromJson(json);

  @JsonKey(name: 'items', defaultValue: <PayrollItem>[])
  final List<PayrollItem> items;
  @JsonKey(name: 'error')
  final PlaidError? error;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$CreditPayrollIncomeGetResponseFromJson;
  static const toJsonFactory = _$CreditPayrollIncomeGetResponseToJson;
  Map<String, dynamic> toJson() => _$CreditPayrollIncomeGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CreditPayrollIncomeGetResponse &&
            (identical(other.items, items) ||
                const DeepCollectionEquality().equals(other.items, items)) &&
            (identical(other.error, error) ||
                const DeepCollectionEquality().equals(other.error, error)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(items) ^
      const DeepCollectionEquality().hash(error) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $CreditPayrollIncomeGetResponseExtension
    on CreditPayrollIncomeGetResponse {
  CreditPayrollIncomeGetResponse copyWith(
      {List<PayrollItem>? items, PlaidError? error, String? requestId}) {
    return CreditPayrollIncomeGetResponse(
        items: items ?? this.items,
        error: error ?? this.error,
        requestId: requestId ?? this.requestId);
  }

  CreditPayrollIncomeGetResponse copyWithWrapped(
      {Wrapped<List<PayrollItem>>? items,
      Wrapped<PlaidError?>? error,
      Wrapped<String>? requestId}) {
    return CreditPayrollIncomeGetResponse(
        items: (items != null ? items.value : this.items),
        error: (error != null ? error.value : this.error),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class CreditDocumentMetadata {
  CreditDocumentMetadata({
    required this.name,
    required this.documentType,
    required this.downloadUrl,
    required this.status,
  });

  factory CreditDocumentMetadata.fromJson(Map<String, dynamic> json) =>
      _$CreditDocumentMetadataFromJson(json);

  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'document_type')
  final String? documentType;
  @JsonKey(name: 'download_url')
  final String? downloadUrl;
  @JsonKey(name: 'status')
  final String? status;
  static const fromJsonFactory = _$CreditDocumentMetadataFromJson;
  static const toJsonFactory = _$CreditDocumentMetadataToJson;
  Map<String, dynamic> toJson() => _$CreditDocumentMetadataToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CreditDocumentMetadata &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.documentType, documentType) ||
                const DeepCollectionEquality()
                    .equals(other.documentType, documentType)) &&
            (identical(other.downloadUrl, downloadUrl) ||
                const DeepCollectionEquality()
                    .equals(other.downloadUrl, downloadUrl)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(documentType) ^
      const DeepCollectionEquality().hash(downloadUrl) ^
      const DeepCollectionEquality().hash(status) ^
      runtimeType.hashCode;
}

extension $CreditDocumentMetadataExtension on CreditDocumentMetadata {
  CreditDocumentMetadata copyWith(
      {String? name,
      String? documentType,
      String? downloadUrl,
      String? status}) {
    return CreditDocumentMetadata(
        name: name ?? this.name,
        documentType: documentType ?? this.documentType,
        downloadUrl: downloadUrl ?? this.downloadUrl,
        status: status ?? this.status);
  }

  CreditDocumentMetadata copyWithWrapped(
      {Wrapped<String>? name,
      Wrapped<String?>? documentType,
      Wrapped<String?>? downloadUrl,
      Wrapped<String?>? status}) {
    return CreditDocumentMetadata(
        name: (name != null ? name.value : this.name),
        documentType:
            (documentType != null ? documentType.value : this.documentType),
        downloadUrl:
            (downloadUrl != null ? downloadUrl.value : this.downloadUrl),
        status: (status != null ? status.value : this.status));
  }
}

@JsonSerializable(explicitToJson: true)
class PayrollItem {
  PayrollItem({
    required this.itemId,
    required this.institutionId,
    required this.institutionName,
    required this.accounts,
    required this.payrollIncome,
    required this.status,
    required this.updatedAt,
  });

  factory PayrollItem.fromJson(Map<String, dynamic> json) =>
      _$PayrollItemFromJson(json);

  @JsonKey(name: 'item_id')
  final String itemId;
  @JsonKey(name: 'institution_id')
  final String institutionId;
  @JsonKey(name: 'institution_name')
  final String institutionName;
  @JsonKey(name: 'accounts', defaultValue: <PayrollIncomeAccountData>[])
  final List<PayrollIncomeAccountData> accounts;
  @JsonKey(name: 'payroll_income', defaultValue: <PayrollIncomeObject>[])
  final List<PayrollIncomeObject> payrollIncome;
  @JsonKey(name: 'status')
  final PayrollItemStatus? status;
  @JsonKey(name: 'updated_at')
  final DateTime? updatedAt;
  static const fromJsonFactory = _$PayrollItemFromJson;
  static const toJsonFactory = _$PayrollItemToJson;
  Map<String, dynamic> toJson() => _$PayrollItemToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PayrollItem &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)) &&
            (identical(other.institutionId, institutionId) ||
                const DeepCollectionEquality()
                    .equals(other.institutionId, institutionId)) &&
            (identical(other.institutionName, institutionName) ||
                const DeepCollectionEquality()
                    .equals(other.institutionName, institutionName)) &&
            (identical(other.accounts, accounts) ||
                const DeepCollectionEquality()
                    .equals(other.accounts, accounts)) &&
            (identical(other.payrollIncome, payrollIncome) ||
                const DeepCollectionEquality()
                    .equals(other.payrollIncome, payrollIncome)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.updatedAt, updatedAt) ||
                const DeepCollectionEquality()
                    .equals(other.updatedAt, updatedAt)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(itemId) ^
      const DeepCollectionEquality().hash(institutionId) ^
      const DeepCollectionEquality().hash(institutionName) ^
      const DeepCollectionEquality().hash(accounts) ^
      const DeepCollectionEquality().hash(payrollIncome) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(updatedAt) ^
      runtimeType.hashCode;
}

extension $PayrollItemExtension on PayrollItem {
  PayrollItem copyWith(
      {String? itemId,
      String? institutionId,
      String? institutionName,
      List<PayrollIncomeAccountData>? accounts,
      List<PayrollIncomeObject>? payrollIncome,
      PayrollItemStatus? status,
      DateTime? updatedAt}) {
    return PayrollItem(
        itemId: itemId ?? this.itemId,
        institutionId: institutionId ?? this.institutionId,
        institutionName: institutionName ?? this.institutionName,
        accounts: accounts ?? this.accounts,
        payrollIncome: payrollIncome ?? this.payrollIncome,
        status: status ?? this.status,
        updatedAt: updatedAt ?? this.updatedAt);
  }

  PayrollItem copyWithWrapped(
      {Wrapped<String>? itemId,
      Wrapped<String>? institutionId,
      Wrapped<String>? institutionName,
      Wrapped<List<PayrollIncomeAccountData>>? accounts,
      Wrapped<List<PayrollIncomeObject>>? payrollIncome,
      Wrapped<PayrollItemStatus?>? status,
      Wrapped<DateTime?>? updatedAt}) {
    return PayrollItem(
        itemId: (itemId != null ? itemId.value : this.itemId),
        institutionId:
            (institutionId != null ? institutionId.value : this.institutionId),
        institutionName: (institutionName != null
            ? institutionName.value
            : this.institutionName),
        accounts: (accounts != null ? accounts.value : this.accounts),
        payrollIncome:
            (payrollIncome != null ? payrollIncome.value : this.payrollIncome),
        status: (status != null ? status.value : this.status),
        updatedAt: (updatedAt != null ? updatedAt.value : this.updatedAt));
  }
}

@JsonSerializable(explicitToJson: true)
class PayrollIncomeAccountData {
  PayrollIncomeAccountData({
    required this.accountId,
    required this.rateOfPay,
    required this.payFrequency,
  });

  factory PayrollIncomeAccountData.fromJson(Map<String, dynamic> json) =>
      _$PayrollIncomeAccountDataFromJson(json);

  @JsonKey(name: 'account_id')
  final String? accountId;
  @JsonKey(name: 'rate_of_pay')
  final PayrollIncomeRateOfPay rateOfPay;
  @JsonKey(name: 'pay_frequency')
  final String? payFrequency;
  static const fromJsonFactory = _$PayrollIncomeAccountDataFromJson;
  static const toJsonFactory = _$PayrollIncomeAccountDataToJson;
  Map<String, dynamic> toJson() => _$PayrollIncomeAccountDataToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PayrollIncomeAccountData &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.rateOfPay, rateOfPay) ||
                const DeepCollectionEquality()
                    .equals(other.rateOfPay, rateOfPay)) &&
            (identical(other.payFrequency, payFrequency) ||
                const DeepCollectionEquality()
                    .equals(other.payFrequency, payFrequency)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(rateOfPay) ^
      const DeepCollectionEquality().hash(payFrequency) ^
      runtimeType.hashCode;
}

extension $PayrollIncomeAccountDataExtension on PayrollIncomeAccountData {
  PayrollIncomeAccountData copyWith(
      {String? accountId,
      PayrollIncomeRateOfPay? rateOfPay,
      String? payFrequency}) {
    return PayrollIncomeAccountData(
        accountId: accountId ?? this.accountId,
        rateOfPay: rateOfPay ?? this.rateOfPay,
        payFrequency: payFrequency ?? this.payFrequency);
  }

  PayrollIncomeAccountData copyWithWrapped(
      {Wrapped<String?>? accountId,
      Wrapped<PayrollIncomeRateOfPay>? rateOfPay,
      Wrapped<String?>? payFrequency}) {
    return PayrollIncomeAccountData(
        accountId: (accountId != null ? accountId.value : this.accountId),
        rateOfPay: (rateOfPay != null ? rateOfPay.value : this.rateOfPay),
        payFrequency:
            (payFrequency != null ? payFrequency.value : this.payFrequency));
  }
}

@JsonSerializable(explicitToJson: true)
class PayrollIncomeObject {
  PayrollIncomeObject({
    required this.accountId,
    required this.payStubs,
    required this.w2s,
    required this.form1099s,
  });

  factory PayrollIncomeObject.fromJson(Map<String, dynamic> json) =>
      _$PayrollIncomeObjectFromJson(json);

  @JsonKey(name: 'account_id')
  final String? accountId;
  @JsonKey(name: 'pay_stubs', defaultValue: <CreditPayStub>[])
  final List<CreditPayStub> payStubs;
  @JsonKey(name: 'w2s', defaultValue: <CreditW2>[])
  final List<CreditW2> w2s;
  @JsonKey(name: 'form1099s', defaultValue: <Credit1099>[])
  final List<Credit1099> form1099s;
  static const fromJsonFactory = _$PayrollIncomeObjectFromJson;
  static const toJsonFactory = _$PayrollIncomeObjectToJson;
  Map<String, dynamic> toJson() => _$PayrollIncomeObjectToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PayrollIncomeObject &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.payStubs, payStubs) ||
                const DeepCollectionEquality()
                    .equals(other.payStubs, payStubs)) &&
            (identical(other.w2s, w2s) ||
                const DeepCollectionEquality().equals(other.w2s, w2s)) &&
            (identical(other.form1099s, form1099s) ||
                const DeepCollectionEquality()
                    .equals(other.form1099s, form1099s)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(payStubs) ^
      const DeepCollectionEquality().hash(w2s) ^
      const DeepCollectionEquality().hash(form1099s) ^
      runtimeType.hashCode;
}

extension $PayrollIncomeObjectExtension on PayrollIncomeObject {
  PayrollIncomeObject copyWith(
      {String? accountId,
      List<CreditPayStub>? payStubs,
      List<CreditW2>? w2s,
      List<Credit1099>? form1099s}) {
    return PayrollIncomeObject(
        accountId: accountId ?? this.accountId,
        payStubs: payStubs ?? this.payStubs,
        w2s: w2s ?? this.w2s,
        form1099s: form1099s ?? this.form1099s);
  }

  PayrollIncomeObject copyWithWrapped(
      {Wrapped<String?>? accountId,
      Wrapped<List<CreditPayStub>>? payStubs,
      Wrapped<List<CreditW2>>? w2s,
      Wrapped<List<Credit1099>>? form1099s}) {
    return PayrollIncomeObject(
        accountId: (accountId != null ? accountId.value : this.accountId),
        payStubs: (payStubs != null ? payStubs.value : this.payStubs),
        w2s: (w2s != null ? w2s.value : this.w2s),
        form1099s: (form1099s != null ? form1099s.value : this.form1099s));
  }
}

@JsonSerializable(explicitToJson: true)
class Credit1099 {
  Credit1099({
    required this.documentId,
    this.documentMetadata,
    this.form1099Type,
    this.recipient,
    this.payer,
    this.filer,
    this.taxYear,
    this.rents,
    this.royalties,
    this.otherIncome,
    this.federalIncomeTaxWithheld,
    this.fishingBoatProceeds,
    this.medicalAndHealthcarePayments,
    this.nonemployeeCompensation,
    this.substitutePaymentsInLieuOfDividendsOrInterest,
    this.payerMadeDirectSalesOf5000OrMoreOfConsumerProductsToBuyer,
    this.cropInsuranceProceeds,
    this.excessGoldenParachutePayments,
    this.grossProceedsPaidToAnAttorney,
    this.section409aDeferrals,
    this.section409aIncome,
    this.stateTaxWithheld,
    this.stateTaxWithheldLower,
    this.payerStateNumber,
    this.payerStateNumberLower,
    this.stateIncome,
    this.stateIncomeLower,
    this.transactionsReported,
    this.pseName,
    this.pseTelephoneNumber,
    this.grossAmount,
    this.cardNotPresentTransaction,
    this.merchantCategoryCode,
    this.numberOfPaymentTransactions,
    this.januaryAmount,
    this.februaryAmount,
    this.marchAmount,
    this.aprilAmount,
    this.mayAmount,
    this.juneAmount,
    this.julyAmount,
    this.augustAmount,
    this.septemberAmount,
    this.octoberAmount,
    this.novemberAmount,
    this.decemberAmount,
    this.primaryState,
    this.secondaryState,
    this.primaryStateId,
    this.secondaryStateId,
    this.primaryStateIncomeTax,
    this.secondaryStateIncomeTax,
  });

  factory Credit1099.fromJson(Map<String, dynamic> json) =>
      _$Credit1099FromJson(json);

  @JsonKey(name: 'document_id')
  final String? documentId;
  @JsonKey(name: 'document_metadata')
  final CreditDocumentMetadata? documentMetadata;
  @JsonKey(
    name: 'form_1099_type',
    toJson: form1099TypeToJson,
    fromJson: form1099TypeFromJson,
  )
  final enums.Form1099Type? form1099Type;
  @JsonKey(name: 'recipient')
  final Credit1099Recipient? recipient;
  @JsonKey(name: 'payer')
  final Credit1099Payer? payer;
  @JsonKey(name: 'filer')
  final Credit1099Filer? filer;
  @JsonKey(name: 'tax_year')
  final String? taxYear;
  @JsonKey(name: 'rents')
  final double? rents;
  @JsonKey(name: 'royalties')
  final double? royalties;
  @JsonKey(name: 'other_income')
  final double? otherIncome;
  @JsonKey(name: 'federal_income_tax_withheld')
  final double? federalIncomeTaxWithheld;
  @JsonKey(name: 'fishing_boat_proceeds')
  final double? fishingBoatProceeds;
  @JsonKey(name: 'medical_and_healthcare_payments')
  final double? medicalAndHealthcarePayments;
  @JsonKey(name: 'nonemployee_compensation')
  final double? nonemployeeCompensation;
  @JsonKey(name: 'substitute_payments_in_lieu_of_dividends_or_interest')
  final double? substitutePaymentsInLieuOfDividendsOrInterest;
  @JsonKey(
      name:
          'payer_made_direct_sales_of_5000_or_more_of_consumer_products_to_buyer')
  final String? payerMadeDirectSalesOf5000OrMoreOfConsumerProductsToBuyer;
  @JsonKey(name: 'crop_insurance_proceeds')
  final double? cropInsuranceProceeds;
  @JsonKey(name: 'excess_golden_parachute_payments')
  final double? excessGoldenParachutePayments;
  @JsonKey(name: 'gross_proceeds_paid_to_an_attorney')
  final double? grossProceedsPaidToAnAttorney;
  @JsonKey(name: 'section_409a_deferrals')
  final double? section409aDeferrals;
  @JsonKey(name: 'section_409a_income')
  final double? section409aIncome;
  @JsonKey(name: 'state_tax_withheld')
  final double? stateTaxWithheld;
  @JsonKey(name: 'state_tax_withheld_lower')
  final double? stateTaxWithheldLower;
  @JsonKey(name: 'payer_state_number')
  final String? payerStateNumber;
  @JsonKey(name: 'payer_state_number_lower')
  final String? payerStateNumberLower;
  @JsonKey(name: 'state_income')
  final double? stateIncome;
  @JsonKey(name: 'state_income_lower')
  final double? stateIncomeLower;
  @JsonKey(name: 'transactions_reported')
  final String? transactionsReported;
  @JsonKey(name: 'pse_name')
  final String? pseName;
  @JsonKey(name: 'pse_telephone_number')
  final String? pseTelephoneNumber;
  @JsonKey(name: 'gross_amount')
  final double? grossAmount;
  @JsonKey(name: 'card_not_present_transaction')
  final double? cardNotPresentTransaction;
  @JsonKey(name: 'merchant_category_code')
  final String? merchantCategoryCode;
  @JsonKey(name: 'number_of_payment_transactions')
  final String? numberOfPaymentTransactions;
  @JsonKey(name: 'january_amount')
  final double? januaryAmount;
  @JsonKey(name: 'february_amount')
  final double? februaryAmount;
  @JsonKey(name: 'march_amount')
  final double? marchAmount;
  @JsonKey(name: 'april_amount')
  final double? aprilAmount;
  @JsonKey(name: 'may_amount')
  final double? mayAmount;
  @JsonKey(name: 'june_amount')
  final double? juneAmount;
  @JsonKey(name: 'july_amount')
  final double? julyAmount;
  @JsonKey(name: 'august_amount')
  final double? augustAmount;
  @JsonKey(name: 'september_amount')
  final double? septemberAmount;
  @JsonKey(name: 'october_amount')
  final double? octoberAmount;
  @JsonKey(name: 'november_amount')
  final double? novemberAmount;
  @JsonKey(name: 'december_amount')
  final double? decemberAmount;
  @JsonKey(name: 'primary_state')
  final String? primaryState;
  @JsonKey(name: 'secondary_state')
  final String? secondaryState;
  @JsonKey(name: 'primary_state_id')
  final String? primaryStateId;
  @JsonKey(name: 'secondary_state_id')
  final String? secondaryStateId;
  @JsonKey(name: 'primary_state_income_tax')
  final double? primaryStateIncomeTax;
  @JsonKey(name: 'secondary_state_income_tax')
  final double? secondaryStateIncomeTax;
  static const fromJsonFactory = _$Credit1099FromJson;
  static const toJsonFactory = _$Credit1099ToJson;
  Map<String, dynamic> toJson() => _$Credit1099ToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Credit1099 &&
            (identical(other.documentId, documentId) ||
                const DeepCollectionEquality()
                    .equals(other.documentId, documentId)) &&
            (identical(other.documentMetadata, documentMetadata) ||
                const DeepCollectionEquality()
                    .equals(other.documentMetadata, documentMetadata)) &&
            (identical(other.form1099Type, form1099Type) ||
                const DeepCollectionEquality()
                    .equals(other.form1099Type, form1099Type)) &&
            (identical(other.recipient, recipient) ||
                const DeepCollectionEquality()
                    .equals(other.recipient, recipient)) &&
            (identical(other.payer, payer) ||
                const DeepCollectionEquality().equals(other.payer, payer)) &&
            (identical(other.filer, filer) ||
                const DeepCollectionEquality().equals(other.filer, filer)) &&
            (identical(other.taxYear, taxYear) ||
                const DeepCollectionEquality()
                    .equals(other.taxYear, taxYear)) &&
            (identical(other.rents, rents) ||
                const DeepCollectionEquality().equals(other.rents, rents)) &&
            (identical(other.royalties, royalties) ||
                const DeepCollectionEquality()
                    .equals(other.royalties, royalties)) &&
            (identical(other.otherIncome, otherIncome) ||
                const DeepCollectionEquality()
                    .equals(other.otherIncome, otherIncome)) &&
            (identical(other.federalIncomeTaxWithheld, federalIncomeTaxWithheld) ||
                const DeepCollectionEquality().equals(
                    other.federalIncomeTaxWithheld,
                    federalIncomeTaxWithheld)) &&
            (identical(other.fishingBoatProceeds, fishingBoatProceeds) ||
                const DeepCollectionEquality()
                    .equals(other.fishingBoatProceeds, fishingBoatProceeds)) &&
            (identical(other.medicalAndHealthcarePayments, medicalAndHealthcarePayments) ||
                const DeepCollectionEquality().equals(
                    other.medicalAndHealthcarePayments,
                    medicalAndHealthcarePayments)) &&
            (identical(other.nonemployeeCompensation, nonemployeeCompensation) ||
                const DeepCollectionEquality().equals(
                    other.nonemployeeCompensation, nonemployeeCompensation)) &&
            (identical(other.substitutePaymentsInLieuOfDividendsOrInterest, substitutePaymentsInLieuOfDividendsOrInterest) ||
                const DeepCollectionEquality().equals(
                    other.substitutePaymentsInLieuOfDividendsOrInterest,
                    substitutePaymentsInLieuOfDividendsOrInterest)) &&
            (identical(other.payerMadeDirectSalesOf5000OrMoreOfConsumerProductsToBuyer, payerMadeDirectSalesOf5000OrMoreOfConsumerProductsToBuyer) ||
                const DeepCollectionEquality().equals(
                    other
                        .payerMadeDirectSalesOf5000OrMoreOfConsumerProductsToBuyer,
                    payerMadeDirectSalesOf5000OrMoreOfConsumerProductsToBuyer)) &&
            (identical(other.cropInsuranceProceeds, cropInsuranceProceeds) || const DeepCollectionEquality().equals(other.cropInsuranceProceeds, cropInsuranceProceeds)) &&
            (identical(other.excessGoldenParachutePayments, excessGoldenParachutePayments) || const DeepCollectionEquality().equals(other.excessGoldenParachutePayments, excessGoldenParachutePayments)) &&
            (identical(other.grossProceedsPaidToAnAttorney, grossProceedsPaidToAnAttorney) || const DeepCollectionEquality().equals(other.grossProceedsPaidToAnAttorney, grossProceedsPaidToAnAttorney)) &&
            (identical(other.section409aDeferrals, section409aDeferrals) || const DeepCollectionEquality().equals(other.section409aDeferrals, section409aDeferrals)) &&
            (identical(other.section409aIncome, section409aIncome) || const DeepCollectionEquality().equals(other.section409aIncome, section409aIncome)) &&
            (identical(other.stateTaxWithheld, stateTaxWithheld) || const DeepCollectionEquality().equals(other.stateTaxWithheld, stateTaxWithheld)) &&
            (identical(other.stateTaxWithheldLower, stateTaxWithheldLower) || const DeepCollectionEquality().equals(other.stateTaxWithheldLower, stateTaxWithheldLower)) &&
            (identical(other.payerStateNumber, payerStateNumber) || const DeepCollectionEquality().equals(other.payerStateNumber, payerStateNumber)) &&
            (identical(other.payerStateNumberLower, payerStateNumberLower) || const DeepCollectionEquality().equals(other.payerStateNumberLower, payerStateNumberLower)) &&
            (identical(other.stateIncome, stateIncome) || const DeepCollectionEquality().equals(other.stateIncome, stateIncome)) &&
            (identical(other.stateIncomeLower, stateIncomeLower) || const DeepCollectionEquality().equals(other.stateIncomeLower, stateIncomeLower)) &&
            (identical(other.transactionsReported, transactionsReported) || const DeepCollectionEquality().equals(other.transactionsReported, transactionsReported)) &&
            (identical(other.pseName, pseName) || const DeepCollectionEquality().equals(other.pseName, pseName)) &&
            (identical(other.pseTelephoneNumber, pseTelephoneNumber) || const DeepCollectionEquality().equals(other.pseTelephoneNumber, pseTelephoneNumber)) &&
            (identical(other.grossAmount, grossAmount) || const DeepCollectionEquality().equals(other.grossAmount, grossAmount)) &&
            (identical(other.cardNotPresentTransaction, cardNotPresentTransaction) || const DeepCollectionEquality().equals(other.cardNotPresentTransaction, cardNotPresentTransaction)) &&
            (identical(other.merchantCategoryCode, merchantCategoryCode) || const DeepCollectionEquality().equals(other.merchantCategoryCode, merchantCategoryCode)) &&
            (identical(other.numberOfPaymentTransactions, numberOfPaymentTransactions) || const DeepCollectionEquality().equals(other.numberOfPaymentTransactions, numberOfPaymentTransactions)) &&
            (identical(other.januaryAmount, januaryAmount) || const DeepCollectionEquality().equals(other.januaryAmount, januaryAmount)) &&
            (identical(other.februaryAmount, februaryAmount) || const DeepCollectionEquality().equals(other.februaryAmount, februaryAmount)) &&
            (identical(other.marchAmount, marchAmount) || const DeepCollectionEquality().equals(other.marchAmount, marchAmount)) &&
            (identical(other.aprilAmount, aprilAmount) || const DeepCollectionEquality().equals(other.aprilAmount, aprilAmount)) &&
            (identical(other.mayAmount, mayAmount) || const DeepCollectionEquality().equals(other.mayAmount, mayAmount)) &&
            (identical(other.juneAmount, juneAmount) || const DeepCollectionEquality().equals(other.juneAmount, juneAmount)) &&
            (identical(other.julyAmount, julyAmount) || const DeepCollectionEquality().equals(other.julyAmount, julyAmount)) &&
            (identical(other.augustAmount, augustAmount) || const DeepCollectionEquality().equals(other.augustAmount, augustAmount)) &&
            (identical(other.septemberAmount, septemberAmount) || const DeepCollectionEquality().equals(other.septemberAmount, septemberAmount)) &&
            (identical(other.octoberAmount, octoberAmount) || const DeepCollectionEquality().equals(other.octoberAmount, octoberAmount)) &&
            (identical(other.novemberAmount, novemberAmount) || const DeepCollectionEquality().equals(other.novemberAmount, novemberAmount)) &&
            (identical(other.decemberAmount, decemberAmount) || const DeepCollectionEquality().equals(other.decemberAmount, decemberAmount)) &&
            (identical(other.primaryState, primaryState) || const DeepCollectionEquality().equals(other.primaryState, primaryState)) &&
            (identical(other.secondaryState, secondaryState) || const DeepCollectionEquality().equals(other.secondaryState, secondaryState)) &&
            (identical(other.primaryStateId, primaryStateId) || const DeepCollectionEquality().equals(other.primaryStateId, primaryStateId)) &&
            (identical(other.secondaryStateId, secondaryStateId) || const DeepCollectionEquality().equals(other.secondaryStateId, secondaryStateId)) &&
            (identical(other.primaryStateIncomeTax, primaryStateIncomeTax) || const DeepCollectionEquality().equals(other.primaryStateIncomeTax, primaryStateIncomeTax)) &&
            (identical(other.secondaryStateIncomeTax, secondaryStateIncomeTax) || const DeepCollectionEquality().equals(other.secondaryStateIncomeTax, secondaryStateIncomeTax)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(documentId) ^
      const DeepCollectionEquality().hash(documentMetadata) ^
      const DeepCollectionEquality().hash(form1099Type) ^
      const DeepCollectionEquality().hash(recipient) ^
      const DeepCollectionEquality().hash(payer) ^
      const DeepCollectionEquality().hash(filer) ^
      const DeepCollectionEquality().hash(taxYear) ^
      const DeepCollectionEquality().hash(rents) ^
      const DeepCollectionEquality().hash(royalties) ^
      const DeepCollectionEquality().hash(otherIncome) ^
      const DeepCollectionEquality().hash(federalIncomeTaxWithheld) ^
      const DeepCollectionEquality().hash(fishingBoatProceeds) ^
      const DeepCollectionEquality().hash(medicalAndHealthcarePayments) ^
      const DeepCollectionEquality().hash(nonemployeeCompensation) ^
      const DeepCollectionEquality()
          .hash(substitutePaymentsInLieuOfDividendsOrInterest) ^
      const DeepCollectionEquality()
          .hash(payerMadeDirectSalesOf5000OrMoreOfConsumerProductsToBuyer) ^
      const DeepCollectionEquality().hash(cropInsuranceProceeds) ^
      const DeepCollectionEquality().hash(excessGoldenParachutePayments) ^
      const DeepCollectionEquality().hash(grossProceedsPaidToAnAttorney) ^
      const DeepCollectionEquality().hash(section409aDeferrals) ^
      const DeepCollectionEquality().hash(section409aIncome) ^
      const DeepCollectionEquality().hash(stateTaxWithheld) ^
      const DeepCollectionEquality().hash(stateTaxWithheldLower) ^
      const DeepCollectionEquality().hash(payerStateNumber) ^
      const DeepCollectionEquality().hash(payerStateNumberLower) ^
      const DeepCollectionEquality().hash(stateIncome) ^
      const DeepCollectionEquality().hash(stateIncomeLower) ^
      const DeepCollectionEquality().hash(transactionsReported) ^
      const DeepCollectionEquality().hash(pseName) ^
      const DeepCollectionEquality().hash(pseTelephoneNumber) ^
      const DeepCollectionEquality().hash(grossAmount) ^
      const DeepCollectionEquality().hash(cardNotPresentTransaction) ^
      const DeepCollectionEquality().hash(merchantCategoryCode) ^
      const DeepCollectionEquality().hash(numberOfPaymentTransactions) ^
      const DeepCollectionEquality().hash(januaryAmount) ^
      const DeepCollectionEquality().hash(februaryAmount) ^
      const DeepCollectionEquality().hash(marchAmount) ^
      const DeepCollectionEquality().hash(aprilAmount) ^
      const DeepCollectionEquality().hash(mayAmount) ^
      const DeepCollectionEquality().hash(juneAmount) ^
      const DeepCollectionEquality().hash(julyAmount) ^
      const DeepCollectionEquality().hash(augustAmount) ^
      const DeepCollectionEquality().hash(septemberAmount) ^
      const DeepCollectionEquality().hash(octoberAmount) ^
      const DeepCollectionEquality().hash(novemberAmount) ^
      const DeepCollectionEquality().hash(decemberAmount) ^
      const DeepCollectionEquality().hash(primaryState) ^
      const DeepCollectionEquality().hash(secondaryState) ^
      const DeepCollectionEquality().hash(primaryStateId) ^
      const DeepCollectionEquality().hash(secondaryStateId) ^
      const DeepCollectionEquality().hash(primaryStateIncomeTax) ^
      const DeepCollectionEquality().hash(secondaryStateIncomeTax) ^
      runtimeType.hashCode;
}

extension $Credit1099Extension on Credit1099 {
  Credit1099 copyWith(
      {String? documentId,
      CreditDocumentMetadata? documentMetadata,
      enums.Form1099Type? form1099Type,
      Credit1099Recipient? recipient,
      Credit1099Payer? payer,
      Credit1099Filer? filer,
      String? taxYear,
      double? rents,
      double? royalties,
      double? otherIncome,
      double? federalIncomeTaxWithheld,
      double? fishingBoatProceeds,
      double? medicalAndHealthcarePayments,
      double? nonemployeeCompensation,
      double? substitutePaymentsInLieuOfDividendsOrInterest,
      String? payerMadeDirectSalesOf5000OrMoreOfConsumerProductsToBuyer,
      double? cropInsuranceProceeds,
      double? excessGoldenParachutePayments,
      double? grossProceedsPaidToAnAttorney,
      double? section409aDeferrals,
      double? section409aIncome,
      double? stateTaxWithheld,
      double? stateTaxWithheldLower,
      String? payerStateNumber,
      String? payerStateNumberLower,
      double? stateIncome,
      double? stateIncomeLower,
      String? transactionsReported,
      String? pseName,
      String? pseTelephoneNumber,
      double? grossAmount,
      double? cardNotPresentTransaction,
      String? merchantCategoryCode,
      String? numberOfPaymentTransactions,
      double? januaryAmount,
      double? februaryAmount,
      double? marchAmount,
      double? aprilAmount,
      double? mayAmount,
      double? juneAmount,
      double? julyAmount,
      double? augustAmount,
      double? septemberAmount,
      double? octoberAmount,
      double? novemberAmount,
      double? decemberAmount,
      String? primaryState,
      String? secondaryState,
      String? primaryStateId,
      String? secondaryStateId,
      double? primaryStateIncomeTax,
      double? secondaryStateIncomeTax}) {
    return Credit1099(
        documentId: documentId ?? this.documentId,
        documentMetadata: documentMetadata ?? this.documentMetadata,
        form1099Type: form1099Type ?? this.form1099Type,
        recipient: recipient ?? this.recipient,
        payer: payer ?? this.payer,
        filer: filer ?? this.filer,
        taxYear: taxYear ?? this.taxYear,
        rents: rents ?? this.rents,
        royalties: royalties ?? this.royalties,
        otherIncome: otherIncome ?? this.otherIncome,
        federalIncomeTaxWithheld:
            federalIncomeTaxWithheld ?? this.federalIncomeTaxWithheld,
        fishingBoatProceeds: fishingBoatProceeds ?? this.fishingBoatProceeds,
        medicalAndHealthcarePayments:
            medicalAndHealthcarePayments ?? this.medicalAndHealthcarePayments,
        nonemployeeCompensation:
            nonemployeeCompensation ?? this.nonemployeeCompensation,
        substitutePaymentsInLieuOfDividendsOrInterest:
            substitutePaymentsInLieuOfDividendsOrInterest ??
                this.substitutePaymentsInLieuOfDividendsOrInterest,
        payerMadeDirectSalesOf5000OrMoreOfConsumerProductsToBuyer:
            payerMadeDirectSalesOf5000OrMoreOfConsumerProductsToBuyer ??
                this.payerMadeDirectSalesOf5000OrMoreOfConsumerProductsToBuyer,
        cropInsuranceProceeds:
            cropInsuranceProceeds ?? this.cropInsuranceProceeds,
        excessGoldenParachutePayments:
            excessGoldenParachutePayments ?? this.excessGoldenParachutePayments,
        grossProceedsPaidToAnAttorney:
            grossProceedsPaidToAnAttorney ?? this.grossProceedsPaidToAnAttorney,
        section409aDeferrals: section409aDeferrals ?? this.section409aDeferrals,
        section409aIncome: section409aIncome ?? this.section409aIncome,
        stateTaxWithheld: stateTaxWithheld ?? this.stateTaxWithheld,
        stateTaxWithheldLower:
            stateTaxWithheldLower ?? this.stateTaxWithheldLower,
        payerStateNumber: payerStateNumber ?? this.payerStateNumber,
        payerStateNumberLower:
            payerStateNumberLower ?? this.payerStateNumberLower,
        stateIncome: stateIncome ?? this.stateIncome,
        stateIncomeLower: stateIncomeLower ?? this.stateIncomeLower,
        transactionsReported: transactionsReported ?? this.transactionsReported,
        pseName: pseName ?? this.pseName,
        pseTelephoneNumber: pseTelephoneNumber ?? this.pseTelephoneNumber,
        grossAmount: grossAmount ?? this.grossAmount,
        cardNotPresentTransaction:
            cardNotPresentTransaction ?? this.cardNotPresentTransaction,
        merchantCategoryCode: merchantCategoryCode ?? this.merchantCategoryCode,
        numberOfPaymentTransactions:
            numberOfPaymentTransactions ?? this.numberOfPaymentTransactions,
        januaryAmount: januaryAmount ?? this.januaryAmount,
        februaryAmount: februaryAmount ?? this.februaryAmount,
        marchAmount: marchAmount ?? this.marchAmount,
        aprilAmount: aprilAmount ?? this.aprilAmount,
        mayAmount: mayAmount ?? this.mayAmount,
        juneAmount: juneAmount ?? this.juneAmount,
        julyAmount: julyAmount ?? this.julyAmount,
        augustAmount: augustAmount ?? this.augustAmount,
        septemberAmount: septemberAmount ?? this.septemberAmount,
        octoberAmount: octoberAmount ?? this.octoberAmount,
        novemberAmount: novemberAmount ?? this.novemberAmount,
        decemberAmount: decemberAmount ?? this.decemberAmount,
        primaryState: primaryState ?? this.primaryState,
        secondaryState: secondaryState ?? this.secondaryState,
        primaryStateId: primaryStateId ?? this.primaryStateId,
        secondaryStateId: secondaryStateId ?? this.secondaryStateId,
        primaryStateIncomeTax:
            primaryStateIncomeTax ?? this.primaryStateIncomeTax,
        secondaryStateIncomeTax:
            secondaryStateIncomeTax ?? this.secondaryStateIncomeTax);
  }

  Credit1099 copyWithWrapped(
      {Wrapped<String?>? documentId,
      Wrapped<CreditDocumentMetadata?>? documentMetadata,
      Wrapped<enums.Form1099Type?>? form1099Type,
      Wrapped<Credit1099Recipient?>? recipient,
      Wrapped<Credit1099Payer?>? payer,
      Wrapped<Credit1099Filer?>? filer,
      Wrapped<String?>? taxYear,
      Wrapped<double?>? rents,
      Wrapped<double?>? royalties,
      Wrapped<double?>? otherIncome,
      Wrapped<double?>? federalIncomeTaxWithheld,
      Wrapped<double?>? fishingBoatProceeds,
      Wrapped<double?>? medicalAndHealthcarePayments,
      Wrapped<double?>? nonemployeeCompensation,
      Wrapped<double?>? substitutePaymentsInLieuOfDividendsOrInterest,
      Wrapped<String?>?
          payerMadeDirectSalesOf5000OrMoreOfConsumerProductsToBuyer,
      Wrapped<double?>? cropInsuranceProceeds,
      Wrapped<double?>? excessGoldenParachutePayments,
      Wrapped<double?>? grossProceedsPaidToAnAttorney,
      Wrapped<double?>? section409aDeferrals,
      Wrapped<double?>? section409aIncome,
      Wrapped<double?>? stateTaxWithheld,
      Wrapped<double?>? stateTaxWithheldLower,
      Wrapped<String?>? payerStateNumber,
      Wrapped<String?>? payerStateNumberLower,
      Wrapped<double?>? stateIncome,
      Wrapped<double?>? stateIncomeLower,
      Wrapped<String?>? transactionsReported,
      Wrapped<String?>? pseName,
      Wrapped<String?>? pseTelephoneNumber,
      Wrapped<double?>? grossAmount,
      Wrapped<double?>? cardNotPresentTransaction,
      Wrapped<String?>? merchantCategoryCode,
      Wrapped<String?>? numberOfPaymentTransactions,
      Wrapped<double?>? januaryAmount,
      Wrapped<double?>? februaryAmount,
      Wrapped<double?>? marchAmount,
      Wrapped<double?>? aprilAmount,
      Wrapped<double?>? mayAmount,
      Wrapped<double?>? juneAmount,
      Wrapped<double?>? julyAmount,
      Wrapped<double?>? augustAmount,
      Wrapped<double?>? septemberAmount,
      Wrapped<double?>? octoberAmount,
      Wrapped<double?>? novemberAmount,
      Wrapped<double?>? decemberAmount,
      Wrapped<String?>? primaryState,
      Wrapped<String?>? secondaryState,
      Wrapped<String?>? primaryStateId,
      Wrapped<String?>? secondaryStateId,
      Wrapped<double?>? primaryStateIncomeTax,
      Wrapped<double?>? secondaryStateIncomeTax}) {
    return Credit1099(
        documentId: (documentId != null ? documentId.value : this.documentId),
        documentMetadata: (documentMetadata != null
            ? documentMetadata.value
            : this.documentMetadata),
        form1099Type:
            (form1099Type != null ? form1099Type.value : this.form1099Type),
        recipient: (recipient != null ? recipient.value : this.recipient),
        payer: (payer != null ? payer.value : this.payer),
        filer: (filer != null ? filer.value : this.filer),
        taxYear: (taxYear != null ? taxYear.value : this.taxYear),
        rents: (rents != null ? rents.value : this.rents),
        royalties: (royalties != null ? royalties.value : this.royalties),
        otherIncome:
            (otherIncome != null ? otherIncome.value : this.otherIncome),
        federalIncomeTaxWithheld: (federalIncomeTaxWithheld != null
            ? federalIncomeTaxWithheld.value
            : this.federalIncomeTaxWithheld),
        fishingBoatProceeds: (fishingBoatProceeds != null
            ? fishingBoatProceeds.value
            : this.fishingBoatProceeds),
        medicalAndHealthcarePayments: (medicalAndHealthcarePayments != null
            ? medicalAndHealthcarePayments.value
            : this.medicalAndHealthcarePayments),
        nonemployeeCompensation: (nonemployeeCompensation != null
            ? nonemployeeCompensation.value
            : this.nonemployeeCompensation),
        substitutePaymentsInLieuOfDividendsOrInterest:
            (substitutePaymentsInLieuOfDividendsOrInterest != null
                ? substitutePaymentsInLieuOfDividendsOrInterest.value
                : this.substitutePaymentsInLieuOfDividendsOrInterest),
        payerMadeDirectSalesOf5000OrMoreOfConsumerProductsToBuyer: (payerMadeDirectSalesOf5000OrMoreOfConsumerProductsToBuyer != null
            ? payerMadeDirectSalesOf5000OrMoreOfConsumerProductsToBuyer.value
            : this.payerMadeDirectSalesOf5000OrMoreOfConsumerProductsToBuyer),
        cropInsuranceProceeds: (cropInsuranceProceeds != null
            ? cropInsuranceProceeds.value
            : this.cropInsuranceProceeds),
        excessGoldenParachutePayments: (excessGoldenParachutePayments != null
            ? excessGoldenParachutePayments.value
            : this.excessGoldenParachutePayments),
        grossProceedsPaidToAnAttorney: (grossProceedsPaidToAnAttorney != null
            ? grossProceedsPaidToAnAttorney.value
            : this.grossProceedsPaidToAnAttorney),
        section409aDeferrals: (section409aDeferrals != null
            ? section409aDeferrals.value
            : this.section409aDeferrals),
        section409aIncome: (section409aIncome != null
            ? section409aIncome.value
            : this.section409aIncome),
        stateTaxWithheld: (stateTaxWithheld != null
            ? stateTaxWithheld.value
            : this.stateTaxWithheld),
        stateTaxWithheldLower: (stateTaxWithheldLower != null
            ? stateTaxWithheldLower.value
            : this.stateTaxWithheldLower),
        payerStateNumber: (payerStateNumber != null
            ? payerStateNumber.value
            : this.payerStateNumber),
        payerStateNumberLower: (payerStateNumberLower != null
            ? payerStateNumberLower.value
            : this.payerStateNumberLower),
        stateIncome:
            (stateIncome != null ? stateIncome.value : this.stateIncome),
        stateIncomeLower: (stateIncomeLower != null
            ? stateIncomeLower.value
            : this.stateIncomeLower),
        transactionsReported: (transactionsReported != null
            ? transactionsReported.value
            : this.transactionsReported),
        pseName: (pseName != null ? pseName.value : this.pseName),
        pseTelephoneNumber: (pseTelephoneNumber != null
            ? pseTelephoneNumber.value
            : this.pseTelephoneNumber),
        grossAmount:
            (grossAmount != null ? grossAmount.value : this.grossAmount),
        cardNotPresentTransaction: (cardNotPresentTransaction != null
            ? cardNotPresentTransaction.value
            : this.cardNotPresentTransaction),
        merchantCategoryCode:
            (merchantCategoryCode != null ? merchantCategoryCode.value : this.merchantCategoryCode),
        numberOfPaymentTransactions: (numberOfPaymentTransactions != null ? numberOfPaymentTransactions.value : this.numberOfPaymentTransactions),
        januaryAmount: (januaryAmount != null ? januaryAmount.value : this.januaryAmount),
        februaryAmount: (februaryAmount != null ? februaryAmount.value : this.februaryAmount),
        marchAmount: (marchAmount != null ? marchAmount.value : this.marchAmount),
        aprilAmount: (aprilAmount != null ? aprilAmount.value : this.aprilAmount),
        mayAmount: (mayAmount != null ? mayAmount.value : this.mayAmount),
        juneAmount: (juneAmount != null ? juneAmount.value : this.juneAmount),
        julyAmount: (julyAmount != null ? julyAmount.value : this.julyAmount),
        augustAmount: (augustAmount != null ? augustAmount.value : this.augustAmount),
        septemberAmount: (septemberAmount != null ? septemberAmount.value : this.septemberAmount),
        octoberAmount: (octoberAmount != null ? octoberAmount.value : this.octoberAmount),
        novemberAmount: (novemberAmount != null ? novemberAmount.value : this.novemberAmount),
        decemberAmount: (decemberAmount != null ? decemberAmount.value : this.decemberAmount),
        primaryState: (primaryState != null ? primaryState.value : this.primaryState),
        secondaryState: (secondaryState != null ? secondaryState.value : this.secondaryState),
        primaryStateId: (primaryStateId != null ? primaryStateId.value : this.primaryStateId),
        secondaryStateId: (secondaryStateId != null ? secondaryStateId.value : this.secondaryStateId),
        primaryStateIncomeTax: (primaryStateIncomeTax != null ? primaryStateIncomeTax.value : this.primaryStateIncomeTax),
        secondaryStateIncomeTax: (secondaryStateIncomeTax != null ? secondaryStateIncomeTax.value : this.secondaryStateIncomeTax));
  }
}

@JsonSerializable(explicitToJson: true)
class Credit1099Payer {
  Credit1099Payer({
    this.address,
    this.name,
    this.tin,
    this.telephoneNumber,
  });

  factory Credit1099Payer.fromJson(Map<String, dynamic> json) =>
      _$Credit1099PayerFromJson(json);

  @JsonKey(name: 'address')
  final CreditPayStubAddress? address;
  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'tin')
  final String? tin;
  @JsonKey(name: 'telephone_number')
  final String? telephoneNumber;
  static const fromJsonFactory = _$Credit1099PayerFromJson;
  static const toJsonFactory = _$Credit1099PayerToJson;
  Map<String, dynamic> toJson() => _$Credit1099PayerToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Credit1099Payer &&
            (identical(other.address, address) ||
                const DeepCollectionEquality()
                    .equals(other.address, address)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.tin, tin) ||
                const DeepCollectionEquality().equals(other.tin, tin)) &&
            (identical(other.telephoneNumber, telephoneNumber) ||
                const DeepCollectionEquality()
                    .equals(other.telephoneNumber, telephoneNumber)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(tin) ^
      const DeepCollectionEquality().hash(telephoneNumber) ^
      runtimeType.hashCode;
}

extension $Credit1099PayerExtension on Credit1099Payer {
  Credit1099Payer copyWith(
      {CreditPayStubAddress? address,
      String? name,
      String? tin,
      String? telephoneNumber}) {
    return Credit1099Payer(
        address: address ?? this.address,
        name: name ?? this.name,
        tin: tin ?? this.tin,
        telephoneNumber: telephoneNumber ?? this.telephoneNumber);
  }

  Credit1099Payer copyWithWrapped(
      {Wrapped<CreditPayStubAddress?>? address,
      Wrapped<String?>? name,
      Wrapped<String?>? tin,
      Wrapped<String?>? telephoneNumber}) {
    return Credit1099Payer(
        address: (address != null ? address.value : this.address),
        name: (name != null ? name.value : this.name),
        tin: (tin != null ? tin.value : this.tin),
        telephoneNumber: (telephoneNumber != null
            ? telephoneNumber.value
            : this.telephoneNumber));
  }
}

@JsonSerializable(explicitToJson: true)
class Credit1099Recipient {
  Credit1099Recipient({
    this.address,
    this.name,
    this.tin,
    this.accountNumber,
    this.factaFilingRequirement,
    this.secondTinExists,
  });

  factory Credit1099Recipient.fromJson(Map<String, dynamic> json) =>
      _$Credit1099RecipientFromJson(json);

  @JsonKey(name: 'address')
  final CreditPayStubAddress? address;
  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'tin')
  final String? tin;
  @JsonKey(name: 'account_number')
  final String? accountNumber;
  @JsonKey(name: 'facta_filing_requirement')
  final String? factaFilingRequirement;
  @JsonKey(name: 'second_tin_exists')
  final String? secondTinExists;
  static const fromJsonFactory = _$Credit1099RecipientFromJson;
  static const toJsonFactory = _$Credit1099RecipientToJson;
  Map<String, dynamic> toJson() => _$Credit1099RecipientToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Credit1099Recipient &&
            (identical(other.address, address) ||
                const DeepCollectionEquality()
                    .equals(other.address, address)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.tin, tin) ||
                const DeepCollectionEquality().equals(other.tin, tin)) &&
            (identical(other.accountNumber, accountNumber) ||
                const DeepCollectionEquality()
                    .equals(other.accountNumber, accountNumber)) &&
            (identical(other.factaFilingRequirement, factaFilingRequirement) ||
                const DeepCollectionEquality().equals(
                    other.factaFilingRequirement, factaFilingRequirement)) &&
            (identical(other.secondTinExists, secondTinExists) ||
                const DeepCollectionEquality()
                    .equals(other.secondTinExists, secondTinExists)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(tin) ^
      const DeepCollectionEquality().hash(accountNumber) ^
      const DeepCollectionEquality().hash(factaFilingRequirement) ^
      const DeepCollectionEquality().hash(secondTinExists) ^
      runtimeType.hashCode;
}

extension $Credit1099RecipientExtension on Credit1099Recipient {
  Credit1099Recipient copyWith(
      {CreditPayStubAddress? address,
      String? name,
      String? tin,
      String? accountNumber,
      String? factaFilingRequirement,
      String? secondTinExists}) {
    return Credit1099Recipient(
        address: address ?? this.address,
        name: name ?? this.name,
        tin: tin ?? this.tin,
        accountNumber: accountNumber ?? this.accountNumber,
        factaFilingRequirement:
            factaFilingRequirement ?? this.factaFilingRequirement,
        secondTinExists: secondTinExists ?? this.secondTinExists);
  }

  Credit1099Recipient copyWithWrapped(
      {Wrapped<CreditPayStubAddress?>? address,
      Wrapped<String?>? name,
      Wrapped<String?>? tin,
      Wrapped<String?>? accountNumber,
      Wrapped<String?>? factaFilingRequirement,
      Wrapped<String?>? secondTinExists}) {
    return Credit1099Recipient(
        address: (address != null ? address.value : this.address),
        name: (name != null ? name.value : this.name),
        tin: (tin != null ? tin.value : this.tin),
        accountNumber:
            (accountNumber != null ? accountNumber.value : this.accountNumber),
        factaFilingRequirement: (factaFilingRequirement != null
            ? factaFilingRequirement.value
            : this.factaFilingRequirement),
        secondTinExists: (secondTinExists != null
            ? secondTinExists.value
            : this.secondTinExists));
  }
}

@JsonSerializable(explicitToJson: true)
class Credit1099Filer {
  Credit1099Filer({
    this.address,
    this.name,
    this.tin,
    this.type,
  });

  factory Credit1099Filer.fromJson(Map<String, dynamic> json) =>
      _$Credit1099FilerFromJson(json);

  @JsonKey(name: 'address')
  final CreditPayStubAddress? address;
  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'tin')
  final String? tin;
  @JsonKey(name: 'type')
  final String? type;
  static const fromJsonFactory = _$Credit1099FilerFromJson;
  static const toJsonFactory = _$Credit1099FilerToJson;
  Map<String, dynamic> toJson() => _$Credit1099FilerToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Credit1099Filer &&
            (identical(other.address, address) ||
                const DeepCollectionEquality()
                    .equals(other.address, address)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.tin, tin) ||
                const DeepCollectionEquality().equals(other.tin, tin)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(tin) ^
      const DeepCollectionEquality().hash(type) ^
      runtimeType.hashCode;
}

extension $Credit1099FilerExtension on Credit1099Filer {
  Credit1099Filer copyWith(
      {CreditPayStubAddress? address,
      String? name,
      String? tin,
      String? type}) {
    return Credit1099Filer(
        address: address ?? this.address,
        name: name ?? this.name,
        tin: tin ?? this.tin,
        type: type ?? this.type);
  }

  Credit1099Filer copyWithWrapped(
      {Wrapped<CreditPayStubAddress?>? address,
      Wrapped<String?>? name,
      Wrapped<String?>? tin,
      Wrapped<String?>? type}) {
    return Credit1099Filer(
        address: (address != null ? address.value : this.address),
        name: (name != null ? name.value : this.name),
        tin: (tin != null ? tin.value : this.tin),
        type: (type != null ? type.value : this.type));
  }
}

@JsonSerializable(explicitToJson: true)
class CreditPayStub {
  CreditPayStub({
    required this.deductions,
    required this.documentId,
    required this.documentMetadata,
    required this.earnings,
    required this.employee,
    required this.employer,
    required this.netPay,
    required this.payPeriodDetails,
  });

  factory CreditPayStub.fromJson(Map<String, dynamic> json) =>
      _$CreditPayStubFromJson(json);

  @JsonKey(name: 'deductions')
  final CreditPayStubDeductions deductions;
  @JsonKey(name: 'document_id')
  final String? documentId;
  @JsonKey(name: 'document_metadata')
  final CreditDocumentMetadata documentMetadata;
  @JsonKey(name: 'earnings')
  final CreditPayStubEarnings earnings;
  @JsonKey(name: 'employee')
  final CreditPayStubEmployee employee;
  @JsonKey(name: 'employer')
  final CreditPayStubEmployer employer;
  @JsonKey(name: 'net_pay')
  final CreditPayStubNetPay netPay;
  @JsonKey(name: 'pay_period_details')
  final PayStubPayPeriodDetails payPeriodDetails;
  static const fromJsonFactory = _$CreditPayStubFromJson;
  static const toJsonFactory = _$CreditPayStubToJson;
  Map<String, dynamic> toJson() => _$CreditPayStubToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CreditPayStub &&
            (identical(other.deductions, deductions) ||
                const DeepCollectionEquality()
                    .equals(other.deductions, deductions)) &&
            (identical(other.documentId, documentId) ||
                const DeepCollectionEquality()
                    .equals(other.documentId, documentId)) &&
            (identical(other.documentMetadata, documentMetadata) ||
                const DeepCollectionEquality()
                    .equals(other.documentMetadata, documentMetadata)) &&
            (identical(other.earnings, earnings) ||
                const DeepCollectionEquality()
                    .equals(other.earnings, earnings)) &&
            (identical(other.employee, employee) ||
                const DeepCollectionEquality()
                    .equals(other.employee, employee)) &&
            (identical(other.employer, employer) ||
                const DeepCollectionEquality()
                    .equals(other.employer, employer)) &&
            (identical(other.netPay, netPay) ||
                const DeepCollectionEquality().equals(other.netPay, netPay)) &&
            (identical(other.payPeriodDetails, payPeriodDetails) ||
                const DeepCollectionEquality()
                    .equals(other.payPeriodDetails, payPeriodDetails)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(deductions) ^
      const DeepCollectionEquality().hash(documentId) ^
      const DeepCollectionEquality().hash(documentMetadata) ^
      const DeepCollectionEquality().hash(earnings) ^
      const DeepCollectionEquality().hash(employee) ^
      const DeepCollectionEquality().hash(employer) ^
      const DeepCollectionEquality().hash(netPay) ^
      const DeepCollectionEquality().hash(payPeriodDetails) ^
      runtimeType.hashCode;
}

extension $CreditPayStubExtension on CreditPayStub {
  CreditPayStub copyWith(
      {CreditPayStubDeductions? deductions,
      String? documentId,
      CreditDocumentMetadata? documentMetadata,
      CreditPayStubEarnings? earnings,
      CreditPayStubEmployee? employee,
      CreditPayStubEmployer? employer,
      CreditPayStubNetPay? netPay,
      PayStubPayPeriodDetails? payPeriodDetails}) {
    return CreditPayStub(
        deductions: deductions ?? this.deductions,
        documentId: documentId ?? this.documentId,
        documentMetadata: documentMetadata ?? this.documentMetadata,
        earnings: earnings ?? this.earnings,
        employee: employee ?? this.employee,
        employer: employer ?? this.employer,
        netPay: netPay ?? this.netPay,
        payPeriodDetails: payPeriodDetails ?? this.payPeriodDetails);
  }

  CreditPayStub copyWithWrapped(
      {Wrapped<CreditPayStubDeductions>? deductions,
      Wrapped<String?>? documentId,
      Wrapped<CreditDocumentMetadata>? documentMetadata,
      Wrapped<CreditPayStubEarnings>? earnings,
      Wrapped<CreditPayStubEmployee>? employee,
      Wrapped<CreditPayStubEmployer>? employer,
      Wrapped<CreditPayStubNetPay>? netPay,
      Wrapped<PayStubPayPeriodDetails>? payPeriodDetails}) {
    return CreditPayStub(
        deductions: (deductions != null ? deductions.value : this.deductions),
        documentId: (documentId != null ? documentId.value : this.documentId),
        documentMetadata: (documentMetadata != null
            ? documentMetadata.value
            : this.documentMetadata),
        earnings: (earnings != null ? earnings.value : this.earnings),
        employee: (employee != null ? employee.value : this.employee),
        employer: (employer != null ? employer.value : this.employer),
        netPay: (netPay != null ? netPay.value : this.netPay),
        payPeriodDetails: (payPeriodDetails != null
            ? payPeriodDetails.value
            : this.payPeriodDetails));
  }
}

@JsonSerializable(explicitToJson: true)
class CreditPayStubDeductions {
  CreditPayStubDeductions({
    required this.breakdown,
    required this.total,
  });

  factory CreditPayStubDeductions.fromJson(Map<String, dynamic> json) =>
      _$CreditPayStubDeductionsFromJson(json);

  @JsonKey(name: 'breakdown', defaultValue: <PayStubDeductionsBreakdown>[])
  final List<PayStubDeductionsBreakdown> breakdown;
  @JsonKey(name: 'total')
  final PayStubDeductionsTotal total;
  static const fromJsonFactory = _$CreditPayStubDeductionsFromJson;
  static const toJsonFactory = _$CreditPayStubDeductionsToJson;
  Map<String, dynamic> toJson() => _$CreditPayStubDeductionsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CreditPayStubDeductions &&
            (identical(other.breakdown, breakdown) ||
                const DeepCollectionEquality()
                    .equals(other.breakdown, breakdown)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(breakdown) ^
      const DeepCollectionEquality().hash(total) ^
      runtimeType.hashCode;
}

extension $CreditPayStubDeductionsExtension on CreditPayStubDeductions {
  CreditPayStubDeductions copyWith(
      {List<PayStubDeductionsBreakdown>? breakdown,
      PayStubDeductionsTotal? total}) {
    return CreditPayStubDeductions(
        breakdown: breakdown ?? this.breakdown, total: total ?? this.total);
  }

  CreditPayStubDeductions copyWithWrapped(
      {Wrapped<List<PayStubDeductionsBreakdown>>? breakdown,
      Wrapped<PayStubDeductionsTotal>? total}) {
    return CreditPayStubDeductions(
        breakdown: (breakdown != null ? breakdown.value : this.breakdown),
        total: (total != null ? total.value : this.total));
  }
}

@JsonSerializable(explicitToJson: true)
class PayStubDeductionsBreakdown {
  PayStubDeductionsBreakdown({
    required this.currentAmount,
    required this.description,
    required this.isoCurrencyCode,
    required this.unofficialCurrencyCode,
    required this.ytdAmount,
  });

  factory PayStubDeductionsBreakdown.fromJson(Map<String, dynamic> json) =>
      _$PayStubDeductionsBreakdownFromJson(json);

  @JsonKey(name: 'current_amount')
  final double? currentAmount;
  @JsonKey(name: 'description')
  final String? description;
  @JsonKey(name: 'iso_currency_code')
  final String? isoCurrencyCode;
  @JsonKey(name: 'unofficial_currency_code')
  final String? unofficialCurrencyCode;
  @JsonKey(name: 'ytd_amount')
  final double? ytdAmount;
  static const fromJsonFactory = _$PayStubDeductionsBreakdownFromJson;
  static const toJsonFactory = _$PayStubDeductionsBreakdownToJson;
  Map<String, dynamic> toJson() => _$PayStubDeductionsBreakdownToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PayStubDeductionsBreakdown &&
            (identical(other.currentAmount, currentAmount) ||
                const DeepCollectionEquality()
                    .equals(other.currentAmount, currentAmount)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)) &&
            (identical(other.unofficialCurrencyCode, unofficialCurrencyCode) ||
                const DeepCollectionEquality().equals(
                    other.unofficialCurrencyCode, unofficialCurrencyCode)) &&
            (identical(other.ytdAmount, ytdAmount) ||
                const DeepCollectionEquality()
                    .equals(other.ytdAmount, ytdAmount)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(currentAmount) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      const DeepCollectionEquality().hash(unofficialCurrencyCode) ^
      const DeepCollectionEquality().hash(ytdAmount) ^
      runtimeType.hashCode;
}

extension $PayStubDeductionsBreakdownExtension on PayStubDeductionsBreakdown {
  PayStubDeductionsBreakdown copyWith(
      {double? currentAmount,
      String? description,
      String? isoCurrencyCode,
      String? unofficialCurrencyCode,
      double? ytdAmount}) {
    return PayStubDeductionsBreakdown(
        currentAmount: currentAmount ?? this.currentAmount,
        description: description ?? this.description,
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode,
        unofficialCurrencyCode:
            unofficialCurrencyCode ?? this.unofficialCurrencyCode,
        ytdAmount: ytdAmount ?? this.ytdAmount);
  }

  PayStubDeductionsBreakdown copyWithWrapped(
      {Wrapped<double?>? currentAmount,
      Wrapped<String?>? description,
      Wrapped<String?>? isoCurrencyCode,
      Wrapped<String?>? unofficialCurrencyCode,
      Wrapped<double?>? ytdAmount}) {
    return PayStubDeductionsBreakdown(
        currentAmount:
            (currentAmount != null ? currentAmount.value : this.currentAmount),
        description:
            (description != null ? description.value : this.description),
        isoCurrencyCode: (isoCurrencyCode != null
            ? isoCurrencyCode.value
            : this.isoCurrencyCode),
        unofficialCurrencyCode: (unofficialCurrencyCode != null
            ? unofficialCurrencyCode.value
            : this.unofficialCurrencyCode),
        ytdAmount: (ytdAmount != null ? ytdAmount.value : this.ytdAmount));
  }
}

@JsonSerializable(explicitToJson: true)
class PayStubDeductionsTotal {
  PayStubDeductionsTotal({
    required this.currentAmount,
    required this.isoCurrencyCode,
    required this.unofficialCurrencyCode,
    required this.ytdAmount,
  });

  factory PayStubDeductionsTotal.fromJson(Map<String, dynamic> json) =>
      _$PayStubDeductionsTotalFromJson(json);

  @JsonKey(name: 'current_amount')
  final double? currentAmount;
  @JsonKey(name: 'iso_currency_code')
  final String? isoCurrencyCode;
  @JsonKey(name: 'unofficial_currency_code')
  final String? unofficialCurrencyCode;
  @JsonKey(name: 'ytd_amount')
  final double? ytdAmount;
  static const fromJsonFactory = _$PayStubDeductionsTotalFromJson;
  static const toJsonFactory = _$PayStubDeductionsTotalToJson;
  Map<String, dynamic> toJson() => _$PayStubDeductionsTotalToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PayStubDeductionsTotal &&
            (identical(other.currentAmount, currentAmount) ||
                const DeepCollectionEquality()
                    .equals(other.currentAmount, currentAmount)) &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)) &&
            (identical(other.unofficialCurrencyCode, unofficialCurrencyCode) ||
                const DeepCollectionEquality().equals(
                    other.unofficialCurrencyCode, unofficialCurrencyCode)) &&
            (identical(other.ytdAmount, ytdAmount) ||
                const DeepCollectionEquality()
                    .equals(other.ytdAmount, ytdAmount)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(currentAmount) ^
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      const DeepCollectionEquality().hash(unofficialCurrencyCode) ^
      const DeepCollectionEquality().hash(ytdAmount) ^
      runtimeType.hashCode;
}

extension $PayStubDeductionsTotalExtension on PayStubDeductionsTotal {
  PayStubDeductionsTotal copyWith(
      {double? currentAmount,
      String? isoCurrencyCode,
      String? unofficialCurrencyCode,
      double? ytdAmount}) {
    return PayStubDeductionsTotal(
        currentAmount: currentAmount ?? this.currentAmount,
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode,
        unofficialCurrencyCode:
            unofficialCurrencyCode ?? this.unofficialCurrencyCode,
        ytdAmount: ytdAmount ?? this.ytdAmount);
  }

  PayStubDeductionsTotal copyWithWrapped(
      {Wrapped<double?>? currentAmount,
      Wrapped<String?>? isoCurrencyCode,
      Wrapped<String?>? unofficialCurrencyCode,
      Wrapped<double?>? ytdAmount}) {
    return PayStubDeductionsTotal(
        currentAmount:
            (currentAmount != null ? currentAmount.value : this.currentAmount),
        isoCurrencyCode: (isoCurrencyCode != null
            ? isoCurrencyCode.value
            : this.isoCurrencyCode),
        unofficialCurrencyCode: (unofficialCurrencyCode != null
            ? unofficialCurrencyCode.value
            : this.unofficialCurrencyCode),
        ytdAmount: (ytdAmount != null ? ytdAmount.value : this.ytdAmount));
  }
}

@JsonSerializable(explicitToJson: true)
class CreditPayStubEarnings {
  CreditPayStubEarnings({
    required this.breakdown,
    required this.total,
  });

  factory CreditPayStubEarnings.fromJson(Map<String, dynamic> json) =>
      _$CreditPayStubEarningsFromJson(json);

  @JsonKey(name: 'breakdown', defaultValue: <PayStubEarningsBreakdown>[])
  final List<PayStubEarningsBreakdown> breakdown;
  @JsonKey(name: 'total')
  final PayStubEarningsTotal total;
  static const fromJsonFactory = _$CreditPayStubEarningsFromJson;
  static const toJsonFactory = _$CreditPayStubEarningsToJson;
  Map<String, dynamic> toJson() => _$CreditPayStubEarningsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CreditPayStubEarnings &&
            (identical(other.breakdown, breakdown) ||
                const DeepCollectionEquality()
                    .equals(other.breakdown, breakdown)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(breakdown) ^
      const DeepCollectionEquality().hash(total) ^
      runtimeType.hashCode;
}

extension $CreditPayStubEarningsExtension on CreditPayStubEarnings {
  CreditPayStubEarnings copyWith(
      {List<PayStubEarningsBreakdown>? breakdown,
      PayStubEarningsTotal? total}) {
    return CreditPayStubEarnings(
        breakdown: breakdown ?? this.breakdown, total: total ?? this.total);
  }

  CreditPayStubEarnings copyWithWrapped(
      {Wrapped<List<PayStubEarningsBreakdown>>? breakdown,
      Wrapped<PayStubEarningsTotal>? total}) {
    return CreditPayStubEarnings(
        breakdown: (breakdown != null ? breakdown.value : this.breakdown),
        total: (total != null ? total.value : this.total));
  }
}

@JsonSerializable(explicitToJson: true)
class PayStubEarningsBreakdown {
  PayStubEarningsBreakdown({
    required this.canonicalDescription,
    required this.currentAmount,
    required this.description,
    required this.hours,
    required this.isoCurrencyCode,
    required this.rate,
    required this.unofficialCurrencyCode,
    required this.ytdAmount,
  });

  factory PayStubEarningsBreakdown.fromJson(Map<String, dynamic> json) =>
      _$PayStubEarningsBreakdownFromJson(json);

  @JsonKey(name: 'canonical_description')
  final String? canonicalDescription;
  @JsonKey(name: 'current_amount')
  final double? currentAmount;
  @JsonKey(name: 'description')
  final String? description;
  @JsonKey(name: 'hours')
  final double? hours;
  @JsonKey(name: 'iso_currency_code')
  final String? isoCurrencyCode;
  @JsonKey(name: 'rate')
  final double? rate;
  @JsonKey(name: 'unofficial_currency_code')
  final String? unofficialCurrencyCode;
  @JsonKey(name: 'ytd_amount')
  final double? ytdAmount;
  static const fromJsonFactory = _$PayStubEarningsBreakdownFromJson;
  static const toJsonFactory = _$PayStubEarningsBreakdownToJson;
  Map<String, dynamic> toJson() => _$PayStubEarningsBreakdownToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PayStubEarningsBreakdown &&
            (identical(other.canonicalDescription, canonicalDescription) ||
                const DeepCollectionEquality().equals(
                    other.canonicalDescription, canonicalDescription)) &&
            (identical(other.currentAmount, currentAmount) ||
                const DeepCollectionEquality()
                    .equals(other.currentAmount, currentAmount)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.hours, hours) ||
                const DeepCollectionEquality().equals(other.hours, hours)) &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)) &&
            (identical(other.rate, rate) ||
                const DeepCollectionEquality().equals(other.rate, rate)) &&
            (identical(other.unofficialCurrencyCode, unofficialCurrencyCode) ||
                const DeepCollectionEquality().equals(
                    other.unofficialCurrencyCode, unofficialCurrencyCode)) &&
            (identical(other.ytdAmount, ytdAmount) ||
                const DeepCollectionEquality()
                    .equals(other.ytdAmount, ytdAmount)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(canonicalDescription) ^
      const DeepCollectionEquality().hash(currentAmount) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(hours) ^
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      const DeepCollectionEquality().hash(rate) ^
      const DeepCollectionEquality().hash(unofficialCurrencyCode) ^
      const DeepCollectionEquality().hash(ytdAmount) ^
      runtimeType.hashCode;
}

extension $PayStubEarningsBreakdownExtension on PayStubEarningsBreakdown {
  PayStubEarningsBreakdown copyWith(
      {String? canonicalDescription,
      double? currentAmount,
      String? description,
      double? hours,
      String? isoCurrencyCode,
      double? rate,
      String? unofficialCurrencyCode,
      double? ytdAmount}) {
    return PayStubEarningsBreakdown(
        canonicalDescription: canonicalDescription ?? this.canonicalDescription,
        currentAmount: currentAmount ?? this.currentAmount,
        description: description ?? this.description,
        hours: hours ?? this.hours,
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode,
        rate: rate ?? this.rate,
        unofficialCurrencyCode:
            unofficialCurrencyCode ?? this.unofficialCurrencyCode,
        ytdAmount: ytdAmount ?? this.ytdAmount);
  }

  PayStubEarningsBreakdown copyWithWrapped(
      {Wrapped<String?>? canonicalDescription,
      Wrapped<double?>? currentAmount,
      Wrapped<String?>? description,
      Wrapped<double?>? hours,
      Wrapped<String?>? isoCurrencyCode,
      Wrapped<double?>? rate,
      Wrapped<String?>? unofficialCurrencyCode,
      Wrapped<double?>? ytdAmount}) {
    return PayStubEarningsBreakdown(
        canonicalDescription: (canonicalDescription != null
            ? canonicalDescription.value
            : this.canonicalDescription),
        currentAmount:
            (currentAmount != null ? currentAmount.value : this.currentAmount),
        description:
            (description != null ? description.value : this.description),
        hours: (hours != null ? hours.value : this.hours),
        isoCurrencyCode: (isoCurrencyCode != null
            ? isoCurrencyCode.value
            : this.isoCurrencyCode),
        rate: (rate != null ? rate.value : this.rate),
        unofficialCurrencyCode: (unofficialCurrencyCode != null
            ? unofficialCurrencyCode.value
            : this.unofficialCurrencyCode),
        ytdAmount: (ytdAmount != null ? ytdAmount.value : this.ytdAmount));
  }
}

@JsonSerializable(explicitToJson: true)
class PayStubEarningsTotal {
  PayStubEarningsTotal({
    required this.currentAmount,
    required this.hours,
    required this.isoCurrencyCode,
    required this.unofficialCurrencyCode,
    required this.ytdAmount,
  });

  factory PayStubEarningsTotal.fromJson(Map<String, dynamic> json) =>
      _$PayStubEarningsTotalFromJson(json);

  @JsonKey(name: 'current_amount')
  final double? currentAmount;
  @JsonKey(name: 'hours')
  final double? hours;
  @JsonKey(name: 'iso_currency_code')
  final String? isoCurrencyCode;
  @JsonKey(name: 'unofficial_currency_code')
  final String? unofficialCurrencyCode;
  @JsonKey(name: 'ytd_amount')
  final double? ytdAmount;
  static const fromJsonFactory = _$PayStubEarningsTotalFromJson;
  static const toJsonFactory = _$PayStubEarningsTotalToJson;
  Map<String, dynamic> toJson() => _$PayStubEarningsTotalToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PayStubEarningsTotal &&
            (identical(other.currentAmount, currentAmount) ||
                const DeepCollectionEquality()
                    .equals(other.currentAmount, currentAmount)) &&
            (identical(other.hours, hours) ||
                const DeepCollectionEquality().equals(other.hours, hours)) &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)) &&
            (identical(other.unofficialCurrencyCode, unofficialCurrencyCode) ||
                const DeepCollectionEquality().equals(
                    other.unofficialCurrencyCode, unofficialCurrencyCode)) &&
            (identical(other.ytdAmount, ytdAmount) ||
                const DeepCollectionEquality()
                    .equals(other.ytdAmount, ytdAmount)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(currentAmount) ^
      const DeepCollectionEquality().hash(hours) ^
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      const DeepCollectionEquality().hash(unofficialCurrencyCode) ^
      const DeepCollectionEquality().hash(ytdAmount) ^
      runtimeType.hashCode;
}

extension $PayStubEarningsTotalExtension on PayStubEarningsTotal {
  PayStubEarningsTotal copyWith(
      {double? currentAmount,
      double? hours,
      String? isoCurrencyCode,
      String? unofficialCurrencyCode,
      double? ytdAmount}) {
    return PayStubEarningsTotal(
        currentAmount: currentAmount ?? this.currentAmount,
        hours: hours ?? this.hours,
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode,
        unofficialCurrencyCode:
            unofficialCurrencyCode ?? this.unofficialCurrencyCode,
        ytdAmount: ytdAmount ?? this.ytdAmount);
  }

  PayStubEarningsTotal copyWithWrapped(
      {Wrapped<double?>? currentAmount,
      Wrapped<double?>? hours,
      Wrapped<String?>? isoCurrencyCode,
      Wrapped<String?>? unofficialCurrencyCode,
      Wrapped<double?>? ytdAmount}) {
    return PayStubEarningsTotal(
        currentAmount:
            (currentAmount != null ? currentAmount.value : this.currentAmount),
        hours: (hours != null ? hours.value : this.hours),
        isoCurrencyCode: (isoCurrencyCode != null
            ? isoCurrencyCode.value
            : this.isoCurrencyCode),
        unofficialCurrencyCode: (unofficialCurrencyCode != null
            ? unofficialCurrencyCode.value
            : this.unofficialCurrencyCode),
        ytdAmount: (ytdAmount != null ? ytdAmount.value : this.ytdAmount));
  }
}

@JsonSerializable(explicitToJson: true)
class CreditPayStubEmployee {
  CreditPayStubEmployee({
    required this.address,
    required this.name,
    required this.maritalStatus,
    required this.taxpayerId,
  });

  factory CreditPayStubEmployee.fromJson(Map<String, dynamic> json) =>
      _$CreditPayStubEmployeeFromJson(json);

  @JsonKey(name: 'address')
  final CreditPayStubAddress address;
  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'marital_status')
  final String? maritalStatus;
  @JsonKey(name: 'taxpayer_id')
  final PayStubTaxpayerID taxpayerId;
  static const fromJsonFactory = _$CreditPayStubEmployeeFromJson;
  static const toJsonFactory = _$CreditPayStubEmployeeToJson;
  Map<String, dynamic> toJson() => _$CreditPayStubEmployeeToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CreditPayStubEmployee &&
            (identical(other.address, address) ||
                const DeepCollectionEquality()
                    .equals(other.address, address)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.maritalStatus, maritalStatus) ||
                const DeepCollectionEquality()
                    .equals(other.maritalStatus, maritalStatus)) &&
            (identical(other.taxpayerId, taxpayerId) ||
                const DeepCollectionEquality()
                    .equals(other.taxpayerId, taxpayerId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(maritalStatus) ^
      const DeepCollectionEquality().hash(taxpayerId) ^
      runtimeType.hashCode;
}

extension $CreditPayStubEmployeeExtension on CreditPayStubEmployee {
  CreditPayStubEmployee copyWith(
      {CreditPayStubAddress? address,
      String? name,
      String? maritalStatus,
      PayStubTaxpayerID? taxpayerId}) {
    return CreditPayStubEmployee(
        address: address ?? this.address,
        name: name ?? this.name,
        maritalStatus: maritalStatus ?? this.maritalStatus,
        taxpayerId: taxpayerId ?? this.taxpayerId);
  }

  CreditPayStubEmployee copyWithWrapped(
      {Wrapped<CreditPayStubAddress>? address,
      Wrapped<String?>? name,
      Wrapped<String?>? maritalStatus,
      Wrapped<PayStubTaxpayerID>? taxpayerId}) {
    return CreditPayStubEmployee(
        address: (address != null ? address.value : this.address),
        name: (name != null ? name.value : this.name),
        maritalStatus:
            (maritalStatus != null ? maritalStatus.value : this.maritalStatus),
        taxpayerId: (taxpayerId != null ? taxpayerId.value : this.taxpayerId));
  }
}

@JsonSerializable(explicitToJson: true)
class CreditPayStubAddress {
  CreditPayStubAddress({
    required this.city,
    required this.country,
    required this.postalCode,
    required this.region,
    required this.street,
  });

  factory CreditPayStubAddress.fromJson(Map<String, dynamic> json) =>
      _$CreditPayStubAddressFromJson(json);

  @JsonKey(name: 'city')
  final String? city;
  @JsonKey(name: 'country')
  final String? country;
  @JsonKey(name: 'postal_code')
  final String? postalCode;
  @JsonKey(name: 'region')
  final String? region;
  @JsonKey(name: 'street')
  final String? street;
  static const fromJsonFactory = _$CreditPayStubAddressFromJson;
  static const toJsonFactory = _$CreditPayStubAddressToJson;
  Map<String, dynamic> toJson() => _$CreditPayStubAddressToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CreditPayStubAddress &&
            (identical(other.city, city) ||
                const DeepCollectionEquality().equals(other.city, city)) &&
            (identical(other.country, country) ||
                const DeepCollectionEquality()
                    .equals(other.country, country)) &&
            (identical(other.postalCode, postalCode) ||
                const DeepCollectionEquality()
                    .equals(other.postalCode, postalCode)) &&
            (identical(other.region, region) ||
                const DeepCollectionEquality().equals(other.region, region)) &&
            (identical(other.street, street) ||
                const DeepCollectionEquality().equals(other.street, street)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(city) ^
      const DeepCollectionEquality().hash(country) ^
      const DeepCollectionEquality().hash(postalCode) ^
      const DeepCollectionEquality().hash(region) ^
      const DeepCollectionEquality().hash(street) ^
      runtimeType.hashCode;
}

extension $CreditPayStubAddressExtension on CreditPayStubAddress {
  CreditPayStubAddress copyWith(
      {String? city,
      String? country,
      String? postalCode,
      String? region,
      String? street}) {
    return CreditPayStubAddress(
        city: city ?? this.city,
        country: country ?? this.country,
        postalCode: postalCode ?? this.postalCode,
        region: region ?? this.region,
        street: street ?? this.street);
  }

  CreditPayStubAddress copyWithWrapped(
      {Wrapped<String?>? city,
      Wrapped<String?>? country,
      Wrapped<String?>? postalCode,
      Wrapped<String?>? region,
      Wrapped<String?>? street}) {
    return CreditPayStubAddress(
        city: (city != null ? city.value : this.city),
        country: (country != null ? country.value : this.country),
        postalCode: (postalCode != null ? postalCode.value : this.postalCode),
        region: (region != null ? region.value : this.region),
        street: (street != null ? street.value : this.street));
  }
}

@JsonSerializable(explicitToJson: true)
class PayStubTaxpayerID {
  PayStubTaxpayerID({
    required this.idType,
    required this.idMask,
  });

  factory PayStubTaxpayerID.fromJson(Map<String, dynamic> json) =>
      _$PayStubTaxpayerIDFromJson(json);

  @JsonKey(name: 'id_type')
  final String? idType;
  @JsonKey(name: 'id_mask')
  final String? idMask;
  static const fromJsonFactory = _$PayStubTaxpayerIDFromJson;
  static const toJsonFactory = _$PayStubTaxpayerIDToJson;
  Map<String, dynamic> toJson() => _$PayStubTaxpayerIDToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PayStubTaxpayerID &&
            (identical(other.idType, idType) ||
                const DeepCollectionEquality().equals(other.idType, idType)) &&
            (identical(other.idMask, idMask) ||
                const DeepCollectionEquality().equals(other.idMask, idMask)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(idType) ^
      const DeepCollectionEquality().hash(idMask) ^
      runtimeType.hashCode;
}

extension $PayStubTaxpayerIDExtension on PayStubTaxpayerID {
  PayStubTaxpayerID copyWith({String? idType, String? idMask}) {
    return PayStubTaxpayerID(
        idType: idType ?? this.idType, idMask: idMask ?? this.idMask);
  }

  PayStubTaxpayerID copyWithWrapped(
      {Wrapped<String?>? idType, Wrapped<String?>? idMask}) {
    return PayStubTaxpayerID(
        idType: (idType != null ? idType.value : this.idType),
        idMask: (idMask != null ? idMask.value : this.idMask));
  }
}

@JsonSerializable(explicitToJson: true)
class CreditPayStubEmployer {
  CreditPayStubEmployer({
    required this.address,
    required this.name,
  });

  factory CreditPayStubEmployer.fromJson(Map<String, dynamic> json) =>
      _$CreditPayStubEmployerFromJson(json);

  @JsonKey(name: 'address')
  final CreditPayStubAddress address;
  @JsonKey(name: 'name')
  final String? name;
  static const fromJsonFactory = _$CreditPayStubEmployerFromJson;
  static const toJsonFactory = _$CreditPayStubEmployerToJson;
  Map<String, dynamic> toJson() => _$CreditPayStubEmployerToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CreditPayStubEmployer &&
            (identical(other.address, address) ||
                const DeepCollectionEquality()
                    .equals(other.address, address)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(name) ^
      runtimeType.hashCode;
}

extension $CreditPayStubEmployerExtension on CreditPayStubEmployer {
  CreditPayStubEmployer copyWith(
      {CreditPayStubAddress? address, String? name}) {
    return CreditPayStubEmployer(
        address: address ?? this.address, name: name ?? this.name);
  }

  CreditPayStubEmployer copyWithWrapped(
      {Wrapped<CreditPayStubAddress>? address, Wrapped<String?>? name}) {
    return CreditPayStubEmployer(
        address: (address != null ? address.value : this.address),
        name: (name != null ? name.value : this.name));
  }
}

@JsonSerializable(explicitToJson: true)
class CreditPayStubNetPay {
  CreditPayStubNetPay({
    required this.currentAmount,
    required this.description,
    required this.isoCurrencyCode,
    required this.unofficialCurrencyCode,
    required this.ytdAmount,
  });

  factory CreditPayStubNetPay.fromJson(Map<String, dynamic> json) =>
      _$CreditPayStubNetPayFromJson(json);

  @JsonKey(name: 'current_amount')
  final double? currentAmount;
  @JsonKey(name: 'description')
  final String? description;
  @JsonKey(name: 'iso_currency_code')
  final String? isoCurrencyCode;
  @JsonKey(name: 'unofficial_currency_code')
  final String? unofficialCurrencyCode;
  @JsonKey(name: 'ytd_amount')
  final double? ytdAmount;
  static const fromJsonFactory = _$CreditPayStubNetPayFromJson;
  static const toJsonFactory = _$CreditPayStubNetPayToJson;
  Map<String, dynamic> toJson() => _$CreditPayStubNetPayToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CreditPayStubNetPay &&
            (identical(other.currentAmount, currentAmount) ||
                const DeepCollectionEquality()
                    .equals(other.currentAmount, currentAmount)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)) &&
            (identical(other.unofficialCurrencyCode, unofficialCurrencyCode) ||
                const DeepCollectionEquality().equals(
                    other.unofficialCurrencyCode, unofficialCurrencyCode)) &&
            (identical(other.ytdAmount, ytdAmount) ||
                const DeepCollectionEquality()
                    .equals(other.ytdAmount, ytdAmount)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(currentAmount) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      const DeepCollectionEquality().hash(unofficialCurrencyCode) ^
      const DeepCollectionEquality().hash(ytdAmount) ^
      runtimeType.hashCode;
}

extension $CreditPayStubNetPayExtension on CreditPayStubNetPay {
  CreditPayStubNetPay copyWith(
      {double? currentAmount,
      String? description,
      String? isoCurrencyCode,
      String? unofficialCurrencyCode,
      double? ytdAmount}) {
    return CreditPayStubNetPay(
        currentAmount: currentAmount ?? this.currentAmount,
        description: description ?? this.description,
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode,
        unofficialCurrencyCode:
            unofficialCurrencyCode ?? this.unofficialCurrencyCode,
        ytdAmount: ytdAmount ?? this.ytdAmount);
  }

  CreditPayStubNetPay copyWithWrapped(
      {Wrapped<double?>? currentAmount,
      Wrapped<String?>? description,
      Wrapped<String?>? isoCurrencyCode,
      Wrapped<String?>? unofficialCurrencyCode,
      Wrapped<double?>? ytdAmount}) {
    return CreditPayStubNetPay(
        currentAmount:
            (currentAmount != null ? currentAmount.value : this.currentAmount),
        description:
            (description != null ? description.value : this.description),
        isoCurrencyCode: (isoCurrencyCode != null
            ? isoCurrencyCode.value
            : this.isoCurrencyCode),
        unofficialCurrencyCode: (unofficialCurrencyCode != null
            ? unofficialCurrencyCode.value
            : this.unofficialCurrencyCode),
        ytdAmount: (ytdAmount != null ? ytdAmount.value : this.ytdAmount));
  }
}

@JsonSerializable(explicitToJson: true)
class PayStubPayPeriodDetails {
  PayStubPayPeriodDetails({
    required this.payAmount,
    required this.distributionBreakdown,
    required this.endDate,
    required this.grossEarnings,
    required this.isoCurrencyCode,
    required this.payDate,
    required this.payFrequency,
    required this.startDate,
    required this.unofficialCurrencyCode,
  });

  factory PayStubPayPeriodDetails.fromJson(Map<String, dynamic> json) =>
      _$PayStubPayPeriodDetailsFromJson(json);

  @JsonKey(name: 'pay_amount')
  final double? payAmount;
  @JsonKey(
      name: 'distribution_breakdown',
      defaultValue: <PayStubDistributionBreakdown>[])
  final List<PayStubDistributionBreakdown> distributionBreakdown;
  @JsonKey(name: 'end_date', toJson: _dateToJson)
  final DateTime? endDate;
  @JsonKey(name: 'gross_earnings')
  final double? grossEarnings;
  @JsonKey(name: 'iso_currency_code')
  final String? isoCurrencyCode;
  @JsonKey(name: 'pay_date', toJson: _dateToJson)
  final DateTime? payDate;
  @JsonKey(name: 'pay_frequency')
  final String? payFrequency;
  @JsonKey(name: 'start_date', toJson: _dateToJson)
  final DateTime? startDate;
  @JsonKey(name: 'unofficial_currency_code')
  final String? unofficialCurrencyCode;
  static const fromJsonFactory = _$PayStubPayPeriodDetailsFromJson;
  static const toJsonFactory = _$PayStubPayPeriodDetailsToJson;
  Map<String, dynamic> toJson() => _$PayStubPayPeriodDetailsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PayStubPayPeriodDetails &&
            (identical(other.payAmount, payAmount) ||
                const DeepCollectionEquality()
                    .equals(other.payAmount, payAmount)) &&
            (identical(other.distributionBreakdown, distributionBreakdown) ||
                const DeepCollectionEquality().equals(
                    other.distributionBreakdown, distributionBreakdown)) &&
            (identical(other.endDate, endDate) ||
                const DeepCollectionEquality()
                    .equals(other.endDate, endDate)) &&
            (identical(other.grossEarnings, grossEarnings) ||
                const DeepCollectionEquality()
                    .equals(other.grossEarnings, grossEarnings)) &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)) &&
            (identical(other.payDate, payDate) ||
                const DeepCollectionEquality()
                    .equals(other.payDate, payDate)) &&
            (identical(other.payFrequency, payFrequency) ||
                const DeepCollectionEquality()
                    .equals(other.payFrequency, payFrequency)) &&
            (identical(other.startDate, startDate) ||
                const DeepCollectionEquality()
                    .equals(other.startDate, startDate)) &&
            (identical(other.unofficialCurrencyCode, unofficialCurrencyCode) ||
                const DeepCollectionEquality().equals(
                    other.unofficialCurrencyCode, unofficialCurrencyCode)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(payAmount) ^
      const DeepCollectionEquality().hash(distributionBreakdown) ^
      const DeepCollectionEquality().hash(endDate) ^
      const DeepCollectionEquality().hash(grossEarnings) ^
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      const DeepCollectionEquality().hash(payDate) ^
      const DeepCollectionEquality().hash(payFrequency) ^
      const DeepCollectionEquality().hash(startDate) ^
      const DeepCollectionEquality().hash(unofficialCurrencyCode) ^
      runtimeType.hashCode;
}

extension $PayStubPayPeriodDetailsExtension on PayStubPayPeriodDetails {
  PayStubPayPeriodDetails copyWith(
      {double? payAmount,
      List<PayStubDistributionBreakdown>? distributionBreakdown,
      DateTime? endDate,
      double? grossEarnings,
      String? isoCurrencyCode,
      DateTime? payDate,
      String? payFrequency,
      DateTime? startDate,
      String? unofficialCurrencyCode}) {
    return PayStubPayPeriodDetails(
        payAmount: payAmount ?? this.payAmount,
        distributionBreakdown:
            distributionBreakdown ?? this.distributionBreakdown,
        endDate: endDate ?? this.endDate,
        grossEarnings: grossEarnings ?? this.grossEarnings,
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode,
        payDate: payDate ?? this.payDate,
        payFrequency: payFrequency ?? this.payFrequency,
        startDate: startDate ?? this.startDate,
        unofficialCurrencyCode:
            unofficialCurrencyCode ?? this.unofficialCurrencyCode);
  }

  PayStubPayPeriodDetails copyWithWrapped(
      {Wrapped<double?>? payAmount,
      Wrapped<List<PayStubDistributionBreakdown>>? distributionBreakdown,
      Wrapped<DateTime?>? endDate,
      Wrapped<double?>? grossEarnings,
      Wrapped<String?>? isoCurrencyCode,
      Wrapped<DateTime?>? payDate,
      Wrapped<String?>? payFrequency,
      Wrapped<DateTime?>? startDate,
      Wrapped<String?>? unofficialCurrencyCode}) {
    return PayStubPayPeriodDetails(
        payAmount: (payAmount != null ? payAmount.value : this.payAmount),
        distributionBreakdown: (distributionBreakdown != null
            ? distributionBreakdown.value
            : this.distributionBreakdown),
        endDate: (endDate != null ? endDate.value : this.endDate),
        grossEarnings:
            (grossEarnings != null ? grossEarnings.value : this.grossEarnings),
        isoCurrencyCode: (isoCurrencyCode != null
            ? isoCurrencyCode.value
            : this.isoCurrencyCode),
        payDate: (payDate != null ? payDate.value : this.payDate),
        payFrequency:
            (payFrequency != null ? payFrequency.value : this.payFrequency),
        startDate: (startDate != null ? startDate.value : this.startDate),
        unofficialCurrencyCode: (unofficialCurrencyCode != null
            ? unofficialCurrencyCode.value
            : this.unofficialCurrencyCode));
  }
}

@JsonSerializable(explicitToJson: true)
class PayStubDistributionBreakdown {
  PayStubDistributionBreakdown({
    required this.accountName,
    required this.bankName,
    required this.currentAmount,
    required this.isoCurrencyCode,
    required this.mask,
    required this.type,
    required this.unofficialCurrencyCode,
  });

  factory PayStubDistributionBreakdown.fromJson(Map<String, dynamic> json) =>
      _$PayStubDistributionBreakdownFromJson(json);

  @JsonKey(name: 'account_name')
  final String? accountName;
  @JsonKey(name: 'bank_name')
  final String? bankName;
  @JsonKey(name: 'current_amount')
  final double? currentAmount;
  @JsonKey(name: 'iso_currency_code')
  final String? isoCurrencyCode;
  @JsonKey(name: 'mask')
  final String? mask;
  @JsonKey(name: 'type')
  final String? type;
  @JsonKey(name: 'unofficial_currency_code')
  final String? unofficialCurrencyCode;
  static const fromJsonFactory = _$PayStubDistributionBreakdownFromJson;
  static const toJsonFactory = _$PayStubDistributionBreakdownToJson;
  Map<String, dynamic> toJson() => _$PayStubDistributionBreakdownToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PayStubDistributionBreakdown &&
            (identical(other.accountName, accountName) ||
                const DeepCollectionEquality()
                    .equals(other.accountName, accountName)) &&
            (identical(other.bankName, bankName) ||
                const DeepCollectionEquality()
                    .equals(other.bankName, bankName)) &&
            (identical(other.currentAmount, currentAmount) ||
                const DeepCollectionEquality()
                    .equals(other.currentAmount, currentAmount)) &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)) &&
            (identical(other.mask, mask) ||
                const DeepCollectionEquality().equals(other.mask, mask)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.unofficialCurrencyCode, unofficialCurrencyCode) ||
                const DeepCollectionEquality().equals(
                    other.unofficialCurrencyCode, unofficialCurrencyCode)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountName) ^
      const DeepCollectionEquality().hash(bankName) ^
      const DeepCollectionEquality().hash(currentAmount) ^
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      const DeepCollectionEquality().hash(mask) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(unofficialCurrencyCode) ^
      runtimeType.hashCode;
}

extension $PayStubDistributionBreakdownExtension
    on PayStubDistributionBreakdown {
  PayStubDistributionBreakdown copyWith(
      {String? accountName,
      String? bankName,
      double? currentAmount,
      String? isoCurrencyCode,
      String? mask,
      String? type,
      String? unofficialCurrencyCode}) {
    return PayStubDistributionBreakdown(
        accountName: accountName ?? this.accountName,
        bankName: bankName ?? this.bankName,
        currentAmount: currentAmount ?? this.currentAmount,
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode,
        mask: mask ?? this.mask,
        type: type ?? this.type,
        unofficialCurrencyCode:
            unofficialCurrencyCode ?? this.unofficialCurrencyCode);
  }

  PayStubDistributionBreakdown copyWithWrapped(
      {Wrapped<String?>? accountName,
      Wrapped<String?>? bankName,
      Wrapped<double?>? currentAmount,
      Wrapped<String?>? isoCurrencyCode,
      Wrapped<String?>? mask,
      Wrapped<String?>? type,
      Wrapped<String?>? unofficialCurrencyCode}) {
    return PayStubDistributionBreakdown(
        accountName:
            (accountName != null ? accountName.value : this.accountName),
        bankName: (bankName != null ? bankName.value : this.bankName),
        currentAmount:
            (currentAmount != null ? currentAmount.value : this.currentAmount),
        isoCurrencyCode: (isoCurrencyCode != null
            ? isoCurrencyCode.value
            : this.isoCurrencyCode),
        mask: (mask != null ? mask.value : this.mask),
        type: (type != null ? type.value : this.type),
        unofficialCurrencyCode: (unofficialCurrencyCode != null
            ? unofficialCurrencyCode.value
            : this.unofficialCurrencyCode));
  }
}

@JsonSerializable(explicitToJson: true)
class DocumentRiskSignal {
  DocumentRiskSignal({
    required this.type,
    required this.field,
    required this.hasFraudRisk,
    required this.institutionMetadata,
    required this.expectedValue,
    required this.actualValue,
    required this.signalDescription,
    required this.pageNumber,
  });

  factory DocumentRiskSignal.fromJson(Map<String, dynamic> json) =>
      _$DocumentRiskSignalFromJson(json);

  @JsonKey(name: 'type')
  final String? type;
  @JsonKey(name: 'field')
  final String? field;
  @JsonKey(name: 'has_fraud_risk')
  final bool? hasFraudRisk;
  @JsonKey(name: 'institution_metadata')
  final DocumentRiskSignalInstitutionMetadata? institutionMetadata;
  @JsonKey(name: 'expected_value')
  final String? expectedValue;
  @JsonKey(name: 'actual_value')
  final String? actualValue;
  @JsonKey(name: 'signal_description')
  final String? signalDescription;
  @JsonKey(name: 'page_number')
  final int? pageNumber;
  static const fromJsonFactory = _$DocumentRiskSignalFromJson;
  static const toJsonFactory = _$DocumentRiskSignalToJson;
  Map<String, dynamic> toJson() => _$DocumentRiskSignalToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is DocumentRiskSignal &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.field, field) ||
                const DeepCollectionEquality().equals(other.field, field)) &&
            (identical(other.hasFraudRisk, hasFraudRisk) ||
                const DeepCollectionEquality()
                    .equals(other.hasFraudRisk, hasFraudRisk)) &&
            (identical(other.institutionMetadata, institutionMetadata) ||
                const DeepCollectionEquality()
                    .equals(other.institutionMetadata, institutionMetadata)) &&
            (identical(other.expectedValue, expectedValue) ||
                const DeepCollectionEquality()
                    .equals(other.expectedValue, expectedValue)) &&
            (identical(other.actualValue, actualValue) ||
                const DeepCollectionEquality()
                    .equals(other.actualValue, actualValue)) &&
            (identical(other.signalDescription, signalDescription) ||
                const DeepCollectionEquality()
                    .equals(other.signalDescription, signalDescription)) &&
            (identical(other.pageNumber, pageNumber) ||
                const DeepCollectionEquality()
                    .equals(other.pageNumber, pageNumber)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(field) ^
      const DeepCollectionEquality().hash(hasFraudRisk) ^
      const DeepCollectionEquality().hash(institutionMetadata) ^
      const DeepCollectionEquality().hash(expectedValue) ^
      const DeepCollectionEquality().hash(actualValue) ^
      const DeepCollectionEquality().hash(signalDescription) ^
      const DeepCollectionEquality().hash(pageNumber) ^
      runtimeType.hashCode;
}

extension $DocumentRiskSignalExtension on DocumentRiskSignal {
  DocumentRiskSignal copyWith(
      {String? type,
      String? field,
      bool? hasFraudRisk,
      DocumentRiskSignalInstitutionMetadata? institutionMetadata,
      String? expectedValue,
      String? actualValue,
      String? signalDescription,
      int? pageNumber}) {
    return DocumentRiskSignal(
        type: type ?? this.type,
        field: field ?? this.field,
        hasFraudRisk: hasFraudRisk ?? this.hasFraudRisk,
        institutionMetadata: institutionMetadata ?? this.institutionMetadata,
        expectedValue: expectedValue ?? this.expectedValue,
        actualValue: actualValue ?? this.actualValue,
        signalDescription: signalDescription ?? this.signalDescription,
        pageNumber: pageNumber ?? this.pageNumber);
  }

  DocumentRiskSignal copyWithWrapped(
      {Wrapped<String?>? type,
      Wrapped<String?>? field,
      Wrapped<bool?>? hasFraudRisk,
      Wrapped<DocumentRiskSignalInstitutionMetadata?>? institutionMetadata,
      Wrapped<String?>? expectedValue,
      Wrapped<String?>? actualValue,
      Wrapped<String?>? signalDescription,
      Wrapped<int?>? pageNumber}) {
    return DocumentRiskSignal(
        type: (type != null ? type.value : this.type),
        field: (field != null ? field.value : this.field),
        hasFraudRisk:
            (hasFraudRisk != null ? hasFraudRisk.value : this.hasFraudRisk),
        institutionMetadata: (institutionMetadata != null
            ? institutionMetadata.value
            : this.institutionMetadata),
        expectedValue:
            (expectedValue != null ? expectedValue.value : this.expectedValue),
        actualValue:
            (actualValue != null ? actualValue.value : this.actualValue),
        signalDescription: (signalDescription != null
            ? signalDescription.value
            : this.signalDescription),
        pageNumber: (pageNumber != null ? pageNumber.value : this.pageNumber));
  }
}

@JsonSerializable(explicitToJson: true)
class DocumentRiskSignalInstitutionMetadata {
  DocumentRiskSignalInstitutionMetadata({
    required this.itemId,
  });

  factory DocumentRiskSignalInstitutionMetadata.fromJson(
          Map<String, dynamic> json) =>
      _$DocumentRiskSignalInstitutionMetadataFromJson(json);

  @JsonKey(name: 'item_id')
  final String itemId;
  static const fromJsonFactory =
      _$DocumentRiskSignalInstitutionMetadataFromJson;
  static const toJsonFactory = _$DocumentRiskSignalInstitutionMetadataToJson;
  Map<String, dynamic> toJson() =>
      _$DocumentRiskSignalInstitutionMetadataToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is DocumentRiskSignalInstitutionMetadata &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(itemId) ^ runtimeType.hashCode;
}

extension $DocumentRiskSignalInstitutionMetadataExtension
    on DocumentRiskSignalInstitutionMetadata {
  DocumentRiskSignalInstitutionMetadata copyWith({String? itemId}) {
    return DocumentRiskSignalInstitutionMetadata(itemId: itemId ?? this.itemId);
  }

  DocumentRiskSignalInstitutionMetadata copyWithWrapped(
      {Wrapped<String>? itemId}) {
    return DocumentRiskSignalInstitutionMetadata(
        itemId: (itemId != null ? itemId.value : this.itemId));
  }
}

@JsonSerializable(explicitToJson: true)
class PayrollItemStatus {
  PayrollItemStatus({
    this.processingStatus,
  });

  factory PayrollItemStatus.fromJson(Map<String, dynamic> json) =>
      _$PayrollItemStatusFromJson(json);

  @JsonKey(name: 'processing_status')
  final String? processingStatus;
  static const fromJsonFactory = _$PayrollItemStatusFromJson;
  static const toJsonFactory = _$PayrollItemStatusToJson;
  Map<String, dynamic> toJson() => _$PayrollItemStatusToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PayrollItemStatus &&
            (identical(other.processingStatus, processingStatus) ||
                const DeepCollectionEquality()
                    .equals(other.processingStatus, processingStatus)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(processingStatus) ^
      runtimeType.hashCode;
}

extension $PayrollItemStatusExtension on PayrollItemStatus {
  PayrollItemStatus copyWith({String? processingStatus}) {
    return PayrollItemStatus(
        processingStatus: processingStatus ?? this.processingStatus);
  }

  PayrollItemStatus copyWithWrapped({Wrapped<String?>? processingStatus}) {
    return PayrollItemStatus(
        processingStatus: (processingStatus != null
            ? processingStatus.value
            : this.processingStatus));
  }
}

@JsonSerializable(explicitToJson: true)
class CreditW2 {
  CreditW2({
    required this.documentMetadata,
    required this.documentId,
    required this.employer,
    required this.employee,
    required this.taxYear,
    required this.employerIdNumber,
    required this.wagesTipsOtherComp,
    required this.federalIncomeTaxWithheld,
    required this.socialSecurityWages,
    required this.socialSecurityTaxWithheld,
    required this.medicareWagesAndTips,
    required this.medicareTaxWithheld,
    required this.socialSecurityTips,
    required this.allocatedTips,
    required this.box9,
    required this.dependentCareBenefits,
    required this.nonqualifiedPlans,
    required this.box12,
    required this.statutoryEmployee,
    required this.retirementPlan,
    required this.thirdPartySickPay,
    required this.other,
    required this.stateAndLocalWages,
  });

  factory CreditW2.fromJson(Map<String, dynamic> json) =>
      _$CreditW2FromJson(json);

  @JsonKey(name: 'document_metadata')
  final CreditDocumentMetadata documentMetadata;
  @JsonKey(name: 'document_id')
  final String documentId;
  @JsonKey(name: 'employer')
  final CreditPayStubEmployer employer;
  @JsonKey(name: 'employee')
  final CreditPayStubEmployee employee;
  @JsonKey(name: 'tax_year')
  final String? taxYear;
  @JsonKey(name: 'employer_id_number')
  final String? employerIdNumber;
  @JsonKey(name: 'wages_tips_other_comp')
  final String? wagesTipsOtherComp;
  @JsonKey(name: 'federal_income_tax_withheld')
  final String? federalIncomeTaxWithheld;
  @JsonKey(name: 'social_security_wages')
  final String? socialSecurityWages;
  @JsonKey(name: 'social_security_tax_withheld')
  final String? socialSecurityTaxWithheld;
  @JsonKey(name: 'medicare_wages_and_tips')
  final String? medicareWagesAndTips;
  @JsonKey(name: 'medicare_tax_withheld')
  final String? medicareTaxWithheld;
  @JsonKey(name: 'social_security_tips')
  final String? socialSecurityTips;
  @JsonKey(name: 'allocated_tips')
  final String? allocatedTips;
  @JsonKey(name: 'box_9')
  final String? box9;
  @JsonKey(name: 'dependent_care_benefits')
  final String? dependentCareBenefits;
  @JsonKey(name: 'nonqualified_plans')
  final String? nonqualifiedPlans;
  @JsonKey(name: 'box_12', defaultValue: <W2Box12>[])
  final List<W2Box12> box12;
  @JsonKey(name: 'statutory_employee')
  final String? statutoryEmployee;
  @JsonKey(name: 'retirement_plan')
  final String? retirementPlan;
  @JsonKey(name: 'third_party_sick_pay')
  final String? thirdPartySickPay;
  @JsonKey(name: 'other')
  final String? other;
  @JsonKey(
      name: 'state_and_local_wages', defaultValue: <W2StateAndLocalWages>[])
  final List<W2StateAndLocalWages> stateAndLocalWages;
  static const fromJsonFactory = _$CreditW2FromJson;
  static const toJsonFactory = _$CreditW2ToJson;
  Map<String, dynamic> toJson() => _$CreditW2ToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CreditW2 &&
            (identical(other.documentMetadata, documentMetadata) ||
                const DeepCollectionEquality()
                    .equals(other.documentMetadata, documentMetadata)) &&
            (identical(other.documentId, documentId) ||
                const DeepCollectionEquality()
                    .equals(other.documentId, documentId)) &&
            (identical(other.employer, employer) ||
                const DeepCollectionEquality()
                    .equals(other.employer, employer)) &&
            (identical(other.employee, employee) ||
                const DeepCollectionEquality()
                    .equals(other.employee, employee)) &&
            (identical(other.taxYear, taxYear) ||
                const DeepCollectionEquality()
                    .equals(other.taxYear, taxYear)) &&
            (identical(other.employerIdNumber, employerIdNumber) ||
                const DeepCollectionEquality()
                    .equals(other.employerIdNumber, employerIdNumber)) &&
            (identical(other.wagesTipsOtherComp, wagesTipsOtherComp) ||
                const DeepCollectionEquality()
                    .equals(other.wagesTipsOtherComp, wagesTipsOtherComp)) &&
            (identical(other.federalIncomeTaxWithheld, federalIncomeTaxWithheld) ||
                const DeepCollectionEquality().equals(
                    other.federalIncomeTaxWithheld,
                    federalIncomeTaxWithheld)) &&
            (identical(other.socialSecurityWages, socialSecurityWages) ||
                const DeepCollectionEquality()
                    .equals(other.socialSecurityWages, socialSecurityWages)) &&
            (identical(other.socialSecurityTaxWithheld, socialSecurityTaxWithheld) ||
                const DeepCollectionEquality().equals(
                    other.socialSecurityTaxWithheld,
                    socialSecurityTaxWithheld)) &&
            (identical(other.medicareWagesAndTips, medicareWagesAndTips) ||
                const DeepCollectionEquality().equals(
                    other.medicareWagesAndTips, medicareWagesAndTips)) &&
            (identical(other.medicareTaxWithheld, medicareTaxWithheld) ||
                const DeepCollectionEquality()
                    .equals(other.medicareTaxWithheld, medicareTaxWithheld)) &&
            (identical(other.socialSecurityTips, socialSecurityTips) ||
                const DeepCollectionEquality()
                    .equals(other.socialSecurityTips, socialSecurityTips)) &&
            (identical(other.allocatedTips, allocatedTips) ||
                const DeepCollectionEquality()
                    .equals(other.allocatedTips, allocatedTips)) &&
            (identical(other.box9, box9) ||
                const DeepCollectionEquality().equals(other.box9, box9)) &&
            (identical(other.dependentCareBenefits, dependentCareBenefits) ||
                const DeepCollectionEquality().equals(
                    other.dependentCareBenefits, dependentCareBenefits)) &&
            (identical(other.nonqualifiedPlans, nonqualifiedPlans) ||
                const DeepCollectionEquality().equals(other.nonqualifiedPlans, nonqualifiedPlans)) &&
            (identical(other.box12, box12) || const DeepCollectionEquality().equals(other.box12, box12)) &&
            (identical(other.statutoryEmployee, statutoryEmployee) || const DeepCollectionEquality().equals(other.statutoryEmployee, statutoryEmployee)) &&
            (identical(other.retirementPlan, retirementPlan) || const DeepCollectionEquality().equals(other.retirementPlan, retirementPlan)) &&
            (identical(other.thirdPartySickPay, thirdPartySickPay) || const DeepCollectionEquality().equals(other.thirdPartySickPay, thirdPartySickPay)) &&
            (identical(other.other, other) || const DeepCollectionEquality().equals(other.other, other)) &&
            (identical(other.stateAndLocalWages, stateAndLocalWages) || const DeepCollectionEquality().equals(other.stateAndLocalWages, stateAndLocalWages)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(documentMetadata) ^
      const DeepCollectionEquality().hash(documentId) ^
      const DeepCollectionEquality().hash(employer) ^
      const DeepCollectionEquality().hash(employee) ^
      const DeepCollectionEquality().hash(taxYear) ^
      const DeepCollectionEquality().hash(employerIdNumber) ^
      const DeepCollectionEquality().hash(wagesTipsOtherComp) ^
      const DeepCollectionEquality().hash(federalIncomeTaxWithheld) ^
      const DeepCollectionEquality().hash(socialSecurityWages) ^
      const DeepCollectionEquality().hash(socialSecurityTaxWithheld) ^
      const DeepCollectionEquality().hash(medicareWagesAndTips) ^
      const DeepCollectionEquality().hash(medicareTaxWithheld) ^
      const DeepCollectionEquality().hash(socialSecurityTips) ^
      const DeepCollectionEquality().hash(allocatedTips) ^
      const DeepCollectionEquality().hash(box9) ^
      const DeepCollectionEquality().hash(dependentCareBenefits) ^
      const DeepCollectionEquality().hash(nonqualifiedPlans) ^
      const DeepCollectionEquality().hash(box12) ^
      const DeepCollectionEquality().hash(statutoryEmployee) ^
      const DeepCollectionEquality().hash(retirementPlan) ^
      const DeepCollectionEquality().hash(thirdPartySickPay) ^
      const DeepCollectionEquality().hash(other) ^
      const DeepCollectionEquality().hash(stateAndLocalWages) ^
      runtimeType.hashCode;
}

extension $CreditW2Extension on CreditW2 {
  CreditW2 copyWith(
      {CreditDocumentMetadata? documentMetadata,
      String? documentId,
      CreditPayStubEmployer? employer,
      CreditPayStubEmployee? employee,
      String? taxYear,
      String? employerIdNumber,
      String? wagesTipsOtherComp,
      String? federalIncomeTaxWithheld,
      String? socialSecurityWages,
      String? socialSecurityTaxWithheld,
      String? medicareWagesAndTips,
      String? medicareTaxWithheld,
      String? socialSecurityTips,
      String? allocatedTips,
      String? box9,
      String? dependentCareBenefits,
      String? nonqualifiedPlans,
      List<W2Box12>? box12,
      String? statutoryEmployee,
      String? retirementPlan,
      String? thirdPartySickPay,
      String? other,
      List<W2StateAndLocalWages>? stateAndLocalWages}) {
    return CreditW2(
        documentMetadata: documentMetadata ?? this.documentMetadata,
        documentId: documentId ?? this.documentId,
        employer: employer ?? this.employer,
        employee: employee ?? this.employee,
        taxYear: taxYear ?? this.taxYear,
        employerIdNumber: employerIdNumber ?? this.employerIdNumber,
        wagesTipsOtherComp: wagesTipsOtherComp ?? this.wagesTipsOtherComp,
        federalIncomeTaxWithheld:
            federalIncomeTaxWithheld ?? this.federalIncomeTaxWithheld,
        socialSecurityWages: socialSecurityWages ?? this.socialSecurityWages,
        socialSecurityTaxWithheld:
            socialSecurityTaxWithheld ?? this.socialSecurityTaxWithheld,
        medicareWagesAndTips: medicareWagesAndTips ?? this.medicareWagesAndTips,
        medicareTaxWithheld: medicareTaxWithheld ?? this.medicareTaxWithheld,
        socialSecurityTips: socialSecurityTips ?? this.socialSecurityTips,
        allocatedTips: allocatedTips ?? this.allocatedTips,
        box9: box9 ?? this.box9,
        dependentCareBenefits:
            dependentCareBenefits ?? this.dependentCareBenefits,
        nonqualifiedPlans: nonqualifiedPlans ?? this.nonqualifiedPlans,
        box12: box12 ?? this.box12,
        statutoryEmployee: statutoryEmployee ?? this.statutoryEmployee,
        retirementPlan: retirementPlan ?? this.retirementPlan,
        thirdPartySickPay: thirdPartySickPay ?? this.thirdPartySickPay,
        other: other ?? this.other,
        stateAndLocalWages: stateAndLocalWages ?? this.stateAndLocalWages);
  }

  CreditW2 copyWithWrapped(
      {Wrapped<CreditDocumentMetadata>? documentMetadata,
      Wrapped<String>? documentId,
      Wrapped<CreditPayStubEmployer>? employer,
      Wrapped<CreditPayStubEmployee>? employee,
      Wrapped<String?>? taxYear,
      Wrapped<String?>? employerIdNumber,
      Wrapped<String?>? wagesTipsOtherComp,
      Wrapped<String?>? federalIncomeTaxWithheld,
      Wrapped<String?>? socialSecurityWages,
      Wrapped<String?>? socialSecurityTaxWithheld,
      Wrapped<String?>? medicareWagesAndTips,
      Wrapped<String?>? medicareTaxWithheld,
      Wrapped<String?>? socialSecurityTips,
      Wrapped<String?>? allocatedTips,
      Wrapped<String?>? box9,
      Wrapped<String?>? dependentCareBenefits,
      Wrapped<String?>? nonqualifiedPlans,
      Wrapped<List<W2Box12>>? box12,
      Wrapped<String?>? statutoryEmployee,
      Wrapped<String?>? retirementPlan,
      Wrapped<String?>? thirdPartySickPay,
      Wrapped<String?>? other,
      Wrapped<List<W2StateAndLocalWages>>? stateAndLocalWages}) {
    return CreditW2(
        documentMetadata: (documentMetadata != null
            ? documentMetadata.value
            : this.documentMetadata),
        documentId: (documentId != null ? documentId.value : this.documentId),
        employer: (employer != null ? employer.value : this.employer),
        employee: (employee != null ? employee.value : this.employee),
        taxYear: (taxYear != null ? taxYear.value : this.taxYear),
        employerIdNumber: (employerIdNumber != null
            ? employerIdNumber.value
            : this.employerIdNumber),
        wagesTipsOtherComp: (wagesTipsOtherComp != null
            ? wagesTipsOtherComp.value
            : this.wagesTipsOtherComp),
        federalIncomeTaxWithheld: (federalIncomeTaxWithheld != null
            ? federalIncomeTaxWithheld.value
            : this.federalIncomeTaxWithheld),
        socialSecurityWages: (socialSecurityWages != null
            ? socialSecurityWages.value
            : this.socialSecurityWages),
        socialSecurityTaxWithheld: (socialSecurityTaxWithheld != null
            ? socialSecurityTaxWithheld.value
            : this.socialSecurityTaxWithheld),
        medicareWagesAndTips: (medicareWagesAndTips != null
            ? medicareWagesAndTips.value
            : this.medicareWagesAndTips),
        medicareTaxWithheld: (medicareTaxWithheld != null
            ? medicareTaxWithheld.value
            : this.medicareTaxWithheld),
        socialSecurityTips: (socialSecurityTips != null
            ? socialSecurityTips.value
            : this.socialSecurityTips),
        allocatedTips:
            (allocatedTips != null ? allocatedTips.value : this.allocatedTips),
        box9: (box9 != null ? box9.value : this.box9),
        dependentCareBenefits: (dependentCareBenefits != null
            ? dependentCareBenefits.value
            : this.dependentCareBenefits),
        nonqualifiedPlans: (nonqualifiedPlans != null
            ? nonqualifiedPlans.value
            : this.nonqualifiedPlans),
        box12: (box12 != null ? box12.value : this.box12),
        statutoryEmployee: (statutoryEmployee != null
            ? statutoryEmployee.value
            : this.statutoryEmployee),
        retirementPlan: (retirementPlan != null
            ? retirementPlan.value
            : this.retirementPlan),
        thirdPartySickPay: (thirdPartySickPay != null
            ? thirdPartySickPay.value
            : this.thirdPartySickPay),
        other: (other != null ? other.value : this.other),
        stateAndLocalWages: (stateAndLocalWages != null
            ? stateAndLocalWages.value
            : this.stateAndLocalWages));
  }
}

@JsonSerializable(explicitToJson: true)
class PayrollIncomeRateOfPay {
  PayrollIncomeRateOfPay({
    this.payRate,
    this.payAmount,
  });

  factory PayrollIncomeRateOfPay.fromJson(Map<String, dynamic> json) =>
      _$PayrollIncomeRateOfPayFromJson(json);

  @JsonKey(name: 'pay_rate')
  final String? payRate;
  @JsonKey(name: 'pay_amount')
  final double? payAmount;
  static const fromJsonFactory = _$PayrollIncomeRateOfPayFromJson;
  static const toJsonFactory = _$PayrollIncomeRateOfPayToJson;
  Map<String, dynamic> toJson() => _$PayrollIncomeRateOfPayToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PayrollIncomeRateOfPay &&
            (identical(other.payRate, payRate) ||
                const DeepCollectionEquality()
                    .equals(other.payRate, payRate)) &&
            (identical(other.payAmount, payAmount) ||
                const DeepCollectionEquality()
                    .equals(other.payAmount, payAmount)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(payRate) ^
      const DeepCollectionEquality().hash(payAmount) ^
      runtimeType.hashCode;
}

extension $PayrollIncomeRateOfPayExtension on PayrollIncomeRateOfPay {
  PayrollIncomeRateOfPay copyWith({String? payRate, double? payAmount}) {
    return PayrollIncomeRateOfPay(
        payRate: payRate ?? this.payRate,
        payAmount: payAmount ?? this.payAmount);
  }

  PayrollIncomeRateOfPay copyWithWrapped(
      {Wrapped<String?>? payRate, Wrapped<double?>? payAmount}) {
    return PayrollIncomeRateOfPay(
        payRate: (payRate != null ? payRate.value : this.payRate),
        payAmount: (payAmount != null ? payAmount.value : this.payAmount));
  }
}

@JsonSerializable(explicitToJson: true)
class CreditPayrollIncomePrecheckRequest {
  CreditPayrollIncomePrecheckRequest({
    this.clientId,
    this.secret,
    this.userToken,
    this.accessTokens,
    this.employer,
    this.usMilitaryInfo,
    this.payrollInstitution,
  });

  factory CreditPayrollIncomePrecheckRequest.fromJson(
          Map<String, dynamic> json) =>
      _$CreditPayrollIncomePrecheckRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'user_token')
  final String? userToken;
  @JsonKey(name: 'access_tokens', defaultValue: <String>[])
  final List<String>? accessTokens;
  @JsonKey(name: 'employer')
  final IncomeVerificationPrecheckEmployer? employer;
  @JsonKey(name: 'us_military_info')
  final IncomeVerificationPrecheckMilitaryInfo? usMilitaryInfo;
  @JsonKey(name: 'payroll_institution')
  final IncomeVerificationPrecheckPayrollInstitution? payrollInstitution;
  static const fromJsonFactory = _$CreditPayrollIncomePrecheckRequestFromJson;
  static const toJsonFactory = _$CreditPayrollIncomePrecheckRequestToJson;
  Map<String, dynamic> toJson() =>
      _$CreditPayrollIncomePrecheckRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CreditPayrollIncomePrecheckRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.userToken, userToken) ||
                const DeepCollectionEquality()
                    .equals(other.userToken, userToken)) &&
            (identical(other.accessTokens, accessTokens) ||
                const DeepCollectionEquality()
                    .equals(other.accessTokens, accessTokens)) &&
            (identical(other.employer, employer) ||
                const DeepCollectionEquality()
                    .equals(other.employer, employer)) &&
            (identical(other.usMilitaryInfo, usMilitaryInfo) ||
                const DeepCollectionEquality()
                    .equals(other.usMilitaryInfo, usMilitaryInfo)) &&
            (identical(other.payrollInstitution, payrollInstitution) ||
                const DeepCollectionEquality()
                    .equals(other.payrollInstitution, payrollInstitution)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(userToken) ^
      const DeepCollectionEquality().hash(accessTokens) ^
      const DeepCollectionEquality().hash(employer) ^
      const DeepCollectionEquality().hash(usMilitaryInfo) ^
      const DeepCollectionEquality().hash(payrollInstitution) ^
      runtimeType.hashCode;
}

extension $CreditPayrollIncomePrecheckRequestExtension
    on CreditPayrollIncomePrecheckRequest {
  CreditPayrollIncomePrecheckRequest copyWith(
      {String? clientId,
      String? secret,
      String? userToken,
      List<String>? accessTokens,
      IncomeVerificationPrecheckEmployer? employer,
      IncomeVerificationPrecheckMilitaryInfo? usMilitaryInfo,
      IncomeVerificationPrecheckPayrollInstitution? payrollInstitution}) {
    return CreditPayrollIncomePrecheckRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        userToken: userToken ?? this.userToken,
        accessTokens: accessTokens ?? this.accessTokens,
        employer: employer ?? this.employer,
        usMilitaryInfo: usMilitaryInfo ?? this.usMilitaryInfo,
        payrollInstitution: payrollInstitution ?? this.payrollInstitution);
  }

  CreditPayrollIncomePrecheckRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String?>? userToken,
      Wrapped<List<String>?>? accessTokens,
      Wrapped<IncomeVerificationPrecheckEmployer?>? employer,
      Wrapped<IncomeVerificationPrecheckMilitaryInfo?>? usMilitaryInfo,
      Wrapped<IncomeVerificationPrecheckPayrollInstitution?>?
          payrollInstitution}) {
    return CreditPayrollIncomePrecheckRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        userToken: (userToken != null ? userToken.value : this.userToken),
        accessTokens:
            (accessTokens != null ? accessTokens.value : this.accessTokens),
        employer: (employer != null ? employer.value : this.employer),
        usMilitaryInfo: (usMilitaryInfo != null
            ? usMilitaryInfo.value
            : this.usMilitaryInfo),
        payrollInstitution: (payrollInstitution != null
            ? payrollInstitution.value
            : this.payrollInstitution));
  }
}

@JsonSerializable(explicitToJson: true)
class CreditPayrollIncomePrecheckResponse {
  CreditPayrollIncomePrecheckResponse({
    required this.requestId,
    required this.confidence,
  });

  factory CreditPayrollIncomePrecheckResponse.fromJson(
          Map<String, dynamic> json) =>
      _$CreditPayrollIncomePrecheckResponseFromJson(json);

  @JsonKey(name: 'request_id')
  final String requestId;
  @JsonKey(
    name: 'confidence',
    toJson: incomeVerificationPrecheckConfidenceToJson,
    fromJson: incomeVerificationPrecheckConfidenceFromJson,
  )
  final enums.IncomeVerificationPrecheckConfidence confidence;
  static const fromJsonFactory = _$CreditPayrollIncomePrecheckResponseFromJson;
  static const toJsonFactory = _$CreditPayrollIncomePrecheckResponseToJson;
  Map<String, dynamic> toJson() =>
      _$CreditPayrollIncomePrecheckResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CreditPayrollIncomePrecheckResponse &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)) &&
            (identical(other.confidence, confidence) ||
                const DeepCollectionEquality()
                    .equals(other.confidence, confidence)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(requestId) ^
      const DeepCollectionEquality().hash(confidence) ^
      runtimeType.hashCode;
}

extension $CreditPayrollIncomePrecheckResponseExtension
    on CreditPayrollIncomePrecheckResponse {
  CreditPayrollIncomePrecheckResponse copyWith(
      {String? requestId,
      enums.IncomeVerificationPrecheckConfidence? confidence}) {
    return CreditPayrollIncomePrecheckResponse(
        requestId: requestId ?? this.requestId,
        confidence: confidence ?? this.confidence);
  }

  CreditPayrollIncomePrecheckResponse copyWithWrapped(
      {Wrapped<String>? requestId,
      Wrapped<enums.IncomeVerificationPrecheckConfidence>? confidence}) {
    return CreditPayrollIncomePrecheckResponse(
        requestId: (requestId != null ? requestId.value : this.requestId),
        confidence: (confidence != null ? confidence.value : this.confidence));
  }
}

@JsonSerializable(explicitToJson: true)
class CreditPayrollIncomeRefreshRequest {
  CreditPayrollIncomeRefreshRequest({
    this.clientId,
    this.secret,
    this.userToken,
  });

  factory CreditPayrollIncomeRefreshRequest.fromJson(
          Map<String, dynamic> json) =>
      _$CreditPayrollIncomeRefreshRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'user_token')
  final String? userToken;
  static const fromJsonFactory = _$CreditPayrollIncomeRefreshRequestFromJson;
  static const toJsonFactory = _$CreditPayrollIncomeRefreshRequestToJson;
  Map<String, dynamic> toJson() =>
      _$CreditPayrollIncomeRefreshRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CreditPayrollIncomeRefreshRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.userToken, userToken) ||
                const DeepCollectionEquality()
                    .equals(other.userToken, userToken)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(userToken) ^
      runtimeType.hashCode;
}

extension $CreditPayrollIncomeRefreshRequestExtension
    on CreditPayrollIncomeRefreshRequest {
  CreditPayrollIncomeRefreshRequest copyWith(
      {String? clientId, String? secret, String? userToken}) {
    return CreditPayrollIncomeRefreshRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        userToken: userToken ?? this.userToken);
  }

  CreditPayrollIncomeRefreshRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String?>? userToken}) {
    return CreditPayrollIncomeRefreshRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        userToken: (userToken != null ? userToken.value : this.userToken));
  }
}

@JsonSerializable(explicitToJson: true)
class CreditPayrollIncomeRefreshResponse {
  CreditPayrollIncomeRefreshResponse({
    required this.requestId,
    required this.verificationRefreshStatus,
  });

  factory CreditPayrollIncomeRefreshResponse.fromJson(
          Map<String, dynamic> json) =>
      _$CreditPayrollIncomeRefreshResponseFromJson(json);

  @JsonKey(name: 'request_id')
  final String requestId;
  @JsonKey(name: 'verification_refresh_status')
  final String verificationRefreshStatus;
  static const fromJsonFactory = _$CreditPayrollIncomeRefreshResponseFromJson;
  static const toJsonFactory = _$CreditPayrollIncomeRefreshResponseToJson;
  Map<String, dynamic> toJson() =>
      _$CreditPayrollIncomeRefreshResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CreditPayrollIncomeRefreshResponse &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)) &&
            (identical(other.verificationRefreshStatus,
                    verificationRefreshStatus) ||
                const DeepCollectionEquality().equals(
                    other.verificationRefreshStatus,
                    verificationRefreshStatus)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(requestId) ^
      const DeepCollectionEquality().hash(verificationRefreshStatus) ^
      runtimeType.hashCode;
}

extension $CreditPayrollIncomeRefreshResponseExtension
    on CreditPayrollIncomeRefreshResponse {
  CreditPayrollIncomeRefreshResponse copyWith(
      {String? requestId, String? verificationRefreshStatus}) {
    return CreditPayrollIncomeRefreshResponse(
        requestId: requestId ?? this.requestId,
        verificationRefreshStatus:
            verificationRefreshStatus ?? this.verificationRefreshStatus);
  }

  CreditPayrollIncomeRefreshResponse copyWithWrapped(
      {Wrapped<String>? requestId,
      Wrapped<String>? verificationRefreshStatus}) {
    return CreditPayrollIncomeRefreshResponse(
        requestId: (requestId != null ? requestId.value : this.requestId),
        verificationRefreshStatus: (verificationRefreshStatus != null
            ? verificationRefreshStatus.value
            : this.verificationRefreshStatus));
  }
}

@JsonSerializable(explicitToJson: true)
class CreditEmploymentGetRequest {
  CreditEmploymentGetRequest({
    this.clientId,
    this.secret,
    required this.userToken,
  });

  factory CreditEmploymentGetRequest.fromJson(Map<String, dynamic> json) =>
      _$CreditEmploymentGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'user_token')
  final String userToken;
  static const fromJsonFactory = _$CreditEmploymentGetRequestFromJson;
  static const toJsonFactory = _$CreditEmploymentGetRequestToJson;
  Map<String, dynamic> toJson() => _$CreditEmploymentGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CreditEmploymentGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.userToken, userToken) ||
                const DeepCollectionEquality()
                    .equals(other.userToken, userToken)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(userToken) ^
      runtimeType.hashCode;
}

extension $CreditEmploymentGetRequestExtension on CreditEmploymentGetRequest {
  CreditEmploymentGetRequest copyWith(
      {String? clientId, String? secret, String? userToken}) {
    return CreditEmploymentGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        userToken: userToken ?? this.userToken);
  }

  CreditEmploymentGetRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? userToken}) {
    return CreditEmploymentGetRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        userToken: (userToken != null ? userToken.value : this.userToken));
  }
}

@JsonSerializable(explicitToJson: true)
class CreditEmploymentGetResponse {
  CreditEmploymentGetResponse({
    required this.items,
    required this.requestId,
  });

  factory CreditEmploymentGetResponse.fromJson(Map<String, dynamic> json) =>
      _$CreditEmploymentGetResponseFromJson(json);

  @JsonKey(name: 'items', defaultValue: <CreditEmploymentItem>[])
  final List<CreditEmploymentItem> items;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$CreditEmploymentGetResponseFromJson;
  static const toJsonFactory = _$CreditEmploymentGetResponseToJson;
  Map<String, dynamic> toJson() => _$CreditEmploymentGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CreditEmploymentGetResponse &&
            (identical(other.items, items) ||
                const DeepCollectionEquality().equals(other.items, items)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(items) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $CreditEmploymentGetResponseExtension on CreditEmploymentGetResponse {
  CreditEmploymentGetResponse copyWith(
      {List<CreditEmploymentItem>? items, String? requestId}) {
    return CreditEmploymentGetResponse(
        items: items ?? this.items, requestId: requestId ?? this.requestId);
  }

  CreditEmploymentGetResponse copyWithWrapped(
      {Wrapped<List<CreditEmploymentItem>>? items,
      Wrapped<String>? requestId}) {
    return CreditEmploymentGetResponse(
        items: (items != null ? items.value : this.items),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class CreditEmploymentItem {
  CreditEmploymentItem({
    required this.itemId,
    required this.employments,
    this.employmentReportToken,
  });

  factory CreditEmploymentItem.fromJson(Map<String, dynamic> json) =>
      _$CreditEmploymentItemFromJson(json);

  @JsonKey(name: 'item_id')
  final String itemId;
  @JsonKey(name: 'employments', defaultValue: <CreditEmploymentVerification>[])
  final List<CreditEmploymentVerification> employments;
  @JsonKey(name: 'employment_report_token')
  final String? employmentReportToken;
  static const fromJsonFactory = _$CreditEmploymentItemFromJson;
  static const toJsonFactory = _$CreditEmploymentItemToJson;
  Map<String, dynamic> toJson() => _$CreditEmploymentItemToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CreditEmploymentItem &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)) &&
            (identical(other.employments, employments) ||
                const DeepCollectionEquality()
                    .equals(other.employments, employments)) &&
            (identical(other.employmentReportToken, employmentReportToken) ||
                const DeepCollectionEquality().equals(
                    other.employmentReportToken, employmentReportToken)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(itemId) ^
      const DeepCollectionEquality().hash(employments) ^
      const DeepCollectionEquality().hash(employmentReportToken) ^
      runtimeType.hashCode;
}

extension $CreditEmploymentItemExtension on CreditEmploymentItem {
  CreditEmploymentItem copyWith(
      {String? itemId,
      List<CreditEmploymentVerification>? employments,
      String? employmentReportToken}) {
    return CreditEmploymentItem(
        itemId: itemId ?? this.itemId,
        employments: employments ?? this.employments,
        employmentReportToken:
            employmentReportToken ?? this.employmentReportToken);
  }

  CreditEmploymentItem copyWithWrapped(
      {Wrapped<String>? itemId,
      Wrapped<List<CreditEmploymentVerification>>? employments,
      Wrapped<String?>? employmentReportToken}) {
    return CreditEmploymentItem(
        itemId: (itemId != null ? itemId.value : this.itemId),
        employments:
            (employments != null ? employments.value : this.employments),
        employmentReportToken: (employmentReportToken != null
            ? employmentReportToken.value
            : this.employmentReportToken));
  }
}

@JsonSerializable(explicitToJson: true)
class CreditEmploymentVerification {
  CreditEmploymentVerification({
    required this.accountId,
    required this.status,
    required this.startDate,
    required this.endDate,
    required this.employer,
    required this.title,
    required this.platformIds,
    required this.employeeType,
    required this.lastPaystubDate,
  });

  factory CreditEmploymentVerification.fromJson(Map<String, dynamic> json) =>
      _$CreditEmploymentVerificationFromJson(json);

  @JsonKey(name: 'account_id')
  final String? accountId;
  @JsonKey(name: 'status')
  final String? status;
  @JsonKey(name: 'start_date', toJson: _dateToJson)
  final DateTime? startDate;
  @JsonKey(name: 'end_date', toJson: _dateToJson)
  final DateTime? endDate;
  @JsonKey(name: 'employer')
  final CreditEmployerVerification employer;
  @JsonKey(name: 'title')
  final String? title;
  @JsonKey(name: 'platform_ids')
  final CreditPlatformIds platformIds;
  @JsonKey(name: 'employee_type')
  final String? employeeType;
  @JsonKey(name: 'last_paystub_date', toJson: _dateToJson)
  final DateTime? lastPaystubDate;
  static const fromJsonFactory = _$CreditEmploymentVerificationFromJson;
  static const toJsonFactory = _$CreditEmploymentVerificationToJson;
  Map<String, dynamic> toJson() => _$CreditEmploymentVerificationToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CreditEmploymentVerification &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.startDate, startDate) ||
                const DeepCollectionEquality()
                    .equals(other.startDate, startDate)) &&
            (identical(other.endDate, endDate) ||
                const DeepCollectionEquality()
                    .equals(other.endDate, endDate)) &&
            (identical(other.employer, employer) ||
                const DeepCollectionEquality()
                    .equals(other.employer, employer)) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.platformIds, platformIds) ||
                const DeepCollectionEquality()
                    .equals(other.platformIds, platformIds)) &&
            (identical(other.employeeType, employeeType) ||
                const DeepCollectionEquality()
                    .equals(other.employeeType, employeeType)) &&
            (identical(other.lastPaystubDate, lastPaystubDate) ||
                const DeepCollectionEquality()
                    .equals(other.lastPaystubDate, lastPaystubDate)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(startDate) ^
      const DeepCollectionEquality().hash(endDate) ^
      const DeepCollectionEquality().hash(employer) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(platformIds) ^
      const DeepCollectionEquality().hash(employeeType) ^
      const DeepCollectionEquality().hash(lastPaystubDate) ^
      runtimeType.hashCode;
}

extension $CreditEmploymentVerificationExtension
    on CreditEmploymentVerification {
  CreditEmploymentVerification copyWith(
      {String? accountId,
      String? status,
      DateTime? startDate,
      DateTime? endDate,
      CreditEmployerVerification? employer,
      String? title,
      CreditPlatformIds? platformIds,
      String? employeeType,
      DateTime? lastPaystubDate}) {
    return CreditEmploymentVerification(
        accountId: accountId ?? this.accountId,
        status: status ?? this.status,
        startDate: startDate ?? this.startDate,
        endDate: endDate ?? this.endDate,
        employer: employer ?? this.employer,
        title: title ?? this.title,
        platformIds: platformIds ?? this.platformIds,
        employeeType: employeeType ?? this.employeeType,
        lastPaystubDate: lastPaystubDate ?? this.lastPaystubDate);
  }

  CreditEmploymentVerification copyWithWrapped(
      {Wrapped<String?>? accountId,
      Wrapped<String?>? status,
      Wrapped<DateTime?>? startDate,
      Wrapped<DateTime?>? endDate,
      Wrapped<CreditEmployerVerification>? employer,
      Wrapped<String?>? title,
      Wrapped<CreditPlatformIds>? platformIds,
      Wrapped<String?>? employeeType,
      Wrapped<DateTime?>? lastPaystubDate}) {
    return CreditEmploymentVerification(
        accountId: (accountId != null ? accountId.value : this.accountId),
        status: (status != null ? status.value : this.status),
        startDate: (startDate != null ? startDate.value : this.startDate),
        endDate: (endDate != null ? endDate.value : this.endDate),
        employer: (employer != null ? employer.value : this.employer),
        title: (title != null ? title.value : this.title),
        platformIds:
            (platformIds != null ? platformIds.value : this.platformIds),
        employeeType:
            (employeeType != null ? employeeType.value : this.employeeType),
        lastPaystubDate: (lastPaystubDate != null
            ? lastPaystubDate.value
            : this.lastPaystubDate));
  }
}

@JsonSerializable(explicitToJson: true)
class CreditEmployerVerification {
  CreditEmployerVerification({
    required this.name,
  });

  factory CreditEmployerVerification.fromJson(Map<String, dynamic> json) =>
      _$CreditEmployerVerificationFromJson(json);

  @JsonKey(name: 'name')
  final String? name;
  static const fromJsonFactory = _$CreditEmployerVerificationFromJson;
  static const toJsonFactory = _$CreditEmployerVerificationToJson;
  Map<String, dynamic> toJson() => _$CreditEmployerVerificationToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CreditEmployerVerification &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^ runtimeType.hashCode;
}

extension $CreditEmployerVerificationExtension on CreditEmployerVerification {
  CreditEmployerVerification copyWith({String? name}) {
    return CreditEmployerVerification(name: name ?? this.name);
  }

  CreditEmployerVerification copyWithWrapped({Wrapped<String?>? name}) {
    return CreditEmployerVerification(
        name: (name != null ? name.value : this.name));
  }
}

@JsonSerializable(explicitToJson: true)
class CreditPlatformIds {
  CreditPlatformIds({
    required this.employeeId,
    required this.payrollId,
    required this.positionId,
  });

  factory CreditPlatformIds.fromJson(Map<String, dynamic> json) =>
      _$CreditPlatformIdsFromJson(json);

  @JsonKey(name: 'employee_id')
  final String? employeeId;
  @JsonKey(name: 'payroll_id')
  final String? payrollId;
  @JsonKey(name: 'position_id')
  final String? positionId;
  static const fromJsonFactory = _$CreditPlatformIdsFromJson;
  static const toJsonFactory = _$CreditPlatformIdsToJson;
  Map<String, dynamic> toJson() => _$CreditPlatformIdsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CreditPlatformIds &&
            (identical(other.employeeId, employeeId) ||
                const DeepCollectionEquality()
                    .equals(other.employeeId, employeeId)) &&
            (identical(other.payrollId, payrollId) ||
                const DeepCollectionEquality()
                    .equals(other.payrollId, payrollId)) &&
            (identical(other.positionId, positionId) ||
                const DeepCollectionEquality()
                    .equals(other.positionId, positionId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(employeeId) ^
      const DeepCollectionEquality().hash(payrollId) ^
      const DeepCollectionEquality().hash(positionId) ^
      runtimeType.hashCode;
}

extension $CreditPlatformIdsExtension on CreditPlatformIds {
  CreditPlatformIds copyWith(
      {String? employeeId, String? payrollId, String? positionId}) {
    return CreditPlatformIds(
        employeeId: employeeId ?? this.employeeId,
        payrollId: payrollId ?? this.payrollId,
        positionId: positionId ?? this.positionId);
  }

  CreditPlatformIds copyWithWrapped(
      {Wrapped<String?>? employeeId,
      Wrapped<String?>? payrollId,
      Wrapped<String?>? positionId}) {
    return CreditPlatformIds(
        employeeId: (employeeId != null ? employeeId.value : this.employeeId),
        payrollId: (payrollId != null ? payrollId.value : this.payrollId),
        positionId: (positionId != null ? positionId.value : this.positionId));
  }
}

@JsonSerializable(explicitToJson: true)
class CreditBankIncomeWarning {
  CreditBankIncomeWarning({
    this.warningType,
    this.warningCode,
    this.cause,
  });

  factory CreditBankIncomeWarning.fromJson(Map<String, dynamic> json) =>
      _$CreditBankIncomeWarningFromJson(json);

  @JsonKey(
    name: 'warning_type',
    toJson: creditBankIncomeWarningTypeToJson,
    fromJson: creditBankIncomeWarningTypeFromJson,
  )
  final enums.CreditBankIncomeWarningType? warningType;
  @JsonKey(
    name: 'warning_code',
    toJson: creditBankIncomeWarningCodeToJson,
    fromJson: creditBankIncomeWarningCodeFromJson,
  )
  final enums.CreditBankIncomeWarningCode? warningCode;
  @JsonKey(name: 'cause')
  final CreditBankIncomeCause? cause;
  static const fromJsonFactory = _$CreditBankIncomeWarningFromJson;
  static const toJsonFactory = _$CreditBankIncomeWarningToJson;
  Map<String, dynamic> toJson() => _$CreditBankIncomeWarningToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CreditBankIncomeWarning &&
            (identical(other.warningType, warningType) ||
                const DeepCollectionEquality()
                    .equals(other.warningType, warningType)) &&
            (identical(other.warningCode, warningCode) ||
                const DeepCollectionEquality()
                    .equals(other.warningCode, warningCode)) &&
            (identical(other.cause, cause) ||
                const DeepCollectionEquality().equals(other.cause, cause)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(warningType) ^
      const DeepCollectionEquality().hash(warningCode) ^
      const DeepCollectionEquality().hash(cause) ^
      runtimeType.hashCode;
}

extension $CreditBankIncomeWarningExtension on CreditBankIncomeWarning {
  CreditBankIncomeWarning copyWith(
      {enums.CreditBankIncomeWarningType? warningType,
      enums.CreditBankIncomeWarningCode? warningCode,
      CreditBankIncomeCause? cause}) {
    return CreditBankIncomeWarning(
        warningType: warningType ?? this.warningType,
        warningCode: warningCode ?? this.warningCode,
        cause: cause ?? this.cause);
  }

  CreditBankIncomeWarning copyWithWrapped(
      {Wrapped<enums.CreditBankIncomeWarningType?>? warningType,
      Wrapped<enums.CreditBankIncomeWarningCode?>? warningCode,
      Wrapped<CreditBankIncomeCause?>? cause}) {
    return CreditBankIncomeWarning(
        warningType:
            (warningType != null ? warningType.value : this.warningType),
        warningCode:
            (warningCode != null ? warningCode.value : this.warningCode),
        cause: (cause != null ? cause.value : this.cause));
  }
}

@JsonSerializable(explicitToJson: true)
class CreditBankIncomeCause {
  CreditBankIncomeCause({
    this.errorType,
    this.errorCode,
    this.errorMessage,
    this.displayMessage,
    this.itemId,
  });

  factory CreditBankIncomeCause.fromJson(Map<String, dynamic> json) =>
      _$CreditBankIncomeCauseFromJson(json);

  @JsonKey(
    name: 'error_type',
    toJson: creditBankIncomeErrorTypeToJson,
    fromJson: creditBankIncomeErrorTypeFromJson,
  )
  final enums.CreditBankIncomeErrorType? errorType;
  @JsonKey(name: 'error_code')
  final String? errorCode;
  @JsonKey(name: 'error_message')
  final String? errorMessage;
  @JsonKey(name: 'display_message')
  final String? displayMessage;
  @JsonKey(name: 'item_id')
  final String? itemId;
  static const fromJsonFactory = _$CreditBankIncomeCauseFromJson;
  static const toJsonFactory = _$CreditBankIncomeCauseToJson;
  Map<String, dynamic> toJson() => _$CreditBankIncomeCauseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CreditBankIncomeCause &&
            (identical(other.errorType, errorType) ||
                const DeepCollectionEquality()
                    .equals(other.errorType, errorType)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.errorMessage, errorMessage) ||
                const DeepCollectionEquality()
                    .equals(other.errorMessage, errorMessage)) &&
            (identical(other.displayMessage, displayMessage) ||
                const DeepCollectionEquality()
                    .equals(other.displayMessage, displayMessage)) &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(errorType) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(errorMessage) ^
      const DeepCollectionEquality().hash(displayMessage) ^
      const DeepCollectionEquality().hash(itemId) ^
      runtimeType.hashCode;
}

extension $CreditBankIncomeCauseExtension on CreditBankIncomeCause {
  CreditBankIncomeCause copyWith(
      {enums.CreditBankIncomeErrorType? errorType,
      String? errorCode,
      String? errorMessage,
      String? displayMessage,
      String? itemId}) {
    return CreditBankIncomeCause(
        errorType: errorType ?? this.errorType,
        errorCode: errorCode ?? this.errorCode,
        errorMessage: errorMessage ?? this.errorMessage,
        displayMessage: displayMessage ?? this.displayMessage,
        itemId: itemId ?? this.itemId);
  }

  CreditBankIncomeCause copyWithWrapped(
      {Wrapped<enums.CreditBankIncomeErrorType?>? errorType,
      Wrapped<String?>? errorCode,
      Wrapped<String?>? errorMessage,
      Wrapped<String?>? displayMessage,
      Wrapped<String?>? itemId}) {
    return CreditBankIncomeCause(
        errorType: (errorType != null ? errorType.value : this.errorType),
        errorCode: (errorCode != null ? errorCode.value : this.errorCode),
        errorMessage:
            (errorMessage != null ? errorMessage.value : this.errorMessage),
        displayMessage: (displayMessage != null
            ? displayMessage.value
            : this.displayMessage),
        itemId: (itemId != null ? itemId.value : this.itemId));
  }
}

@JsonSerializable(explicitToJson: true)
class CreditRelayCreateRequest {
  CreditRelayCreateRequest({
    this.clientId,
    this.secret,
    required this.reportTokens,
    required this.secondaryClientId,
    this.webhook,
  });

  factory CreditRelayCreateRequest.fromJson(Map<String, dynamic> json) =>
      _$CreditRelayCreateRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'report_tokens', defaultValue: <String>[])
  final List<String> reportTokens;
  @JsonKey(name: 'secondary_client_id')
  final String secondaryClientId;
  @JsonKey(name: 'webhook')
  final String? webhook;
  static const fromJsonFactory = _$CreditRelayCreateRequestFromJson;
  static const toJsonFactory = _$CreditRelayCreateRequestToJson;
  Map<String, dynamic> toJson() => _$CreditRelayCreateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CreditRelayCreateRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.reportTokens, reportTokens) ||
                const DeepCollectionEquality()
                    .equals(other.reportTokens, reportTokens)) &&
            (identical(other.secondaryClientId, secondaryClientId) ||
                const DeepCollectionEquality()
                    .equals(other.secondaryClientId, secondaryClientId)) &&
            (identical(other.webhook, webhook) ||
                const DeepCollectionEquality().equals(other.webhook, webhook)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(reportTokens) ^
      const DeepCollectionEquality().hash(secondaryClientId) ^
      const DeepCollectionEquality().hash(webhook) ^
      runtimeType.hashCode;
}

extension $CreditRelayCreateRequestExtension on CreditRelayCreateRequest {
  CreditRelayCreateRequest copyWith(
      {String? clientId,
      String? secret,
      List<String>? reportTokens,
      String? secondaryClientId,
      String? webhook}) {
    return CreditRelayCreateRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        reportTokens: reportTokens ?? this.reportTokens,
        secondaryClientId: secondaryClientId ?? this.secondaryClientId,
        webhook: webhook ?? this.webhook);
  }

  CreditRelayCreateRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<List<String>>? reportTokens,
      Wrapped<String>? secondaryClientId,
      Wrapped<String?>? webhook}) {
    return CreditRelayCreateRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        reportTokens:
            (reportTokens != null ? reportTokens.value : this.reportTokens),
        secondaryClientId: (secondaryClientId != null
            ? secondaryClientId.value
            : this.secondaryClientId),
        webhook: (webhook != null ? webhook.value : this.webhook));
  }
}

@JsonSerializable(explicitToJson: true)
class CreditRelayCreateResponse {
  CreditRelayCreateResponse({
    required this.relayToken,
    required this.requestId,
  });

  factory CreditRelayCreateResponse.fromJson(Map<String, dynamic> json) =>
      _$CreditRelayCreateResponseFromJson(json);

  @JsonKey(name: 'relay_token')
  final String relayToken;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$CreditRelayCreateResponseFromJson;
  static const toJsonFactory = _$CreditRelayCreateResponseToJson;
  Map<String, dynamic> toJson() => _$CreditRelayCreateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CreditRelayCreateResponse &&
            (identical(other.relayToken, relayToken) ||
                const DeepCollectionEquality()
                    .equals(other.relayToken, relayToken)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(relayToken) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $CreditRelayCreateResponseExtension on CreditRelayCreateResponse {
  CreditRelayCreateResponse copyWith({String? relayToken, String? requestId}) {
    return CreditRelayCreateResponse(
        relayToken: relayToken ?? this.relayToken,
        requestId: requestId ?? this.requestId);
  }

  CreditRelayCreateResponse copyWithWrapped(
      {Wrapped<String>? relayToken, Wrapped<String>? requestId}) {
    return CreditRelayCreateResponse(
        relayToken: (relayToken != null ? relayToken.value : this.relayToken),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class CreditRelayGetRequest {
  CreditRelayGetRequest({
    this.clientId,
    this.secret,
    required this.relayToken,
    required this.reportType,
  });

  factory CreditRelayGetRequest.fromJson(Map<String, dynamic> json) =>
      _$CreditRelayGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'relay_token')
  final String relayToken;
  @JsonKey(
    name: 'report_type',
    toJson: reportTypeToJson,
    fromJson: reportTypeFromJson,
  )
  final enums.ReportType reportType;
  static const fromJsonFactory = _$CreditRelayGetRequestFromJson;
  static const toJsonFactory = _$CreditRelayGetRequestToJson;
  Map<String, dynamic> toJson() => _$CreditRelayGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CreditRelayGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.relayToken, relayToken) ||
                const DeepCollectionEquality()
                    .equals(other.relayToken, relayToken)) &&
            (identical(other.reportType, reportType) ||
                const DeepCollectionEquality()
                    .equals(other.reportType, reportType)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(relayToken) ^
      const DeepCollectionEquality().hash(reportType) ^
      runtimeType.hashCode;
}

extension $CreditRelayGetRequestExtension on CreditRelayGetRequest {
  CreditRelayGetRequest copyWith(
      {String? clientId,
      String? secret,
      String? relayToken,
      enums.ReportType? reportType}) {
    return CreditRelayGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        relayToken: relayToken ?? this.relayToken,
        reportType: reportType ?? this.reportType);
  }

  CreditRelayGetRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? relayToken,
      Wrapped<enums.ReportType>? reportType}) {
    return CreditRelayGetRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        relayToken: (relayToken != null ? relayToken.value : this.relayToken),
        reportType: (reportType != null ? reportType.value : this.reportType));
  }
}

@JsonSerializable(explicitToJson: true)
class CreditRelayRefreshRequest {
  CreditRelayRefreshRequest({
    this.clientId,
    this.secret,
    required this.relayToken,
    required this.reportType,
    this.webhook,
  });

  factory CreditRelayRefreshRequest.fromJson(Map<String, dynamic> json) =>
      _$CreditRelayRefreshRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'relay_token')
  final String relayToken;
  @JsonKey(
    name: 'report_type',
    toJson: reportTypeToJson,
    fromJson: reportTypeFromJson,
  )
  final enums.ReportType reportType;
  @JsonKey(name: 'webhook')
  final String? webhook;
  static const fromJsonFactory = _$CreditRelayRefreshRequestFromJson;
  static const toJsonFactory = _$CreditRelayRefreshRequestToJson;
  Map<String, dynamic> toJson() => _$CreditRelayRefreshRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CreditRelayRefreshRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.relayToken, relayToken) ||
                const DeepCollectionEquality()
                    .equals(other.relayToken, relayToken)) &&
            (identical(other.reportType, reportType) ||
                const DeepCollectionEquality()
                    .equals(other.reportType, reportType)) &&
            (identical(other.webhook, webhook) ||
                const DeepCollectionEquality().equals(other.webhook, webhook)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(relayToken) ^
      const DeepCollectionEquality().hash(reportType) ^
      const DeepCollectionEquality().hash(webhook) ^
      runtimeType.hashCode;
}

extension $CreditRelayRefreshRequestExtension on CreditRelayRefreshRequest {
  CreditRelayRefreshRequest copyWith(
      {String? clientId,
      String? secret,
      String? relayToken,
      enums.ReportType? reportType,
      String? webhook}) {
    return CreditRelayRefreshRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        relayToken: relayToken ?? this.relayToken,
        reportType: reportType ?? this.reportType,
        webhook: webhook ?? this.webhook);
  }

  CreditRelayRefreshRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? relayToken,
      Wrapped<enums.ReportType>? reportType,
      Wrapped<String?>? webhook}) {
    return CreditRelayRefreshRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        relayToken: (relayToken != null ? relayToken.value : this.relayToken),
        reportType: (reportType != null ? reportType.value : this.reportType),
        webhook: (webhook != null ? webhook.value : this.webhook));
  }
}

@JsonSerializable(explicitToJson: true)
class CreditRelayRefreshResponse {
  CreditRelayRefreshResponse({
    required this.relayToken,
    this.assetReportId,
    required this.requestId,
  });

  factory CreditRelayRefreshResponse.fromJson(Map<String, dynamic> json) =>
      _$CreditRelayRefreshResponseFromJson(json);

  @JsonKey(name: 'relay_token')
  final String relayToken;
  @JsonKey(name: 'asset_report_id')
  final String? assetReportId;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$CreditRelayRefreshResponseFromJson;
  static const toJsonFactory = _$CreditRelayRefreshResponseToJson;
  Map<String, dynamic> toJson() => _$CreditRelayRefreshResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CreditRelayRefreshResponse &&
            (identical(other.relayToken, relayToken) ||
                const DeepCollectionEquality()
                    .equals(other.relayToken, relayToken)) &&
            (identical(other.assetReportId, assetReportId) ||
                const DeepCollectionEquality()
                    .equals(other.assetReportId, assetReportId)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(relayToken) ^
      const DeepCollectionEquality().hash(assetReportId) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $CreditRelayRefreshResponseExtension on CreditRelayRefreshResponse {
  CreditRelayRefreshResponse copyWith(
      {String? relayToken, String? assetReportId, String? requestId}) {
    return CreditRelayRefreshResponse(
        relayToken: relayToken ?? this.relayToken,
        assetReportId: assetReportId ?? this.assetReportId,
        requestId: requestId ?? this.requestId);
  }

  CreditRelayRefreshResponse copyWithWrapped(
      {Wrapped<String>? relayToken,
      Wrapped<String?>? assetReportId,
      Wrapped<String>? requestId}) {
    return CreditRelayRefreshResponse(
        relayToken: (relayToken != null ? relayToken.value : this.relayToken),
        assetReportId:
            (assetReportId != null ? assetReportId.value : this.assetReportId),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class CreditRelayRemoveRequest {
  CreditRelayRemoveRequest({
    this.clientId,
    this.secret,
    required this.relayToken,
  });

  factory CreditRelayRemoveRequest.fromJson(Map<String, dynamic> json) =>
      _$CreditRelayRemoveRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'relay_token')
  final String relayToken;
  static const fromJsonFactory = _$CreditRelayRemoveRequestFromJson;
  static const toJsonFactory = _$CreditRelayRemoveRequestToJson;
  Map<String, dynamic> toJson() => _$CreditRelayRemoveRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CreditRelayRemoveRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.relayToken, relayToken) ||
                const DeepCollectionEquality()
                    .equals(other.relayToken, relayToken)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(relayToken) ^
      runtimeType.hashCode;
}

extension $CreditRelayRemoveRequestExtension on CreditRelayRemoveRequest {
  CreditRelayRemoveRequest copyWith(
      {String? clientId, String? secret, String? relayToken}) {
    return CreditRelayRemoveRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        relayToken: relayToken ?? this.relayToken);
  }

  CreditRelayRemoveRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? relayToken}) {
    return CreditRelayRemoveRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        relayToken: (relayToken != null ? relayToken.value : this.relayToken));
  }
}

@JsonSerializable(explicitToJson: true)
class CreditRelayRemoveResponse {
  CreditRelayRemoveResponse({
    required this.removed,
    required this.requestId,
  });

  factory CreditRelayRemoveResponse.fromJson(Map<String, dynamic> json) =>
      _$CreditRelayRemoveResponseFromJson(json);

  @JsonKey(name: 'removed')
  final bool removed;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$CreditRelayRemoveResponseFromJson;
  static const toJsonFactory = _$CreditRelayRemoveResponseToJson;
  Map<String, dynamic> toJson() => _$CreditRelayRemoveResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CreditRelayRemoveResponse &&
            (identical(other.removed, removed) ||
                const DeepCollectionEquality()
                    .equals(other.removed, removed)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(removed) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $CreditRelayRemoveResponseExtension on CreditRelayRemoveResponse {
  CreditRelayRemoveResponse copyWith({bool? removed, String? requestId}) {
    return CreditRelayRemoveResponse(
        removed: removed ?? this.removed,
        requestId: requestId ?? this.requestId);
  }

  CreditRelayRemoveResponse copyWithWrapped(
      {Wrapped<bool>? removed, Wrapped<String>? requestId}) {
    return CreditRelayRemoveResponse(
        removed: (removed != null ? removed.value : this.removed),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class SandboxBankTransferFireWebhookRequest {
  SandboxBankTransferFireWebhookRequest({
    this.clientId,
    this.secret,
    required this.webhook,
  });

  factory SandboxBankTransferFireWebhookRequest.fromJson(
          Map<String, dynamic> json) =>
      _$SandboxBankTransferFireWebhookRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'webhook')
  final String webhook;
  static const fromJsonFactory =
      _$SandboxBankTransferFireWebhookRequestFromJson;
  static const toJsonFactory = _$SandboxBankTransferFireWebhookRequestToJson;
  Map<String, dynamic> toJson() =>
      _$SandboxBankTransferFireWebhookRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SandboxBankTransferFireWebhookRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.webhook, webhook) ||
                const DeepCollectionEquality().equals(other.webhook, webhook)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(webhook) ^
      runtimeType.hashCode;
}

extension $SandboxBankTransferFireWebhookRequestExtension
    on SandboxBankTransferFireWebhookRequest {
  SandboxBankTransferFireWebhookRequest copyWith(
      {String? clientId, String? secret, String? webhook}) {
    return SandboxBankTransferFireWebhookRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        webhook: webhook ?? this.webhook);
  }

  SandboxBankTransferFireWebhookRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? webhook}) {
    return SandboxBankTransferFireWebhookRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        webhook: (webhook != null ? webhook.value : this.webhook));
  }
}

@JsonSerializable(explicitToJson: true)
class SandboxBankTransferFireWebhookResponse {
  SandboxBankTransferFireWebhookResponse({
    required this.requestId,
  });

  factory SandboxBankTransferFireWebhookResponse.fromJson(
          Map<String, dynamic> json) =>
      _$SandboxBankTransferFireWebhookResponseFromJson(json);

  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory =
      _$SandboxBankTransferFireWebhookResponseFromJson;
  static const toJsonFactory = _$SandboxBankTransferFireWebhookResponseToJson;
  Map<String, dynamic> toJson() =>
      _$SandboxBankTransferFireWebhookResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SandboxBankTransferFireWebhookResponse &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(requestId) ^ runtimeType.hashCode;
}

extension $SandboxBankTransferFireWebhookResponseExtension
    on SandboxBankTransferFireWebhookResponse {
  SandboxBankTransferFireWebhookResponse copyWith({String? requestId}) {
    return SandboxBankTransferFireWebhookResponse(
        requestId: requestId ?? this.requestId);
  }

  SandboxBankTransferFireWebhookResponse copyWithWrapped(
      {Wrapped<String>? requestId}) {
    return SandboxBankTransferFireWebhookResponse(
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class SandboxTransferFireWebhookRequest {
  SandboxTransferFireWebhookRequest({
    this.clientId,
    this.secret,
    required this.webhook,
  });

  factory SandboxTransferFireWebhookRequest.fromJson(
          Map<String, dynamic> json) =>
      _$SandboxTransferFireWebhookRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'webhook')
  final String webhook;
  static const fromJsonFactory = _$SandboxTransferFireWebhookRequestFromJson;
  static const toJsonFactory = _$SandboxTransferFireWebhookRequestToJson;
  Map<String, dynamic> toJson() =>
      _$SandboxTransferFireWebhookRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SandboxTransferFireWebhookRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.webhook, webhook) ||
                const DeepCollectionEquality().equals(other.webhook, webhook)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(webhook) ^
      runtimeType.hashCode;
}

extension $SandboxTransferFireWebhookRequestExtension
    on SandboxTransferFireWebhookRequest {
  SandboxTransferFireWebhookRequest copyWith(
      {String? clientId, String? secret, String? webhook}) {
    return SandboxTransferFireWebhookRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        webhook: webhook ?? this.webhook);
  }

  SandboxTransferFireWebhookRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? webhook}) {
    return SandboxTransferFireWebhookRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        webhook: (webhook != null ? webhook.value : this.webhook));
  }
}

@JsonSerializable(explicitToJson: true)
class SandboxTransferFireWebhookResponse {
  SandboxTransferFireWebhookResponse({
    required this.requestId,
  });

  factory SandboxTransferFireWebhookResponse.fromJson(
          Map<String, dynamic> json) =>
      _$SandboxTransferFireWebhookResponseFromJson(json);

  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$SandboxTransferFireWebhookResponseFromJson;
  static const toJsonFactory = _$SandboxTransferFireWebhookResponseToJson;
  Map<String, dynamic> toJson() =>
      _$SandboxTransferFireWebhookResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SandboxTransferFireWebhookResponse &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(requestId) ^ runtimeType.hashCode;
}

extension $SandboxTransferFireWebhookResponseExtension
    on SandboxTransferFireWebhookResponse {
  SandboxTransferFireWebhookResponse copyWith({String? requestId}) {
    return SandboxTransferFireWebhookResponse(
        requestId: requestId ?? this.requestId);
  }

  SandboxTransferFireWebhookResponse copyWithWrapped(
      {Wrapped<String>? requestId}) {
    return SandboxTransferFireWebhookResponse(
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class Application {
  Application({
    required this.applicationId,
    required this.name,
    required this.displayName,
    required this.joinDate,
    required this.logoUrl,
    required this.applicationUrl,
    required this.reasonForAccess,
    required this.useCase,
    required this.companyLegalName,
    required this.city,
    required this.region,
    required this.postalCode,
    required this.countryCode,
  });

  factory Application.fromJson(Map<String, dynamic> json) =>
      _$ApplicationFromJson(json);

  @JsonKey(name: 'application_id')
  final String applicationId;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'display_name')
  final String? displayName;
  @JsonKey(name: 'join_date', toJson: _dateToJson)
  final DateTime joinDate;
  @JsonKey(name: 'logo_url')
  final String? logoUrl;
  @JsonKey(name: 'application_url')
  final String? applicationUrl;
  @JsonKey(name: 'reason_for_access')
  final String? reasonForAccess;
  @JsonKey(name: 'use_case')
  final String? useCase;
  @JsonKey(name: 'company_legal_name')
  final String? companyLegalName;
  @JsonKey(name: 'city')
  final String? city;
  @JsonKey(name: 'region')
  final String? region;
  @JsonKey(name: 'postal_code')
  final String? postalCode;
  @JsonKey(name: 'country_code')
  final String? countryCode;
  static const fromJsonFactory = _$ApplicationFromJson;
  static const toJsonFactory = _$ApplicationToJson;
  Map<String, dynamic> toJson() => _$ApplicationToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Application &&
            (identical(other.applicationId, applicationId) ||
                const DeepCollectionEquality()
                    .equals(other.applicationId, applicationId)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.displayName, displayName) ||
                const DeepCollectionEquality()
                    .equals(other.displayName, displayName)) &&
            (identical(other.joinDate, joinDate) ||
                const DeepCollectionEquality()
                    .equals(other.joinDate, joinDate)) &&
            (identical(other.logoUrl, logoUrl) ||
                const DeepCollectionEquality()
                    .equals(other.logoUrl, logoUrl)) &&
            (identical(other.applicationUrl, applicationUrl) ||
                const DeepCollectionEquality()
                    .equals(other.applicationUrl, applicationUrl)) &&
            (identical(other.reasonForAccess, reasonForAccess) ||
                const DeepCollectionEquality()
                    .equals(other.reasonForAccess, reasonForAccess)) &&
            (identical(other.useCase, useCase) ||
                const DeepCollectionEquality()
                    .equals(other.useCase, useCase)) &&
            (identical(other.companyLegalName, companyLegalName) ||
                const DeepCollectionEquality()
                    .equals(other.companyLegalName, companyLegalName)) &&
            (identical(other.city, city) ||
                const DeepCollectionEquality().equals(other.city, city)) &&
            (identical(other.region, region) ||
                const DeepCollectionEquality().equals(other.region, region)) &&
            (identical(other.postalCode, postalCode) ||
                const DeepCollectionEquality()
                    .equals(other.postalCode, postalCode)) &&
            (identical(other.countryCode, countryCode) ||
                const DeepCollectionEquality()
                    .equals(other.countryCode, countryCode)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(applicationId) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(displayName) ^
      const DeepCollectionEquality().hash(joinDate) ^
      const DeepCollectionEquality().hash(logoUrl) ^
      const DeepCollectionEquality().hash(applicationUrl) ^
      const DeepCollectionEquality().hash(reasonForAccess) ^
      const DeepCollectionEquality().hash(useCase) ^
      const DeepCollectionEquality().hash(companyLegalName) ^
      const DeepCollectionEquality().hash(city) ^
      const DeepCollectionEquality().hash(region) ^
      const DeepCollectionEquality().hash(postalCode) ^
      const DeepCollectionEquality().hash(countryCode) ^
      runtimeType.hashCode;
}

extension $ApplicationExtension on Application {
  Application copyWith(
      {String? applicationId,
      String? name,
      String? displayName,
      DateTime? joinDate,
      String? logoUrl,
      String? applicationUrl,
      String? reasonForAccess,
      String? useCase,
      String? companyLegalName,
      String? city,
      String? region,
      String? postalCode,
      String? countryCode}) {
    return Application(
        applicationId: applicationId ?? this.applicationId,
        name: name ?? this.name,
        displayName: displayName ?? this.displayName,
        joinDate: joinDate ?? this.joinDate,
        logoUrl: logoUrl ?? this.logoUrl,
        applicationUrl: applicationUrl ?? this.applicationUrl,
        reasonForAccess: reasonForAccess ?? this.reasonForAccess,
        useCase: useCase ?? this.useCase,
        companyLegalName: companyLegalName ?? this.companyLegalName,
        city: city ?? this.city,
        region: region ?? this.region,
        postalCode: postalCode ?? this.postalCode,
        countryCode: countryCode ?? this.countryCode);
  }

  Application copyWithWrapped(
      {Wrapped<String>? applicationId,
      Wrapped<String>? name,
      Wrapped<String?>? displayName,
      Wrapped<DateTime>? joinDate,
      Wrapped<String?>? logoUrl,
      Wrapped<String?>? applicationUrl,
      Wrapped<String?>? reasonForAccess,
      Wrapped<String?>? useCase,
      Wrapped<String?>? companyLegalName,
      Wrapped<String?>? city,
      Wrapped<String?>? region,
      Wrapped<String?>? postalCode,
      Wrapped<String?>? countryCode}) {
    return Application(
        applicationId:
            (applicationId != null ? applicationId.value : this.applicationId),
        name: (name != null ? name.value : this.name),
        displayName:
            (displayName != null ? displayName.value : this.displayName),
        joinDate: (joinDate != null ? joinDate.value : this.joinDate),
        logoUrl: (logoUrl != null ? logoUrl.value : this.logoUrl),
        applicationUrl: (applicationUrl != null
            ? applicationUrl.value
            : this.applicationUrl),
        reasonForAccess: (reasonForAccess != null
            ? reasonForAccess.value
            : this.reasonForAccess),
        useCase: (useCase != null ? useCase.value : this.useCase),
        companyLegalName: (companyLegalName != null
            ? companyLegalName.value
            : this.companyLegalName),
        city: (city != null ? city.value : this.city),
        region: (region != null ? region.value : this.region),
        postalCode: (postalCode != null ? postalCode.value : this.postalCode),
        countryCode:
            (countryCode != null ? countryCode.value : this.countryCode));
  }
}

@JsonSerializable(explicitToJson: true)
class ApplicationGetRequest {
  ApplicationGetRequest({
    required this.clientId,
    required this.secret,
    required this.applicationId,
  });

  factory ApplicationGetRequest.fromJson(Map<String, dynamic> json) =>
      _$ApplicationGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String clientId;
  @JsonKey(name: 'secret')
  final String secret;
  @JsonKey(name: 'application_id')
  final String applicationId;
  static const fromJsonFactory = _$ApplicationGetRequestFromJson;
  static const toJsonFactory = _$ApplicationGetRequestToJson;
  Map<String, dynamic> toJson() => _$ApplicationGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ApplicationGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.applicationId, applicationId) ||
                const DeepCollectionEquality()
                    .equals(other.applicationId, applicationId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(applicationId) ^
      runtimeType.hashCode;
}

extension $ApplicationGetRequestExtension on ApplicationGetRequest {
  ApplicationGetRequest copyWith(
      {String? clientId, String? secret, String? applicationId}) {
    return ApplicationGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        applicationId: applicationId ?? this.applicationId);
  }

  ApplicationGetRequest copyWithWrapped(
      {Wrapped<String>? clientId,
      Wrapped<String>? secret,
      Wrapped<String>? applicationId}) {
    return ApplicationGetRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        applicationId:
            (applicationId != null ? applicationId.value : this.applicationId));
  }
}

@JsonSerializable(explicitToJson: true)
class ApplicationGetResponse {
  ApplicationGetResponse({
    required this.requestId,
    required this.application,
  });

  factory ApplicationGetResponse.fromJson(Map<String, dynamic> json) =>
      _$ApplicationGetResponseFromJson(json);

  @JsonKey(name: 'request_id')
  final String requestId;
  @JsonKey(name: 'application')
  final Application application;
  static const fromJsonFactory = _$ApplicationGetResponseFromJson;
  static const toJsonFactory = _$ApplicationGetResponseToJson;
  Map<String, dynamic> toJson() => _$ApplicationGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ApplicationGetResponse &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)) &&
            (identical(other.application, application) ||
                const DeepCollectionEquality()
                    .equals(other.application, application)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(requestId) ^
      const DeepCollectionEquality().hash(application) ^
      runtimeType.hashCode;
}

extension $ApplicationGetResponseExtension on ApplicationGetResponse {
  ApplicationGetResponse copyWith(
      {String? requestId, Application? application}) {
    return ApplicationGetResponse(
        requestId: requestId ?? this.requestId,
        application: application ?? this.application);
  }

  ApplicationGetResponse copyWithWrapped(
      {Wrapped<String>? requestId, Wrapped<Application>? application}) {
    return ApplicationGetResponse(
        requestId: (requestId != null ? requestId.value : this.requestId),
        application:
            (application != null ? application.value : this.application));
  }
}

@JsonSerializable(explicitToJson: true)
class ProductAccess {
  ProductAccess({
    this.statements,
    this.identity,
    this.auth,
    this.transactions,
    this.accountsDetailsTransactions,
    this.accountsRoutingNumber,
    this.accountsStatements,
    this.accountsTaxStatements,
    this.customersProfiles,
  });

  factory ProductAccess.fromJson(Map<String, dynamic> json) =>
      _$ProductAccessFromJson(json);

  @JsonKey(name: 'statements', defaultValue: true)
  final bool? statements;
  @JsonKey(name: 'identity', defaultValue: true)
  final bool? identity;
  @JsonKey(name: 'auth', defaultValue: true)
  final bool? auth;
  @JsonKey(name: 'transactions', defaultValue: true)
  final bool? transactions;
  @JsonKey(name: 'accounts_details_transactions', defaultValue: true)
  final bool? accountsDetailsTransactions;
  @JsonKey(name: 'accounts_routing_number', defaultValue: true)
  final bool? accountsRoutingNumber;
  @JsonKey(name: 'accounts_statements', defaultValue: true)
  final bool? accountsStatements;
  @JsonKey(name: 'accounts_tax_statements', defaultValue: true)
  final bool? accountsTaxStatements;
  @JsonKey(name: 'customers_profiles', defaultValue: true)
  final bool? customersProfiles;
  static const fromJsonFactory = _$ProductAccessFromJson;
  static const toJsonFactory = _$ProductAccessToJson;
  Map<String, dynamic> toJson() => _$ProductAccessToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ProductAccess &&
            (identical(other.statements, statements) ||
                const DeepCollectionEquality()
                    .equals(other.statements, statements)) &&
            (identical(other.identity, identity) ||
                const DeepCollectionEquality()
                    .equals(other.identity, identity)) &&
            (identical(other.auth, auth) ||
                const DeepCollectionEquality().equals(other.auth, auth)) &&
            (identical(other.transactions, transactions) ||
                const DeepCollectionEquality()
                    .equals(other.transactions, transactions)) &&
            (identical(other.accountsDetailsTransactions,
                    accountsDetailsTransactions) ||
                const DeepCollectionEquality().equals(
                    other.accountsDetailsTransactions,
                    accountsDetailsTransactions)) &&
            (identical(other.accountsRoutingNumber, accountsRoutingNumber) ||
                const DeepCollectionEquality().equals(
                    other.accountsRoutingNumber, accountsRoutingNumber)) &&
            (identical(other.accountsStatements, accountsStatements) ||
                const DeepCollectionEquality()
                    .equals(other.accountsStatements, accountsStatements)) &&
            (identical(other.accountsTaxStatements, accountsTaxStatements) ||
                const DeepCollectionEquality().equals(
                    other.accountsTaxStatements, accountsTaxStatements)) &&
            (identical(other.customersProfiles, customersProfiles) ||
                const DeepCollectionEquality()
                    .equals(other.customersProfiles, customersProfiles)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(statements) ^
      const DeepCollectionEquality().hash(identity) ^
      const DeepCollectionEquality().hash(auth) ^
      const DeepCollectionEquality().hash(transactions) ^
      const DeepCollectionEquality().hash(accountsDetailsTransactions) ^
      const DeepCollectionEquality().hash(accountsRoutingNumber) ^
      const DeepCollectionEquality().hash(accountsStatements) ^
      const DeepCollectionEquality().hash(accountsTaxStatements) ^
      const DeepCollectionEquality().hash(customersProfiles) ^
      runtimeType.hashCode;
}

extension $ProductAccessExtension on ProductAccess {
  ProductAccess copyWith(
      {bool? statements,
      bool? identity,
      bool? auth,
      bool? transactions,
      bool? accountsDetailsTransactions,
      bool? accountsRoutingNumber,
      bool? accountsStatements,
      bool? accountsTaxStatements,
      bool? customersProfiles}) {
    return ProductAccess(
        statements: statements ?? this.statements,
        identity: identity ?? this.identity,
        auth: auth ?? this.auth,
        transactions: transactions ?? this.transactions,
        accountsDetailsTransactions:
            accountsDetailsTransactions ?? this.accountsDetailsTransactions,
        accountsRoutingNumber:
            accountsRoutingNumber ?? this.accountsRoutingNumber,
        accountsStatements: accountsStatements ?? this.accountsStatements,
        accountsTaxStatements:
            accountsTaxStatements ?? this.accountsTaxStatements,
        customersProfiles: customersProfiles ?? this.customersProfiles);
  }

  ProductAccess copyWithWrapped(
      {Wrapped<bool?>? statements,
      Wrapped<bool?>? identity,
      Wrapped<bool?>? auth,
      Wrapped<bool?>? transactions,
      Wrapped<bool?>? accountsDetailsTransactions,
      Wrapped<bool?>? accountsRoutingNumber,
      Wrapped<bool?>? accountsStatements,
      Wrapped<bool?>? accountsTaxStatements,
      Wrapped<bool?>? customersProfiles}) {
    return ProductAccess(
        statements: (statements != null ? statements.value : this.statements),
        identity: (identity != null ? identity.value : this.identity),
        auth: (auth != null ? auth.value : this.auth),
        transactions:
            (transactions != null ? transactions.value : this.transactions),
        accountsDetailsTransactions: (accountsDetailsTransactions != null
            ? accountsDetailsTransactions.value
            : this.accountsDetailsTransactions),
        accountsRoutingNumber: (accountsRoutingNumber != null
            ? accountsRoutingNumber.value
            : this.accountsRoutingNumber),
        accountsStatements: (accountsStatements != null
            ? accountsStatements.value
            : this.accountsStatements),
        accountsTaxStatements: (accountsTaxStatements != null
            ? accountsTaxStatements.value
            : this.accountsTaxStatements),
        customersProfiles: (customersProfiles != null
            ? customersProfiles.value
            : this.customersProfiles));
  }
}

@JsonSerializable(explicitToJson: true)
class AccountAccess {
  AccountAccess({
    required this.uniqueId,
    this.authorized,
    this.accountProductAccess,
  });

  factory AccountAccess.fromJson(Map<String, dynamic> json) =>
      _$AccountAccessFromJson(json);

  @JsonKey(name: 'unique_id')
  final String uniqueId;
  @JsonKey(name: 'authorized', defaultValue: true)
  final bool? authorized;
  @JsonKey(name: 'account_product_access')
  final AccountProductAccessNullable? accountProductAccess;
  static const fromJsonFactory = _$AccountAccessFromJson;
  static const toJsonFactory = _$AccountAccessToJson;
  Map<String, dynamic> toJson() => _$AccountAccessToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AccountAccess &&
            (identical(other.uniqueId, uniqueId) ||
                const DeepCollectionEquality()
                    .equals(other.uniqueId, uniqueId)) &&
            (identical(other.authorized, authorized) ||
                const DeepCollectionEquality()
                    .equals(other.authorized, authorized)) &&
            (identical(other.accountProductAccess, accountProductAccess) ||
                const DeepCollectionEquality()
                    .equals(other.accountProductAccess, accountProductAccess)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(uniqueId) ^
      const DeepCollectionEquality().hash(authorized) ^
      const DeepCollectionEquality().hash(accountProductAccess) ^
      runtimeType.hashCode;
}

extension $AccountAccessExtension on AccountAccess {
  AccountAccess copyWith(
      {String? uniqueId,
      bool? authorized,
      AccountProductAccessNullable? accountProductAccess}) {
    return AccountAccess(
        uniqueId: uniqueId ?? this.uniqueId,
        authorized: authorized ?? this.authorized,
        accountProductAccess:
            accountProductAccess ?? this.accountProductAccess);
  }

  AccountAccess copyWithWrapped(
      {Wrapped<String>? uniqueId,
      Wrapped<bool?>? authorized,
      Wrapped<AccountProductAccessNullable?>? accountProductAccess}) {
    return AccountAccess(
        uniqueId: (uniqueId != null ? uniqueId.value : this.uniqueId),
        authorized: (authorized != null ? authorized.value : this.authorized),
        accountProductAccess: (accountProductAccess != null
            ? accountProductAccess.value
            : this.accountProductAccess));
  }
}

@JsonSerializable(explicitToJson: true)
class AccountProductAccessNullable {
  AccountProductAccessNullable({
    this.accountData,
    this.statements,
    this.taxDocuments,
  });

  factory AccountProductAccessNullable.fromJson(Map<String, dynamic> json) =>
      _$AccountProductAccessNullableFromJson(json);

  @JsonKey(name: 'account_data', defaultValue: true)
  final bool? accountData;
  @JsonKey(name: 'statements', defaultValue: true)
  final bool? statements;
  @JsonKey(name: 'tax_documents', defaultValue: true)
  final bool? taxDocuments;
  static const fromJsonFactory = _$AccountProductAccessNullableFromJson;
  static const toJsonFactory = _$AccountProductAccessNullableToJson;
  Map<String, dynamic> toJson() => _$AccountProductAccessNullableToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AccountProductAccessNullable &&
            (identical(other.accountData, accountData) ||
                const DeepCollectionEquality()
                    .equals(other.accountData, accountData)) &&
            (identical(other.statements, statements) ||
                const DeepCollectionEquality()
                    .equals(other.statements, statements)) &&
            (identical(other.taxDocuments, taxDocuments) ||
                const DeepCollectionEquality()
                    .equals(other.taxDocuments, taxDocuments)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountData) ^
      const DeepCollectionEquality().hash(statements) ^
      const DeepCollectionEquality().hash(taxDocuments) ^
      runtimeType.hashCode;
}

extension $AccountProductAccessNullableExtension
    on AccountProductAccessNullable {
  AccountProductAccessNullable copyWith(
      {bool? accountData, bool? statements, bool? taxDocuments}) {
    return AccountProductAccessNullable(
        accountData: accountData ?? this.accountData,
        statements: statements ?? this.statements,
        taxDocuments: taxDocuments ?? this.taxDocuments);
  }

  AccountProductAccessNullable copyWithWrapped(
      {Wrapped<bool?>? accountData,
      Wrapped<bool?>? statements,
      Wrapped<bool?>? taxDocuments}) {
    return AccountProductAccessNullable(
        accountData:
            (accountData != null ? accountData.value : this.accountData),
        statements: (statements != null ? statements.value : this.statements),
        taxDocuments:
            (taxDocuments != null ? taxDocuments.value : this.taxDocuments));
  }
}

@JsonSerializable(explicitToJson: true)
class AccountProductAccess {
  AccountProductAccess({
    this.accountData,
    this.statements,
    this.taxDocuments,
  });

  factory AccountProductAccess.fromJson(Map<String, dynamic> json) =>
      _$AccountProductAccessFromJson(json);

  @JsonKey(name: 'account_data', defaultValue: true)
  final bool? accountData;
  @JsonKey(name: 'statements', defaultValue: true)
  final bool? statements;
  @JsonKey(name: 'tax_documents', defaultValue: true)
  final bool? taxDocuments;
  static const fromJsonFactory = _$AccountProductAccessFromJson;
  static const toJsonFactory = _$AccountProductAccessToJson;
  Map<String, dynamic> toJson() => _$AccountProductAccessToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AccountProductAccess &&
            (identical(other.accountData, accountData) ||
                const DeepCollectionEquality()
                    .equals(other.accountData, accountData)) &&
            (identical(other.statements, statements) ||
                const DeepCollectionEquality()
                    .equals(other.statements, statements)) &&
            (identical(other.taxDocuments, taxDocuments) ||
                const DeepCollectionEquality()
                    .equals(other.taxDocuments, taxDocuments)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountData) ^
      const DeepCollectionEquality().hash(statements) ^
      const DeepCollectionEquality().hash(taxDocuments) ^
      runtimeType.hashCode;
}

extension $AccountProductAccessExtension on AccountProductAccess {
  AccountProductAccess copyWith(
      {bool? accountData, bool? statements, bool? taxDocuments}) {
    return AccountProductAccess(
        accountData: accountData ?? this.accountData,
        statements: statements ?? this.statements,
        taxDocuments: taxDocuments ?? this.taxDocuments);
  }

  AccountProductAccess copyWithWrapped(
      {Wrapped<bool?>? accountData,
      Wrapped<bool?>? statements,
      Wrapped<bool?>? taxDocuments}) {
    return AccountProductAccess(
        accountData:
            (accountData != null ? accountData.value : this.accountData),
        statements: (statements != null ? statements.value : this.statements),
        taxDocuments:
            (taxDocuments != null ? taxDocuments.value : this.taxDocuments));
  }
}

@JsonSerializable(explicitToJson: true)
class ScopesNullable {
  ScopesNullable({
    this.productAccess,
    this.accounts,
    this.newAccounts,
  });

  factory ScopesNullable.fromJson(Map<String, dynamic> json) =>
      _$ScopesNullableFromJson(json);

  @JsonKey(name: 'product_access')
  final ProductAccess? productAccess;
  @JsonKey(name: 'accounts', defaultValue: <AccountAccess>[])
  final List<AccountAccess>? accounts;
  @JsonKey(name: 'new_accounts', defaultValue: true)
  final bool? newAccounts;
  static const fromJsonFactory = _$ScopesNullableFromJson;
  static const toJsonFactory = _$ScopesNullableToJson;
  Map<String, dynamic> toJson() => _$ScopesNullableToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ScopesNullable &&
            (identical(other.productAccess, productAccess) ||
                const DeepCollectionEquality()
                    .equals(other.productAccess, productAccess)) &&
            (identical(other.accounts, accounts) ||
                const DeepCollectionEquality()
                    .equals(other.accounts, accounts)) &&
            (identical(other.newAccounts, newAccounts) ||
                const DeepCollectionEquality()
                    .equals(other.newAccounts, newAccounts)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(productAccess) ^
      const DeepCollectionEquality().hash(accounts) ^
      const DeepCollectionEquality().hash(newAccounts) ^
      runtimeType.hashCode;
}

extension $ScopesNullableExtension on ScopesNullable {
  ScopesNullable copyWith(
      {ProductAccess? productAccess,
      List<AccountAccess>? accounts,
      bool? newAccounts}) {
    return ScopesNullable(
        productAccess: productAccess ?? this.productAccess,
        accounts: accounts ?? this.accounts,
        newAccounts: newAccounts ?? this.newAccounts);
  }

  ScopesNullable copyWithWrapped(
      {Wrapped<ProductAccess?>? productAccess,
      Wrapped<List<AccountAccess>?>? accounts,
      Wrapped<bool?>? newAccounts}) {
    return ScopesNullable(
        productAccess:
            (productAccess != null ? productAccess.value : this.productAccess),
        accounts: (accounts != null ? accounts.value : this.accounts),
        newAccounts:
            (newAccounts != null ? newAccounts.value : this.newAccounts));
  }
}

@JsonSerializable(explicitToJson: true)
class Scopes {
  Scopes({
    this.productAccess,
    this.accounts,
    this.newAccounts,
  });

  factory Scopes.fromJson(Map<String, dynamic> json) => _$ScopesFromJson(json);

  @JsonKey(name: 'product_access')
  final ProductAccess? productAccess;
  @JsonKey(name: 'accounts', defaultValue: <AccountAccess>[])
  final List<AccountAccess>? accounts;
  @JsonKey(name: 'new_accounts', defaultValue: true)
  final bool? newAccounts;
  static const fromJsonFactory = _$ScopesFromJson;
  static const toJsonFactory = _$ScopesToJson;
  Map<String, dynamic> toJson() => _$ScopesToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Scopes &&
            (identical(other.productAccess, productAccess) ||
                const DeepCollectionEquality()
                    .equals(other.productAccess, productAccess)) &&
            (identical(other.accounts, accounts) ||
                const DeepCollectionEquality()
                    .equals(other.accounts, accounts)) &&
            (identical(other.newAccounts, newAccounts) ||
                const DeepCollectionEquality()
                    .equals(other.newAccounts, newAccounts)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(productAccess) ^
      const DeepCollectionEquality().hash(accounts) ^
      const DeepCollectionEquality().hash(newAccounts) ^
      runtimeType.hashCode;
}

extension $ScopesExtension on Scopes {
  Scopes copyWith(
      {ProductAccess? productAccess,
      List<AccountAccess>? accounts,
      bool? newAccounts}) {
    return Scopes(
        productAccess: productAccess ?? this.productAccess,
        accounts: accounts ?? this.accounts,
        newAccounts: newAccounts ?? this.newAccounts);
  }

  Scopes copyWithWrapped(
      {Wrapped<ProductAccess?>? productAccess,
      Wrapped<List<AccountAccess>?>? accounts,
      Wrapped<bool?>? newAccounts}) {
    return Scopes(
        productAccess:
            (productAccess != null ? productAccess.value : this.productAccess),
        accounts: (accounts != null ? accounts.value : this.accounts),
        newAccounts:
            (newAccounts != null ? newAccounts.value : this.newAccounts));
  }
}

@JsonSerializable(explicitToJson: true)
class ItemApplicationScopesUpdateRequest {
  ItemApplicationScopesUpdateRequest({
    this.clientId,
    this.secret,
    required this.accessToken,
    required this.applicationId,
    required this.scopes,
    this.state,
    required this.context,
  });

  factory ItemApplicationScopesUpdateRequest.fromJson(
          Map<String, dynamic> json) =>
      _$ItemApplicationScopesUpdateRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'access_token')
  final String accessToken;
  @JsonKey(name: 'application_id')
  final String applicationId;
  @JsonKey(name: 'scopes')
  final Scopes scopes;
  @JsonKey(name: 'state')
  final String? state;
  @JsonKey(
    name: 'context',
    toJson: scopesContextToJson,
    fromJson: scopesContextFromJson,
  )
  final enums.ScopesContext context;
  static const fromJsonFactory = _$ItemApplicationScopesUpdateRequestFromJson;
  static const toJsonFactory = _$ItemApplicationScopesUpdateRequestToJson;
  Map<String, dynamic> toJson() =>
      _$ItemApplicationScopesUpdateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ItemApplicationScopesUpdateRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)) &&
            (identical(other.applicationId, applicationId) ||
                const DeepCollectionEquality()
                    .equals(other.applicationId, applicationId)) &&
            (identical(other.scopes, scopes) ||
                const DeepCollectionEquality().equals(other.scopes, scopes)) &&
            (identical(other.state, state) ||
                const DeepCollectionEquality().equals(other.state, state)) &&
            (identical(other.context, context) ||
                const DeepCollectionEquality().equals(other.context, context)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(accessToken) ^
      const DeepCollectionEquality().hash(applicationId) ^
      const DeepCollectionEquality().hash(scopes) ^
      const DeepCollectionEquality().hash(state) ^
      const DeepCollectionEquality().hash(context) ^
      runtimeType.hashCode;
}

extension $ItemApplicationScopesUpdateRequestExtension
    on ItemApplicationScopesUpdateRequest {
  ItemApplicationScopesUpdateRequest copyWith(
      {String? clientId,
      String? secret,
      String? accessToken,
      String? applicationId,
      Scopes? scopes,
      String? state,
      enums.ScopesContext? context}) {
    return ItemApplicationScopesUpdateRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        accessToken: accessToken ?? this.accessToken,
        applicationId: applicationId ?? this.applicationId,
        scopes: scopes ?? this.scopes,
        state: state ?? this.state,
        context: context ?? this.context);
  }

  ItemApplicationScopesUpdateRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? accessToken,
      Wrapped<String>? applicationId,
      Wrapped<Scopes>? scopes,
      Wrapped<String?>? state,
      Wrapped<enums.ScopesContext>? context}) {
    return ItemApplicationScopesUpdateRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        accessToken:
            (accessToken != null ? accessToken.value : this.accessToken),
        applicationId:
            (applicationId != null ? applicationId.value : this.applicationId),
        scopes: (scopes != null ? scopes.value : this.scopes),
        state: (state != null ? state.value : this.state),
        context: (context != null ? context.value : this.context));
  }
}

@JsonSerializable(explicitToJson: true)
class ItemApplicationScopesUpdateResponse {
  ItemApplicationScopesUpdateResponse({
    required this.requestId,
  });

  factory ItemApplicationScopesUpdateResponse.fromJson(
          Map<String, dynamic> json) =>
      _$ItemApplicationScopesUpdateResponseFromJson(json);

  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$ItemApplicationScopesUpdateResponseFromJson;
  static const toJsonFactory = _$ItemApplicationScopesUpdateResponseToJson;
  Map<String, dynamic> toJson() =>
      _$ItemApplicationScopesUpdateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ItemApplicationScopesUpdateResponse &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(requestId) ^ runtimeType.hashCode;
}

extension $ItemApplicationScopesUpdateResponseExtension
    on ItemApplicationScopesUpdateResponse {
  ItemApplicationScopesUpdateResponse copyWith({String? requestId}) {
    return ItemApplicationScopesUpdateResponse(
        requestId: requestId ?? this.requestId);
  }

  ItemApplicationScopesUpdateResponse copyWithWrapped(
      {Wrapped<String>? requestId}) {
    return ItemApplicationScopesUpdateResponse(
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class ItemApplicationListRequest {
  ItemApplicationListRequest({
    this.clientId,
    this.secret,
    this.accessToken,
  });

  factory ItemApplicationListRequest.fromJson(Map<String, dynamic> json) =>
      _$ItemApplicationListRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'access_token')
  final String? accessToken;
  static const fromJsonFactory = _$ItemApplicationListRequestFromJson;
  static const toJsonFactory = _$ItemApplicationListRequestToJson;
  Map<String, dynamic> toJson() => _$ItemApplicationListRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ItemApplicationListRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(accessToken) ^
      runtimeType.hashCode;
}

extension $ItemApplicationListRequestExtension on ItemApplicationListRequest {
  ItemApplicationListRequest copyWith(
      {String? clientId, String? secret, String? accessToken}) {
    return ItemApplicationListRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        accessToken: accessToken ?? this.accessToken);
  }

  ItemApplicationListRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String?>? accessToken}) {
    return ItemApplicationListRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        accessToken:
            (accessToken != null ? accessToken.value : this.accessToken));
  }
}

@JsonSerializable(explicitToJson: true)
class ItemApplicationListResponse {
  ItemApplicationListResponse({
    this.requestId,
    required this.applications,
  });

  factory ItemApplicationListResponse.fromJson(Map<String, dynamic> json) =>
      _$ItemApplicationListResponseFromJson(json);

  @JsonKey(name: 'request_id')
  final String? requestId;
  @JsonKey(name: 'applications', defaultValue: <ConnectedApplication>[])
  final List<ConnectedApplication> applications;
  static const fromJsonFactory = _$ItemApplicationListResponseFromJson;
  static const toJsonFactory = _$ItemApplicationListResponseToJson;
  Map<String, dynamic> toJson() => _$ItemApplicationListResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ItemApplicationListResponse &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)) &&
            (identical(other.applications, applications) ||
                const DeepCollectionEquality()
                    .equals(other.applications, applications)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(requestId) ^
      const DeepCollectionEquality().hash(applications) ^
      runtimeType.hashCode;
}

extension $ItemApplicationListResponseExtension on ItemApplicationListResponse {
  ItemApplicationListResponse copyWith(
      {String? requestId, List<ConnectedApplication>? applications}) {
    return ItemApplicationListResponse(
        requestId: requestId ?? this.requestId,
        applications: applications ?? this.applications);
  }

  ItemApplicationListResponse copyWithWrapped(
      {Wrapped<String?>? requestId,
      Wrapped<List<ConnectedApplication>>? applications}) {
    return ItemApplicationListResponse(
        requestId: (requestId != null ? requestId.value : this.requestId),
        applications:
            (applications != null ? applications.value : this.applications));
  }
}

@JsonSerializable(explicitToJson: true)
class ConnectedApplication {
  ConnectedApplication({
    required this.applicationId,
    required this.name,
    this.displayName,
    this.logoUrl,
    this.applicationUrl,
    this.reasonForAccess,
    required this.createdAt,
    this.scopes,
  });

  factory ConnectedApplication.fromJson(Map<String, dynamic> json) =>
      _$ConnectedApplicationFromJson(json);

  @JsonKey(name: 'application_id')
  final String applicationId;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'display_name')
  final String? displayName;
  @JsonKey(name: 'logo_url')
  final String? logoUrl;
  @JsonKey(name: 'application_url')
  final String? applicationUrl;
  @JsonKey(name: 'reason_for_access')
  final String? reasonForAccess;
  @JsonKey(name: 'created_at', toJson: _dateToJson)
  final DateTime createdAt;
  @JsonKey(name: 'scopes')
  final ScopesNullable? scopes;
  static const fromJsonFactory = _$ConnectedApplicationFromJson;
  static const toJsonFactory = _$ConnectedApplicationToJson;
  Map<String, dynamic> toJson() => _$ConnectedApplicationToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ConnectedApplication &&
            (identical(other.applicationId, applicationId) ||
                const DeepCollectionEquality()
                    .equals(other.applicationId, applicationId)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.displayName, displayName) ||
                const DeepCollectionEquality()
                    .equals(other.displayName, displayName)) &&
            (identical(other.logoUrl, logoUrl) ||
                const DeepCollectionEquality()
                    .equals(other.logoUrl, logoUrl)) &&
            (identical(other.applicationUrl, applicationUrl) ||
                const DeepCollectionEquality()
                    .equals(other.applicationUrl, applicationUrl)) &&
            (identical(other.reasonForAccess, reasonForAccess) ||
                const DeepCollectionEquality()
                    .equals(other.reasonForAccess, reasonForAccess)) &&
            (identical(other.createdAt, createdAt) ||
                const DeepCollectionEquality()
                    .equals(other.createdAt, createdAt)) &&
            (identical(other.scopes, scopes) ||
                const DeepCollectionEquality().equals(other.scopes, scopes)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(applicationId) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(displayName) ^
      const DeepCollectionEquality().hash(logoUrl) ^
      const DeepCollectionEquality().hash(applicationUrl) ^
      const DeepCollectionEquality().hash(reasonForAccess) ^
      const DeepCollectionEquality().hash(createdAt) ^
      const DeepCollectionEquality().hash(scopes) ^
      runtimeType.hashCode;
}

extension $ConnectedApplicationExtension on ConnectedApplication {
  ConnectedApplication copyWith(
      {String? applicationId,
      String? name,
      String? displayName,
      String? logoUrl,
      String? applicationUrl,
      String? reasonForAccess,
      DateTime? createdAt,
      ScopesNullable? scopes}) {
    return ConnectedApplication(
        applicationId: applicationId ?? this.applicationId,
        name: name ?? this.name,
        displayName: displayName ?? this.displayName,
        logoUrl: logoUrl ?? this.logoUrl,
        applicationUrl: applicationUrl ?? this.applicationUrl,
        reasonForAccess: reasonForAccess ?? this.reasonForAccess,
        createdAt: createdAt ?? this.createdAt,
        scopes: scopes ?? this.scopes);
  }

  ConnectedApplication copyWithWrapped(
      {Wrapped<String>? applicationId,
      Wrapped<String>? name,
      Wrapped<String?>? displayName,
      Wrapped<String?>? logoUrl,
      Wrapped<String?>? applicationUrl,
      Wrapped<String?>? reasonForAccess,
      Wrapped<DateTime>? createdAt,
      Wrapped<ScopesNullable?>? scopes}) {
    return ConnectedApplication(
        applicationId:
            (applicationId != null ? applicationId.value : this.applicationId),
        name: (name != null ? name.value : this.name),
        displayName:
            (displayName != null ? displayName.value : this.displayName),
        logoUrl: (logoUrl != null ? logoUrl.value : this.logoUrl),
        applicationUrl: (applicationUrl != null
            ? applicationUrl.value
            : this.applicationUrl),
        reasonForAccess: (reasonForAccess != null
            ? reasonForAccess.value
            : this.reasonForAccess),
        createdAt: (createdAt != null ? createdAt.value : this.createdAt),
        scopes: (scopes != null ? scopes.value : this.scopes));
  }
}

@JsonSerializable(explicitToJson: true)
class AccountFilter {
  AccountFilter({
    this.depository,
    this.credit,
    this.loan,
    this.investment,
  });

  factory AccountFilter.fromJson(Map<String, dynamic> json) =>
      _$AccountFilterFromJson(json);

  @JsonKey(name: 'depository')
  final AccountFilterSubtypes? depository;
  @JsonKey(name: 'credit')
  final AccountFilterSubtypes? credit;
  @JsonKey(name: 'loan')
  final AccountFilterSubtypes? loan;
  @JsonKey(name: 'investment')
  final AccountFilterSubtypes? investment;
  static const fromJsonFactory = _$AccountFilterFromJson;
  static const toJsonFactory = _$AccountFilterToJson;
  Map<String, dynamic> toJson() => _$AccountFilterToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AccountFilter &&
            (identical(other.depository, depository) ||
                const DeepCollectionEquality()
                    .equals(other.depository, depository)) &&
            (identical(other.credit, credit) ||
                const DeepCollectionEquality().equals(other.credit, credit)) &&
            (identical(other.loan, loan) ||
                const DeepCollectionEquality().equals(other.loan, loan)) &&
            (identical(other.investment, investment) ||
                const DeepCollectionEquality()
                    .equals(other.investment, investment)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(depository) ^
      const DeepCollectionEquality().hash(credit) ^
      const DeepCollectionEquality().hash(loan) ^
      const DeepCollectionEquality().hash(investment) ^
      runtimeType.hashCode;
}

extension $AccountFilterExtension on AccountFilter {
  AccountFilter copyWith(
      {AccountFilterSubtypes? depository,
      AccountFilterSubtypes? credit,
      AccountFilterSubtypes? loan,
      AccountFilterSubtypes? investment}) {
    return AccountFilter(
        depository: depository ?? this.depository,
        credit: credit ?? this.credit,
        loan: loan ?? this.loan,
        investment: investment ?? this.investment);
  }

  AccountFilter copyWithWrapped(
      {Wrapped<AccountFilterSubtypes?>? depository,
      Wrapped<AccountFilterSubtypes?>? credit,
      Wrapped<AccountFilterSubtypes?>? loan,
      Wrapped<AccountFilterSubtypes?>? investment}) {
    return AccountFilter(
        depository: (depository != null ? depository.value : this.depository),
        credit: (credit != null ? credit.value : this.credit),
        loan: (loan != null ? loan.value : this.loan),
        investment: (investment != null ? investment.value : this.investment));
  }
}

typedef AccountFilterSubtypes = List<Object>;

@JsonSerializable(explicitToJson: true)
class SandboxIncomeFireWebhookRequest {
  SandboxIncomeFireWebhookRequest({
    this.clientId,
    this.secret,
    required this.itemId,
    this.userId,
    required this.webhook,
    required this.verificationStatus,
  });

  factory SandboxIncomeFireWebhookRequest.fromJson(Map<String, dynamic> json) =>
      _$SandboxIncomeFireWebhookRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'item_id')
  final String itemId;
  @JsonKey(name: 'user_id')
  final String? userId;
  @JsonKey(name: 'webhook')
  final String webhook;
  @JsonKey(
    name: 'verification_status',
    toJson: sandboxIncomeFireWebhookRequestVerificationStatusToJson,
    fromJson: sandboxIncomeFireWebhookRequestVerificationStatusFromJson,
  )
  final enums.SandboxIncomeFireWebhookRequestVerificationStatus
      verificationStatus;
  static const fromJsonFactory = _$SandboxIncomeFireWebhookRequestFromJson;
  static const toJsonFactory = _$SandboxIncomeFireWebhookRequestToJson;
  Map<String, dynamic> toJson() =>
      _$SandboxIncomeFireWebhookRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SandboxIncomeFireWebhookRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)) &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)) &&
            (identical(other.webhook, webhook) ||
                const DeepCollectionEquality()
                    .equals(other.webhook, webhook)) &&
            (identical(other.verificationStatus, verificationStatus) ||
                const DeepCollectionEquality()
                    .equals(other.verificationStatus, verificationStatus)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(itemId) ^
      const DeepCollectionEquality().hash(userId) ^
      const DeepCollectionEquality().hash(webhook) ^
      const DeepCollectionEquality().hash(verificationStatus) ^
      runtimeType.hashCode;
}

extension $SandboxIncomeFireWebhookRequestExtension
    on SandboxIncomeFireWebhookRequest {
  SandboxIncomeFireWebhookRequest copyWith(
      {String? clientId,
      String? secret,
      String? itemId,
      String? userId,
      String? webhook,
      enums.SandboxIncomeFireWebhookRequestVerificationStatus?
          verificationStatus}) {
    return SandboxIncomeFireWebhookRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        itemId: itemId ?? this.itemId,
        userId: userId ?? this.userId,
        webhook: webhook ?? this.webhook,
        verificationStatus: verificationStatus ?? this.verificationStatus);
  }

  SandboxIncomeFireWebhookRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? itemId,
      Wrapped<String?>? userId,
      Wrapped<String>? webhook,
      Wrapped<enums.SandboxIncomeFireWebhookRequestVerificationStatus>?
          verificationStatus}) {
    return SandboxIncomeFireWebhookRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        itemId: (itemId != null ? itemId.value : this.itemId),
        userId: (userId != null ? userId.value : this.userId),
        webhook: (webhook != null ? webhook.value : this.webhook),
        verificationStatus: (verificationStatus != null
            ? verificationStatus.value
            : this.verificationStatus));
  }
}

@JsonSerializable(explicitToJson: true)
class SandboxIncomeFireWebhookResponse {
  SandboxIncomeFireWebhookResponse({
    required this.requestId,
  });

  factory SandboxIncomeFireWebhookResponse.fromJson(
          Map<String, dynamic> json) =>
      _$SandboxIncomeFireWebhookResponseFromJson(json);

  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$SandboxIncomeFireWebhookResponseFromJson;
  static const toJsonFactory = _$SandboxIncomeFireWebhookResponseToJson;
  Map<String, dynamic> toJson() =>
      _$SandboxIncomeFireWebhookResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SandboxIncomeFireWebhookResponse &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(requestId) ^ runtimeType.hashCode;
}

extension $SandboxIncomeFireWebhookResponseExtension
    on SandboxIncomeFireWebhookResponse {
  SandboxIncomeFireWebhookResponse copyWith({String? requestId}) {
    return SandboxIncomeFireWebhookResponse(
        requestId: requestId ?? this.requestId);
  }

  SandboxIncomeFireWebhookResponse copyWithWrapped(
      {Wrapped<String>? requestId}) {
    return SandboxIncomeFireWebhookResponse(
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class ItemApplicationListUserAuth {
  ItemApplicationListUserAuth({
    this.userId,
    this.fiUsernameHash,
  });

  factory ItemApplicationListUserAuth.fromJson(Map<String, dynamic> json) =>
      _$ItemApplicationListUserAuthFromJson(json);

  @JsonKey(name: 'user_id')
  final String? userId;
  @JsonKey(name: 'fi_username_hash')
  final String? fiUsernameHash;
  static const fromJsonFactory = _$ItemApplicationListUserAuthFromJson;
  static const toJsonFactory = _$ItemApplicationListUserAuthToJson;
  Map<String, dynamic> toJson() => _$ItemApplicationListUserAuthToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ItemApplicationListUserAuth &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)) &&
            (identical(other.fiUsernameHash, fiUsernameHash) ||
                const DeepCollectionEquality()
                    .equals(other.fiUsernameHash, fiUsernameHash)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(userId) ^
      const DeepCollectionEquality().hash(fiUsernameHash) ^
      runtimeType.hashCode;
}

extension $ItemApplicationListUserAuthExtension on ItemApplicationListUserAuth {
  ItemApplicationListUserAuth copyWith(
      {String? userId, String? fiUsernameHash}) {
    return ItemApplicationListUserAuth(
        userId: userId ?? this.userId,
        fiUsernameHash: fiUsernameHash ?? this.fiUsernameHash);
  }

  ItemApplicationListUserAuth copyWithWrapped(
      {Wrapped<String?>? userId, Wrapped<String?>? fiUsernameHash}) {
    return ItemApplicationListUserAuth(
        userId: (userId != null ? userId.value : this.userId),
        fiUsernameHash: (fiUsernameHash != null
            ? fiUsernameHash.value
            : this.fiUsernameHash));
  }
}

@JsonSerializable(explicitToJson: true)
class SignalEvaluateRequest {
  SignalEvaluateRequest({
    this.clientId,
    this.secret,
    required this.accessToken,
    required this.accountId,
    required this.clientTransactionId,
    required this.amount,
    this.userPresent,
    this.clientUserId,
    this.isRecurring,
    this.defaultPaymentMethod,
    this.user,
    this.device,
  });

  factory SignalEvaluateRequest.fromJson(Map<String, dynamic> json) =>
      _$SignalEvaluateRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'access_token')
  final String accessToken;
  @JsonKey(name: 'account_id')
  final String accountId;
  @JsonKey(name: 'client_transaction_id')
  final String clientTransactionId;
  @JsonKey(name: 'amount')
  final double amount;
  @JsonKey(name: 'user_present')
  final bool? userPresent;
  @JsonKey(name: 'client_user_id')
  final String? clientUserId;
  @JsonKey(name: 'is_recurring')
  final bool? isRecurring;
  @JsonKey(name: 'default_payment_method')
  final String? defaultPaymentMethod;
  @JsonKey(name: 'user')
  final SignalUser? user;
  @JsonKey(name: 'device')
  final SignalDevice? device;
  static const fromJsonFactory = _$SignalEvaluateRequestFromJson;
  static const toJsonFactory = _$SignalEvaluateRequestToJson;
  Map<String, dynamic> toJson() => _$SignalEvaluateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SignalEvaluateRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)) &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.clientTransactionId, clientTransactionId) ||
                const DeepCollectionEquality()
                    .equals(other.clientTransactionId, clientTransactionId)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.userPresent, userPresent) ||
                const DeepCollectionEquality()
                    .equals(other.userPresent, userPresent)) &&
            (identical(other.clientUserId, clientUserId) ||
                const DeepCollectionEquality()
                    .equals(other.clientUserId, clientUserId)) &&
            (identical(other.isRecurring, isRecurring) ||
                const DeepCollectionEquality()
                    .equals(other.isRecurring, isRecurring)) &&
            (identical(other.defaultPaymentMethod, defaultPaymentMethod) ||
                const DeepCollectionEquality().equals(
                    other.defaultPaymentMethod, defaultPaymentMethod)) &&
            (identical(other.user, user) ||
                const DeepCollectionEquality().equals(other.user, user)) &&
            (identical(other.device, device) ||
                const DeepCollectionEquality().equals(other.device, device)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(accessToken) ^
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(clientTransactionId) ^
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(userPresent) ^
      const DeepCollectionEquality().hash(clientUserId) ^
      const DeepCollectionEquality().hash(isRecurring) ^
      const DeepCollectionEquality().hash(defaultPaymentMethod) ^
      const DeepCollectionEquality().hash(user) ^
      const DeepCollectionEquality().hash(device) ^
      runtimeType.hashCode;
}

extension $SignalEvaluateRequestExtension on SignalEvaluateRequest {
  SignalEvaluateRequest copyWith(
      {String? clientId,
      String? secret,
      String? accessToken,
      String? accountId,
      String? clientTransactionId,
      double? amount,
      bool? userPresent,
      String? clientUserId,
      bool? isRecurring,
      String? defaultPaymentMethod,
      SignalUser? user,
      SignalDevice? device}) {
    return SignalEvaluateRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        accessToken: accessToken ?? this.accessToken,
        accountId: accountId ?? this.accountId,
        clientTransactionId: clientTransactionId ?? this.clientTransactionId,
        amount: amount ?? this.amount,
        userPresent: userPresent ?? this.userPresent,
        clientUserId: clientUserId ?? this.clientUserId,
        isRecurring: isRecurring ?? this.isRecurring,
        defaultPaymentMethod: defaultPaymentMethod ?? this.defaultPaymentMethod,
        user: user ?? this.user,
        device: device ?? this.device);
  }

  SignalEvaluateRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? accessToken,
      Wrapped<String>? accountId,
      Wrapped<String>? clientTransactionId,
      Wrapped<double>? amount,
      Wrapped<bool?>? userPresent,
      Wrapped<String?>? clientUserId,
      Wrapped<bool?>? isRecurring,
      Wrapped<String?>? defaultPaymentMethod,
      Wrapped<SignalUser?>? user,
      Wrapped<SignalDevice?>? device}) {
    return SignalEvaluateRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        accessToken:
            (accessToken != null ? accessToken.value : this.accessToken),
        accountId: (accountId != null ? accountId.value : this.accountId),
        clientTransactionId: (clientTransactionId != null
            ? clientTransactionId.value
            : this.clientTransactionId),
        amount: (amount != null ? amount.value : this.amount),
        userPresent:
            (userPresent != null ? userPresent.value : this.userPresent),
        clientUserId:
            (clientUserId != null ? clientUserId.value : this.clientUserId),
        isRecurring:
            (isRecurring != null ? isRecurring.value : this.isRecurring),
        defaultPaymentMethod: (defaultPaymentMethod != null
            ? defaultPaymentMethod.value
            : this.defaultPaymentMethod),
        user: (user != null ? user.value : this.user),
        device: (device != null ? device.value : this.device));
  }
}

@JsonSerializable(explicitToJson: true)
class SignalUser {
  SignalUser({
    this.name,
    this.phoneNumber,
    this.emailAddress,
    this.address,
  });

  factory SignalUser.fromJson(Map<String, dynamic> json) =>
      _$SignalUserFromJson(json);

  @JsonKey(name: 'name')
  final SignalPersonName? name;
  @JsonKey(name: 'phone_number')
  final String? phoneNumber;
  @JsonKey(name: 'email_address')
  final String? emailAddress;
  @JsonKey(name: 'address')
  final SignalAddressData? address;
  static const fromJsonFactory = _$SignalUserFromJson;
  static const toJsonFactory = _$SignalUserToJson;
  Map<String, dynamic> toJson() => _$SignalUserToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SignalUser &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.phoneNumber, phoneNumber) ||
                const DeepCollectionEquality()
                    .equals(other.phoneNumber, phoneNumber)) &&
            (identical(other.emailAddress, emailAddress) ||
                const DeepCollectionEquality()
                    .equals(other.emailAddress, emailAddress)) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality().equals(other.address, address)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(phoneNumber) ^
      const DeepCollectionEquality().hash(emailAddress) ^
      const DeepCollectionEquality().hash(address) ^
      runtimeType.hashCode;
}

extension $SignalUserExtension on SignalUser {
  SignalUser copyWith(
      {SignalPersonName? name,
      String? phoneNumber,
      String? emailAddress,
      SignalAddressData? address}) {
    return SignalUser(
        name: name ?? this.name,
        phoneNumber: phoneNumber ?? this.phoneNumber,
        emailAddress: emailAddress ?? this.emailAddress,
        address: address ?? this.address);
  }

  SignalUser copyWithWrapped(
      {Wrapped<SignalPersonName?>? name,
      Wrapped<String?>? phoneNumber,
      Wrapped<String?>? emailAddress,
      Wrapped<SignalAddressData?>? address}) {
    return SignalUser(
        name: (name != null ? name.value : this.name),
        phoneNumber:
            (phoneNumber != null ? phoneNumber.value : this.phoneNumber),
        emailAddress:
            (emailAddress != null ? emailAddress.value : this.emailAddress),
        address: (address != null ? address.value : this.address));
  }
}

@JsonSerializable(explicitToJson: true)
class SignalPersonName {
  SignalPersonName({
    this.prefix,
    this.givenName,
    this.middleName,
    this.familyName,
    this.suffix,
  });

  factory SignalPersonName.fromJson(Map<String, dynamic> json) =>
      _$SignalPersonNameFromJson(json);

  @JsonKey(name: 'prefix')
  final String? prefix;
  @JsonKey(name: 'given_name')
  final String? givenName;
  @JsonKey(name: 'middle_name')
  final String? middleName;
  @JsonKey(name: 'family_name')
  final String? familyName;
  @JsonKey(name: 'suffix')
  final String? suffix;
  static const fromJsonFactory = _$SignalPersonNameFromJson;
  static const toJsonFactory = _$SignalPersonNameToJson;
  Map<String, dynamic> toJson() => _$SignalPersonNameToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SignalPersonName &&
            (identical(other.prefix, prefix) ||
                const DeepCollectionEquality().equals(other.prefix, prefix)) &&
            (identical(other.givenName, givenName) ||
                const DeepCollectionEquality()
                    .equals(other.givenName, givenName)) &&
            (identical(other.middleName, middleName) ||
                const DeepCollectionEquality()
                    .equals(other.middleName, middleName)) &&
            (identical(other.familyName, familyName) ||
                const DeepCollectionEquality()
                    .equals(other.familyName, familyName)) &&
            (identical(other.suffix, suffix) ||
                const DeepCollectionEquality().equals(other.suffix, suffix)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(prefix) ^
      const DeepCollectionEquality().hash(givenName) ^
      const DeepCollectionEquality().hash(middleName) ^
      const DeepCollectionEquality().hash(familyName) ^
      const DeepCollectionEquality().hash(suffix) ^
      runtimeType.hashCode;
}

extension $SignalPersonNameExtension on SignalPersonName {
  SignalPersonName copyWith(
      {String? prefix,
      String? givenName,
      String? middleName,
      String? familyName,
      String? suffix}) {
    return SignalPersonName(
        prefix: prefix ?? this.prefix,
        givenName: givenName ?? this.givenName,
        middleName: middleName ?? this.middleName,
        familyName: familyName ?? this.familyName,
        suffix: suffix ?? this.suffix);
  }

  SignalPersonName copyWithWrapped(
      {Wrapped<String?>? prefix,
      Wrapped<String?>? givenName,
      Wrapped<String?>? middleName,
      Wrapped<String?>? familyName,
      Wrapped<String?>? suffix}) {
    return SignalPersonName(
        prefix: (prefix != null ? prefix.value : this.prefix),
        givenName: (givenName != null ? givenName.value : this.givenName),
        middleName: (middleName != null ? middleName.value : this.middleName),
        familyName: (familyName != null ? familyName.value : this.familyName),
        suffix: (suffix != null ? suffix.value : this.suffix));
  }
}

@JsonSerializable(explicitToJson: true)
class SignalAddressData {
  SignalAddressData({
    this.city,
    this.region,
    this.street,
    this.postalCode,
    this.country,
  });

  factory SignalAddressData.fromJson(Map<String, dynamic> json) =>
      _$SignalAddressDataFromJson(json);

  @JsonKey(name: 'city')
  final String? city;
  @JsonKey(name: 'region')
  final String? region;
  @JsonKey(name: 'street')
  final String? street;
  @JsonKey(name: 'postal_code')
  final String? postalCode;
  @JsonKey(name: 'country')
  final String? country;
  static const fromJsonFactory = _$SignalAddressDataFromJson;
  static const toJsonFactory = _$SignalAddressDataToJson;
  Map<String, dynamic> toJson() => _$SignalAddressDataToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SignalAddressData &&
            (identical(other.city, city) ||
                const DeepCollectionEquality().equals(other.city, city)) &&
            (identical(other.region, region) ||
                const DeepCollectionEquality().equals(other.region, region)) &&
            (identical(other.street, street) ||
                const DeepCollectionEquality().equals(other.street, street)) &&
            (identical(other.postalCode, postalCode) ||
                const DeepCollectionEquality()
                    .equals(other.postalCode, postalCode)) &&
            (identical(other.country, country) ||
                const DeepCollectionEquality().equals(other.country, country)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(city) ^
      const DeepCollectionEquality().hash(region) ^
      const DeepCollectionEquality().hash(street) ^
      const DeepCollectionEquality().hash(postalCode) ^
      const DeepCollectionEquality().hash(country) ^
      runtimeType.hashCode;
}

extension $SignalAddressDataExtension on SignalAddressData {
  SignalAddressData copyWith(
      {String? city,
      String? region,
      String? street,
      String? postalCode,
      String? country}) {
    return SignalAddressData(
        city: city ?? this.city,
        region: region ?? this.region,
        street: street ?? this.street,
        postalCode: postalCode ?? this.postalCode,
        country: country ?? this.country);
  }

  SignalAddressData copyWithWrapped(
      {Wrapped<String?>? city,
      Wrapped<String?>? region,
      Wrapped<String?>? street,
      Wrapped<String?>? postalCode,
      Wrapped<String?>? country}) {
    return SignalAddressData(
        city: (city != null ? city.value : this.city),
        region: (region != null ? region.value : this.region),
        street: (street != null ? street.value : this.street),
        postalCode: (postalCode != null ? postalCode.value : this.postalCode),
        country: (country != null ? country.value : this.country));
  }
}

@JsonSerializable(explicitToJson: true)
class SignalDevice {
  SignalDevice({
    this.ipAddress,
    this.userAgent,
  });

  factory SignalDevice.fromJson(Map<String, dynamic> json) =>
      _$SignalDeviceFromJson(json);

  @JsonKey(name: 'ip_address')
  final String? ipAddress;
  @JsonKey(name: 'user_agent')
  final String? userAgent;
  static const fromJsonFactory = _$SignalDeviceFromJson;
  static const toJsonFactory = _$SignalDeviceToJson;
  Map<String, dynamic> toJson() => _$SignalDeviceToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SignalDevice &&
            (identical(other.ipAddress, ipAddress) ||
                const DeepCollectionEquality()
                    .equals(other.ipAddress, ipAddress)) &&
            (identical(other.userAgent, userAgent) ||
                const DeepCollectionEquality()
                    .equals(other.userAgent, userAgent)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ipAddress) ^
      const DeepCollectionEquality().hash(userAgent) ^
      runtimeType.hashCode;
}

extension $SignalDeviceExtension on SignalDevice {
  SignalDevice copyWith({String? ipAddress, String? userAgent}) {
    return SignalDevice(
        ipAddress: ipAddress ?? this.ipAddress,
        userAgent: userAgent ?? this.userAgent);
  }

  SignalDevice copyWithWrapped(
      {Wrapped<String?>? ipAddress, Wrapped<String?>? userAgent}) {
    return SignalDevice(
        ipAddress: (ipAddress != null ? ipAddress.value : this.ipAddress),
        userAgent: (userAgent != null ? userAgent.value : this.userAgent));
  }
}

@JsonSerializable(explicitToJson: true)
class SignalEvaluateResponse {
  SignalEvaluateResponse({
    required this.requestId,
    required this.scores,
    this.coreAttributes,
  });

  factory SignalEvaluateResponse.fromJson(Map<String, dynamic> json) =>
      _$SignalEvaluateResponseFromJson(json);

  @JsonKey(name: 'request_id')
  final String requestId;
  @JsonKey(name: 'scores')
  final SignalScores scores;
  @JsonKey(name: 'core_attributes')
  final SignalEvaluateCoreAttributes? coreAttributes;
  static const fromJsonFactory = _$SignalEvaluateResponseFromJson;
  static const toJsonFactory = _$SignalEvaluateResponseToJson;
  Map<String, dynamic> toJson() => _$SignalEvaluateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SignalEvaluateResponse &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)) &&
            (identical(other.scores, scores) ||
                const DeepCollectionEquality().equals(other.scores, scores)) &&
            (identical(other.coreAttributes, coreAttributes) ||
                const DeepCollectionEquality()
                    .equals(other.coreAttributes, coreAttributes)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(requestId) ^
      const DeepCollectionEquality().hash(scores) ^
      const DeepCollectionEquality().hash(coreAttributes) ^
      runtimeType.hashCode;
}

extension $SignalEvaluateResponseExtension on SignalEvaluateResponse {
  SignalEvaluateResponse copyWith(
      {String? requestId,
      SignalScores? scores,
      SignalEvaluateCoreAttributes? coreAttributes}) {
    return SignalEvaluateResponse(
        requestId: requestId ?? this.requestId,
        scores: scores ?? this.scores,
        coreAttributes: coreAttributes ?? this.coreAttributes);
  }

  SignalEvaluateResponse copyWithWrapped(
      {Wrapped<String>? requestId,
      Wrapped<SignalScores>? scores,
      Wrapped<SignalEvaluateCoreAttributes?>? coreAttributes}) {
    return SignalEvaluateResponse(
        requestId: (requestId != null ? requestId.value : this.requestId),
        scores: (scores != null ? scores.value : this.scores),
        coreAttributes: (coreAttributes != null
            ? coreAttributes.value
            : this.coreAttributes));
  }
}

@JsonSerializable(explicitToJson: true)
class SignalScores {
  SignalScores({
    this.customerInitiatedReturnRisk,
    this.bankInitiatedReturnRisk,
  });

  factory SignalScores.fromJson(Map<String, dynamic> json) =>
      _$SignalScoresFromJson(json);

  @JsonKey(name: 'customer_initiated_return_risk')
  final CustomerInitiatedReturnRisk? customerInitiatedReturnRisk;
  @JsonKey(name: 'bank_initiated_return_risk')
  final BankInitiatedReturnRisk? bankInitiatedReturnRisk;
  static const fromJsonFactory = _$SignalScoresFromJson;
  static const toJsonFactory = _$SignalScoresToJson;
  Map<String, dynamic> toJson() => _$SignalScoresToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SignalScores &&
            (identical(other.customerInitiatedReturnRisk,
                    customerInitiatedReturnRisk) ||
                const DeepCollectionEquality().equals(
                    other.customerInitiatedReturnRisk,
                    customerInitiatedReturnRisk)) &&
            (identical(
                    other.bankInitiatedReturnRisk, bankInitiatedReturnRisk) ||
                const DeepCollectionEquality().equals(
                    other.bankInitiatedReturnRisk, bankInitiatedReturnRisk)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(customerInitiatedReturnRisk) ^
      const DeepCollectionEquality().hash(bankInitiatedReturnRisk) ^
      runtimeType.hashCode;
}

extension $SignalScoresExtension on SignalScores {
  SignalScores copyWith(
      {CustomerInitiatedReturnRisk? customerInitiatedReturnRisk,
      BankInitiatedReturnRisk? bankInitiatedReturnRisk}) {
    return SignalScores(
        customerInitiatedReturnRisk:
            customerInitiatedReturnRisk ?? this.customerInitiatedReturnRisk,
        bankInitiatedReturnRisk:
            bankInitiatedReturnRisk ?? this.bankInitiatedReturnRisk);
  }

  SignalScores copyWithWrapped(
      {Wrapped<CustomerInitiatedReturnRisk?>? customerInitiatedReturnRisk,
      Wrapped<BankInitiatedReturnRisk?>? bankInitiatedReturnRisk}) {
    return SignalScores(
        customerInitiatedReturnRisk: (customerInitiatedReturnRisk != null
            ? customerInitiatedReturnRisk.value
            : this.customerInitiatedReturnRisk),
        bankInitiatedReturnRisk: (bankInitiatedReturnRisk != null
            ? bankInitiatedReturnRisk.value
            : this.bankInitiatedReturnRisk));
  }
}

@JsonSerializable(explicitToJson: true)
class CustomerInitiatedReturnRisk {
  CustomerInitiatedReturnRisk({
    required this.score,
    required this.riskTier,
  });

  factory CustomerInitiatedReturnRisk.fromJson(Map<String, dynamic> json) =>
      _$CustomerInitiatedReturnRiskFromJson(json);

  @JsonKey(name: 'score')
  final int score;
  @JsonKey(name: 'risk_tier')
  final int riskTier;
  static const fromJsonFactory = _$CustomerInitiatedReturnRiskFromJson;
  static const toJsonFactory = _$CustomerInitiatedReturnRiskToJson;
  Map<String, dynamic> toJson() => _$CustomerInitiatedReturnRiskToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CustomerInitiatedReturnRisk &&
            (identical(other.score, score) ||
                const DeepCollectionEquality().equals(other.score, score)) &&
            (identical(other.riskTier, riskTier) ||
                const DeepCollectionEquality()
                    .equals(other.riskTier, riskTier)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(score) ^
      const DeepCollectionEquality().hash(riskTier) ^
      runtimeType.hashCode;
}

extension $CustomerInitiatedReturnRiskExtension on CustomerInitiatedReturnRisk {
  CustomerInitiatedReturnRisk copyWith({int? score, int? riskTier}) {
    return CustomerInitiatedReturnRisk(
        score: score ?? this.score, riskTier: riskTier ?? this.riskTier);
  }

  CustomerInitiatedReturnRisk copyWithWrapped(
      {Wrapped<int>? score, Wrapped<int>? riskTier}) {
    return CustomerInitiatedReturnRisk(
        score: (score != null ? score.value : this.score),
        riskTier: (riskTier != null ? riskTier.value : this.riskTier));
  }
}

@JsonSerializable(explicitToJson: true)
class BankInitiatedReturnRisk {
  BankInitiatedReturnRisk({
    required this.score,
    required this.riskTier,
  });

  factory BankInitiatedReturnRisk.fromJson(Map<String, dynamic> json) =>
      _$BankInitiatedReturnRiskFromJson(json);

  @JsonKey(name: 'score')
  final int score;
  @JsonKey(name: 'risk_tier')
  final int riskTier;
  static const fromJsonFactory = _$BankInitiatedReturnRiskFromJson;
  static const toJsonFactory = _$BankInitiatedReturnRiskToJson;
  Map<String, dynamic> toJson() => _$BankInitiatedReturnRiskToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BankInitiatedReturnRisk &&
            (identical(other.score, score) ||
                const DeepCollectionEquality().equals(other.score, score)) &&
            (identical(other.riskTier, riskTier) ||
                const DeepCollectionEquality()
                    .equals(other.riskTier, riskTier)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(score) ^
      const DeepCollectionEquality().hash(riskTier) ^
      runtimeType.hashCode;
}

extension $BankInitiatedReturnRiskExtension on BankInitiatedReturnRisk {
  BankInitiatedReturnRisk copyWith({int? score, int? riskTier}) {
    return BankInitiatedReturnRisk(
        score: score ?? this.score, riskTier: riskTier ?? this.riskTier);
  }

  BankInitiatedReturnRisk copyWithWrapped(
      {Wrapped<int>? score, Wrapped<int>? riskTier}) {
    return BankInitiatedReturnRisk(
        score: (score != null ? score.value : this.score),
        riskTier: (riskTier != null ? riskTier.value : this.riskTier));
  }
}

@JsonSerializable(explicitToJson: true)
class SignalEvaluateCoreAttributes {
  SignalEvaluateCoreAttributes({
    this.unauthorizedTransactionsCount7d,
    this.unauthorizedTransactionsCount30d,
    this.unauthorizedTransactionsCount60d,
    this.unauthorizedTransactionsCount90d,
    this.nsfOverdraftTransactionsCount7d,
    this.nsfOverdraftTransactionsCount30d,
    this.nsfOverdraftTransactionsCount60d,
    this.nsfOverdraftTransactionsCount90d,
    this.daysSinceFirstPlaidConnection,
    this.plaidConnectionsCount7d,
    this.plaidConnectionsCount30d,
    this.totalPlaidConnectionsCount,
    this.isSavingsOrMoneyMarketAccount,
    this.totalCreditTransactionsAmount10d,
    this.totalDebitTransactionsAmount10d,
    this.p50CreditTransactionsAmount28d,
    this.p50DebitTransactionsAmount28d,
    this.p95CreditTransactionsAmount28d,
    this.p95DebitTransactionsAmount28d,
    this.daysWithNegativeBalanceCount90d,
    this.p90EodBalance30d,
    this.p90EodBalance60d,
    this.p90EodBalance90d,
    this.p10EodBalance30d,
    this.p10EodBalance60d,
    this.p10EodBalance90d,
    this.availableBalance,
    this.currentBalance,
    this.balanceLastUpdated,
    this.phoneChangeCount28d,
    this.phoneChangeCount90d,
    this.emailChangeCount28d,
    this.emailChangeCount90d,
    this.addressChangeCount28d,
    this.addressChangeCount90d,
    this.plaidNonOauthAuthenticationAttemptsCount3d,
    this.plaidNonOauthAuthenticationAttemptsCount7d,
    this.plaidNonOauthAuthenticationAttemptsCount30d,
    this.failedPlaidNonOauthAuthenticationAttemptsCount3d,
    this.failedPlaidNonOauthAuthenticationAttemptsCount7d,
    this.failedPlaidNonOauthAuthenticationAttemptsCount30d,
    this.debitTransactionsCount10d,
    this.creditTransactionsCount10d,
    this.debitTransactionsCount30d,
    this.creditTransactionsCount30d,
    this.debitTransactionsCount60d,
    this.creditTransactionsCount60d,
    this.debitTransactionsCount90d,
    this.creditTransactionsCount90d,
    this.totalDebitTransactionsAmount30d,
    this.totalCreditTransactionsAmount30d,
    this.totalDebitTransactionsAmount60d,
    this.totalCreditTransactionsAmount60d,
    this.totalDebitTransactionsAmount90d,
    this.totalCreditTransactionsAmount90d,
    this.p50EodBalance30d,
    this.p50EodBalance60d,
    this.p50EodBalance90d,
    this.p50EodBalance31dTo60d,
    this.p50EodBalance61dTo90d,
    this.p90EodBalance31dTo60d,
    this.p90EodBalance61dTo90d,
    this.p10EodBalance31dTo60d,
    this.p10EodBalance61dTo90d,
    this.transactionsLastUpdated,
  });

  factory SignalEvaluateCoreAttributes.fromJson(Map<String, dynamic> json) =>
      _$SignalEvaluateCoreAttributesFromJson(json);

  @JsonKey(name: 'unauthorized_transactions_count_7d')
  final int? unauthorizedTransactionsCount7d;
  @JsonKey(name: 'unauthorized_transactions_count_30d')
  final int? unauthorizedTransactionsCount30d;
  @JsonKey(name: 'unauthorized_transactions_count_60d')
  final int? unauthorizedTransactionsCount60d;
  @JsonKey(name: 'unauthorized_transactions_count_90d')
  final int? unauthorizedTransactionsCount90d;
  @JsonKey(name: 'nsf_overdraft_transactions_count_7d')
  final int? nsfOverdraftTransactionsCount7d;
  @JsonKey(name: 'nsf_overdraft_transactions_count_30d')
  final int? nsfOverdraftTransactionsCount30d;
  @JsonKey(name: 'nsf_overdraft_transactions_count_60d')
  final int? nsfOverdraftTransactionsCount60d;
  @JsonKey(name: 'nsf_overdraft_transactions_count_90d')
  final int? nsfOverdraftTransactionsCount90d;
  @JsonKey(name: 'days_since_first_plaid_connection')
  final int? daysSinceFirstPlaidConnection;
  @JsonKey(name: 'plaid_connections_count_7d')
  final int? plaidConnectionsCount7d;
  @JsonKey(name: 'plaid_connections_count_30d')
  final int? plaidConnectionsCount30d;
  @JsonKey(name: 'total_plaid_connections_count')
  final int? totalPlaidConnectionsCount;
  @JsonKey(name: 'is_savings_or_money_market_account')
  final bool? isSavingsOrMoneyMarketAccount;
  @JsonKey(name: 'total_credit_transactions_amount_10d')
  final double? totalCreditTransactionsAmount10d;
  @JsonKey(name: 'total_debit_transactions_amount_10d')
  final double? totalDebitTransactionsAmount10d;
  @JsonKey(name: 'p50_credit_transactions_amount_28d')
  final double? p50CreditTransactionsAmount28d;
  @JsonKey(name: 'p50_debit_transactions_amount_28d')
  final double? p50DebitTransactionsAmount28d;
  @JsonKey(name: 'p95_credit_transactions_amount_28d')
  final double? p95CreditTransactionsAmount28d;
  @JsonKey(name: 'p95_debit_transactions_amount_28d')
  final double? p95DebitTransactionsAmount28d;
  @JsonKey(name: 'days_with_negative_balance_count_90d')
  final int? daysWithNegativeBalanceCount90d;
  @JsonKey(name: 'p90_eod_balance_30d')
  final double? p90EodBalance30d;
  @JsonKey(name: 'p90_eod_balance_60d')
  final double? p90EodBalance60d;
  @JsonKey(name: 'p90_eod_balance_90d')
  final double? p90EodBalance90d;
  @JsonKey(name: 'p10_eod_balance_30d')
  final double? p10EodBalance30d;
  @JsonKey(name: 'p10_eod_balance_60d')
  final double? p10EodBalance60d;
  @JsonKey(name: 'p10_eod_balance_90d')
  final double? p10EodBalance90d;
  @JsonKey(name: 'available_balance')
  final double? availableBalance;
  @JsonKey(name: 'current_balance')
  final double? currentBalance;
  @JsonKey(name: 'balance_last_updated')
  final DateTime? balanceLastUpdated;
  @JsonKey(name: 'phone_change_count_28d')
  final int? phoneChangeCount28d;
  @JsonKey(name: 'phone_change_count_90d')
  final int? phoneChangeCount90d;
  @JsonKey(name: 'email_change_count_28d')
  final int? emailChangeCount28d;
  @JsonKey(name: 'email_change_count_90d')
  final int? emailChangeCount90d;
  @JsonKey(name: 'address_change_count_28d')
  final int? addressChangeCount28d;
  @JsonKey(name: 'address_change_count_90d')
  final int? addressChangeCount90d;
  @JsonKey(name: 'plaid_non_oauth_authentication_attempts_count_3d')
  final int? plaidNonOauthAuthenticationAttemptsCount3d;
  @JsonKey(name: 'plaid_non_oauth_authentication_attempts_count_7d')
  final int? plaidNonOauthAuthenticationAttemptsCount7d;
  @JsonKey(name: 'plaid_non_oauth_authentication_attempts_count_30d')
  final int? plaidNonOauthAuthenticationAttemptsCount30d;
  @JsonKey(name: 'failed_plaid_non_oauth_authentication_attempts_count_3d')
  final int? failedPlaidNonOauthAuthenticationAttemptsCount3d;
  @JsonKey(name: 'failed_plaid_non_oauth_authentication_attempts_count_7d')
  final int? failedPlaidNonOauthAuthenticationAttemptsCount7d;
  @JsonKey(name: 'failed_plaid_non_oauth_authentication_attempts_count_30d')
  final int? failedPlaidNonOauthAuthenticationAttemptsCount30d;
  @JsonKey(name: 'debit_transactions_count_10d')
  final int? debitTransactionsCount10d;
  @JsonKey(name: 'credit_transactions_count_10d')
  final int? creditTransactionsCount10d;
  @JsonKey(name: 'debit_transactions_count_30d')
  final int? debitTransactionsCount30d;
  @JsonKey(name: 'credit_transactions_count_30d')
  final int? creditTransactionsCount30d;
  @JsonKey(name: 'debit_transactions_count_60d')
  final int? debitTransactionsCount60d;
  @JsonKey(name: 'credit_transactions_count_60d')
  final int? creditTransactionsCount60d;
  @JsonKey(name: 'debit_transactions_count_90d')
  final int? debitTransactionsCount90d;
  @JsonKey(name: 'credit_transactions_count_90d')
  final int? creditTransactionsCount90d;
  @JsonKey(name: 'total_debit_transactions_amount_30d')
  final double? totalDebitTransactionsAmount30d;
  @JsonKey(name: 'total_credit_transactions_amount_30d')
  final double? totalCreditTransactionsAmount30d;
  @JsonKey(name: 'total_debit_transactions_amount_60d')
  final double? totalDebitTransactionsAmount60d;
  @JsonKey(name: 'total_credit_transactions_amount_60d')
  final double? totalCreditTransactionsAmount60d;
  @JsonKey(name: 'total_debit_transactions_amount_90d')
  final double? totalDebitTransactionsAmount90d;
  @JsonKey(name: 'total_credit_transactions_amount_90d')
  final double? totalCreditTransactionsAmount90d;
  @JsonKey(name: 'p50_eod_balance_30d')
  final double? p50EodBalance30d;
  @JsonKey(name: 'p50_eod_balance_60d')
  final double? p50EodBalance60d;
  @JsonKey(name: 'p50_eod_balance_90d')
  final double? p50EodBalance90d;
  @JsonKey(name: 'p50_eod_balance_31d_to_60d')
  final double? p50EodBalance31dTo60d;
  @JsonKey(name: 'p50_eod_balance_61d_to_90d')
  final double? p50EodBalance61dTo90d;
  @JsonKey(name: 'p90_eod_balance_31d_to_60d')
  final double? p90EodBalance31dTo60d;
  @JsonKey(name: 'p90_eod_balance_61d_to_90d')
  final double? p90EodBalance61dTo90d;
  @JsonKey(name: 'p10_eod_balance_31d_to_60d')
  final double? p10EodBalance31dTo60d;
  @JsonKey(name: 'p10_eod_balance_61d_to_90d')
  final double? p10EodBalance61dTo90d;
  @JsonKey(name: 'transactions_last_updated')
  final DateTime? transactionsLastUpdated;
  static const fromJsonFactory = _$SignalEvaluateCoreAttributesFromJson;
  static const toJsonFactory = _$SignalEvaluateCoreAttributesToJson;
  Map<String, dynamic> toJson() => _$SignalEvaluateCoreAttributesToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SignalEvaluateCoreAttributes &&
            (identical(other.unauthorizedTransactionsCount7d, unauthorizedTransactionsCount7d) ||
                const DeepCollectionEquality().equals(
                    other.unauthorizedTransactionsCount7d,
                    unauthorizedTransactionsCount7d)) &&
            (identical(other.unauthorizedTransactionsCount30d, unauthorizedTransactionsCount30d) ||
                const DeepCollectionEquality().equals(
                    other.unauthorizedTransactionsCount30d,
                    unauthorizedTransactionsCount30d)) &&
            (identical(other.unauthorizedTransactionsCount60d, unauthorizedTransactionsCount60d) ||
                const DeepCollectionEquality().equals(
                    other.unauthorizedTransactionsCount60d,
                    unauthorizedTransactionsCount60d)) &&
            (identical(other.unauthorizedTransactionsCount90d, unauthorizedTransactionsCount90d) ||
                const DeepCollectionEquality().equals(
                    other.unauthorizedTransactionsCount90d,
                    unauthorizedTransactionsCount90d)) &&
            (identical(other.nsfOverdraftTransactionsCount7d, nsfOverdraftTransactionsCount7d) ||
                const DeepCollectionEquality().equals(
                    other.nsfOverdraftTransactionsCount7d,
                    nsfOverdraftTransactionsCount7d)) &&
            (identical(other.nsfOverdraftTransactionsCount30d, nsfOverdraftTransactionsCount30d) ||
                const DeepCollectionEquality().equals(
                    other.nsfOverdraftTransactionsCount30d,
                    nsfOverdraftTransactionsCount30d)) &&
            (identical(other.nsfOverdraftTransactionsCount60d, nsfOverdraftTransactionsCount60d) ||
                const DeepCollectionEquality().equals(
                    other.nsfOverdraftTransactionsCount60d,
                    nsfOverdraftTransactionsCount60d)) &&
            (identical(other.nsfOverdraftTransactionsCount90d, nsfOverdraftTransactionsCount90d) ||
                const DeepCollectionEquality().equals(
                    other.nsfOverdraftTransactionsCount90d,
                    nsfOverdraftTransactionsCount90d)) &&
            (identical(other.daysSinceFirstPlaidConnection, daysSinceFirstPlaidConnection) ||
                const DeepCollectionEquality().equals(
                    other.daysSinceFirstPlaidConnection,
                    daysSinceFirstPlaidConnection)) &&
            (identical(other.plaidConnectionsCount7d, plaidConnectionsCount7d) ||
                const DeepCollectionEquality().equals(other.plaidConnectionsCount7d, plaidConnectionsCount7d)) &&
            (identical(other.plaidConnectionsCount30d, plaidConnectionsCount30d) || const DeepCollectionEquality().equals(other.plaidConnectionsCount30d, plaidConnectionsCount30d)) &&
            (identical(other.totalPlaidConnectionsCount, totalPlaidConnectionsCount) || const DeepCollectionEquality().equals(other.totalPlaidConnectionsCount, totalPlaidConnectionsCount)) &&
            (identical(other.isSavingsOrMoneyMarketAccount, isSavingsOrMoneyMarketAccount) || const DeepCollectionEquality().equals(other.isSavingsOrMoneyMarketAccount, isSavingsOrMoneyMarketAccount)) &&
            (identical(other.totalCreditTransactionsAmount10d, totalCreditTransactionsAmount10d) || const DeepCollectionEquality().equals(other.totalCreditTransactionsAmount10d, totalCreditTransactionsAmount10d)) &&
            (identical(other.totalDebitTransactionsAmount10d, totalDebitTransactionsAmount10d) || const DeepCollectionEquality().equals(other.totalDebitTransactionsAmount10d, totalDebitTransactionsAmount10d)) &&
            (identical(other.p50CreditTransactionsAmount28d, p50CreditTransactionsAmount28d) || const DeepCollectionEquality().equals(other.p50CreditTransactionsAmount28d, p50CreditTransactionsAmount28d)) &&
            (identical(other.p50DebitTransactionsAmount28d, p50DebitTransactionsAmount28d) || const DeepCollectionEquality().equals(other.p50DebitTransactionsAmount28d, p50DebitTransactionsAmount28d)) &&
            (identical(other.p95CreditTransactionsAmount28d, p95CreditTransactionsAmount28d) || const DeepCollectionEquality().equals(other.p95CreditTransactionsAmount28d, p95CreditTransactionsAmount28d)) &&
            (identical(other.p95DebitTransactionsAmount28d, p95DebitTransactionsAmount28d) || const DeepCollectionEquality().equals(other.p95DebitTransactionsAmount28d, p95DebitTransactionsAmount28d)) &&
            (identical(other.daysWithNegativeBalanceCount90d, daysWithNegativeBalanceCount90d) || const DeepCollectionEquality().equals(other.daysWithNegativeBalanceCount90d, daysWithNegativeBalanceCount90d)) &&
            (identical(other.p90EodBalance30d, p90EodBalance30d) || const DeepCollectionEquality().equals(other.p90EodBalance30d, p90EodBalance30d)) &&
            (identical(other.p90EodBalance60d, p90EodBalance60d) || const DeepCollectionEquality().equals(other.p90EodBalance60d, p90EodBalance60d)) &&
            (identical(other.p90EodBalance90d, p90EodBalance90d) || const DeepCollectionEquality().equals(other.p90EodBalance90d, p90EodBalance90d)) &&
            (identical(other.p10EodBalance30d, p10EodBalance30d) || const DeepCollectionEquality().equals(other.p10EodBalance30d, p10EodBalance30d)) &&
            (identical(other.p10EodBalance60d, p10EodBalance60d) || const DeepCollectionEquality().equals(other.p10EodBalance60d, p10EodBalance60d)) &&
            (identical(other.p10EodBalance90d, p10EodBalance90d) || const DeepCollectionEquality().equals(other.p10EodBalance90d, p10EodBalance90d)) &&
            (identical(other.availableBalance, availableBalance) || const DeepCollectionEquality().equals(other.availableBalance, availableBalance)) &&
            (identical(other.currentBalance, currentBalance) || const DeepCollectionEquality().equals(other.currentBalance, currentBalance)) &&
            (identical(other.balanceLastUpdated, balanceLastUpdated) || const DeepCollectionEquality().equals(other.balanceLastUpdated, balanceLastUpdated)) &&
            (identical(other.phoneChangeCount28d, phoneChangeCount28d) || const DeepCollectionEquality().equals(other.phoneChangeCount28d, phoneChangeCount28d)) &&
            (identical(other.phoneChangeCount90d, phoneChangeCount90d) || const DeepCollectionEquality().equals(other.phoneChangeCount90d, phoneChangeCount90d)) &&
            (identical(other.emailChangeCount28d, emailChangeCount28d) || const DeepCollectionEquality().equals(other.emailChangeCount28d, emailChangeCount28d)) &&
            (identical(other.emailChangeCount90d, emailChangeCount90d) || const DeepCollectionEquality().equals(other.emailChangeCount90d, emailChangeCount90d)) &&
            (identical(other.addressChangeCount28d, addressChangeCount28d) || const DeepCollectionEquality().equals(other.addressChangeCount28d, addressChangeCount28d)) &&
            (identical(other.addressChangeCount90d, addressChangeCount90d) || const DeepCollectionEquality().equals(other.addressChangeCount90d, addressChangeCount90d)) &&
            (identical(other.plaidNonOauthAuthenticationAttemptsCount3d, plaidNonOauthAuthenticationAttemptsCount3d) || const DeepCollectionEquality().equals(other.plaidNonOauthAuthenticationAttemptsCount3d, plaidNonOauthAuthenticationAttemptsCount3d)) &&
            (identical(other.plaidNonOauthAuthenticationAttemptsCount7d, plaidNonOauthAuthenticationAttemptsCount7d) || const DeepCollectionEquality().equals(other.plaidNonOauthAuthenticationAttemptsCount7d, plaidNonOauthAuthenticationAttemptsCount7d)) &&
            (identical(other.plaidNonOauthAuthenticationAttemptsCount30d, plaidNonOauthAuthenticationAttemptsCount30d) || const DeepCollectionEquality().equals(other.plaidNonOauthAuthenticationAttemptsCount30d, plaidNonOauthAuthenticationAttemptsCount30d)) &&
            (identical(other.failedPlaidNonOauthAuthenticationAttemptsCount3d, failedPlaidNonOauthAuthenticationAttemptsCount3d) || const DeepCollectionEquality().equals(other.failedPlaidNonOauthAuthenticationAttemptsCount3d, failedPlaidNonOauthAuthenticationAttemptsCount3d)) &&
            (identical(other.failedPlaidNonOauthAuthenticationAttemptsCount7d, failedPlaidNonOauthAuthenticationAttemptsCount7d) || const DeepCollectionEquality().equals(other.failedPlaidNonOauthAuthenticationAttemptsCount7d, failedPlaidNonOauthAuthenticationAttemptsCount7d)) &&
            (identical(other.failedPlaidNonOauthAuthenticationAttemptsCount30d, failedPlaidNonOauthAuthenticationAttemptsCount30d) || const DeepCollectionEquality().equals(other.failedPlaidNonOauthAuthenticationAttemptsCount30d, failedPlaidNonOauthAuthenticationAttemptsCount30d)) &&
            (identical(other.debitTransactionsCount10d, debitTransactionsCount10d) || const DeepCollectionEquality().equals(other.debitTransactionsCount10d, debitTransactionsCount10d)) &&
            (identical(other.creditTransactionsCount10d, creditTransactionsCount10d) || const DeepCollectionEquality().equals(other.creditTransactionsCount10d, creditTransactionsCount10d)) &&
            (identical(other.debitTransactionsCount30d, debitTransactionsCount30d) || const DeepCollectionEquality().equals(other.debitTransactionsCount30d, debitTransactionsCount30d)) &&
            (identical(other.creditTransactionsCount30d, creditTransactionsCount30d) || const DeepCollectionEquality().equals(other.creditTransactionsCount30d, creditTransactionsCount30d)) &&
            (identical(other.debitTransactionsCount60d, debitTransactionsCount60d) || const DeepCollectionEquality().equals(other.debitTransactionsCount60d, debitTransactionsCount60d)) &&
            (identical(other.creditTransactionsCount60d, creditTransactionsCount60d) || const DeepCollectionEquality().equals(other.creditTransactionsCount60d, creditTransactionsCount60d)) &&
            (identical(other.debitTransactionsCount90d, debitTransactionsCount90d) || const DeepCollectionEquality().equals(other.debitTransactionsCount90d, debitTransactionsCount90d)) &&
            (identical(other.creditTransactionsCount90d, creditTransactionsCount90d) || const DeepCollectionEquality().equals(other.creditTransactionsCount90d, creditTransactionsCount90d)) &&
            (identical(other.totalDebitTransactionsAmount30d, totalDebitTransactionsAmount30d) || const DeepCollectionEquality().equals(other.totalDebitTransactionsAmount30d, totalDebitTransactionsAmount30d)) &&
            (identical(other.totalCreditTransactionsAmount30d, totalCreditTransactionsAmount30d) || const DeepCollectionEquality().equals(other.totalCreditTransactionsAmount30d, totalCreditTransactionsAmount30d)) &&
            (identical(other.totalDebitTransactionsAmount60d, totalDebitTransactionsAmount60d) || const DeepCollectionEquality().equals(other.totalDebitTransactionsAmount60d, totalDebitTransactionsAmount60d)) &&
            (identical(other.totalCreditTransactionsAmount60d, totalCreditTransactionsAmount60d) || const DeepCollectionEquality().equals(other.totalCreditTransactionsAmount60d, totalCreditTransactionsAmount60d)) &&
            (identical(other.totalDebitTransactionsAmount90d, totalDebitTransactionsAmount90d) || const DeepCollectionEquality().equals(other.totalDebitTransactionsAmount90d, totalDebitTransactionsAmount90d)) &&
            (identical(other.totalCreditTransactionsAmount90d, totalCreditTransactionsAmount90d) || const DeepCollectionEquality().equals(other.totalCreditTransactionsAmount90d, totalCreditTransactionsAmount90d)) &&
            (identical(other.p50EodBalance30d, p50EodBalance30d) || const DeepCollectionEquality().equals(other.p50EodBalance30d, p50EodBalance30d)) &&
            (identical(other.p50EodBalance60d, p50EodBalance60d) || const DeepCollectionEquality().equals(other.p50EodBalance60d, p50EodBalance60d)) &&
            (identical(other.p50EodBalance90d, p50EodBalance90d) || const DeepCollectionEquality().equals(other.p50EodBalance90d, p50EodBalance90d)) &&
            (identical(other.p50EodBalance31dTo60d, p50EodBalance31dTo60d) || const DeepCollectionEquality().equals(other.p50EodBalance31dTo60d, p50EodBalance31dTo60d)) &&
            (identical(other.p50EodBalance61dTo90d, p50EodBalance61dTo90d) || const DeepCollectionEquality().equals(other.p50EodBalance61dTo90d, p50EodBalance61dTo90d)) &&
            (identical(other.p90EodBalance31dTo60d, p90EodBalance31dTo60d) || const DeepCollectionEquality().equals(other.p90EodBalance31dTo60d, p90EodBalance31dTo60d)) &&
            (identical(other.p90EodBalance61dTo90d, p90EodBalance61dTo90d) || const DeepCollectionEquality().equals(other.p90EodBalance61dTo90d, p90EodBalance61dTo90d)) &&
            (identical(other.p10EodBalance31dTo60d, p10EodBalance31dTo60d) || const DeepCollectionEquality().equals(other.p10EodBalance31dTo60d, p10EodBalance31dTo60d)) &&
            (identical(other.p10EodBalance61dTo90d, p10EodBalance61dTo90d) || const DeepCollectionEquality().equals(other.p10EodBalance61dTo90d, p10EodBalance61dTo90d)) &&
            (identical(other.transactionsLastUpdated, transactionsLastUpdated) || const DeepCollectionEquality().equals(other.transactionsLastUpdated, transactionsLastUpdated)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(unauthorizedTransactionsCount7d) ^
      const DeepCollectionEquality().hash(unauthorizedTransactionsCount30d) ^
      const DeepCollectionEquality().hash(unauthorizedTransactionsCount60d) ^
      const DeepCollectionEquality().hash(unauthorizedTransactionsCount90d) ^
      const DeepCollectionEquality().hash(nsfOverdraftTransactionsCount7d) ^
      const DeepCollectionEquality().hash(nsfOverdraftTransactionsCount30d) ^
      const DeepCollectionEquality().hash(nsfOverdraftTransactionsCount60d) ^
      const DeepCollectionEquality().hash(nsfOverdraftTransactionsCount90d) ^
      const DeepCollectionEquality().hash(daysSinceFirstPlaidConnection) ^
      const DeepCollectionEquality().hash(plaidConnectionsCount7d) ^
      const DeepCollectionEquality().hash(plaidConnectionsCount30d) ^
      const DeepCollectionEquality().hash(totalPlaidConnectionsCount) ^
      const DeepCollectionEquality().hash(isSavingsOrMoneyMarketAccount) ^
      const DeepCollectionEquality().hash(totalCreditTransactionsAmount10d) ^
      const DeepCollectionEquality().hash(totalDebitTransactionsAmount10d) ^
      const DeepCollectionEquality().hash(p50CreditTransactionsAmount28d) ^
      const DeepCollectionEquality().hash(p50DebitTransactionsAmount28d) ^
      const DeepCollectionEquality().hash(p95CreditTransactionsAmount28d) ^
      const DeepCollectionEquality().hash(p95DebitTransactionsAmount28d) ^
      const DeepCollectionEquality().hash(daysWithNegativeBalanceCount90d) ^
      const DeepCollectionEquality().hash(p90EodBalance30d) ^
      const DeepCollectionEquality().hash(p90EodBalance60d) ^
      const DeepCollectionEquality().hash(p90EodBalance90d) ^
      const DeepCollectionEquality().hash(p10EodBalance30d) ^
      const DeepCollectionEquality().hash(p10EodBalance60d) ^
      const DeepCollectionEquality().hash(p10EodBalance90d) ^
      const DeepCollectionEquality().hash(availableBalance) ^
      const DeepCollectionEquality().hash(currentBalance) ^
      const DeepCollectionEquality().hash(balanceLastUpdated) ^
      const DeepCollectionEquality().hash(phoneChangeCount28d) ^
      const DeepCollectionEquality().hash(phoneChangeCount90d) ^
      const DeepCollectionEquality().hash(emailChangeCount28d) ^
      const DeepCollectionEquality().hash(emailChangeCount90d) ^
      const DeepCollectionEquality().hash(addressChangeCount28d) ^
      const DeepCollectionEquality().hash(addressChangeCount90d) ^
      const DeepCollectionEquality()
          .hash(plaidNonOauthAuthenticationAttemptsCount3d) ^
      const DeepCollectionEquality()
          .hash(plaidNonOauthAuthenticationAttemptsCount7d) ^
      const DeepCollectionEquality()
          .hash(plaidNonOauthAuthenticationAttemptsCount30d) ^
      const DeepCollectionEquality()
          .hash(failedPlaidNonOauthAuthenticationAttemptsCount3d) ^
      const DeepCollectionEquality()
          .hash(failedPlaidNonOauthAuthenticationAttemptsCount7d) ^
      const DeepCollectionEquality()
          .hash(failedPlaidNonOauthAuthenticationAttemptsCount30d) ^
      const DeepCollectionEquality().hash(debitTransactionsCount10d) ^
      const DeepCollectionEquality().hash(creditTransactionsCount10d) ^
      const DeepCollectionEquality().hash(debitTransactionsCount30d) ^
      const DeepCollectionEquality().hash(creditTransactionsCount30d) ^
      const DeepCollectionEquality().hash(debitTransactionsCount60d) ^
      const DeepCollectionEquality().hash(creditTransactionsCount60d) ^
      const DeepCollectionEquality().hash(debitTransactionsCount90d) ^
      const DeepCollectionEquality().hash(creditTransactionsCount90d) ^
      const DeepCollectionEquality().hash(totalDebitTransactionsAmount30d) ^
      const DeepCollectionEquality().hash(totalCreditTransactionsAmount30d) ^
      const DeepCollectionEquality().hash(totalDebitTransactionsAmount60d) ^
      const DeepCollectionEquality().hash(totalCreditTransactionsAmount60d) ^
      const DeepCollectionEquality().hash(totalDebitTransactionsAmount90d) ^
      const DeepCollectionEquality().hash(totalCreditTransactionsAmount90d) ^
      const DeepCollectionEquality().hash(p50EodBalance30d) ^
      const DeepCollectionEquality().hash(p50EodBalance60d) ^
      const DeepCollectionEquality().hash(p50EodBalance90d) ^
      const DeepCollectionEquality().hash(p50EodBalance31dTo60d) ^
      const DeepCollectionEquality().hash(p50EodBalance61dTo90d) ^
      const DeepCollectionEquality().hash(p90EodBalance31dTo60d) ^
      const DeepCollectionEquality().hash(p90EodBalance61dTo90d) ^
      const DeepCollectionEquality().hash(p10EodBalance31dTo60d) ^
      const DeepCollectionEquality().hash(p10EodBalance61dTo90d) ^
      const DeepCollectionEquality().hash(transactionsLastUpdated) ^
      runtimeType.hashCode;
}

extension $SignalEvaluateCoreAttributesExtension
    on SignalEvaluateCoreAttributes {
  SignalEvaluateCoreAttributes copyWith(
      {int? unauthorizedTransactionsCount7d,
      int? unauthorizedTransactionsCount30d,
      int? unauthorizedTransactionsCount60d,
      int? unauthorizedTransactionsCount90d,
      int? nsfOverdraftTransactionsCount7d,
      int? nsfOverdraftTransactionsCount30d,
      int? nsfOverdraftTransactionsCount60d,
      int? nsfOverdraftTransactionsCount90d,
      int? daysSinceFirstPlaidConnection,
      int? plaidConnectionsCount7d,
      int? plaidConnectionsCount30d,
      int? totalPlaidConnectionsCount,
      bool? isSavingsOrMoneyMarketAccount,
      double? totalCreditTransactionsAmount10d,
      double? totalDebitTransactionsAmount10d,
      double? p50CreditTransactionsAmount28d,
      double? p50DebitTransactionsAmount28d,
      double? p95CreditTransactionsAmount28d,
      double? p95DebitTransactionsAmount28d,
      int? daysWithNegativeBalanceCount90d,
      double? p90EodBalance30d,
      double? p90EodBalance60d,
      double? p90EodBalance90d,
      double? p10EodBalance30d,
      double? p10EodBalance60d,
      double? p10EodBalance90d,
      double? availableBalance,
      double? currentBalance,
      DateTime? balanceLastUpdated,
      int? phoneChangeCount28d,
      int? phoneChangeCount90d,
      int? emailChangeCount28d,
      int? emailChangeCount90d,
      int? addressChangeCount28d,
      int? addressChangeCount90d,
      int? plaidNonOauthAuthenticationAttemptsCount3d,
      int? plaidNonOauthAuthenticationAttemptsCount7d,
      int? plaidNonOauthAuthenticationAttemptsCount30d,
      int? failedPlaidNonOauthAuthenticationAttemptsCount3d,
      int? failedPlaidNonOauthAuthenticationAttemptsCount7d,
      int? failedPlaidNonOauthAuthenticationAttemptsCount30d,
      int? debitTransactionsCount10d,
      int? creditTransactionsCount10d,
      int? debitTransactionsCount30d,
      int? creditTransactionsCount30d,
      int? debitTransactionsCount60d,
      int? creditTransactionsCount60d,
      int? debitTransactionsCount90d,
      int? creditTransactionsCount90d,
      double? totalDebitTransactionsAmount30d,
      double? totalCreditTransactionsAmount30d,
      double? totalDebitTransactionsAmount60d,
      double? totalCreditTransactionsAmount60d,
      double? totalDebitTransactionsAmount90d,
      double? totalCreditTransactionsAmount90d,
      double? p50EodBalance30d,
      double? p50EodBalance60d,
      double? p50EodBalance90d,
      double? p50EodBalance31dTo60d,
      double? p50EodBalance61dTo90d,
      double? p90EodBalance31dTo60d,
      double? p90EodBalance61dTo90d,
      double? p10EodBalance31dTo60d,
      double? p10EodBalance61dTo90d,
      DateTime? transactionsLastUpdated}) {
    return SignalEvaluateCoreAttributes(
        unauthorizedTransactionsCount7d: unauthorizedTransactionsCount7d ??
            this.unauthorizedTransactionsCount7d,
        unauthorizedTransactionsCount30d: unauthorizedTransactionsCount30d ??
            this.unauthorizedTransactionsCount30d,
        unauthorizedTransactionsCount60d: unauthorizedTransactionsCount60d ??
            this.unauthorizedTransactionsCount60d,
        unauthorizedTransactionsCount90d: unauthorizedTransactionsCount90d ??
            this.unauthorizedTransactionsCount90d,
        nsfOverdraftTransactionsCount7d: nsfOverdraftTransactionsCount7d ??
            this.nsfOverdraftTransactionsCount7d,
        nsfOverdraftTransactionsCount30d: nsfOverdraftTransactionsCount30d ??
            this.nsfOverdraftTransactionsCount30d,
        nsfOverdraftTransactionsCount60d: nsfOverdraftTransactionsCount60d ??
            this.nsfOverdraftTransactionsCount60d,
        nsfOverdraftTransactionsCount90d: nsfOverdraftTransactionsCount90d ??
            this.nsfOverdraftTransactionsCount90d,
        daysSinceFirstPlaidConnection:
            daysSinceFirstPlaidConnection ?? this.daysSinceFirstPlaidConnection,
        plaidConnectionsCount7d:
            plaidConnectionsCount7d ?? this.plaidConnectionsCount7d,
        plaidConnectionsCount30d:
            plaidConnectionsCount30d ?? this.plaidConnectionsCount30d,
        totalPlaidConnectionsCount:
            totalPlaidConnectionsCount ?? this.totalPlaidConnectionsCount,
        isSavingsOrMoneyMarketAccount:
            isSavingsOrMoneyMarketAccount ?? this.isSavingsOrMoneyMarketAccount,
        totalCreditTransactionsAmount10d: totalCreditTransactionsAmount10d ??
            this.totalCreditTransactionsAmount10d,
        totalDebitTransactionsAmount10d: totalDebitTransactionsAmount10d ??
            this.totalDebitTransactionsAmount10d,
        p50CreditTransactionsAmount28d: p50CreditTransactionsAmount28d ??
            this.p50CreditTransactionsAmount28d,
        p50DebitTransactionsAmount28d:
            p50DebitTransactionsAmount28d ?? this.p50DebitTransactionsAmount28d,
        p95CreditTransactionsAmount28d: p95CreditTransactionsAmount28d ??
            this.p95CreditTransactionsAmount28d,
        p95DebitTransactionsAmount28d:
            p95DebitTransactionsAmount28d ?? this.p95DebitTransactionsAmount28d,
        daysWithNegativeBalanceCount90d: daysWithNegativeBalanceCount90d ??
            this.daysWithNegativeBalanceCount90d,
        p90EodBalance30d: p90EodBalance30d ?? this.p90EodBalance30d,
        p90EodBalance60d: p90EodBalance60d ?? this.p90EodBalance60d,
        p90EodBalance90d: p90EodBalance90d ?? this.p90EodBalance90d,
        p10EodBalance30d: p10EodBalance30d ?? this.p10EodBalance30d,
        p10EodBalance60d: p10EodBalance60d ?? this.p10EodBalance60d,
        p10EodBalance90d: p10EodBalance90d ?? this.p10EodBalance90d,
        availableBalance: availableBalance ?? this.availableBalance,
        currentBalance: currentBalance ?? this.currentBalance,
        balanceLastUpdated: balanceLastUpdated ?? this.balanceLastUpdated,
        phoneChangeCount28d: phoneChangeCount28d ?? this.phoneChangeCount28d,
        phoneChangeCount90d: phoneChangeCount90d ?? this.phoneChangeCount90d,
        emailChangeCount28d: emailChangeCount28d ?? this.emailChangeCount28d,
        emailChangeCount90d: emailChangeCount90d ?? this.emailChangeCount90d,
        addressChangeCount28d:
            addressChangeCount28d ?? this.addressChangeCount28d,
        addressChangeCount90d:
            addressChangeCount90d ?? this.addressChangeCount90d,
        plaidNonOauthAuthenticationAttemptsCount3d:
            plaidNonOauthAuthenticationAttemptsCount3d ??
                this.plaidNonOauthAuthenticationAttemptsCount3d,
        plaidNonOauthAuthenticationAttemptsCount7d:
            plaidNonOauthAuthenticationAttemptsCount7d ??
                this.plaidNonOauthAuthenticationAttemptsCount7d,
        plaidNonOauthAuthenticationAttemptsCount30d:
            plaidNonOauthAuthenticationAttemptsCount30d ??
                this.plaidNonOauthAuthenticationAttemptsCount30d,
        failedPlaidNonOauthAuthenticationAttemptsCount3d:
            failedPlaidNonOauthAuthenticationAttemptsCount3d ??
                this.failedPlaidNonOauthAuthenticationAttemptsCount3d,
        failedPlaidNonOauthAuthenticationAttemptsCount7d:
            failedPlaidNonOauthAuthenticationAttemptsCount7d ??
                this.failedPlaidNonOauthAuthenticationAttemptsCount7d,
        failedPlaidNonOauthAuthenticationAttemptsCount30d:
            failedPlaidNonOauthAuthenticationAttemptsCount30d ??
                this.failedPlaidNonOauthAuthenticationAttemptsCount30d,
        debitTransactionsCount10d:
            debitTransactionsCount10d ?? this.debitTransactionsCount10d,
        creditTransactionsCount10d:
            creditTransactionsCount10d ?? this.creditTransactionsCount10d,
        debitTransactionsCount30d:
            debitTransactionsCount30d ?? this.debitTransactionsCount30d,
        creditTransactionsCount30d:
            creditTransactionsCount30d ?? this.creditTransactionsCount30d,
        debitTransactionsCount60d:
            debitTransactionsCount60d ?? this.debitTransactionsCount60d,
        creditTransactionsCount60d: creditTransactionsCount60d ?? this.creditTransactionsCount60d,
        debitTransactionsCount90d: debitTransactionsCount90d ?? this.debitTransactionsCount90d,
        creditTransactionsCount90d: creditTransactionsCount90d ?? this.creditTransactionsCount90d,
        totalDebitTransactionsAmount30d: totalDebitTransactionsAmount30d ?? this.totalDebitTransactionsAmount30d,
        totalCreditTransactionsAmount30d: totalCreditTransactionsAmount30d ?? this.totalCreditTransactionsAmount30d,
        totalDebitTransactionsAmount60d: totalDebitTransactionsAmount60d ?? this.totalDebitTransactionsAmount60d,
        totalCreditTransactionsAmount60d: totalCreditTransactionsAmount60d ?? this.totalCreditTransactionsAmount60d,
        totalDebitTransactionsAmount90d: totalDebitTransactionsAmount90d ?? this.totalDebitTransactionsAmount90d,
        totalCreditTransactionsAmount90d: totalCreditTransactionsAmount90d ?? this.totalCreditTransactionsAmount90d,
        p50EodBalance30d: p50EodBalance30d ?? this.p50EodBalance30d,
        p50EodBalance60d: p50EodBalance60d ?? this.p50EodBalance60d,
        p50EodBalance90d: p50EodBalance90d ?? this.p50EodBalance90d,
        p50EodBalance31dTo60d: p50EodBalance31dTo60d ?? this.p50EodBalance31dTo60d,
        p50EodBalance61dTo90d: p50EodBalance61dTo90d ?? this.p50EodBalance61dTo90d,
        p90EodBalance31dTo60d: p90EodBalance31dTo60d ?? this.p90EodBalance31dTo60d,
        p90EodBalance61dTo90d: p90EodBalance61dTo90d ?? this.p90EodBalance61dTo90d,
        p10EodBalance31dTo60d: p10EodBalance31dTo60d ?? this.p10EodBalance31dTo60d,
        p10EodBalance61dTo90d: p10EodBalance61dTo90d ?? this.p10EodBalance61dTo90d,
        transactionsLastUpdated: transactionsLastUpdated ?? this.transactionsLastUpdated);
  }

  SignalEvaluateCoreAttributes copyWithWrapped(
      {Wrapped<int?>? unauthorizedTransactionsCount7d,
      Wrapped<int?>? unauthorizedTransactionsCount30d,
      Wrapped<int?>? unauthorizedTransactionsCount60d,
      Wrapped<int?>? unauthorizedTransactionsCount90d,
      Wrapped<int?>? nsfOverdraftTransactionsCount7d,
      Wrapped<int?>? nsfOverdraftTransactionsCount30d,
      Wrapped<int?>? nsfOverdraftTransactionsCount60d,
      Wrapped<int?>? nsfOverdraftTransactionsCount90d,
      Wrapped<int?>? daysSinceFirstPlaidConnection,
      Wrapped<int?>? plaidConnectionsCount7d,
      Wrapped<int?>? plaidConnectionsCount30d,
      Wrapped<int?>? totalPlaidConnectionsCount,
      Wrapped<bool?>? isSavingsOrMoneyMarketAccount,
      Wrapped<double?>? totalCreditTransactionsAmount10d,
      Wrapped<double?>? totalDebitTransactionsAmount10d,
      Wrapped<double?>? p50CreditTransactionsAmount28d,
      Wrapped<double?>? p50DebitTransactionsAmount28d,
      Wrapped<double?>? p95CreditTransactionsAmount28d,
      Wrapped<double?>? p95DebitTransactionsAmount28d,
      Wrapped<int?>? daysWithNegativeBalanceCount90d,
      Wrapped<double?>? p90EodBalance30d,
      Wrapped<double?>? p90EodBalance60d,
      Wrapped<double?>? p90EodBalance90d,
      Wrapped<double?>? p10EodBalance30d,
      Wrapped<double?>? p10EodBalance60d,
      Wrapped<double?>? p10EodBalance90d,
      Wrapped<double?>? availableBalance,
      Wrapped<double?>? currentBalance,
      Wrapped<DateTime?>? balanceLastUpdated,
      Wrapped<int?>? phoneChangeCount28d,
      Wrapped<int?>? phoneChangeCount90d,
      Wrapped<int?>? emailChangeCount28d,
      Wrapped<int?>? emailChangeCount90d,
      Wrapped<int?>? addressChangeCount28d,
      Wrapped<int?>? addressChangeCount90d,
      Wrapped<int?>? plaidNonOauthAuthenticationAttemptsCount3d,
      Wrapped<int?>? plaidNonOauthAuthenticationAttemptsCount7d,
      Wrapped<int?>? plaidNonOauthAuthenticationAttemptsCount30d,
      Wrapped<int?>? failedPlaidNonOauthAuthenticationAttemptsCount3d,
      Wrapped<int?>? failedPlaidNonOauthAuthenticationAttemptsCount7d,
      Wrapped<int?>? failedPlaidNonOauthAuthenticationAttemptsCount30d,
      Wrapped<int?>? debitTransactionsCount10d,
      Wrapped<int?>? creditTransactionsCount10d,
      Wrapped<int?>? debitTransactionsCount30d,
      Wrapped<int?>? creditTransactionsCount30d,
      Wrapped<int?>? debitTransactionsCount60d,
      Wrapped<int?>? creditTransactionsCount60d,
      Wrapped<int?>? debitTransactionsCount90d,
      Wrapped<int?>? creditTransactionsCount90d,
      Wrapped<double?>? totalDebitTransactionsAmount30d,
      Wrapped<double?>? totalCreditTransactionsAmount30d,
      Wrapped<double?>? totalDebitTransactionsAmount60d,
      Wrapped<double?>? totalCreditTransactionsAmount60d,
      Wrapped<double?>? totalDebitTransactionsAmount90d,
      Wrapped<double?>? totalCreditTransactionsAmount90d,
      Wrapped<double?>? p50EodBalance30d,
      Wrapped<double?>? p50EodBalance60d,
      Wrapped<double?>? p50EodBalance90d,
      Wrapped<double?>? p50EodBalance31dTo60d,
      Wrapped<double?>? p50EodBalance61dTo90d,
      Wrapped<double?>? p90EodBalance31dTo60d,
      Wrapped<double?>? p90EodBalance61dTo90d,
      Wrapped<double?>? p10EodBalance31dTo60d,
      Wrapped<double?>? p10EodBalance61dTo90d,
      Wrapped<DateTime?>? transactionsLastUpdated}) {
    return SignalEvaluateCoreAttributes(
        unauthorizedTransactionsCount7d: (unauthorizedTransactionsCount7d != null
            ? unauthorizedTransactionsCount7d.value
            : this.unauthorizedTransactionsCount7d),
        unauthorizedTransactionsCount30d: (unauthorizedTransactionsCount30d != null
            ? unauthorizedTransactionsCount30d.value
            : this.unauthorizedTransactionsCount30d),
        unauthorizedTransactionsCount60d: (unauthorizedTransactionsCount60d != null
            ? unauthorizedTransactionsCount60d.value
            : this.unauthorizedTransactionsCount60d),
        unauthorizedTransactionsCount90d: (unauthorizedTransactionsCount90d != null
            ? unauthorizedTransactionsCount90d.value
            : this.unauthorizedTransactionsCount90d),
        nsfOverdraftTransactionsCount7d: (nsfOverdraftTransactionsCount7d != null
            ? nsfOverdraftTransactionsCount7d.value
            : this.nsfOverdraftTransactionsCount7d),
        nsfOverdraftTransactionsCount30d: (nsfOverdraftTransactionsCount30d != null
            ? nsfOverdraftTransactionsCount30d.value
            : this.nsfOverdraftTransactionsCount30d),
        nsfOverdraftTransactionsCount60d: (nsfOverdraftTransactionsCount60d != null
            ? nsfOverdraftTransactionsCount60d.value
            : this.nsfOverdraftTransactionsCount60d),
        nsfOverdraftTransactionsCount90d: (nsfOverdraftTransactionsCount90d != null
            ? nsfOverdraftTransactionsCount90d.value
            : this.nsfOverdraftTransactionsCount90d),
        daysSinceFirstPlaidConnection: (daysSinceFirstPlaidConnection != null
            ? daysSinceFirstPlaidConnection.value
            : this.daysSinceFirstPlaidConnection),
        plaidConnectionsCount7d: (plaidConnectionsCount7d != null
            ? plaidConnectionsCount7d.value
            : this.plaidConnectionsCount7d),
        plaidConnectionsCount30d: (plaidConnectionsCount30d != null
            ? plaidConnectionsCount30d.value
            : this.plaidConnectionsCount30d),
        totalPlaidConnectionsCount: (totalPlaidConnectionsCount != null
            ? totalPlaidConnectionsCount.value
            : this.totalPlaidConnectionsCount),
        isSavingsOrMoneyMarketAccount: (isSavingsOrMoneyMarketAccount != null
            ? isSavingsOrMoneyMarketAccount.value
            : this.isSavingsOrMoneyMarketAccount),
        totalCreditTransactionsAmount10d: (totalCreditTransactionsAmount10d != null
            ? totalCreditTransactionsAmount10d.value
            : this.totalCreditTransactionsAmount10d),
        totalDebitTransactionsAmount10d: (totalDebitTransactionsAmount10d != null
            ? totalDebitTransactionsAmount10d.value
            : this.totalDebitTransactionsAmount10d),
        p50CreditTransactionsAmount28d: (p50CreditTransactionsAmount28d != null
            ? p50CreditTransactionsAmount28d.value
            : this.p50CreditTransactionsAmount28d),
        p50DebitTransactionsAmount28d: (p50DebitTransactionsAmount28d != null
            ? p50DebitTransactionsAmount28d.value
            : this.p50DebitTransactionsAmount28d),
        p95CreditTransactionsAmount28d: (p95CreditTransactionsAmount28d != null
            ? p95CreditTransactionsAmount28d.value
            : this.p95CreditTransactionsAmount28d),
        p95DebitTransactionsAmount28d:
            (p95DebitTransactionsAmount28d != null ? p95DebitTransactionsAmount28d.value : this.p95DebitTransactionsAmount28d),
        daysWithNegativeBalanceCount90d: (daysWithNegativeBalanceCount90d != null ? daysWithNegativeBalanceCount90d.value : this.daysWithNegativeBalanceCount90d),
        p90EodBalance30d: (p90EodBalance30d != null ? p90EodBalance30d.value : this.p90EodBalance30d),
        p90EodBalance60d: (p90EodBalance60d != null ? p90EodBalance60d.value : this.p90EodBalance60d),
        p90EodBalance90d: (p90EodBalance90d != null ? p90EodBalance90d.value : this.p90EodBalance90d),
        p10EodBalance30d: (p10EodBalance30d != null ? p10EodBalance30d.value : this.p10EodBalance30d),
        p10EodBalance60d: (p10EodBalance60d != null ? p10EodBalance60d.value : this.p10EodBalance60d),
        p10EodBalance90d: (p10EodBalance90d != null ? p10EodBalance90d.value : this.p10EodBalance90d),
        availableBalance: (availableBalance != null ? availableBalance.value : this.availableBalance),
        currentBalance: (currentBalance != null ? currentBalance.value : this.currentBalance),
        balanceLastUpdated: (balanceLastUpdated != null ? balanceLastUpdated.value : this.balanceLastUpdated),
        phoneChangeCount28d: (phoneChangeCount28d != null ? phoneChangeCount28d.value : this.phoneChangeCount28d),
        phoneChangeCount90d: (phoneChangeCount90d != null ? phoneChangeCount90d.value : this.phoneChangeCount90d),
        emailChangeCount28d: (emailChangeCount28d != null ? emailChangeCount28d.value : this.emailChangeCount28d),
        emailChangeCount90d: (emailChangeCount90d != null ? emailChangeCount90d.value : this.emailChangeCount90d),
        addressChangeCount28d: (addressChangeCount28d != null ? addressChangeCount28d.value : this.addressChangeCount28d),
        addressChangeCount90d: (addressChangeCount90d != null ? addressChangeCount90d.value : this.addressChangeCount90d),
        plaidNonOauthAuthenticationAttemptsCount3d: (plaidNonOauthAuthenticationAttemptsCount3d != null ? plaidNonOauthAuthenticationAttemptsCount3d.value : this.plaidNonOauthAuthenticationAttemptsCount3d),
        plaidNonOauthAuthenticationAttemptsCount7d: (plaidNonOauthAuthenticationAttemptsCount7d != null ? plaidNonOauthAuthenticationAttemptsCount7d.value : this.plaidNonOauthAuthenticationAttemptsCount7d),
        plaidNonOauthAuthenticationAttemptsCount30d: (plaidNonOauthAuthenticationAttemptsCount30d != null ? plaidNonOauthAuthenticationAttemptsCount30d.value : this.plaidNonOauthAuthenticationAttemptsCount30d),
        failedPlaidNonOauthAuthenticationAttemptsCount3d: (failedPlaidNonOauthAuthenticationAttemptsCount3d != null ? failedPlaidNonOauthAuthenticationAttemptsCount3d.value : this.failedPlaidNonOauthAuthenticationAttemptsCount3d),
        failedPlaidNonOauthAuthenticationAttemptsCount7d: (failedPlaidNonOauthAuthenticationAttemptsCount7d != null ? failedPlaidNonOauthAuthenticationAttemptsCount7d.value : this.failedPlaidNonOauthAuthenticationAttemptsCount7d),
        failedPlaidNonOauthAuthenticationAttemptsCount30d: (failedPlaidNonOauthAuthenticationAttemptsCount30d != null ? failedPlaidNonOauthAuthenticationAttemptsCount30d.value : this.failedPlaidNonOauthAuthenticationAttemptsCount30d),
        debitTransactionsCount10d: (debitTransactionsCount10d != null ? debitTransactionsCount10d.value : this.debitTransactionsCount10d),
        creditTransactionsCount10d: (creditTransactionsCount10d != null ? creditTransactionsCount10d.value : this.creditTransactionsCount10d),
        debitTransactionsCount30d: (debitTransactionsCount30d != null ? debitTransactionsCount30d.value : this.debitTransactionsCount30d),
        creditTransactionsCount30d: (creditTransactionsCount30d != null ? creditTransactionsCount30d.value : this.creditTransactionsCount30d),
        debitTransactionsCount60d: (debitTransactionsCount60d != null ? debitTransactionsCount60d.value : this.debitTransactionsCount60d),
        creditTransactionsCount60d: (creditTransactionsCount60d != null ? creditTransactionsCount60d.value : this.creditTransactionsCount60d),
        debitTransactionsCount90d: (debitTransactionsCount90d != null ? debitTransactionsCount90d.value : this.debitTransactionsCount90d),
        creditTransactionsCount90d: (creditTransactionsCount90d != null ? creditTransactionsCount90d.value : this.creditTransactionsCount90d),
        totalDebitTransactionsAmount30d: (totalDebitTransactionsAmount30d != null ? totalDebitTransactionsAmount30d.value : this.totalDebitTransactionsAmount30d),
        totalCreditTransactionsAmount30d: (totalCreditTransactionsAmount30d != null ? totalCreditTransactionsAmount30d.value : this.totalCreditTransactionsAmount30d),
        totalDebitTransactionsAmount60d: (totalDebitTransactionsAmount60d != null ? totalDebitTransactionsAmount60d.value : this.totalDebitTransactionsAmount60d),
        totalCreditTransactionsAmount60d: (totalCreditTransactionsAmount60d != null ? totalCreditTransactionsAmount60d.value : this.totalCreditTransactionsAmount60d),
        totalDebitTransactionsAmount90d: (totalDebitTransactionsAmount90d != null ? totalDebitTransactionsAmount90d.value : this.totalDebitTransactionsAmount90d),
        totalCreditTransactionsAmount90d: (totalCreditTransactionsAmount90d != null ? totalCreditTransactionsAmount90d.value : this.totalCreditTransactionsAmount90d),
        p50EodBalance30d: (p50EodBalance30d != null ? p50EodBalance30d.value : this.p50EodBalance30d),
        p50EodBalance60d: (p50EodBalance60d != null ? p50EodBalance60d.value : this.p50EodBalance60d),
        p50EodBalance90d: (p50EodBalance90d != null ? p50EodBalance90d.value : this.p50EodBalance90d),
        p50EodBalance31dTo60d: (p50EodBalance31dTo60d != null ? p50EodBalance31dTo60d.value : this.p50EodBalance31dTo60d),
        p50EodBalance61dTo90d: (p50EodBalance61dTo90d != null ? p50EodBalance61dTo90d.value : this.p50EodBalance61dTo90d),
        p90EodBalance31dTo60d: (p90EodBalance31dTo60d != null ? p90EodBalance31dTo60d.value : this.p90EodBalance31dTo60d),
        p90EodBalance61dTo90d: (p90EodBalance61dTo90d != null ? p90EodBalance61dTo90d.value : this.p90EodBalance61dTo90d),
        p10EodBalance31dTo60d: (p10EodBalance31dTo60d != null ? p10EodBalance31dTo60d.value : this.p10EodBalance31dTo60d),
        p10EodBalance61dTo90d: (p10EodBalance61dTo90d != null ? p10EodBalance61dTo90d.value : this.p10EodBalance61dTo90d),
        transactionsLastUpdated: (transactionsLastUpdated != null ? transactionsLastUpdated.value : this.transactionsLastUpdated));
  }
}

@JsonSerializable(explicitToJson: true)
class SignalDecisionReportRequest {
  SignalDecisionReportRequest({
    this.clientId,
    this.secret,
    required this.clientTransactionId,
    required this.initiated,
    this.daysFundsOnHold,
    this.decisionOutcome,
    this.paymentMethod,
    this.amountInstantlyAvailable,
  });

  factory SignalDecisionReportRequest.fromJson(Map<String, dynamic> json) =>
      _$SignalDecisionReportRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'client_transaction_id')
  final String clientTransactionId;
  @JsonKey(name: 'initiated')
  final bool initiated;
  @JsonKey(name: 'days_funds_on_hold')
  final int? daysFundsOnHold;
  @JsonKey(
    name: 'decision_outcome',
    toJson: signalDecisionOutcomeToJson,
    fromJson: signalDecisionOutcomeFromJson,
  )
  final enums.SignalDecisionOutcome? decisionOutcome;
  @JsonKey(
    name: 'payment_method',
    toJson: signalPaymentMethodToJson,
    fromJson: signalPaymentMethodFromJson,
  )
  final enums.SignalPaymentMethod? paymentMethod;
  @JsonKey(name: 'amount_instantly_available')
  final double? amountInstantlyAvailable;
  static const fromJsonFactory = _$SignalDecisionReportRequestFromJson;
  static const toJsonFactory = _$SignalDecisionReportRequestToJson;
  Map<String, dynamic> toJson() => _$SignalDecisionReportRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SignalDecisionReportRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.clientTransactionId, clientTransactionId) ||
                const DeepCollectionEquality()
                    .equals(other.clientTransactionId, clientTransactionId)) &&
            (identical(other.initiated, initiated) ||
                const DeepCollectionEquality()
                    .equals(other.initiated, initiated)) &&
            (identical(other.daysFundsOnHold, daysFundsOnHold) ||
                const DeepCollectionEquality()
                    .equals(other.daysFundsOnHold, daysFundsOnHold)) &&
            (identical(other.decisionOutcome, decisionOutcome) ||
                const DeepCollectionEquality()
                    .equals(other.decisionOutcome, decisionOutcome)) &&
            (identical(other.paymentMethod, paymentMethod) ||
                const DeepCollectionEquality()
                    .equals(other.paymentMethod, paymentMethod)) &&
            (identical(
                    other.amountInstantlyAvailable, amountInstantlyAvailable) ||
                const DeepCollectionEquality().equals(
                    other.amountInstantlyAvailable, amountInstantlyAvailable)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(clientTransactionId) ^
      const DeepCollectionEquality().hash(initiated) ^
      const DeepCollectionEquality().hash(daysFundsOnHold) ^
      const DeepCollectionEquality().hash(decisionOutcome) ^
      const DeepCollectionEquality().hash(paymentMethod) ^
      const DeepCollectionEquality().hash(amountInstantlyAvailable) ^
      runtimeType.hashCode;
}

extension $SignalDecisionReportRequestExtension on SignalDecisionReportRequest {
  SignalDecisionReportRequest copyWith(
      {String? clientId,
      String? secret,
      String? clientTransactionId,
      bool? initiated,
      int? daysFundsOnHold,
      enums.SignalDecisionOutcome? decisionOutcome,
      enums.SignalPaymentMethod? paymentMethod,
      double? amountInstantlyAvailable}) {
    return SignalDecisionReportRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        clientTransactionId: clientTransactionId ?? this.clientTransactionId,
        initiated: initiated ?? this.initiated,
        daysFundsOnHold: daysFundsOnHold ?? this.daysFundsOnHold,
        decisionOutcome: decisionOutcome ?? this.decisionOutcome,
        paymentMethod: paymentMethod ?? this.paymentMethod,
        amountInstantlyAvailable:
            amountInstantlyAvailable ?? this.amountInstantlyAvailable);
  }

  SignalDecisionReportRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? clientTransactionId,
      Wrapped<bool>? initiated,
      Wrapped<int?>? daysFundsOnHold,
      Wrapped<enums.SignalDecisionOutcome?>? decisionOutcome,
      Wrapped<enums.SignalPaymentMethod?>? paymentMethod,
      Wrapped<double?>? amountInstantlyAvailable}) {
    return SignalDecisionReportRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        clientTransactionId: (clientTransactionId != null
            ? clientTransactionId.value
            : this.clientTransactionId),
        initiated: (initiated != null ? initiated.value : this.initiated),
        daysFundsOnHold: (daysFundsOnHold != null
            ? daysFundsOnHold.value
            : this.daysFundsOnHold),
        decisionOutcome: (decisionOutcome != null
            ? decisionOutcome.value
            : this.decisionOutcome),
        paymentMethod:
            (paymentMethod != null ? paymentMethod.value : this.paymentMethod),
        amountInstantlyAvailable: (amountInstantlyAvailable != null
            ? amountInstantlyAvailable.value
            : this.amountInstantlyAvailable));
  }
}

@JsonSerializable(explicitToJson: true)
class SignalDecisionReportResponse {
  SignalDecisionReportResponse({
    required this.requestId,
  });

  factory SignalDecisionReportResponse.fromJson(Map<String, dynamic> json) =>
      _$SignalDecisionReportResponseFromJson(json);

  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$SignalDecisionReportResponseFromJson;
  static const toJsonFactory = _$SignalDecisionReportResponseToJson;
  Map<String, dynamic> toJson() => _$SignalDecisionReportResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SignalDecisionReportResponse &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(requestId) ^ runtimeType.hashCode;
}

extension $SignalDecisionReportResponseExtension
    on SignalDecisionReportResponse {
  SignalDecisionReportResponse copyWith({String? requestId}) {
    return SignalDecisionReportResponse(requestId: requestId ?? this.requestId);
  }

  SignalDecisionReportResponse copyWithWrapped({Wrapped<String>? requestId}) {
    return SignalDecisionReportResponse(
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class SignalReturnReportRequest {
  SignalReturnReportRequest({
    this.clientId,
    this.secret,
    required this.clientTransactionId,
    required this.returnCode,
    this.returnedAt,
  });

  factory SignalReturnReportRequest.fromJson(Map<String, dynamic> json) =>
      _$SignalReturnReportRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'client_transaction_id')
  final String clientTransactionId;
  @JsonKey(name: 'return_code')
  final String returnCode;
  @JsonKey(name: 'returned_at')
  final DateTime? returnedAt;
  static const fromJsonFactory = _$SignalReturnReportRequestFromJson;
  static const toJsonFactory = _$SignalReturnReportRequestToJson;
  Map<String, dynamic> toJson() => _$SignalReturnReportRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SignalReturnReportRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.clientTransactionId, clientTransactionId) ||
                const DeepCollectionEquality()
                    .equals(other.clientTransactionId, clientTransactionId)) &&
            (identical(other.returnCode, returnCode) ||
                const DeepCollectionEquality()
                    .equals(other.returnCode, returnCode)) &&
            (identical(other.returnedAt, returnedAt) ||
                const DeepCollectionEquality()
                    .equals(other.returnedAt, returnedAt)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(clientTransactionId) ^
      const DeepCollectionEquality().hash(returnCode) ^
      const DeepCollectionEquality().hash(returnedAt) ^
      runtimeType.hashCode;
}

extension $SignalReturnReportRequestExtension on SignalReturnReportRequest {
  SignalReturnReportRequest copyWith(
      {String? clientId,
      String? secret,
      String? clientTransactionId,
      String? returnCode,
      DateTime? returnedAt}) {
    return SignalReturnReportRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        clientTransactionId: clientTransactionId ?? this.clientTransactionId,
        returnCode: returnCode ?? this.returnCode,
        returnedAt: returnedAt ?? this.returnedAt);
  }

  SignalReturnReportRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? clientTransactionId,
      Wrapped<String>? returnCode,
      Wrapped<DateTime?>? returnedAt}) {
    return SignalReturnReportRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        clientTransactionId: (clientTransactionId != null
            ? clientTransactionId.value
            : this.clientTransactionId),
        returnCode: (returnCode != null ? returnCode.value : this.returnCode),
        returnedAt: (returnedAt != null ? returnedAt.value : this.returnedAt));
  }
}

@JsonSerializable(explicitToJson: true)
class SignalReturnReportResponse {
  SignalReturnReportResponse({
    required this.requestId,
  });

  factory SignalReturnReportResponse.fromJson(Map<String, dynamic> json) =>
      _$SignalReturnReportResponseFromJson(json);

  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$SignalReturnReportResponseFromJson;
  static const toJsonFactory = _$SignalReturnReportResponseToJson;
  Map<String, dynamic> toJson() => _$SignalReturnReportResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SignalReturnReportResponse &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(requestId) ^ runtimeType.hashCode;
}

extension $SignalReturnReportResponseExtension on SignalReturnReportResponse {
  SignalReturnReportResponse copyWith({String? requestId}) {
    return SignalReturnReportResponse(requestId: requestId ?? this.requestId);
  }

  SignalReturnReportResponse copyWithWrapped({Wrapped<String>? requestId}) {
    return SignalReturnReportResponse(
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class SignalPrepareRequest {
  SignalPrepareRequest({
    this.clientId,
    this.secret,
    required this.accessToken,
  });

  factory SignalPrepareRequest.fromJson(Map<String, dynamic> json) =>
      _$SignalPrepareRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'access_token')
  final String accessToken;
  static const fromJsonFactory = _$SignalPrepareRequestFromJson;
  static const toJsonFactory = _$SignalPrepareRequestToJson;
  Map<String, dynamic> toJson() => _$SignalPrepareRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SignalPrepareRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(accessToken) ^
      runtimeType.hashCode;
}

extension $SignalPrepareRequestExtension on SignalPrepareRequest {
  SignalPrepareRequest copyWith(
      {String? clientId, String? secret, String? accessToken}) {
    return SignalPrepareRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        accessToken: accessToken ?? this.accessToken);
  }

  SignalPrepareRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? accessToken}) {
    return SignalPrepareRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        accessToken:
            (accessToken != null ? accessToken.value : this.accessToken));
  }
}

@JsonSerializable(explicitToJson: true)
class SignalPrepareResponse {
  SignalPrepareResponse({
    required this.requestId,
  });

  factory SignalPrepareResponse.fromJson(Map<String, dynamic> json) =>
      _$SignalPrepareResponseFromJson(json);

  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$SignalPrepareResponseFromJson;
  static const toJsonFactory = _$SignalPrepareResponseToJson;
  Map<String, dynamic> toJson() => _$SignalPrepareResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SignalPrepareResponse &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(requestId) ^ runtimeType.hashCode;
}

extension $SignalPrepareResponseExtension on SignalPrepareResponse {
  SignalPrepareResponse copyWith({String? requestId}) {
    return SignalPrepareResponse(requestId: requestId ?? this.requestId);
  }

  SignalPrepareResponse copyWithWrapped({Wrapped<String>? requestId}) {
    return SignalPrepareResponse(
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class SandboxOauthSelectAccountsRequest {
  SandboxOauthSelectAccountsRequest({
    required this.oauthStateId,
    required this.accounts,
  });

  factory SandboxOauthSelectAccountsRequest.fromJson(
          Map<String, dynamic> json) =>
      _$SandboxOauthSelectAccountsRequestFromJson(json);

  @JsonKey(name: 'oauth_state_id')
  final String oauthStateId;
  @JsonKey(name: 'accounts', defaultValue: <String>[])
  final List<String> accounts;
  static const fromJsonFactory = _$SandboxOauthSelectAccountsRequestFromJson;
  static const toJsonFactory = _$SandboxOauthSelectAccountsRequestToJson;
  Map<String, dynamic> toJson() =>
      _$SandboxOauthSelectAccountsRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SandboxOauthSelectAccountsRequest &&
            (identical(other.oauthStateId, oauthStateId) ||
                const DeepCollectionEquality()
                    .equals(other.oauthStateId, oauthStateId)) &&
            (identical(other.accounts, accounts) ||
                const DeepCollectionEquality()
                    .equals(other.accounts, accounts)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(oauthStateId) ^
      const DeepCollectionEquality().hash(accounts) ^
      runtimeType.hashCode;
}

extension $SandboxOauthSelectAccountsRequestExtension
    on SandboxOauthSelectAccountsRequest {
  SandboxOauthSelectAccountsRequest copyWith(
      {String? oauthStateId, List<String>? accounts}) {
    return SandboxOauthSelectAccountsRequest(
        oauthStateId: oauthStateId ?? this.oauthStateId,
        accounts: accounts ?? this.accounts);
  }

  SandboxOauthSelectAccountsRequest copyWithWrapped(
      {Wrapped<String>? oauthStateId, Wrapped<List<String>>? accounts}) {
    return SandboxOauthSelectAccountsRequest(
        oauthStateId:
            (oauthStateId != null ? oauthStateId.value : this.oauthStateId),
        accounts: (accounts != null ? accounts.value : this.accounts));
  }
}

@JsonSerializable(explicitToJson: true)
class SandboxOauthSelectAccountsResponse {
  SandboxOauthSelectAccountsResponse();

  factory SandboxOauthSelectAccountsResponse.fromJson(
          Map<String, dynamic> json) =>
      _$SandboxOauthSelectAccountsResponseFromJson(json);

  static const fromJsonFactory = _$SandboxOauthSelectAccountsResponseFromJson;
  static const toJsonFactory = _$SandboxOauthSelectAccountsResponseToJson;
  Map<String, dynamic> toJson() =>
      _$SandboxOauthSelectAccountsResponseToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => runtimeType.hashCode;
}

@JsonSerializable(explicitToJson: true)
class NewAccountsAvailableWebhook {
  NewAccountsAvailableWebhook({
    this.webhookType,
    this.webhookCode,
    this.itemId,
    this.error,
    this.environment,
  });

  factory NewAccountsAvailableWebhook.fromJson(Map<String, dynamic> json) =>
      _$NewAccountsAvailableWebhookFromJson(json);

  @JsonKey(name: 'webhook_type')
  final String? webhookType;
  @JsonKey(name: 'webhook_code')
  final String? webhookCode;
  @JsonKey(name: 'item_id')
  final String? itemId;
  @JsonKey(name: 'error')
  final PlaidError? error;
  @JsonKey(
    name: 'environment',
    toJson: webhookEnvironmentValuesToJson,
    fromJson: webhookEnvironmentValuesFromJson,
  )
  final enums.WebhookEnvironmentValues? environment;
  static const fromJsonFactory = _$NewAccountsAvailableWebhookFromJson;
  static const toJsonFactory = _$NewAccountsAvailableWebhookToJson;
  Map<String, dynamic> toJson() => _$NewAccountsAvailableWebhookToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is NewAccountsAvailableWebhook &&
            (identical(other.webhookType, webhookType) ||
                const DeepCollectionEquality()
                    .equals(other.webhookType, webhookType)) &&
            (identical(other.webhookCode, webhookCode) ||
                const DeepCollectionEquality()
                    .equals(other.webhookCode, webhookCode)) &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)) &&
            (identical(other.error, error) ||
                const DeepCollectionEquality().equals(other.error, error)) &&
            (identical(other.environment, environment) ||
                const DeepCollectionEquality()
                    .equals(other.environment, environment)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(webhookType) ^
      const DeepCollectionEquality().hash(webhookCode) ^
      const DeepCollectionEquality().hash(itemId) ^
      const DeepCollectionEquality().hash(error) ^
      const DeepCollectionEquality().hash(environment) ^
      runtimeType.hashCode;
}

extension $NewAccountsAvailableWebhookExtension on NewAccountsAvailableWebhook {
  NewAccountsAvailableWebhook copyWith(
      {String? webhookType,
      String? webhookCode,
      String? itemId,
      PlaidError? error,
      enums.WebhookEnvironmentValues? environment}) {
    return NewAccountsAvailableWebhook(
        webhookType: webhookType ?? this.webhookType,
        webhookCode: webhookCode ?? this.webhookCode,
        itemId: itemId ?? this.itemId,
        error: error ?? this.error,
        environment: environment ?? this.environment);
  }

  NewAccountsAvailableWebhook copyWithWrapped(
      {Wrapped<String?>? webhookType,
      Wrapped<String?>? webhookCode,
      Wrapped<String?>? itemId,
      Wrapped<PlaidError?>? error,
      Wrapped<enums.WebhookEnvironmentValues?>? environment}) {
    return NewAccountsAvailableWebhook(
        webhookType:
            (webhookType != null ? webhookType.value : this.webhookType),
        webhookCode:
            (webhookCode != null ? webhookCode.value : this.webhookCode),
        itemId: (itemId != null ? itemId.value : this.itemId),
        error: (error != null ? error.value : this.error),
        environment:
            (environment != null ? environment.value : this.environment));
  }
}

@JsonSerializable(explicitToJson: true)
class WalletCreateRequest {
  WalletCreateRequest({
    this.clientId,
    this.secret,
    required this.isoCurrencyCode,
  });

  factory WalletCreateRequest.fromJson(Map<String, dynamic> json) =>
      _$WalletCreateRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(
    name: 'iso_currency_code',
    toJson: walletISOCurrencyCodeToJson,
    fromJson: walletISOCurrencyCodeFromJson,
  )
  final enums.WalletISOCurrencyCode isoCurrencyCode;
  static const fromJsonFactory = _$WalletCreateRequestFromJson;
  static const toJsonFactory = _$WalletCreateRequestToJson;
  Map<String, dynamic> toJson() => _$WalletCreateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WalletCreateRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      runtimeType.hashCode;
}

extension $WalletCreateRequestExtension on WalletCreateRequest {
  WalletCreateRequest copyWith(
      {String? clientId,
      String? secret,
      enums.WalletISOCurrencyCode? isoCurrencyCode}) {
    return WalletCreateRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode);
  }

  WalletCreateRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<enums.WalletISOCurrencyCode>? isoCurrencyCode}) {
    return WalletCreateRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        isoCurrencyCode: (isoCurrencyCode != null
            ? isoCurrencyCode.value
            : this.isoCurrencyCode));
  }
}

@JsonSerializable(explicitToJson: true)
class WalletCreateResponse {
  WalletCreateResponse({
    required this.requestId,
    required this.walletId,
    required this.balance,
    required this.numbers,
    this.recipientId,
  });

  factory WalletCreateResponse.fromJson(Map<String, dynamic> json) =>
      _$WalletCreateResponseFromJson(json);

  @JsonKey(name: 'request_id')
  final String requestId;
  @JsonKey(name: 'wallet_id')
  final String walletId;
  @JsonKey(name: 'balance')
  final WalletBalance balance;
  @JsonKey(name: 'numbers')
  final WalletNumbers numbers;
  @JsonKey(name: 'recipient_id')
  final String? recipientId;
  static const fromJsonFactory = _$WalletCreateResponseFromJson;
  static const toJsonFactory = _$WalletCreateResponseToJson;
  Map<String, dynamic> toJson() => _$WalletCreateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WalletCreateResponse &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)) &&
            (identical(other.walletId, walletId) ||
                const DeepCollectionEquality()
                    .equals(other.walletId, walletId)) &&
            (identical(other.balance, balance) ||
                const DeepCollectionEquality()
                    .equals(other.balance, balance)) &&
            (identical(other.numbers, numbers) ||
                const DeepCollectionEquality()
                    .equals(other.numbers, numbers)) &&
            (identical(other.recipientId, recipientId) ||
                const DeepCollectionEquality()
                    .equals(other.recipientId, recipientId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(requestId) ^
      const DeepCollectionEquality().hash(walletId) ^
      const DeepCollectionEquality().hash(balance) ^
      const DeepCollectionEquality().hash(numbers) ^
      const DeepCollectionEquality().hash(recipientId) ^
      runtimeType.hashCode;
}

extension $WalletCreateResponseExtension on WalletCreateResponse {
  WalletCreateResponse copyWith(
      {String? requestId,
      String? walletId,
      WalletBalance? balance,
      WalletNumbers? numbers,
      String? recipientId}) {
    return WalletCreateResponse(
        requestId: requestId ?? this.requestId,
        walletId: walletId ?? this.walletId,
        balance: balance ?? this.balance,
        numbers: numbers ?? this.numbers,
        recipientId: recipientId ?? this.recipientId);
  }

  WalletCreateResponse copyWithWrapped(
      {Wrapped<String>? requestId,
      Wrapped<String>? walletId,
      Wrapped<WalletBalance>? balance,
      Wrapped<WalletNumbers>? numbers,
      Wrapped<String?>? recipientId}) {
    return WalletCreateResponse(
        requestId: (requestId != null ? requestId.value : this.requestId),
        walletId: (walletId != null ? walletId.value : this.walletId),
        balance: (balance != null ? balance.value : this.balance),
        numbers: (numbers != null ? numbers.value : this.numbers),
        recipientId:
            (recipientId != null ? recipientId.value : this.recipientId));
  }
}

@JsonSerializable(explicitToJson: true)
class WalletGetRequest {
  WalletGetRequest({
    this.clientId,
    this.secret,
    required this.walletId,
  });

  factory WalletGetRequest.fromJson(Map<String, dynamic> json) =>
      _$WalletGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'wallet_id')
  final String walletId;
  static const fromJsonFactory = _$WalletGetRequestFromJson;
  static const toJsonFactory = _$WalletGetRequestToJson;
  Map<String, dynamic> toJson() => _$WalletGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WalletGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.walletId, walletId) ||
                const DeepCollectionEquality()
                    .equals(other.walletId, walletId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(walletId) ^
      runtimeType.hashCode;
}

extension $WalletGetRequestExtension on WalletGetRequest {
  WalletGetRequest copyWith(
      {String? clientId, String? secret, String? walletId}) {
    return WalletGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        walletId: walletId ?? this.walletId);
  }

  WalletGetRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? walletId}) {
    return WalletGetRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        walletId: (walletId != null ? walletId.value : this.walletId));
  }
}

@JsonSerializable(explicitToJson: true)
class WalletGetResponse {
  WalletGetResponse({
    required this.requestId,
    required this.walletId,
    required this.balance,
    required this.numbers,
    this.recipientId,
  });

  factory WalletGetResponse.fromJson(Map<String, dynamic> json) =>
      _$WalletGetResponseFromJson(json);

  @JsonKey(name: 'request_id')
  final String requestId;
  @JsonKey(name: 'wallet_id')
  final String walletId;
  @JsonKey(name: 'balance')
  final WalletBalance balance;
  @JsonKey(name: 'numbers')
  final WalletNumbers numbers;
  @JsonKey(name: 'recipient_id')
  final String? recipientId;
  static const fromJsonFactory = _$WalletGetResponseFromJson;
  static const toJsonFactory = _$WalletGetResponseToJson;
  Map<String, dynamic> toJson() => _$WalletGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WalletGetResponse &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)) &&
            (identical(other.walletId, walletId) ||
                const DeepCollectionEquality()
                    .equals(other.walletId, walletId)) &&
            (identical(other.balance, balance) ||
                const DeepCollectionEquality()
                    .equals(other.balance, balance)) &&
            (identical(other.numbers, numbers) ||
                const DeepCollectionEquality()
                    .equals(other.numbers, numbers)) &&
            (identical(other.recipientId, recipientId) ||
                const DeepCollectionEquality()
                    .equals(other.recipientId, recipientId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(requestId) ^
      const DeepCollectionEquality().hash(walletId) ^
      const DeepCollectionEquality().hash(balance) ^
      const DeepCollectionEquality().hash(numbers) ^
      const DeepCollectionEquality().hash(recipientId) ^
      runtimeType.hashCode;
}

extension $WalletGetResponseExtension on WalletGetResponse {
  WalletGetResponse copyWith(
      {String? requestId,
      String? walletId,
      WalletBalance? balance,
      WalletNumbers? numbers,
      String? recipientId}) {
    return WalletGetResponse(
        requestId: requestId ?? this.requestId,
        walletId: walletId ?? this.walletId,
        balance: balance ?? this.balance,
        numbers: numbers ?? this.numbers,
        recipientId: recipientId ?? this.recipientId);
  }

  WalletGetResponse copyWithWrapped(
      {Wrapped<String>? requestId,
      Wrapped<String>? walletId,
      Wrapped<WalletBalance>? balance,
      Wrapped<WalletNumbers>? numbers,
      Wrapped<String?>? recipientId}) {
    return WalletGetResponse(
        requestId: (requestId != null ? requestId.value : this.requestId),
        walletId: (walletId != null ? walletId.value : this.walletId),
        balance: (balance != null ? balance.value : this.balance),
        numbers: (numbers != null ? numbers.value : this.numbers),
        recipientId:
            (recipientId != null ? recipientId.value : this.recipientId));
  }
}

@JsonSerializable(explicitToJson: true)
class WalletListRequest {
  WalletListRequest({
    this.clientId,
    this.secret,
    this.isoCurrencyCode,
    this.cursor,
    this.count,
  });

  factory WalletListRequest.fromJson(Map<String, dynamic> json) =>
      _$WalletListRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(
    name: 'iso_currency_code',
    toJson: walletISOCurrencyCodeToJson,
    fromJson: walletISOCurrencyCodeFromJson,
  )
  final enums.WalletISOCurrencyCode? isoCurrencyCode;
  @JsonKey(name: 'cursor')
  final String? cursor;
  @JsonKey(name: 'count')
  final int? count;
  static const fromJsonFactory = _$WalletListRequestFromJson;
  static const toJsonFactory = _$WalletListRequestToJson;
  Map<String, dynamic> toJson() => _$WalletListRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WalletListRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)) &&
            (identical(other.cursor, cursor) ||
                const DeepCollectionEquality().equals(other.cursor, cursor)) &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      const DeepCollectionEquality().hash(cursor) ^
      const DeepCollectionEquality().hash(count) ^
      runtimeType.hashCode;
}

extension $WalletListRequestExtension on WalletListRequest {
  WalletListRequest copyWith(
      {String? clientId,
      String? secret,
      enums.WalletISOCurrencyCode? isoCurrencyCode,
      String? cursor,
      int? count}) {
    return WalletListRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode,
        cursor: cursor ?? this.cursor,
        count: count ?? this.count);
  }

  WalletListRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<enums.WalletISOCurrencyCode?>? isoCurrencyCode,
      Wrapped<String?>? cursor,
      Wrapped<int?>? count}) {
    return WalletListRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        isoCurrencyCode: (isoCurrencyCode != null
            ? isoCurrencyCode.value
            : this.isoCurrencyCode),
        cursor: (cursor != null ? cursor.value : this.cursor),
        count: (count != null ? count.value : this.count));
  }
}

@JsonSerializable(explicitToJson: true)
class WalletListResponse {
  WalletListResponse({
    required this.wallets,
    this.nextCursor,
    required this.requestId,
  });

  factory WalletListResponse.fromJson(Map<String, dynamic> json) =>
      _$WalletListResponseFromJson(json);

  @JsonKey(name: 'wallets', defaultValue: <Wallet>[])
  final List<Wallet> wallets;
  @JsonKey(name: 'next_cursor')
  final String? nextCursor;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$WalletListResponseFromJson;
  static const toJsonFactory = _$WalletListResponseToJson;
  Map<String, dynamic> toJson() => _$WalletListResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WalletListResponse &&
            (identical(other.wallets, wallets) ||
                const DeepCollectionEquality()
                    .equals(other.wallets, wallets)) &&
            (identical(other.nextCursor, nextCursor) ||
                const DeepCollectionEquality()
                    .equals(other.nextCursor, nextCursor)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(wallets) ^
      const DeepCollectionEquality().hash(nextCursor) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $WalletListResponseExtension on WalletListResponse {
  WalletListResponse copyWith(
      {List<Wallet>? wallets, String? nextCursor, String? requestId}) {
    return WalletListResponse(
        wallets: wallets ?? this.wallets,
        nextCursor: nextCursor ?? this.nextCursor,
        requestId: requestId ?? this.requestId);
  }

  WalletListResponse copyWithWrapped(
      {Wrapped<List<Wallet>>? wallets,
      Wrapped<String?>? nextCursor,
      Wrapped<String>? requestId}) {
    return WalletListResponse(
        wallets: (wallets != null ? wallets.value : this.wallets),
        nextCursor: (nextCursor != null ? nextCursor.value : this.nextCursor),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class Wallet {
  Wallet({
    required this.walletId,
    required this.balance,
    required this.numbers,
    this.recipientId,
  });

  factory Wallet.fromJson(Map<String, dynamic> json) => _$WalletFromJson(json);

  @JsonKey(name: 'wallet_id')
  final String walletId;
  @JsonKey(name: 'balance')
  final WalletBalance balance;
  @JsonKey(name: 'numbers')
  final WalletNumbers numbers;
  @JsonKey(name: 'recipient_id')
  final String? recipientId;
  static const fromJsonFactory = _$WalletFromJson;
  static const toJsonFactory = _$WalletToJson;
  Map<String, dynamic> toJson() => _$WalletToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Wallet &&
            (identical(other.walletId, walletId) ||
                const DeepCollectionEquality()
                    .equals(other.walletId, walletId)) &&
            (identical(other.balance, balance) ||
                const DeepCollectionEquality()
                    .equals(other.balance, balance)) &&
            (identical(other.numbers, numbers) ||
                const DeepCollectionEquality()
                    .equals(other.numbers, numbers)) &&
            (identical(other.recipientId, recipientId) ||
                const DeepCollectionEquality()
                    .equals(other.recipientId, recipientId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(walletId) ^
      const DeepCollectionEquality().hash(balance) ^
      const DeepCollectionEquality().hash(numbers) ^
      const DeepCollectionEquality().hash(recipientId) ^
      runtimeType.hashCode;
}

extension $WalletExtension on Wallet {
  Wallet copyWith(
      {String? walletId,
      WalletBalance? balance,
      WalletNumbers? numbers,
      String? recipientId}) {
    return Wallet(
        walletId: walletId ?? this.walletId,
        balance: balance ?? this.balance,
        numbers: numbers ?? this.numbers,
        recipientId: recipientId ?? this.recipientId);
  }

  Wallet copyWithWrapped(
      {Wrapped<String>? walletId,
      Wrapped<WalletBalance>? balance,
      Wrapped<WalletNumbers>? numbers,
      Wrapped<String?>? recipientId}) {
    return Wallet(
        walletId: (walletId != null ? walletId.value : this.walletId),
        balance: (balance != null ? balance.value : this.balance),
        numbers: (numbers != null ? numbers.value : this.numbers),
        recipientId:
            (recipientId != null ? recipientId.value : this.recipientId));
  }
}

@JsonSerializable(explicitToJson: true)
class WalletNumbers {
  WalletNumbers({
    this.bacs,
    this.international,
  });

  factory WalletNumbers.fromJson(Map<String, dynamic> json) =>
      _$WalletNumbersFromJson(json);

  @JsonKey(name: 'bacs')
  final RecipientBACS? bacs;
  @JsonKey(name: 'international')
  final NumbersInternationalIBAN? international;
  static const fromJsonFactory = _$WalletNumbersFromJson;
  static const toJsonFactory = _$WalletNumbersToJson;
  Map<String, dynamic> toJson() => _$WalletNumbersToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WalletNumbers &&
            (identical(other.bacs, bacs) ||
                const DeepCollectionEquality().equals(other.bacs, bacs)) &&
            (identical(other.international, international) ||
                const DeepCollectionEquality()
                    .equals(other.international, international)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(bacs) ^
      const DeepCollectionEquality().hash(international) ^
      runtimeType.hashCode;
}

extension $WalletNumbersExtension on WalletNumbers {
  WalletNumbers copyWith(
      {RecipientBACS? bacs, NumbersInternationalIBAN? international}) {
    return WalletNumbers(
        bacs: bacs ?? this.bacs,
        international: international ?? this.international);
  }

  WalletNumbers copyWithWrapped(
      {Wrapped<RecipientBACS?>? bacs,
      Wrapped<NumbersInternationalIBAN?>? international}) {
    return WalletNumbers(
        bacs: (bacs != null ? bacs.value : this.bacs),
        international:
            (international != null ? international.value : this.international));
  }
}

@JsonSerializable(explicitToJson: true)
class WalletBalance {
  WalletBalance({
    required this.isoCurrencyCode,
    required this.current,
  });

  factory WalletBalance.fromJson(Map<String, dynamic> json) =>
      _$WalletBalanceFromJson(json);

  @JsonKey(name: 'iso_currency_code')
  final String isoCurrencyCode;
  @JsonKey(name: 'current')
  final double current;
  static const fromJsonFactory = _$WalletBalanceFromJson;
  static const toJsonFactory = _$WalletBalanceToJson;
  Map<String, dynamic> toJson() => _$WalletBalanceToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WalletBalance &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)) &&
            (identical(other.current, current) ||
                const DeepCollectionEquality().equals(other.current, current)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      const DeepCollectionEquality().hash(current) ^
      runtimeType.hashCode;
}

extension $WalletBalanceExtension on WalletBalance {
  WalletBalance copyWith({String? isoCurrencyCode, double? current}) {
    return WalletBalance(
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode,
        current: current ?? this.current);
  }

  WalletBalance copyWithWrapped(
      {Wrapped<String>? isoCurrencyCode, Wrapped<double>? current}) {
    return WalletBalance(
        isoCurrencyCode: (isoCurrencyCode != null
            ? isoCurrencyCode.value
            : this.isoCurrencyCode),
        current: (current != null ? current.value : this.current));
  }
}

@JsonSerializable(explicitToJson: true)
class WalletTransactionExecuteRequest {
  WalletTransactionExecuteRequest({
    this.clientId,
    this.secret,
    required this.idempotencyKey,
    required this.walletId,
    required this.counterparty,
    required this.amount,
    required this.reference,
  });

  factory WalletTransactionExecuteRequest.fromJson(Map<String, dynamic> json) =>
      _$WalletTransactionExecuteRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'idempotency_key')
  final String idempotencyKey;
  @JsonKey(name: 'wallet_id')
  final String walletId;
  @JsonKey(name: 'counterparty')
  final WalletTransactionCounterparty counterparty;
  @JsonKey(name: 'amount')
  final WalletTransactionAmount amount;
  @JsonKey(name: 'reference')
  final String reference;
  static const fromJsonFactory = _$WalletTransactionExecuteRequestFromJson;
  static const toJsonFactory = _$WalletTransactionExecuteRequestToJson;
  Map<String, dynamic> toJson() =>
      _$WalletTransactionExecuteRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WalletTransactionExecuteRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.idempotencyKey, idempotencyKey) ||
                const DeepCollectionEquality()
                    .equals(other.idempotencyKey, idempotencyKey)) &&
            (identical(other.walletId, walletId) ||
                const DeepCollectionEquality()
                    .equals(other.walletId, walletId)) &&
            (identical(other.counterparty, counterparty) ||
                const DeepCollectionEquality()
                    .equals(other.counterparty, counterparty)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.reference, reference) ||
                const DeepCollectionEquality()
                    .equals(other.reference, reference)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(idempotencyKey) ^
      const DeepCollectionEquality().hash(walletId) ^
      const DeepCollectionEquality().hash(counterparty) ^
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(reference) ^
      runtimeType.hashCode;
}

extension $WalletTransactionExecuteRequestExtension
    on WalletTransactionExecuteRequest {
  WalletTransactionExecuteRequest copyWith(
      {String? clientId,
      String? secret,
      String? idempotencyKey,
      String? walletId,
      WalletTransactionCounterparty? counterparty,
      WalletTransactionAmount? amount,
      String? reference}) {
    return WalletTransactionExecuteRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        idempotencyKey: idempotencyKey ?? this.idempotencyKey,
        walletId: walletId ?? this.walletId,
        counterparty: counterparty ?? this.counterparty,
        amount: amount ?? this.amount,
        reference: reference ?? this.reference);
  }

  WalletTransactionExecuteRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? idempotencyKey,
      Wrapped<String>? walletId,
      Wrapped<WalletTransactionCounterparty>? counterparty,
      Wrapped<WalletTransactionAmount>? amount,
      Wrapped<String>? reference}) {
    return WalletTransactionExecuteRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        idempotencyKey: (idempotencyKey != null
            ? idempotencyKey.value
            : this.idempotencyKey),
        walletId: (walletId != null ? walletId.value : this.walletId),
        counterparty:
            (counterparty != null ? counterparty.value : this.counterparty),
        amount: (amount != null ? amount.value : this.amount),
        reference: (reference != null ? reference.value : this.reference));
  }
}

@JsonSerializable(explicitToJson: true)
class WalletTransactionCounterparty {
  WalletTransactionCounterparty({
    required this.name,
    required this.numbers,
  });

  factory WalletTransactionCounterparty.fromJson(Map<String, dynamic> json) =>
      _$WalletTransactionCounterpartyFromJson(json);

  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'numbers')
  final WalletTransactionCounterpartyNumbers numbers;
  static const fromJsonFactory = _$WalletTransactionCounterpartyFromJson;
  static const toJsonFactory = _$WalletTransactionCounterpartyToJson;
  Map<String, dynamic> toJson() => _$WalletTransactionCounterpartyToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WalletTransactionCounterparty &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.numbers, numbers) ||
                const DeepCollectionEquality().equals(other.numbers, numbers)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(numbers) ^
      runtimeType.hashCode;
}

extension $WalletTransactionCounterpartyExtension
    on WalletTransactionCounterparty {
  WalletTransactionCounterparty copyWith(
      {String? name, WalletTransactionCounterpartyNumbers? numbers}) {
    return WalletTransactionCounterparty(
        name: name ?? this.name, numbers: numbers ?? this.numbers);
  }

  WalletTransactionCounterparty copyWithWrapped(
      {Wrapped<String>? name,
      Wrapped<WalletTransactionCounterpartyNumbers>? numbers}) {
    return WalletTransactionCounterparty(
        name: (name != null ? name.value : this.name),
        numbers: (numbers != null ? numbers.value : this.numbers));
  }
}

@JsonSerializable(explicitToJson: true)
class WalletTransactionCounterpartyNumbers {
  WalletTransactionCounterpartyNumbers({
    this.bacs,
    this.international,
  });

  factory WalletTransactionCounterpartyNumbers.fromJson(
          Map<String, dynamic> json) =>
      _$WalletTransactionCounterpartyNumbersFromJson(json);

  @JsonKey(name: 'bacs')
  final WalletTransactionCounterpartyBACS? bacs;
  @JsonKey(name: 'international')
  final WalletTransactionCounterpartyInternational? international;
  static const fromJsonFactory = _$WalletTransactionCounterpartyNumbersFromJson;
  static const toJsonFactory = _$WalletTransactionCounterpartyNumbersToJson;
  Map<String, dynamic> toJson() =>
      _$WalletTransactionCounterpartyNumbersToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WalletTransactionCounterpartyNumbers &&
            (identical(other.bacs, bacs) ||
                const DeepCollectionEquality().equals(other.bacs, bacs)) &&
            (identical(other.international, international) ||
                const DeepCollectionEquality()
                    .equals(other.international, international)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(bacs) ^
      const DeepCollectionEquality().hash(international) ^
      runtimeType.hashCode;
}

extension $WalletTransactionCounterpartyNumbersExtension
    on WalletTransactionCounterpartyNumbers {
  WalletTransactionCounterpartyNumbers copyWith(
      {WalletTransactionCounterpartyBACS? bacs,
      WalletTransactionCounterpartyInternational? international}) {
    return WalletTransactionCounterpartyNumbers(
        bacs: bacs ?? this.bacs,
        international: international ?? this.international);
  }

  WalletTransactionCounterpartyNumbers copyWithWrapped(
      {Wrapped<WalletTransactionCounterpartyBACS?>? bacs,
      Wrapped<WalletTransactionCounterpartyInternational?>? international}) {
    return WalletTransactionCounterpartyNumbers(
        bacs: (bacs != null ? bacs.value : this.bacs),
        international:
            (international != null ? international.value : this.international));
  }
}

@JsonSerializable(explicitToJson: true)
class WalletTransactionCounterpartyBACS {
  WalletTransactionCounterpartyBACS({
    this.account,
    this.sortCode,
  });

  factory WalletTransactionCounterpartyBACS.fromJson(
          Map<String, dynamic> json) =>
      _$WalletTransactionCounterpartyBACSFromJson(json);

  @JsonKey(name: 'account')
  final String? account;
  @JsonKey(name: 'sort_code')
  final String? sortCode;
  static const fromJsonFactory = _$WalletTransactionCounterpartyBACSFromJson;
  static const toJsonFactory = _$WalletTransactionCounterpartyBACSToJson;
  Map<String, dynamic> toJson() =>
      _$WalletTransactionCounterpartyBACSToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WalletTransactionCounterpartyBACS &&
            (identical(other.account, account) ||
                const DeepCollectionEquality()
                    .equals(other.account, account)) &&
            (identical(other.sortCode, sortCode) ||
                const DeepCollectionEquality()
                    .equals(other.sortCode, sortCode)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(account) ^
      const DeepCollectionEquality().hash(sortCode) ^
      runtimeType.hashCode;
}

extension $WalletTransactionCounterpartyBACSExtension
    on WalletTransactionCounterpartyBACS {
  WalletTransactionCounterpartyBACS copyWith(
      {String? account, String? sortCode}) {
    return WalletTransactionCounterpartyBACS(
        account: account ?? this.account, sortCode: sortCode ?? this.sortCode);
  }

  WalletTransactionCounterpartyBACS copyWithWrapped(
      {Wrapped<String?>? account, Wrapped<String?>? sortCode}) {
    return WalletTransactionCounterpartyBACS(
        account: (account != null ? account.value : this.account),
        sortCode: (sortCode != null ? sortCode.value : this.sortCode));
  }
}

@JsonSerializable(explicitToJson: true)
class WalletTransactionCounterpartyInternational {
  WalletTransactionCounterpartyInternational({
    this.iban,
  });

  factory WalletTransactionCounterpartyInternational.fromJson(
          Map<String, dynamic> json) =>
      _$WalletTransactionCounterpartyInternationalFromJson(json);

  @JsonKey(name: 'iban')
  final String? iban;
  static const fromJsonFactory =
      _$WalletTransactionCounterpartyInternationalFromJson;
  static const toJsonFactory =
      _$WalletTransactionCounterpartyInternationalToJson;
  Map<String, dynamic> toJson() =>
      _$WalletTransactionCounterpartyInternationalToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WalletTransactionCounterpartyInternational &&
            (identical(other.iban, iban) ||
                const DeepCollectionEquality().equals(other.iban, iban)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(iban) ^ runtimeType.hashCode;
}

extension $WalletTransactionCounterpartyInternationalExtension
    on WalletTransactionCounterpartyInternational {
  WalletTransactionCounterpartyInternational copyWith({String? iban}) {
    return WalletTransactionCounterpartyInternational(iban: iban ?? this.iban);
  }

  WalletTransactionCounterpartyInternational copyWithWrapped(
      {Wrapped<String?>? iban}) {
    return WalletTransactionCounterpartyInternational(
        iban: (iban != null ? iban.value : this.iban));
  }
}

@JsonSerializable(explicitToJson: true)
class WalletTransactionAmount {
  WalletTransactionAmount({
    required this.isoCurrencyCode,
    required this.value,
  });

  factory WalletTransactionAmount.fromJson(Map<String, dynamic> json) =>
      _$WalletTransactionAmountFromJson(json);

  @JsonKey(
    name: 'iso_currency_code',
    toJson: walletISOCurrencyCodeToJson,
    fromJson: walletISOCurrencyCodeFromJson,
  )
  final enums.WalletISOCurrencyCode isoCurrencyCode;
  @JsonKey(name: 'value')
  final double value;
  static const fromJsonFactory = _$WalletTransactionAmountFromJson;
  static const toJsonFactory = _$WalletTransactionAmountToJson;
  Map<String, dynamic> toJson() => _$WalletTransactionAmountToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WalletTransactionAmount &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)) &&
            (identical(other.value, value) ||
                const DeepCollectionEquality().equals(other.value, value)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      const DeepCollectionEquality().hash(value) ^
      runtimeType.hashCode;
}

extension $WalletTransactionAmountExtension on WalletTransactionAmount {
  WalletTransactionAmount copyWith(
      {enums.WalletISOCurrencyCode? isoCurrencyCode, double? value}) {
    return WalletTransactionAmount(
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode,
        value: value ?? this.value);
  }

  WalletTransactionAmount copyWithWrapped(
      {Wrapped<enums.WalletISOCurrencyCode>? isoCurrencyCode,
      Wrapped<double>? value}) {
    return WalletTransactionAmount(
        isoCurrencyCode: (isoCurrencyCode != null
            ? isoCurrencyCode.value
            : this.isoCurrencyCode),
        value: (value != null ? value.value : this.value));
  }
}

@JsonSerializable(explicitToJson: true)
class WalletTransactionExecuteResponse {
  WalletTransactionExecuteResponse({
    required this.transactionId,
    required this.status,
    required this.requestId,
  });

  factory WalletTransactionExecuteResponse.fromJson(
          Map<String, dynamic> json) =>
      _$WalletTransactionExecuteResponseFromJson(json);

  @JsonKey(name: 'transaction_id')
  final String transactionId;
  @JsonKey(
    name: 'status',
    toJson: walletTransactionStatusToJson,
    fromJson: walletTransactionStatusFromJson,
  )
  final enums.WalletTransactionStatus status;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$WalletTransactionExecuteResponseFromJson;
  static const toJsonFactory = _$WalletTransactionExecuteResponseToJson;
  Map<String, dynamic> toJson() =>
      _$WalletTransactionExecuteResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WalletTransactionExecuteResponse &&
            (identical(other.transactionId, transactionId) ||
                const DeepCollectionEquality()
                    .equals(other.transactionId, transactionId)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(transactionId) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $WalletTransactionExecuteResponseExtension
    on WalletTransactionExecuteResponse {
  WalletTransactionExecuteResponse copyWith(
      {String? transactionId,
      enums.WalletTransactionStatus? status,
      String? requestId}) {
    return WalletTransactionExecuteResponse(
        transactionId: transactionId ?? this.transactionId,
        status: status ?? this.status,
        requestId: requestId ?? this.requestId);
  }

  WalletTransactionExecuteResponse copyWithWrapped(
      {Wrapped<String>? transactionId,
      Wrapped<enums.WalletTransactionStatus>? status,
      Wrapped<String>? requestId}) {
    return WalletTransactionExecuteResponse(
        transactionId:
            (transactionId != null ? transactionId.value : this.transactionId),
        status: (status != null ? status.value : this.status),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class WalletTransactionGetRequest {
  WalletTransactionGetRequest({
    this.clientId,
    this.secret,
    required this.transactionId,
  });

  factory WalletTransactionGetRequest.fromJson(Map<String, dynamic> json) =>
      _$WalletTransactionGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'transaction_id')
  final String transactionId;
  static const fromJsonFactory = _$WalletTransactionGetRequestFromJson;
  static const toJsonFactory = _$WalletTransactionGetRequestToJson;
  Map<String, dynamic> toJson() => _$WalletTransactionGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WalletTransactionGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.transactionId, transactionId) ||
                const DeepCollectionEquality()
                    .equals(other.transactionId, transactionId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(transactionId) ^
      runtimeType.hashCode;
}

extension $WalletTransactionGetRequestExtension on WalletTransactionGetRequest {
  WalletTransactionGetRequest copyWith(
      {String? clientId, String? secret, String? transactionId}) {
    return WalletTransactionGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        transactionId: transactionId ?? this.transactionId);
  }

  WalletTransactionGetRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? transactionId}) {
    return WalletTransactionGetRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        transactionId:
            (transactionId != null ? transactionId.value : this.transactionId));
  }
}

@JsonSerializable(explicitToJson: true)
class WalletTransactionGetResponse {
  WalletTransactionGetResponse({
    required this.requestId,
    required this.transactionId,
    required this.reference,
    required this.type,
    required this.amount,
    required this.counterparty,
    required this.status,
    required this.createdAt,
    required this.lastStatusUpdate,
    this.paymentId,
  });

  factory WalletTransactionGetResponse.fromJson(Map<String, dynamic> json) =>
      _$WalletTransactionGetResponseFromJson(json);

  @JsonKey(name: 'request_id')
  final String requestId;
  @JsonKey(name: 'transaction_id')
  final String transactionId;
  @JsonKey(name: 'reference')
  final String reference;
  @JsonKey(
    name: 'type',
    toJson: walletTransactionGetResponseTypeToJson,
    fromJson: walletTransactionGetResponseTypeFromJson,
  )
  final enums.WalletTransactionGetResponseType type;
  @JsonKey(name: 'amount')
  final WalletTransactionAmount amount;
  @JsonKey(name: 'counterparty')
  final WalletTransactionCounterparty counterparty;
  @JsonKey(
    name: 'status',
    toJson: walletTransactionStatusToJson,
    fromJson: walletTransactionStatusFromJson,
  )
  final enums.WalletTransactionStatus status;
  @JsonKey(name: 'created_at')
  final DateTime createdAt;
  @JsonKey(name: 'last_status_update')
  final DateTime lastStatusUpdate;
  @JsonKey(name: 'payment_id')
  final String? paymentId;
  static const fromJsonFactory = _$WalletTransactionGetResponseFromJson;
  static const toJsonFactory = _$WalletTransactionGetResponseToJson;
  Map<String, dynamic> toJson() => _$WalletTransactionGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WalletTransactionGetResponse &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)) &&
            (identical(other.transactionId, transactionId) ||
                const DeepCollectionEquality()
                    .equals(other.transactionId, transactionId)) &&
            (identical(other.reference, reference) ||
                const DeepCollectionEquality()
                    .equals(other.reference, reference)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.counterparty, counterparty) ||
                const DeepCollectionEquality()
                    .equals(other.counterparty, counterparty)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.createdAt, createdAt) ||
                const DeepCollectionEquality()
                    .equals(other.createdAt, createdAt)) &&
            (identical(other.lastStatusUpdate, lastStatusUpdate) ||
                const DeepCollectionEquality()
                    .equals(other.lastStatusUpdate, lastStatusUpdate)) &&
            (identical(other.paymentId, paymentId) ||
                const DeepCollectionEquality()
                    .equals(other.paymentId, paymentId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(requestId) ^
      const DeepCollectionEquality().hash(transactionId) ^
      const DeepCollectionEquality().hash(reference) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(counterparty) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(createdAt) ^
      const DeepCollectionEquality().hash(lastStatusUpdate) ^
      const DeepCollectionEquality().hash(paymentId) ^
      runtimeType.hashCode;
}

extension $WalletTransactionGetResponseExtension
    on WalletTransactionGetResponse {
  WalletTransactionGetResponse copyWith(
      {String? requestId,
      String? transactionId,
      String? reference,
      enums.WalletTransactionGetResponseType? type,
      WalletTransactionAmount? amount,
      WalletTransactionCounterparty? counterparty,
      enums.WalletTransactionStatus? status,
      DateTime? createdAt,
      DateTime? lastStatusUpdate,
      String? paymentId}) {
    return WalletTransactionGetResponse(
        requestId: requestId ?? this.requestId,
        transactionId: transactionId ?? this.transactionId,
        reference: reference ?? this.reference,
        type: type ?? this.type,
        amount: amount ?? this.amount,
        counterparty: counterparty ?? this.counterparty,
        status: status ?? this.status,
        createdAt: createdAt ?? this.createdAt,
        lastStatusUpdate: lastStatusUpdate ?? this.lastStatusUpdate,
        paymentId: paymentId ?? this.paymentId);
  }

  WalletTransactionGetResponse copyWithWrapped(
      {Wrapped<String>? requestId,
      Wrapped<String>? transactionId,
      Wrapped<String>? reference,
      Wrapped<enums.WalletTransactionGetResponseType>? type,
      Wrapped<WalletTransactionAmount>? amount,
      Wrapped<WalletTransactionCounterparty>? counterparty,
      Wrapped<enums.WalletTransactionStatus>? status,
      Wrapped<DateTime>? createdAt,
      Wrapped<DateTime>? lastStatusUpdate,
      Wrapped<String?>? paymentId}) {
    return WalletTransactionGetResponse(
        requestId: (requestId != null ? requestId.value : this.requestId),
        transactionId:
            (transactionId != null ? transactionId.value : this.transactionId),
        reference: (reference != null ? reference.value : this.reference),
        type: (type != null ? type.value : this.type),
        amount: (amount != null ? amount.value : this.amount),
        counterparty:
            (counterparty != null ? counterparty.value : this.counterparty),
        status: (status != null ? status.value : this.status),
        createdAt: (createdAt != null ? createdAt.value : this.createdAt),
        lastStatusUpdate: (lastStatusUpdate != null
            ? lastStatusUpdate.value
            : this.lastStatusUpdate),
        paymentId: (paymentId != null ? paymentId.value : this.paymentId));
  }
}

@JsonSerializable(explicitToJson: true)
class WalletTransactionListRequest {
  WalletTransactionListRequest({
    this.clientId,
    this.secret,
    required this.walletId,
    this.cursor,
    this.count,
    this.options,
  });

  factory WalletTransactionListRequest.fromJson(Map<String, dynamic> json) =>
      _$WalletTransactionListRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'wallet_id')
  final String walletId;
  @JsonKey(name: 'cursor')
  final String? cursor;
  @JsonKey(name: 'count')
  final int? count;
  @JsonKey(name: 'options')
  final WalletTransactionListRequestOptions? options;
  static const fromJsonFactory = _$WalletTransactionListRequestFromJson;
  static const toJsonFactory = _$WalletTransactionListRequestToJson;
  Map<String, dynamic> toJson() => _$WalletTransactionListRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WalletTransactionListRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.walletId, walletId) ||
                const DeepCollectionEquality()
                    .equals(other.walletId, walletId)) &&
            (identical(other.cursor, cursor) ||
                const DeepCollectionEquality().equals(other.cursor, cursor)) &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)) &&
            (identical(other.options, options) ||
                const DeepCollectionEquality().equals(other.options, options)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(walletId) ^
      const DeepCollectionEquality().hash(cursor) ^
      const DeepCollectionEquality().hash(count) ^
      const DeepCollectionEquality().hash(options) ^
      runtimeType.hashCode;
}

extension $WalletTransactionListRequestExtension
    on WalletTransactionListRequest {
  WalletTransactionListRequest copyWith(
      {String? clientId,
      String? secret,
      String? walletId,
      String? cursor,
      int? count,
      WalletTransactionListRequestOptions? options}) {
    return WalletTransactionListRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        walletId: walletId ?? this.walletId,
        cursor: cursor ?? this.cursor,
        count: count ?? this.count,
        options: options ?? this.options);
  }

  WalletTransactionListRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? walletId,
      Wrapped<String?>? cursor,
      Wrapped<int?>? count,
      Wrapped<WalletTransactionListRequestOptions?>? options}) {
    return WalletTransactionListRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        walletId: (walletId != null ? walletId.value : this.walletId),
        cursor: (cursor != null ? cursor.value : this.cursor),
        count: (count != null ? count.value : this.count),
        options: (options != null ? options.value : this.options));
  }
}

@JsonSerializable(explicitToJson: true)
class WalletTransactionsListRequest {
  WalletTransactionsListRequest({
    this.clientId,
    this.secret,
    required this.walletId,
    this.cursor,
    this.count,
    this.options,
  });

  factory WalletTransactionsListRequest.fromJson(Map<String, dynamic> json) =>
      _$WalletTransactionsListRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'wallet_id')
  final String walletId;
  @JsonKey(name: 'cursor')
  final String? cursor;
  @JsonKey(name: 'count')
  final int? count;
  @JsonKey(name: 'options')
  final WalletTransactionListRequestOptions? options;
  static const fromJsonFactory = _$WalletTransactionsListRequestFromJson;
  static const toJsonFactory = _$WalletTransactionsListRequestToJson;
  Map<String, dynamic> toJson() => _$WalletTransactionsListRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WalletTransactionsListRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.walletId, walletId) ||
                const DeepCollectionEquality()
                    .equals(other.walletId, walletId)) &&
            (identical(other.cursor, cursor) ||
                const DeepCollectionEquality().equals(other.cursor, cursor)) &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)) &&
            (identical(other.options, options) ||
                const DeepCollectionEquality().equals(other.options, options)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(walletId) ^
      const DeepCollectionEquality().hash(cursor) ^
      const DeepCollectionEquality().hash(count) ^
      const DeepCollectionEquality().hash(options) ^
      runtimeType.hashCode;
}

extension $WalletTransactionsListRequestExtension
    on WalletTransactionsListRequest {
  WalletTransactionsListRequest copyWith(
      {String? clientId,
      String? secret,
      String? walletId,
      String? cursor,
      int? count,
      WalletTransactionListRequestOptions? options}) {
    return WalletTransactionsListRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        walletId: walletId ?? this.walletId,
        cursor: cursor ?? this.cursor,
        count: count ?? this.count,
        options: options ?? this.options);
  }

  WalletTransactionsListRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? walletId,
      Wrapped<String?>? cursor,
      Wrapped<int?>? count,
      Wrapped<WalletTransactionListRequestOptions?>? options}) {
    return WalletTransactionsListRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        walletId: (walletId != null ? walletId.value : this.walletId),
        cursor: (cursor != null ? cursor.value : this.cursor),
        count: (count != null ? count.value : this.count),
        options: (options != null ? options.value : this.options));
  }
}

@JsonSerializable(explicitToJson: true)
class WalletTransactionListRequestOptions {
  WalletTransactionListRequestOptions({
    this.startTime,
    this.endTime,
  });

  factory WalletTransactionListRequestOptions.fromJson(
          Map<String, dynamic> json) =>
      _$WalletTransactionListRequestOptionsFromJson(json);

  @JsonKey(name: 'start_time')
  final DateTime? startTime;
  @JsonKey(name: 'end_time')
  final DateTime? endTime;
  static const fromJsonFactory = _$WalletTransactionListRequestOptionsFromJson;
  static const toJsonFactory = _$WalletTransactionListRequestOptionsToJson;
  Map<String, dynamic> toJson() =>
      _$WalletTransactionListRequestOptionsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WalletTransactionListRequestOptions &&
            (identical(other.startTime, startTime) ||
                const DeepCollectionEquality()
                    .equals(other.startTime, startTime)) &&
            (identical(other.endTime, endTime) ||
                const DeepCollectionEquality().equals(other.endTime, endTime)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(startTime) ^
      const DeepCollectionEquality().hash(endTime) ^
      runtimeType.hashCode;
}

extension $WalletTransactionListRequestOptionsExtension
    on WalletTransactionListRequestOptions {
  WalletTransactionListRequestOptions copyWith(
      {DateTime? startTime, DateTime? endTime}) {
    return WalletTransactionListRequestOptions(
        startTime: startTime ?? this.startTime,
        endTime: endTime ?? this.endTime);
  }

  WalletTransactionListRequestOptions copyWithWrapped(
      {Wrapped<DateTime?>? startTime, Wrapped<DateTime?>? endTime}) {
    return WalletTransactionListRequestOptions(
        startTime: (startTime != null ? startTime.value : this.startTime),
        endTime: (endTime != null ? endTime.value : this.endTime));
  }
}

@JsonSerializable(explicitToJson: true)
class WalletTransactionListResponse {
  WalletTransactionListResponse({
    required this.transactions,
    this.nextCursor,
    required this.requestId,
  });

  factory WalletTransactionListResponse.fromJson(Map<String, dynamic> json) =>
      _$WalletTransactionListResponseFromJson(json);

  @JsonKey(name: 'transactions', defaultValue: <WalletTransaction>[])
  final List<WalletTransaction> transactions;
  @JsonKey(name: 'next_cursor')
  final String? nextCursor;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$WalletTransactionListResponseFromJson;
  static const toJsonFactory = _$WalletTransactionListResponseToJson;
  Map<String, dynamic> toJson() => _$WalletTransactionListResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WalletTransactionListResponse &&
            (identical(other.transactions, transactions) ||
                const DeepCollectionEquality()
                    .equals(other.transactions, transactions)) &&
            (identical(other.nextCursor, nextCursor) ||
                const DeepCollectionEquality()
                    .equals(other.nextCursor, nextCursor)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(transactions) ^
      const DeepCollectionEquality().hash(nextCursor) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $WalletTransactionListResponseExtension
    on WalletTransactionListResponse {
  WalletTransactionListResponse copyWith(
      {List<WalletTransaction>? transactions,
      String? nextCursor,
      String? requestId}) {
    return WalletTransactionListResponse(
        transactions: transactions ?? this.transactions,
        nextCursor: nextCursor ?? this.nextCursor,
        requestId: requestId ?? this.requestId);
  }

  WalletTransactionListResponse copyWithWrapped(
      {Wrapped<List<WalletTransaction>>? transactions,
      Wrapped<String?>? nextCursor,
      Wrapped<String>? requestId}) {
    return WalletTransactionListResponse(
        transactions:
            (transactions != null ? transactions.value : this.transactions),
        nextCursor: (nextCursor != null ? nextCursor.value : this.nextCursor),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class WalletTransaction {
  WalletTransaction({
    required this.transactionId,
    required this.reference,
    required this.type,
    required this.amount,
    required this.counterparty,
    required this.status,
    required this.createdAt,
    required this.lastStatusUpdate,
    this.paymentId,
  });

  factory WalletTransaction.fromJson(Map<String, dynamic> json) =>
      _$WalletTransactionFromJson(json);

  @JsonKey(name: 'transaction_id')
  final String transactionId;
  @JsonKey(name: 'reference')
  final String reference;
  @JsonKey(
    name: 'type',
    toJson: walletTransactionTypeToJson,
    fromJson: walletTransactionTypeFromJson,
  )
  final enums.WalletTransactionType type;
  @JsonKey(name: 'amount')
  final WalletTransactionAmount amount;
  @JsonKey(name: 'counterparty')
  final WalletTransactionCounterparty counterparty;
  @JsonKey(
    name: 'status',
    toJson: walletTransactionStatusToJson,
    fromJson: walletTransactionStatusFromJson,
  )
  final enums.WalletTransactionStatus status;
  @JsonKey(name: 'created_at')
  final DateTime createdAt;
  @JsonKey(name: 'last_status_update')
  final DateTime lastStatusUpdate;
  @JsonKey(name: 'payment_id')
  final String? paymentId;
  static const fromJsonFactory = _$WalletTransactionFromJson;
  static const toJsonFactory = _$WalletTransactionToJson;
  Map<String, dynamic> toJson() => _$WalletTransactionToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WalletTransaction &&
            (identical(other.transactionId, transactionId) ||
                const DeepCollectionEquality()
                    .equals(other.transactionId, transactionId)) &&
            (identical(other.reference, reference) ||
                const DeepCollectionEquality()
                    .equals(other.reference, reference)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.counterparty, counterparty) ||
                const DeepCollectionEquality()
                    .equals(other.counterparty, counterparty)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.createdAt, createdAt) ||
                const DeepCollectionEquality()
                    .equals(other.createdAt, createdAt)) &&
            (identical(other.lastStatusUpdate, lastStatusUpdate) ||
                const DeepCollectionEquality()
                    .equals(other.lastStatusUpdate, lastStatusUpdate)) &&
            (identical(other.paymentId, paymentId) ||
                const DeepCollectionEquality()
                    .equals(other.paymentId, paymentId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(transactionId) ^
      const DeepCollectionEquality().hash(reference) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(counterparty) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(createdAt) ^
      const DeepCollectionEquality().hash(lastStatusUpdate) ^
      const DeepCollectionEquality().hash(paymentId) ^
      runtimeType.hashCode;
}

extension $WalletTransactionExtension on WalletTransaction {
  WalletTransaction copyWith(
      {String? transactionId,
      String? reference,
      enums.WalletTransactionType? type,
      WalletTransactionAmount? amount,
      WalletTransactionCounterparty? counterparty,
      enums.WalletTransactionStatus? status,
      DateTime? createdAt,
      DateTime? lastStatusUpdate,
      String? paymentId}) {
    return WalletTransaction(
        transactionId: transactionId ?? this.transactionId,
        reference: reference ?? this.reference,
        type: type ?? this.type,
        amount: amount ?? this.amount,
        counterparty: counterparty ?? this.counterparty,
        status: status ?? this.status,
        createdAt: createdAt ?? this.createdAt,
        lastStatusUpdate: lastStatusUpdate ?? this.lastStatusUpdate,
        paymentId: paymentId ?? this.paymentId);
  }

  WalletTransaction copyWithWrapped(
      {Wrapped<String>? transactionId,
      Wrapped<String>? reference,
      Wrapped<enums.WalletTransactionType>? type,
      Wrapped<WalletTransactionAmount>? amount,
      Wrapped<WalletTransactionCounterparty>? counterparty,
      Wrapped<enums.WalletTransactionStatus>? status,
      Wrapped<DateTime>? createdAt,
      Wrapped<DateTime>? lastStatusUpdate,
      Wrapped<String?>? paymentId}) {
    return WalletTransaction(
        transactionId:
            (transactionId != null ? transactionId.value : this.transactionId),
        reference: (reference != null ? reference.value : this.reference),
        type: (type != null ? type.value : this.type),
        amount: (amount != null ? amount.value : this.amount),
        counterparty:
            (counterparty != null ? counterparty.value : this.counterparty),
        status: (status != null ? status.value : this.status),
        createdAt: (createdAt != null ? createdAt.value : this.createdAt),
        lastStatusUpdate: (lastStatusUpdate != null
            ? lastStatusUpdate.value
            : this.lastStatusUpdate),
        paymentId: (paymentId != null ? paymentId.value : this.paymentId));
  }
}

@JsonSerializable(explicitToJson: true)
class TransactionsEnhanceGetRequest {
  TransactionsEnhanceGetRequest({
    this.clientId,
    this.secret,
    required this.accountType,
    required this.transactions,
  });

  factory TransactionsEnhanceGetRequest.fromJson(Map<String, dynamic> json) =>
      _$TransactionsEnhanceGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'account_type')
  final String accountType;
  @JsonKey(name: 'transactions', defaultValue: <ClientProvidedRawTransaction>[])
  final List<ClientProvidedRawTransaction> transactions;
  static const fromJsonFactory = _$TransactionsEnhanceGetRequestFromJson;
  static const toJsonFactory = _$TransactionsEnhanceGetRequestToJson;
  Map<String, dynamic> toJson() => _$TransactionsEnhanceGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransactionsEnhanceGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.accountType, accountType) ||
                const DeepCollectionEquality()
                    .equals(other.accountType, accountType)) &&
            (identical(other.transactions, transactions) ||
                const DeepCollectionEquality()
                    .equals(other.transactions, transactions)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(accountType) ^
      const DeepCollectionEquality().hash(transactions) ^
      runtimeType.hashCode;
}

extension $TransactionsEnhanceGetRequestExtension
    on TransactionsEnhanceGetRequest {
  TransactionsEnhanceGetRequest copyWith(
      {String? clientId,
      String? secret,
      String? accountType,
      List<ClientProvidedRawTransaction>? transactions}) {
    return TransactionsEnhanceGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        accountType: accountType ?? this.accountType,
        transactions: transactions ?? this.transactions);
  }

  TransactionsEnhanceGetRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? accountType,
      Wrapped<List<ClientProvidedRawTransaction>>? transactions}) {
    return TransactionsEnhanceGetRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        accountType:
            (accountType != null ? accountType.value : this.accountType),
        transactions:
            (transactions != null ? transactions.value : this.transactions));
  }
}

@JsonSerializable(explicitToJson: true)
class TransactionsEnrichGetRequest {
  TransactionsEnrichGetRequest({
    this.clientId,
    this.secret,
    required this.accountType,
    required this.transactions,
    this.includeLegacyCategories,
  });

  factory TransactionsEnrichGetRequest.fromJson(Map<String, dynamic> json) =>
      _$TransactionsEnrichGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'account_type')
  final String accountType;
  @JsonKey(name: 'transactions', defaultValue: <ClientProvidedTransaction>[])
  final List<ClientProvidedTransaction> transactions;
  @JsonKey(name: 'include_legacy_categories', defaultValue: false)
  final bool? includeLegacyCategories;
  static const fromJsonFactory = _$TransactionsEnrichGetRequestFromJson;
  static const toJsonFactory = _$TransactionsEnrichGetRequestToJson;
  Map<String, dynamic> toJson() => _$TransactionsEnrichGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransactionsEnrichGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.accountType, accountType) ||
                const DeepCollectionEquality()
                    .equals(other.accountType, accountType)) &&
            (identical(other.transactions, transactions) ||
                const DeepCollectionEquality()
                    .equals(other.transactions, transactions)) &&
            (identical(
                    other.includeLegacyCategories, includeLegacyCategories) ||
                const DeepCollectionEquality().equals(
                    other.includeLegacyCategories, includeLegacyCategories)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(accountType) ^
      const DeepCollectionEquality().hash(transactions) ^
      const DeepCollectionEquality().hash(includeLegacyCategories) ^
      runtimeType.hashCode;
}

extension $TransactionsEnrichGetRequestExtension
    on TransactionsEnrichGetRequest {
  TransactionsEnrichGetRequest copyWith(
      {String? clientId,
      String? secret,
      String? accountType,
      List<ClientProvidedTransaction>? transactions,
      bool? includeLegacyCategories}) {
    return TransactionsEnrichGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        accountType: accountType ?? this.accountType,
        transactions: transactions ?? this.transactions,
        includeLegacyCategories:
            includeLegacyCategories ?? this.includeLegacyCategories);
  }

  TransactionsEnrichGetRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? accountType,
      Wrapped<List<ClientProvidedTransaction>>? transactions,
      Wrapped<bool?>? includeLegacyCategories}) {
    return TransactionsEnrichGetRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        accountType:
            (accountType != null ? accountType.value : this.accountType),
        transactions:
            (transactions != null ? transactions.value : this.transactions),
        includeLegacyCategories: (includeLegacyCategories != null
            ? includeLegacyCategories.value
            : this.includeLegacyCategories));
  }
}

@JsonSerializable(explicitToJson: true)
class ClientProvidedTransaction {
  ClientProvidedTransaction({
    required this.id,
    required this.description,
    required this.amount,
    this.direction,
    required this.isoCurrencyCode,
  });

  factory ClientProvidedTransaction.fromJson(Map<String, dynamic> json) =>
      _$ClientProvidedTransactionFromJson(json);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'description')
  final String description;
  @JsonKey(name: 'amount')
  final double amount;
  @JsonKey(
    name: 'direction',
    toJson: enrichTransactionDirectionToJson,
    fromJson: enrichTransactionDirectionFromJson,
  )
  final enums.EnrichTransactionDirection? direction;
  @JsonKey(name: 'iso_currency_code')
  final String isoCurrencyCode;
  static const fromJsonFactory = _$ClientProvidedTransactionFromJson;
  static const toJsonFactory = _$ClientProvidedTransactionToJson;
  Map<String, dynamic> toJson() => _$ClientProvidedTransactionToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ClientProvidedTransaction &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.direction, direction) ||
                const DeepCollectionEquality()
                    .equals(other.direction, direction)) &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(direction) ^
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      runtimeType.hashCode;
}

extension $ClientProvidedTransactionExtension on ClientProvidedTransaction {
  ClientProvidedTransaction copyWith(
      {String? id,
      String? description,
      double? amount,
      enums.EnrichTransactionDirection? direction,
      String? isoCurrencyCode}) {
    return ClientProvidedTransaction(
        id: id ?? this.id,
        description: description ?? this.description,
        amount: amount ?? this.amount,
        direction: direction ?? this.direction,
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode);
  }

  ClientProvidedTransaction copyWithWrapped(
      {Wrapped<String>? id,
      Wrapped<String>? description,
      Wrapped<double>? amount,
      Wrapped<enums.EnrichTransactionDirection?>? direction,
      Wrapped<String>? isoCurrencyCode}) {
    return ClientProvidedTransaction(
        id: (id != null ? id.value : this.id),
        description:
            (description != null ? description.value : this.description),
        amount: (amount != null ? amount.value : this.amount),
        direction: (direction != null ? direction.value : this.direction),
        isoCurrencyCode: (isoCurrencyCode != null
            ? isoCurrencyCode.value
            : this.isoCurrencyCode));
  }
}

@JsonSerializable(explicitToJson: true)
class ClientProvidedRawTransaction {
  ClientProvidedRawTransaction({
    required this.id,
    required this.description,
    required this.amount,
    required this.isoCurrencyCode,
  });

  factory ClientProvidedRawTransaction.fromJson(Map<String, dynamic> json) =>
      _$ClientProvidedRawTransactionFromJson(json);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'description')
  final String description;
  @JsonKey(name: 'amount')
  final double amount;
  @JsonKey(name: 'iso_currency_code')
  final String isoCurrencyCode;
  static const fromJsonFactory = _$ClientProvidedRawTransactionFromJson;
  static const toJsonFactory = _$ClientProvidedRawTransactionToJson;
  Map<String, dynamic> toJson() => _$ClientProvidedRawTransactionToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ClientProvidedRawTransaction &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      runtimeType.hashCode;
}

extension $ClientProvidedRawTransactionExtension
    on ClientProvidedRawTransaction {
  ClientProvidedRawTransaction copyWith(
      {String? id,
      String? description,
      double? amount,
      String? isoCurrencyCode}) {
    return ClientProvidedRawTransaction(
        id: id ?? this.id,
        description: description ?? this.description,
        amount: amount ?? this.amount,
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode);
  }

  ClientProvidedRawTransaction copyWithWrapped(
      {Wrapped<String>? id,
      Wrapped<String>? description,
      Wrapped<double>? amount,
      Wrapped<String>? isoCurrencyCode}) {
    return ClientProvidedRawTransaction(
        id: (id != null ? id.value : this.id),
        description:
            (description != null ? description.value : this.description),
        amount: (amount != null ? amount.value : this.amount),
        isoCurrencyCode: (isoCurrencyCode != null
            ? isoCurrencyCode.value
            : this.isoCurrencyCode));
  }
}

@JsonSerializable(explicitToJson: true)
class TransactionsEnhanceGetResponse {
  TransactionsEnhanceGetResponse({
    required this.enhancedTransactions,
  });

  factory TransactionsEnhanceGetResponse.fromJson(Map<String, dynamic> json) =>
      _$TransactionsEnhanceGetResponseFromJson(json);

  @JsonKey(
      name: 'enhanced_transactions',
      defaultValue: <ClientProvidedEnhancedTransaction>[])
  final List<ClientProvidedEnhancedTransaction> enhancedTransactions;
  static const fromJsonFactory = _$TransactionsEnhanceGetResponseFromJson;
  static const toJsonFactory = _$TransactionsEnhanceGetResponseToJson;
  Map<String, dynamic> toJson() => _$TransactionsEnhanceGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransactionsEnhanceGetResponse &&
            (identical(other.enhancedTransactions, enhancedTransactions) ||
                const DeepCollectionEquality()
                    .equals(other.enhancedTransactions, enhancedTransactions)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(enhancedTransactions) ^
      runtimeType.hashCode;
}

extension $TransactionsEnhanceGetResponseExtension
    on TransactionsEnhanceGetResponse {
  TransactionsEnhanceGetResponse copyWith(
      {List<ClientProvidedEnhancedTransaction>? enhancedTransactions}) {
    return TransactionsEnhanceGetResponse(
        enhancedTransactions:
            enhancedTransactions ?? this.enhancedTransactions);
  }

  TransactionsEnhanceGetResponse copyWithWrapped(
      {Wrapped<List<ClientProvidedEnhancedTransaction>>?
          enhancedTransactions}) {
    return TransactionsEnhanceGetResponse(
        enhancedTransactions: (enhancedTransactions != null
            ? enhancedTransactions.value
            : this.enhancedTransactions));
  }
}

@JsonSerializable(explicitToJson: true)
class TransactionsEnrichGetResponse {
  TransactionsEnrichGetResponse({
    required this.enrichedTransactions,
    this.requestId,
  });

  factory TransactionsEnrichGetResponse.fromJson(Map<String, dynamic> json) =>
      _$TransactionsEnrichGetResponseFromJson(json);

  @JsonKey(
      name: 'enriched_transactions',
      defaultValue: <ClientProvidedEnrichedTransaction>[])
  final List<ClientProvidedEnrichedTransaction> enrichedTransactions;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$TransactionsEnrichGetResponseFromJson;
  static const toJsonFactory = _$TransactionsEnrichGetResponseToJson;
  Map<String, dynamic> toJson() => _$TransactionsEnrichGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransactionsEnrichGetResponse &&
            (identical(other.enrichedTransactions, enrichedTransactions) ||
                const DeepCollectionEquality().equals(
                    other.enrichedTransactions, enrichedTransactions)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(enrichedTransactions) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $TransactionsEnrichGetResponseExtension
    on TransactionsEnrichGetResponse {
  TransactionsEnrichGetResponse copyWith(
      {List<ClientProvidedEnrichedTransaction>? enrichedTransactions,
      String? requestId}) {
    return TransactionsEnrichGetResponse(
        enrichedTransactions: enrichedTransactions ?? this.enrichedTransactions,
        requestId: requestId ?? this.requestId);
  }

  TransactionsEnrichGetResponse copyWithWrapped(
      {Wrapped<List<ClientProvidedEnrichedTransaction>>? enrichedTransactions,
      Wrapped<String?>? requestId}) {
    return TransactionsEnrichGetResponse(
        enrichedTransactions: (enrichedTransactions != null
            ? enrichedTransactions.value
            : this.enrichedTransactions),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class ClientProvidedEnhancedTransaction {
  ClientProvidedEnhancedTransaction({
    required this.id,
    required this.description,
    required this.amount,
    required this.isoCurrencyCode,
    required this.enhancements,
  });

  factory ClientProvidedEnhancedTransaction.fromJson(
          Map<String, dynamic> json) =>
      _$ClientProvidedEnhancedTransactionFromJson(json);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'description')
  final String description;
  @JsonKey(name: 'amount')
  final double amount;
  @JsonKey(name: 'iso_currency_code')
  final String isoCurrencyCode;
  @JsonKey(name: 'enhancements')
  final Enhancements enhancements;
  static const fromJsonFactory = _$ClientProvidedEnhancedTransactionFromJson;
  static const toJsonFactory = _$ClientProvidedEnhancedTransactionToJson;
  Map<String, dynamic> toJson() =>
      _$ClientProvidedEnhancedTransactionToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ClientProvidedEnhancedTransaction &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)) &&
            (identical(other.enhancements, enhancements) ||
                const DeepCollectionEquality()
                    .equals(other.enhancements, enhancements)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      const DeepCollectionEquality().hash(enhancements) ^
      runtimeType.hashCode;
}

extension $ClientProvidedEnhancedTransactionExtension
    on ClientProvidedEnhancedTransaction {
  ClientProvidedEnhancedTransaction copyWith(
      {String? id,
      String? description,
      double? amount,
      String? isoCurrencyCode,
      Enhancements? enhancements}) {
    return ClientProvidedEnhancedTransaction(
        id: id ?? this.id,
        description: description ?? this.description,
        amount: amount ?? this.amount,
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode,
        enhancements: enhancements ?? this.enhancements);
  }

  ClientProvidedEnhancedTransaction copyWithWrapped(
      {Wrapped<String>? id,
      Wrapped<String>? description,
      Wrapped<double>? amount,
      Wrapped<String>? isoCurrencyCode,
      Wrapped<Enhancements>? enhancements}) {
    return ClientProvidedEnhancedTransaction(
        id: (id != null ? id.value : this.id),
        description:
            (description != null ? description.value : this.description),
        amount: (amount != null ? amount.value : this.amount),
        isoCurrencyCode: (isoCurrencyCode != null
            ? isoCurrencyCode.value
            : this.isoCurrencyCode),
        enhancements:
            (enhancements != null ? enhancements.value : this.enhancements));
  }
}

@JsonSerializable(explicitToJson: true)
class ClientProvidedEnrichedTransaction {
  ClientProvidedEnrichedTransaction({
    required this.id,
    required this.description,
    required this.amount,
    this.direction,
    required this.isoCurrencyCode,
    required this.enrichments,
  });

  factory ClientProvidedEnrichedTransaction.fromJson(
          Map<String, dynamic> json) =>
      _$ClientProvidedEnrichedTransactionFromJson(json);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'description')
  final String description;
  @JsonKey(name: 'amount')
  final double amount;
  @JsonKey(
    name: 'direction',
    toJson: enrichTransactionDirectionToJson,
    fromJson: enrichTransactionDirectionFromJson,
  )
  final enums.EnrichTransactionDirection? direction;
  @JsonKey(name: 'iso_currency_code')
  final String isoCurrencyCode;
  @JsonKey(name: 'enrichments')
  final Enrichments enrichments;
  static const fromJsonFactory = _$ClientProvidedEnrichedTransactionFromJson;
  static const toJsonFactory = _$ClientProvidedEnrichedTransactionToJson;
  Map<String, dynamic> toJson() =>
      _$ClientProvidedEnrichedTransactionToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ClientProvidedEnrichedTransaction &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.direction, direction) ||
                const DeepCollectionEquality()
                    .equals(other.direction, direction)) &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)) &&
            (identical(other.enrichments, enrichments) ||
                const DeepCollectionEquality()
                    .equals(other.enrichments, enrichments)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(direction) ^
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      const DeepCollectionEquality().hash(enrichments) ^
      runtimeType.hashCode;
}

extension $ClientProvidedEnrichedTransactionExtension
    on ClientProvidedEnrichedTransaction {
  ClientProvidedEnrichedTransaction copyWith(
      {String? id,
      String? description,
      double? amount,
      enums.EnrichTransactionDirection? direction,
      String? isoCurrencyCode,
      Enrichments? enrichments}) {
    return ClientProvidedEnrichedTransaction(
        id: id ?? this.id,
        description: description ?? this.description,
        amount: amount ?? this.amount,
        direction: direction ?? this.direction,
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode,
        enrichments: enrichments ?? this.enrichments);
  }

  ClientProvidedEnrichedTransaction copyWithWrapped(
      {Wrapped<String>? id,
      Wrapped<String>? description,
      Wrapped<double>? amount,
      Wrapped<enums.EnrichTransactionDirection?>? direction,
      Wrapped<String>? isoCurrencyCode,
      Wrapped<Enrichments>? enrichments}) {
    return ClientProvidedEnrichedTransaction(
        id: (id != null ? id.value : this.id),
        description:
            (description != null ? description.value : this.description),
        amount: (amount != null ? amount.value : this.amount),
        direction: (direction != null ? direction.value : this.direction),
        isoCurrencyCode: (isoCurrencyCode != null
            ? isoCurrencyCode.value
            : this.isoCurrencyCode),
        enrichments:
            (enrichments != null ? enrichments.value : this.enrichments));
  }
}

@JsonSerializable(explicitToJson: true)
class Enhancements {
  Enhancements({
    this.merchantName,
    this.website,
    this.logoUrl,
    this.checkNumber,
    required this.paymentChannel,
    required this.categoryId,
    required this.category,
    required this.location,
    this.personalFinanceCategory,
    this.personalFinanceCategoryIconUrl,
    this.counterparties,
  });

  factory Enhancements.fromJson(Map<String, dynamic> json) =>
      _$EnhancementsFromJson(json);

  @JsonKey(name: 'merchant_name')
  final String? merchantName;
  @JsonKey(name: 'website')
  final String? website;
  @JsonKey(name: 'logo_url')
  final String? logoUrl;
  @JsonKey(name: 'check_number')
  final String? checkNumber;
  @JsonKey(
    name: 'payment_channel',
    toJson: paymentChannelToJson,
    fromJson: paymentChannelFromJson,
  )
  final enums.PaymentChannel paymentChannel;
  @JsonKey(name: 'category_id')
  final String? categoryId;
  @JsonKey(name: 'category', defaultValue: <String>[])
  final List<String> category;
  @JsonKey(name: 'location')
  final Location location;
  @JsonKey(name: 'personal_finance_category')
  final PersonalFinanceCategory? personalFinanceCategory;
  @JsonKey(name: 'personal_finance_category_icon_url')
  final String? personalFinanceCategoryIconUrl;
  @JsonKey(name: 'counterparties', defaultValue: <Counterparty>[])
  final List<Counterparty>? counterparties;
  static const fromJsonFactory = _$EnhancementsFromJson;
  static const toJsonFactory = _$EnhancementsToJson;
  Map<String, dynamic> toJson() => _$EnhancementsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Enhancements &&
            (identical(other.merchantName, merchantName) ||
                const DeepCollectionEquality()
                    .equals(other.merchantName, merchantName)) &&
            (identical(other.website, website) ||
                const DeepCollectionEquality()
                    .equals(other.website, website)) &&
            (identical(other.logoUrl, logoUrl) ||
                const DeepCollectionEquality()
                    .equals(other.logoUrl, logoUrl)) &&
            (identical(other.checkNumber, checkNumber) ||
                const DeepCollectionEquality()
                    .equals(other.checkNumber, checkNumber)) &&
            (identical(other.paymentChannel, paymentChannel) ||
                const DeepCollectionEquality()
                    .equals(other.paymentChannel, paymentChannel)) &&
            (identical(other.categoryId, categoryId) ||
                const DeepCollectionEquality()
                    .equals(other.categoryId, categoryId)) &&
            (identical(other.category, category) ||
                const DeepCollectionEquality()
                    .equals(other.category, category)) &&
            (identical(other.location, location) ||
                const DeepCollectionEquality()
                    .equals(other.location, location)) &&
            (identical(
                    other.personalFinanceCategory, personalFinanceCategory) ||
                const DeepCollectionEquality().equals(
                    other.personalFinanceCategory, personalFinanceCategory)) &&
            (identical(other.personalFinanceCategoryIconUrl,
                    personalFinanceCategoryIconUrl) ||
                const DeepCollectionEquality().equals(
                    other.personalFinanceCategoryIconUrl,
                    personalFinanceCategoryIconUrl)) &&
            (identical(other.counterparties, counterparties) ||
                const DeepCollectionEquality()
                    .equals(other.counterparties, counterparties)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(merchantName) ^
      const DeepCollectionEquality().hash(website) ^
      const DeepCollectionEquality().hash(logoUrl) ^
      const DeepCollectionEquality().hash(checkNumber) ^
      const DeepCollectionEquality().hash(paymentChannel) ^
      const DeepCollectionEquality().hash(categoryId) ^
      const DeepCollectionEquality().hash(category) ^
      const DeepCollectionEquality().hash(location) ^
      const DeepCollectionEquality().hash(personalFinanceCategory) ^
      const DeepCollectionEquality().hash(personalFinanceCategoryIconUrl) ^
      const DeepCollectionEquality().hash(counterparties) ^
      runtimeType.hashCode;
}

extension $EnhancementsExtension on Enhancements {
  Enhancements copyWith(
      {String? merchantName,
      String? website,
      String? logoUrl,
      String? checkNumber,
      enums.PaymentChannel? paymentChannel,
      String? categoryId,
      List<String>? category,
      Location? location,
      PersonalFinanceCategory? personalFinanceCategory,
      String? personalFinanceCategoryIconUrl,
      List<Counterparty>? counterparties}) {
    return Enhancements(
        merchantName: merchantName ?? this.merchantName,
        website: website ?? this.website,
        logoUrl: logoUrl ?? this.logoUrl,
        checkNumber: checkNumber ?? this.checkNumber,
        paymentChannel: paymentChannel ?? this.paymentChannel,
        categoryId: categoryId ?? this.categoryId,
        category: category ?? this.category,
        location: location ?? this.location,
        personalFinanceCategory:
            personalFinanceCategory ?? this.personalFinanceCategory,
        personalFinanceCategoryIconUrl: personalFinanceCategoryIconUrl ??
            this.personalFinanceCategoryIconUrl,
        counterparties: counterparties ?? this.counterparties);
  }

  Enhancements copyWithWrapped(
      {Wrapped<String?>? merchantName,
      Wrapped<String?>? website,
      Wrapped<String?>? logoUrl,
      Wrapped<String?>? checkNumber,
      Wrapped<enums.PaymentChannel>? paymentChannel,
      Wrapped<String?>? categoryId,
      Wrapped<List<String>>? category,
      Wrapped<Location>? location,
      Wrapped<PersonalFinanceCategory?>? personalFinanceCategory,
      Wrapped<String?>? personalFinanceCategoryIconUrl,
      Wrapped<List<Counterparty>?>? counterparties}) {
    return Enhancements(
        merchantName:
            (merchantName != null ? merchantName.value : this.merchantName),
        website: (website != null ? website.value : this.website),
        logoUrl: (logoUrl != null ? logoUrl.value : this.logoUrl),
        checkNumber:
            (checkNumber != null ? checkNumber.value : this.checkNumber),
        paymentChannel: (paymentChannel != null
            ? paymentChannel.value
            : this.paymentChannel),
        categoryId: (categoryId != null ? categoryId.value : this.categoryId),
        category: (category != null ? category.value : this.category),
        location: (location != null ? location.value : this.location),
        personalFinanceCategory: (personalFinanceCategory != null
            ? personalFinanceCategory.value
            : this.personalFinanceCategory),
        personalFinanceCategoryIconUrl: (personalFinanceCategoryIconUrl != null
            ? personalFinanceCategoryIconUrl.value
            : this.personalFinanceCategoryIconUrl),
        counterparties: (counterparties != null
            ? counterparties.value
            : this.counterparties));
  }
}

@JsonSerializable(explicitToJson: true)
class Enrichments {
  Enrichments({
    this.merchantName,
    this.website,
    this.logoUrl,
    this.checkNumber,
    required this.paymentChannel,
    this.legacyCategoryId,
    this.legacyCategory,
    required this.location,
    required this.personalFinanceCategory,
    required this.personalFinanceCategoryIconUrl,
    this.counterparties,
  });

  factory Enrichments.fromJson(Map<String, dynamic> json) =>
      _$EnrichmentsFromJson(json);

  @JsonKey(name: 'merchant_name')
  final String? merchantName;
  @JsonKey(name: 'website')
  final String? website;
  @JsonKey(name: 'logo_url')
  final String? logoUrl;
  @JsonKey(name: 'check_number')
  final String? checkNumber;
  @JsonKey(
    name: 'payment_channel',
    toJson: paymentChannelToJson,
    fromJson: paymentChannelFromJson,
  )
  final enums.PaymentChannel paymentChannel;
  @JsonKey(name: 'legacy_category_id')
  final String? legacyCategoryId;
  @JsonKey(name: 'legacy_category', defaultValue: <String>[])
  final List<String>? legacyCategory;
  @JsonKey(name: 'location')
  final Location location;
  @JsonKey(name: 'personal_finance_category')
  final PersonalFinanceCategory? personalFinanceCategory;
  @JsonKey(name: 'personal_finance_category_icon_url')
  final String personalFinanceCategoryIconUrl;
  @JsonKey(name: 'counterparties', defaultValue: <Counterparty>[])
  final List<Counterparty>? counterparties;
  static const fromJsonFactory = _$EnrichmentsFromJson;
  static const toJsonFactory = _$EnrichmentsToJson;
  Map<String, dynamic> toJson() => _$EnrichmentsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Enrichments &&
            (identical(other.merchantName, merchantName) ||
                const DeepCollectionEquality()
                    .equals(other.merchantName, merchantName)) &&
            (identical(other.website, website) ||
                const DeepCollectionEquality()
                    .equals(other.website, website)) &&
            (identical(other.logoUrl, logoUrl) ||
                const DeepCollectionEquality()
                    .equals(other.logoUrl, logoUrl)) &&
            (identical(other.checkNumber, checkNumber) ||
                const DeepCollectionEquality()
                    .equals(other.checkNumber, checkNumber)) &&
            (identical(other.paymentChannel, paymentChannel) ||
                const DeepCollectionEquality()
                    .equals(other.paymentChannel, paymentChannel)) &&
            (identical(other.legacyCategoryId, legacyCategoryId) ||
                const DeepCollectionEquality()
                    .equals(other.legacyCategoryId, legacyCategoryId)) &&
            (identical(other.legacyCategory, legacyCategory) ||
                const DeepCollectionEquality()
                    .equals(other.legacyCategory, legacyCategory)) &&
            (identical(other.location, location) ||
                const DeepCollectionEquality()
                    .equals(other.location, location)) &&
            (identical(
                    other.personalFinanceCategory, personalFinanceCategory) ||
                const DeepCollectionEquality().equals(
                    other.personalFinanceCategory, personalFinanceCategory)) &&
            (identical(other.personalFinanceCategoryIconUrl,
                    personalFinanceCategoryIconUrl) ||
                const DeepCollectionEquality().equals(
                    other.personalFinanceCategoryIconUrl,
                    personalFinanceCategoryIconUrl)) &&
            (identical(other.counterparties, counterparties) ||
                const DeepCollectionEquality()
                    .equals(other.counterparties, counterparties)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(merchantName) ^
      const DeepCollectionEquality().hash(website) ^
      const DeepCollectionEquality().hash(logoUrl) ^
      const DeepCollectionEquality().hash(checkNumber) ^
      const DeepCollectionEquality().hash(paymentChannel) ^
      const DeepCollectionEquality().hash(legacyCategoryId) ^
      const DeepCollectionEquality().hash(legacyCategory) ^
      const DeepCollectionEquality().hash(location) ^
      const DeepCollectionEquality().hash(personalFinanceCategory) ^
      const DeepCollectionEquality().hash(personalFinanceCategoryIconUrl) ^
      const DeepCollectionEquality().hash(counterparties) ^
      runtimeType.hashCode;
}

extension $EnrichmentsExtension on Enrichments {
  Enrichments copyWith(
      {String? merchantName,
      String? website,
      String? logoUrl,
      String? checkNumber,
      enums.PaymentChannel? paymentChannel,
      String? legacyCategoryId,
      List<String>? legacyCategory,
      Location? location,
      PersonalFinanceCategory? personalFinanceCategory,
      String? personalFinanceCategoryIconUrl,
      List<Counterparty>? counterparties}) {
    return Enrichments(
        merchantName: merchantName ?? this.merchantName,
        website: website ?? this.website,
        logoUrl: logoUrl ?? this.logoUrl,
        checkNumber: checkNumber ?? this.checkNumber,
        paymentChannel: paymentChannel ?? this.paymentChannel,
        legacyCategoryId: legacyCategoryId ?? this.legacyCategoryId,
        legacyCategory: legacyCategory ?? this.legacyCategory,
        location: location ?? this.location,
        personalFinanceCategory:
            personalFinanceCategory ?? this.personalFinanceCategory,
        personalFinanceCategoryIconUrl: personalFinanceCategoryIconUrl ??
            this.personalFinanceCategoryIconUrl,
        counterparties: counterparties ?? this.counterparties);
  }

  Enrichments copyWithWrapped(
      {Wrapped<String?>? merchantName,
      Wrapped<String?>? website,
      Wrapped<String?>? logoUrl,
      Wrapped<String?>? checkNumber,
      Wrapped<enums.PaymentChannel>? paymentChannel,
      Wrapped<String?>? legacyCategoryId,
      Wrapped<List<String>?>? legacyCategory,
      Wrapped<Location>? location,
      Wrapped<PersonalFinanceCategory?>? personalFinanceCategory,
      Wrapped<String>? personalFinanceCategoryIconUrl,
      Wrapped<List<Counterparty>?>? counterparties}) {
    return Enrichments(
        merchantName:
            (merchantName != null ? merchantName.value : this.merchantName),
        website: (website != null ? website.value : this.website),
        logoUrl: (logoUrl != null ? logoUrl.value : this.logoUrl),
        checkNumber:
            (checkNumber != null ? checkNumber.value : this.checkNumber),
        paymentChannel: (paymentChannel != null
            ? paymentChannel.value
            : this.paymentChannel),
        legacyCategoryId: (legacyCategoryId != null
            ? legacyCategoryId.value
            : this.legacyCategoryId),
        legacyCategory: (legacyCategory != null
            ? legacyCategory.value
            : this.legacyCategory),
        location: (location != null ? location.value : this.location),
        personalFinanceCategory: (personalFinanceCategory != null
            ? personalFinanceCategory.value
            : this.personalFinanceCategory),
        personalFinanceCategoryIconUrl: (personalFinanceCategoryIconUrl != null
            ? personalFinanceCategoryIconUrl.value
            : this.personalFinanceCategoryIconUrl),
        counterparties: (counterparties != null
            ? counterparties.value
            : this.counterparties));
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentProfileCreateRequest {
  PaymentProfileCreateRequest({
    this.clientId,
    this.secret,
  });

  factory PaymentProfileCreateRequest.fromJson(Map<String, dynamic> json) =>
      _$PaymentProfileCreateRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  static const fromJsonFactory = _$PaymentProfileCreateRequestFromJson;
  static const toJsonFactory = _$PaymentProfileCreateRequestToJson;
  Map<String, dynamic> toJson() => _$PaymentProfileCreateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentProfileCreateRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      runtimeType.hashCode;
}

extension $PaymentProfileCreateRequestExtension on PaymentProfileCreateRequest {
  PaymentProfileCreateRequest copyWith({String? clientId, String? secret}) {
    return PaymentProfileCreateRequest(
        clientId: clientId ?? this.clientId, secret: secret ?? this.secret);
  }

  PaymentProfileCreateRequest copyWithWrapped(
      {Wrapped<String?>? clientId, Wrapped<String?>? secret}) {
    return PaymentProfileCreateRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret));
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentProfileCreateResponse {
  PaymentProfileCreateResponse({
    required this.paymentProfileToken,
    required this.requestId,
  });

  factory PaymentProfileCreateResponse.fromJson(Map<String, dynamic> json) =>
      _$PaymentProfileCreateResponseFromJson(json);

  @JsonKey(name: 'payment_profile_token')
  final String paymentProfileToken;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$PaymentProfileCreateResponseFromJson;
  static const toJsonFactory = _$PaymentProfileCreateResponseToJson;
  Map<String, dynamic> toJson() => _$PaymentProfileCreateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentProfileCreateResponse &&
            (identical(other.paymentProfileToken, paymentProfileToken) ||
                const DeepCollectionEquality()
                    .equals(other.paymentProfileToken, paymentProfileToken)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(paymentProfileToken) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $PaymentProfileCreateResponseExtension
    on PaymentProfileCreateResponse {
  PaymentProfileCreateResponse copyWith(
      {String? paymentProfileToken, String? requestId}) {
    return PaymentProfileCreateResponse(
        paymentProfileToken: paymentProfileToken ?? this.paymentProfileToken,
        requestId: requestId ?? this.requestId);
  }

  PaymentProfileCreateResponse copyWithWrapped(
      {Wrapped<String>? paymentProfileToken, Wrapped<String>? requestId}) {
    return PaymentProfileCreateResponse(
        paymentProfileToken: (paymentProfileToken != null
            ? paymentProfileToken.value
            : this.paymentProfileToken),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentProfileGetRequest {
  PaymentProfileGetRequest({
    this.clientId,
    this.secret,
    required this.paymentProfileToken,
  });

  factory PaymentProfileGetRequest.fromJson(Map<String, dynamic> json) =>
      _$PaymentProfileGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'payment_profile_token')
  final String paymentProfileToken;
  static const fromJsonFactory = _$PaymentProfileGetRequestFromJson;
  static const toJsonFactory = _$PaymentProfileGetRequestToJson;
  Map<String, dynamic> toJson() => _$PaymentProfileGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentProfileGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.paymentProfileToken, paymentProfileToken) ||
                const DeepCollectionEquality()
                    .equals(other.paymentProfileToken, paymentProfileToken)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(paymentProfileToken) ^
      runtimeType.hashCode;
}

extension $PaymentProfileGetRequestExtension on PaymentProfileGetRequest {
  PaymentProfileGetRequest copyWith(
      {String? clientId, String? secret, String? paymentProfileToken}) {
    return PaymentProfileGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        paymentProfileToken: paymentProfileToken ?? this.paymentProfileToken);
  }

  PaymentProfileGetRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? paymentProfileToken}) {
    return PaymentProfileGetRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        paymentProfileToken: (paymentProfileToken != null
            ? paymentProfileToken.value
            : this.paymentProfileToken));
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentProfileGetResponse {
  PaymentProfileGetResponse({
    required this.updatedAt,
    required this.createdAt,
    required this.deletedAt,
    required this.status,
    required this.requestId,
  });

  factory PaymentProfileGetResponse.fromJson(Map<String, dynamic> json) =>
      _$PaymentProfileGetResponseFromJson(json);

  @JsonKey(name: 'updated_at')
  final DateTime updatedAt;
  @JsonKey(name: 'created_at')
  final DateTime createdAt;
  @JsonKey(name: 'deleted_at')
  final DateTime? deletedAt;
  @JsonKey(
    name: 'status',
    toJson: paymentProfileStatusToJson,
    fromJson: paymentProfileStatusFromJson,
  )
  final enums.PaymentProfileStatus status;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$PaymentProfileGetResponseFromJson;
  static const toJsonFactory = _$PaymentProfileGetResponseToJson;
  Map<String, dynamic> toJson() => _$PaymentProfileGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentProfileGetResponse &&
            (identical(other.updatedAt, updatedAt) ||
                const DeepCollectionEquality()
                    .equals(other.updatedAt, updatedAt)) &&
            (identical(other.createdAt, createdAt) ||
                const DeepCollectionEquality()
                    .equals(other.createdAt, createdAt)) &&
            (identical(other.deletedAt, deletedAt) ||
                const DeepCollectionEquality()
                    .equals(other.deletedAt, deletedAt)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(updatedAt) ^
      const DeepCollectionEquality().hash(createdAt) ^
      const DeepCollectionEquality().hash(deletedAt) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $PaymentProfileGetResponseExtension on PaymentProfileGetResponse {
  PaymentProfileGetResponse copyWith(
      {DateTime? updatedAt,
      DateTime? createdAt,
      DateTime? deletedAt,
      enums.PaymentProfileStatus? status,
      String? requestId}) {
    return PaymentProfileGetResponse(
        updatedAt: updatedAt ?? this.updatedAt,
        createdAt: createdAt ?? this.createdAt,
        deletedAt: deletedAt ?? this.deletedAt,
        status: status ?? this.status,
        requestId: requestId ?? this.requestId);
  }

  PaymentProfileGetResponse copyWithWrapped(
      {Wrapped<DateTime>? updatedAt,
      Wrapped<DateTime>? createdAt,
      Wrapped<DateTime?>? deletedAt,
      Wrapped<enums.PaymentProfileStatus>? status,
      Wrapped<String>? requestId}) {
    return PaymentProfileGetResponse(
        updatedAt: (updatedAt != null ? updatedAt.value : this.updatedAt),
        createdAt: (createdAt != null ? createdAt.value : this.createdAt),
        deletedAt: (deletedAt != null ? deletedAt.value : this.deletedAt),
        status: (status != null ? status.value : this.status),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentProfileRemoveRequest {
  PaymentProfileRemoveRequest({
    this.clientId,
    this.secret,
    required this.paymentProfileToken,
  });

  factory PaymentProfileRemoveRequest.fromJson(Map<String, dynamic> json) =>
      _$PaymentProfileRemoveRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'payment_profile_token')
  final String paymentProfileToken;
  static const fromJsonFactory = _$PaymentProfileRemoveRequestFromJson;
  static const toJsonFactory = _$PaymentProfileRemoveRequestToJson;
  Map<String, dynamic> toJson() => _$PaymentProfileRemoveRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentProfileRemoveRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.paymentProfileToken, paymentProfileToken) ||
                const DeepCollectionEquality()
                    .equals(other.paymentProfileToken, paymentProfileToken)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(paymentProfileToken) ^
      runtimeType.hashCode;
}

extension $PaymentProfileRemoveRequestExtension on PaymentProfileRemoveRequest {
  PaymentProfileRemoveRequest copyWith(
      {String? clientId, String? secret, String? paymentProfileToken}) {
    return PaymentProfileRemoveRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        paymentProfileToken: paymentProfileToken ?? this.paymentProfileToken);
  }

  PaymentProfileRemoveRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? paymentProfileToken}) {
    return PaymentProfileRemoveRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        paymentProfileToken: (paymentProfileToken != null
            ? paymentProfileToken.value
            : this.paymentProfileToken));
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentProfileRemoveResponse {
  PaymentProfileRemoveResponse({
    required this.requestId,
  });

  factory PaymentProfileRemoveResponse.fromJson(Map<String, dynamic> json) =>
      _$PaymentProfileRemoveResponseFromJson(json);

  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$PaymentProfileRemoveResponseFromJson;
  static const toJsonFactory = _$PaymentProfileRemoveResponseToJson;
  Map<String, dynamic> toJson() => _$PaymentProfileRemoveResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentProfileRemoveResponse &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(requestId) ^ runtimeType.hashCode;
}

extension $PaymentProfileRemoveResponseExtension
    on PaymentProfileRemoveResponse {
  PaymentProfileRemoveResponse copyWith({String? requestId}) {
    return PaymentProfileRemoveResponse(requestId: requestId ?? this.requestId);
  }

  PaymentProfileRemoveResponse copyWithWrapped({Wrapped<String>? requestId}) {
    return PaymentProfileRemoveResponse(
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class PartnerCustomerCreateRequest {
  PartnerCustomerCreateRequest({
    this.clientId,
    this.secret,
    required this.companyName,
    required this.isDiligenceAttested,
    required this.products,
    this.createLinkCustomization,
    this.logo,
    required this.legalEntityName,
    required this.website,
    required this.applicationName,
    this.technicalContact,
    this.billingContact,
    required this.address,
    required this.isBankAddendumCompleted,
    this.assetsUnderManagement,
  });

  factory PartnerCustomerCreateRequest.fromJson(Map<String, dynamic> json) =>
      _$PartnerCustomerCreateRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'company_name')
  final String companyName;
  @JsonKey(name: 'is_diligence_attested')
  final bool isDiligenceAttested;
  @JsonKey(
    name: 'products',
    toJson: productsListToJson,
    fromJson: productsListFromJson,
  )
  final List<enums.Products> products;
  @JsonKey(name: 'create_link_customization')
  final bool? createLinkCustomization;
  @JsonKey(name: 'logo')
  final String? logo;
  @JsonKey(name: 'legal_entity_name')
  final String legalEntityName;
  @JsonKey(name: 'website')
  final String website;
  @JsonKey(name: 'application_name')
  final String applicationName;
  @JsonKey(name: 'technical_contact')
  final PartnerEndCustomerTechnicalContact? technicalContact;
  @JsonKey(name: 'billing_contact')
  final PartnerEndCustomerBillingContact? billingContact;
  @JsonKey(name: 'address')
  final PartnerEndCustomerAddress address;
  @JsonKey(name: 'is_bank_addendum_completed')
  final bool isBankAddendumCompleted;
  @JsonKey(name: 'assets_under_management')
  final PartnerEndCustomerAssetsUnderManagement? assetsUnderManagement;
  static const fromJsonFactory = _$PartnerCustomerCreateRequestFromJson;
  static const toJsonFactory = _$PartnerCustomerCreateRequestToJson;
  Map<String, dynamic> toJson() => _$PartnerCustomerCreateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PartnerCustomerCreateRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.companyName, companyName) ||
                const DeepCollectionEquality()
                    .equals(other.companyName, companyName)) &&
            (identical(other.isDiligenceAttested, isDiligenceAttested) ||
                const DeepCollectionEquality()
                    .equals(other.isDiligenceAttested, isDiligenceAttested)) &&
            (identical(other.products, products) ||
                const DeepCollectionEquality()
                    .equals(other.products, products)) &&
            (identical(
                    other.createLinkCustomization, createLinkCustomization) ||
                const DeepCollectionEquality().equals(
                    other.createLinkCustomization, createLinkCustomization)) &&
            (identical(other.logo, logo) ||
                const DeepCollectionEquality().equals(other.logo, logo)) &&
            (identical(other.legalEntityName, legalEntityName) ||
                const DeepCollectionEquality()
                    .equals(other.legalEntityName, legalEntityName)) &&
            (identical(other.website, website) ||
                const DeepCollectionEquality()
                    .equals(other.website, website)) &&
            (identical(other.applicationName, applicationName) ||
                const DeepCollectionEquality()
                    .equals(other.applicationName, applicationName)) &&
            (identical(other.technicalContact, technicalContact) ||
                const DeepCollectionEquality()
                    .equals(other.technicalContact, technicalContact)) &&
            (identical(other.billingContact, billingContact) ||
                const DeepCollectionEquality()
                    .equals(other.billingContact, billingContact)) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality()
                    .equals(other.address, address)) &&
            (identical(
                    other.isBankAddendumCompleted, isBankAddendumCompleted) ||
                const DeepCollectionEquality().equals(
                    other.isBankAddendumCompleted, isBankAddendumCompleted)) &&
            (identical(other.assetsUnderManagement, assetsUnderManagement) ||
                const DeepCollectionEquality().equals(
                    other.assetsUnderManagement, assetsUnderManagement)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(companyName) ^
      const DeepCollectionEquality().hash(isDiligenceAttested) ^
      const DeepCollectionEquality().hash(products) ^
      const DeepCollectionEquality().hash(createLinkCustomization) ^
      const DeepCollectionEquality().hash(logo) ^
      const DeepCollectionEquality().hash(legalEntityName) ^
      const DeepCollectionEquality().hash(website) ^
      const DeepCollectionEquality().hash(applicationName) ^
      const DeepCollectionEquality().hash(technicalContact) ^
      const DeepCollectionEquality().hash(billingContact) ^
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(isBankAddendumCompleted) ^
      const DeepCollectionEquality().hash(assetsUnderManagement) ^
      runtimeType.hashCode;
}

extension $PartnerCustomerCreateRequestExtension
    on PartnerCustomerCreateRequest {
  PartnerCustomerCreateRequest copyWith(
      {String? clientId,
      String? secret,
      String? companyName,
      bool? isDiligenceAttested,
      List<enums.Products>? products,
      bool? createLinkCustomization,
      String? logo,
      String? legalEntityName,
      String? website,
      String? applicationName,
      PartnerEndCustomerTechnicalContact? technicalContact,
      PartnerEndCustomerBillingContact? billingContact,
      PartnerEndCustomerAddress? address,
      bool? isBankAddendumCompleted,
      PartnerEndCustomerAssetsUnderManagement? assetsUnderManagement}) {
    return PartnerCustomerCreateRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        companyName: companyName ?? this.companyName,
        isDiligenceAttested: isDiligenceAttested ?? this.isDiligenceAttested,
        products: products ?? this.products,
        createLinkCustomization:
            createLinkCustomization ?? this.createLinkCustomization,
        logo: logo ?? this.logo,
        legalEntityName: legalEntityName ?? this.legalEntityName,
        website: website ?? this.website,
        applicationName: applicationName ?? this.applicationName,
        technicalContact: technicalContact ?? this.technicalContact,
        billingContact: billingContact ?? this.billingContact,
        address: address ?? this.address,
        isBankAddendumCompleted:
            isBankAddendumCompleted ?? this.isBankAddendumCompleted,
        assetsUnderManagement:
            assetsUnderManagement ?? this.assetsUnderManagement);
  }

  PartnerCustomerCreateRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? companyName,
      Wrapped<bool>? isDiligenceAttested,
      Wrapped<List<enums.Products>>? products,
      Wrapped<bool?>? createLinkCustomization,
      Wrapped<String?>? logo,
      Wrapped<String>? legalEntityName,
      Wrapped<String>? website,
      Wrapped<String>? applicationName,
      Wrapped<PartnerEndCustomerTechnicalContact?>? technicalContact,
      Wrapped<PartnerEndCustomerBillingContact?>? billingContact,
      Wrapped<PartnerEndCustomerAddress>? address,
      Wrapped<bool>? isBankAddendumCompleted,
      Wrapped<PartnerEndCustomerAssetsUnderManagement?>?
          assetsUnderManagement}) {
    return PartnerCustomerCreateRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        companyName:
            (companyName != null ? companyName.value : this.companyName),
        isDiligenceAttested: (isDiligenceAttested != null
            ? isDiligenceAttested.value
            : this.isDiligenceAttested),
        products: (products != null ? products.value : this.products),
        createLinkCustomization: (createLinkCustomization != null
            ? createLinkCustomization.value
            : this.createLinkCustomization),
        logo: (logo != null ? logo.value : this.logo),
        legalEntityName: (legalEntityName != null
            ? legalEntityName.value
            : this.legalEntityName),
        website: (website != null ? website.value : this.website),
        applicationName: (applicationName != null
            ? applicationName.value
            : this.applicationName),
        technicalContact: (technicalContact != null
            ? technicalContact.value
            : this.technicalContact),
        billingContact: (billingContact != null
            ? billingContact.value
            : this.billingContact),
        address: (address != null ? address.value : this.address),
        isBankAddendumCompleted: (isBankAddendumCompleted != null
            ? isBankAddendumCompleted.value
            : this.isBankAddendumCompleted),
        assetsUnderManagement: (assetsUnderManagement != null
            ? assetsUnderManagement.value
            : this.assetsUnderManagement));
  }
}

@JsonSerializable(explicitToJson: true)
class PartnerCustomerCreateResponse {
  PartnerCustomerCreateResponse({
    this.endCustomer,
    this.requestId,
  });

  factory PartnerCustomerCreateResponse.fromJson(Map<String, dynamic> json) =>
      _$PartnerCustomerCreateResponseFromJson(json);

  @JsonKey(name: 'end_customer')
  final PartnerEndCustomerWithSecrets? endCustomer;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$PartnerCustomerCreateResponseFromJson;
  static const toJsonFactory = _$PartnerCustomerCreateResponseToJson;
  Map<String, dynamic> toJson() => _$PartnerCustomerCreateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PartnerCustomerCreateResponse &&
            (identical(other.endCustomer, endCustomer) ||
                const DeepCollectionEquality()
                    .equals(other.endCustomer, endCustomer)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(endCustomer) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $PartnerCustomerCreateResponseExtension
    on PartnerCustomerCreateResponse {
  PartnerCustomerCreateResponse copyWith(
      {PartnerEndCustomerWithSecrets? endCustomer, String? requestId}) {
    return PartnerCustomerCreateResponse(
        endCustomer: endCustomer ?? this.endCustomer,
        requestId: requestId ?? this.requestId);
  }

  PartnerCustomerCreateResponse copyWithWrapped(
      {Wrapped<PartnerEndCustomerWithSecrets?>? endCustomer,
      Wrapped<String?>? requestId}) {
    return PartnerCustomerCreateResponse(
        endCustomer:
            (endCustomer != null ? endCustomer.value : this.endCustomer),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class PartnerCustomerGetRequest {
  PartnerCustomerGetRequest({
    this.clientId,
    this.secret,
    required this.endCustomerClientId,
  });

  factory PartnerCustomerGetRequest.fromJson(Map<String, dynamic> json) =>
      _$PartnerCustomerGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'end_customer_client_id')
  final String endCustomerClientId;
  static const fromJsonFactory = _$PartnerCustomerGetRequestFromJson;
  static const toJsonFactory = _$PartnerCustomerGetRequestToJson;
  Map<String, dynamic> toJson() => _$PartnerCustomerGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PartnerCustomerGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.endCustomerClientId, endCustomerClientId) ||
                const DeepCollectionEquality()
                    .equals(other.endCustomerClientId, endCustomerClientId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(endCustomerClientId) ^
      runtimeType.hashCode;
}

extension $PartnerCustomerGetRequestExtension on PartnerCustomerGetRequest {
  PartnerCustomerGetRequest copyWith(
      {String? clientId, String? secret, String? endCustomerClientId}) {
    return PartnerCustomerGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        endCustomerClientId: endCustomerClientId ?? this.endCustomerClientId);
  }

  PartnerCustomerGetRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? endCustomerClientId}) {
    return PartnerCustomerGetRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        endCustomerClientId: (endCustomerClientId != null
            ? endCustomerClientId.value
            : this.endCustomerClientId));
  }
}

@JsonSerializable(explicitToJson: true)
class PartnerCustomerGetResponse {
  PartnerCustomerGetResponse({
    this.endCustomer,
    this.requestId,
  });

  factory PartnerCustomerGetResponse.fromJson(Map<String, dynamic> json) =>
      _$PartnerCustomerGetResponseFromJson(json);

  @JsonKey(name: 'end_customer')
  final PartnerEndCustomer? endCustomer;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$PartnerCustomerGetResponseFromJson;
  static const toJsonFactory = _$PartnerCustomerGetResponseToJson;
  Map<String, dynamic> toJson() => _$PartnerCustomerGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PartnerCustomerGetResponse &&
            (identical(other.endCustomer, endCustomer) ||
                const DeepCollectionEquality()
                    .equals(other.endCustomer, endCustomer)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(endCustomer) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $PartnerCustomerGetResponseExtension on PartnerCustomerGetResponse {
  PartnerCustomerGetResponse copyWith(
      {PartnerEndCustomer? endCustomer, String? requestId}) {
    return PartnerCustomerGetResponse(
        endCustomer: endCustomer ?? this.endCustomer,
        requestId: requestId ?? this.requestId);
  }

  PartnerCustomerGetResponse copyWithWrapped(
      {Wrapped<PartnerEndCustomer?>? endCustomer,
      Wrapped<String?>? requestId}) {
    return PartnerCustomerGetResponse(
        endCustomer:
            (endCustomer != null ? endCustomer.value : this.endCustomer),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class PartnerCustomerEnableRequest {
  PartnerCustomerEnableRequest({
    this.clientId,
    this.secret,
    required this.endCustomerClientId,
  });

  factory PartnerCustomerEnableRequest.fromJson(Map<String, dynamic> json) =>
      _$PartnerCustomerEnableRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'end_customer_client_id')
  final String endCustomerClientId;
  static const fromJsonFactory = _$PartnerCustomerEnableRequestFromJson;
  static const toJsonFactory = _$PartnerCustomerEnableRequestToJson;
  Map<String, dynamic> toJson() => _$PartnerCustomerEnableRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PartnerCustomerEnableRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.endCustomerClientId, endCustomerClientId) ||
                const DeepCollectionEquality()
                    .equals(other.endCustomerClientId, endCustomerClientId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(endCustomerClientId) ^
      runtimeType.hashCode;
}

extension $PartnerCustomerEnableRequestExtension
    on PartnerCustomerEnableRequest {
  PartnerCustomerEnableRequest copyWith(
      {String? clientId, String? secret, String? endCustomerClientId}) {
    return PartnerCustomerEnableRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        endCustomerClientId: endCustomerClientId ?? this.endCustomerClientId);
  }

  PartnerCustomerEnableRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? endCustomerClientId}) {
    return PartnerCustomerEnableRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        endCustomerClientId: (endCustomerClientId != null
            ? endCustomerClientId.value
            : this.endCustomerClientId));
  }
}

@JsonSerializable(explicitToJson: true)
class PartnerCustomerEnableResponse {
  PartnerCustomerEnableResponse({
    this.productionSecret,
    this.requestId,
  });

  factory PartnerCustomerEnableResponse.fromJson(Map<String, dynamic> json) =>
      _$PartnerCustomerEnableResponseFromJson(json);

  @JsonKey(name: 'production_secret')
  final String? productionSecret;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$PartnerCustomerEnableResponseFromJson;
  static const toJsonFactory = _$PartnerCustomerEnableResponseToJson;
  Map<String, dynamic> toJson() => _$PartnerCustomerEnableResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PartnerCustomerEnableResponse &&
            (identical(other.productionSecret, productionSecret) ||
                const DeepCollectionEquality()
                    .equals(other.productionSecret, productionSecret)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(productionSecret) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $PartnerCustomerEnableResponseExtension
    on PartnerCustomerEnableResponse {
  PartnerCustomerEnableResponse copyWith(
      {String? productionSecret, String? requestId}) {
    return PartnerCustomerEnableResponse(
        productionSecret: productionSecret ?? this.productionSecret,
        requestId: requestId ?? this.requestId);
  }

  PartnerCustomerEnableResponse copyWithWrapped(
      {Wrapped<String?>? productionSecret, Wrapped<String?>? requestId}) {
    return PartnerCustomerEnableResponse(
        productionSecret: (productionSecret != null
            ? productionSecret.value
            : this.productionSecret),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class PartnerCustomerRemoveRequest {
  PartnerCustomerRemoveRequest({
    this.clientId,
    this.secret,
    required this.endCustomerClientId,
  });

  factory PartnerCustomerRemoveRequest.fromJson(Map<String, dynamic> json) =>
      _$PartnerCustomerRemoveRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'end_customer_client_id')
  final String endCustomerClientId;
  static const fromJsonFactory = _$PartnerCustomerRemoveRequestFromJson;
  static const toJsonFactory = _$PartnerCustomerRemoveRequestToJson;
  Map<String, dynamic> toJson() => _$PartnerCustomerRemoveRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PartnerCustomerRemoveRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.endCustomerClientId, endCustomerClientId) ||
                const DeepCollectionEquality()
                    .equals(other.endCustomerClientId, endCustomerClientId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(endCustomerClientId) ^
      runtimeType.hashCode;
}

extension $PartnerCustomerRemoveRequestExtension
    on PartnerCustomerRemoveRequest {
  PartnerCustomerRemoveRequest copyWith(
      {String? clientId, String? secret, String? endCustomerClientId}) {
    return PartnerCustomerRemoveRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        endCustomerClientId: endCustomerClientId ?? this.endCustomerClientId);
  }

  PartnerCustomerRemoveRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? endCustomerClientId}) {
    return PartnerCustomerRemoveRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        endCustomerClientId: (endCustomerClientId != null
            ? endCustomerClientId.value
            : this.endCustomerClientId));
  }
}

@JsonSerializable(explicitToJson: true)
class PartnerCustomerRemoveResponse {
  PartnerCustomerRemoveResponse({
    this.requestId,
  });

  factory PartnerCustomerRemoveResponse.fromJson(Map<String, dynamic> json) =>
      _$PartnerCustomerRemoveResponseFromJson(json);

  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$PartnerCustomerRemoveResponseFromJson;
  static const toJsonFactory = _$PartnerCustomerRemoveResponseToJson;
  Map<String, dynamic> toJson() => _$PartnerCustomerRemoveResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PartnerCustomerRemoveResponse &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(requestId) ^ runtimeType.hashCode;
}

extension $PartnerCustomerRemoveResponseExtension
    on PartnerCustomerRemoveResponse {
  PartnerCustomerRemoveResponse copyWith({String? requestId}) {
    return PartnerCustomerRemoveResponse(
        requestId: requestId ?? this.requestId);
  }

  PartnerCustomerRemoveResponse copyWithWrapped({Wrapped<String?>? requestId}) {
    return PartnerCustomerRemoveResponse(
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class PartnerEndCustomer {
  PartnerEndCustomer({
    this.clientId,
    this.companyName,
    this.status,
  });

  factory PartnerEndCustomer.fromJson(Map<String, dynamic> json) =>
      _$PartnerEndCustomerFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'company_name')
  final String? companyName;
  @JsonKey(
    name: 'status',
    toJson: partnerEndCustomerStatusToJson,
    fromJson: partnerEndCustomerStatusFromJson,
  )
  final enums.PartnerEndCustomerStatus? status;
  static const fromJsonFactory = _$PartnerEndCustomerFromJson;
  static const toJsonFactory = _$PartnerEndCustomerToJson;
  Map<String, dynamic> toJson() => _$PartnerEndCustomerToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PartnerEndCustomer &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.companyName, companyName) ||
                const DeepCollectionEquality()
                    .equals(other.companyName, companyName)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(companyName) ^
      const DeepCollectionEquality().hash(status) ^
      runtimeType.hashCode;
}

extension $PartnerEndCustomerExtension on PartnerEndCustomer {
  PartnerEndCustomer copyWith(
      {String? clientId,
      String? companyName,
      enums.PartnerEndCustomerStatus? status}) {
    return PartnerEndCustomer(
        clientId: clientId ?? this.clientId,
        companyName: companyName ?? this.companyName,
        status: status ?? this.status);
  }

  PartnerEndCustomer copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? companyName,
      Wrapped<enums.PartnerEndCustomerStatus?>? status}) {
    return PartnerEndCustomer(
        clientId: (clientId != null ? clientId.value : this.clientId),
        companyName:
            (companyName != null ? companyName.value : this.companyName),
        status: (status != null ? status.value : this.status));
  }
}

@JsonSerializable(explicitToJson: true)
class PartnerEndCustomerWithSecrets {
  PartnerEndCustomerWithSecrets({
    this.secrets,
    this.clientId,
    this.companyName,
    this.status,
  });

  factory PartnerEndCustomerWithSecrets.fromJson(Map<String, dynamic> json) =>
      _$PartnerEndCustomerWithSecretsFromJson(json);

  @JsonKey(name: 'secrets')
  final PartnerEndCustomerSecrets? secrets;
  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'company_name')
  final String? companyName;
  @JsonKey(
    name: 'status',
    toJson: partnerEndCustomerStatusToJson,
    fromJson: partnerEndCustomerStatusFromJson,
  )
  final enums.PartnerEndCustomerStatus? status;
  static const fromJsonFactory = _$PartnerEndCustomerWithSecretsFromJson;
  static const toJsonFactory = _$PartnerEndCustomerWithSecretsToJson;
  Map<String, dynamic> toJson() => _$PartnerEndCustomerWithSecretsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PartnerEndCustomerWithSecrets &&
            (identical(other.secrets, secrets) ||
                const DeepCollectionEquality()
                    .equals(other.secrets, secrets)) &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.companyName, companyName) ||
                const DeepCollectionEquality()
                    .equals(other.companyName, companyName)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(secrets) ^
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(companyName) ^
      const DeepCollectionEquality().hash(status) ^
      runtimeType.hashCode;
}

extension $PartnerEndCustomerWithSecretsExtension
    on PartnerEndCustomerWithSecrets {
  PartnerEndCustomerWithSecrets copyWith(
      {PartnerEndCustomerSecrets? secrets,
      String? clientId,
      String? companyName,
      enums.PartnerEndCustomerStatus? status}) {
    return PartnerEndCustomerWithSecrets(
        secrets: secrets ?? this.secrets,
        clientId: clientId ?? this.clientId,
        companyName: companyName ?? this.companyName,
        status: status ?? this.status);
  }

  PartnerEndCustomerWithSecrets copyWithWrapped(
      {Wrapped<PartnerEndCustomerSecrets?>? secrets,
      Wrapped<String?>? clientId,
      Wrapped<String?>? companyName,
      Wrapped<enums.PartnerEndCustomerStatus?>? status}) {
    return PartnerEndCustomerWithSecrets(
        secrets: (secrets != null ? secrets.value : this.secrets),
        clientId: (clientId != null ? clientId.value : this.clientId),
        companyName:
            (companyName != null ? companyName.value : this.companyName),
        status: (status != null ? status.value : this.status));
  }
}

@JsonSerializable(explicitToJson: true)
class PartnerEndCustomerSecrets {
  PartnerEndCustomerSecrets({
    this.sandbox,
    this.development,
  });

  factory PartnerEndCustomerSecrets.fromJson(Map<String, dynamic> json) =>
      _$PartnerEndCustomerSecretsFromJson(json);

  @JsonKey(name: 'sandbox')
  final String? sandbox;
  @JsonKey(name: 'development')
  final String? development;
  static const fromJsonFactory = _$PartnerEndCustomerSecretsFromJson;
  static const toJsonFactory = _$PartnerEndCustomerSecretsToJson;
  Map<String, dynamic> toJson() => _$PartnerEndCustomerSecretsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PartnerEndCustomerSecrets &&
            (identical(other.sandbox, sandbox) ||
                const DeepCollectionEquality()
                    .equals(other.sandbox, sandbox)) &&
            (identical(other.development, development) ||
                const DeepCollectionEquality()
                    .equals(other.development, development)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(sandbox) ^
      const DeepCollectionEquality().hash(development) ^
      runtimeType.hashCode;
}

extension $PartnerEndCustomerSecretsExtension on PartnerEndCustomerSecrets {
  PartnerEndCustomerSecrets copyWith({String? sandbox, String? development}) {
    return PartnerEndCustomerSecrets(
        sandbox: sandbox ?? this.sandbox,
        development: development ?? this.development);
  }

  PartnerEndCustomerSecrets copyWithWrapped(
      {Wrapped<String?>? sandbox, Wrapped<String?>? development}) {
    return PartnerEndCustomerSecrets(
        sandbox: (sandbox != null ? sandbox.value : this.sandbox),
        development:
            (development != null ? development.value : this.development));
  }
}

@JsonSerializable(explicitToJson: true)
class PartnerEndCustomerTechnicalContact {
  PartnerEndCustomerTechnicalContact({
    this.givenName,
    this.familyName,
    this.email,
  });

  factory PartnerEndCustomerTechnicalContact.fromJson(
          Map<String, dynamic> json) =>
      _$PartnerEndCustomerTechnicalContactFromJson(json);

  @JsonKey(name: 'given_name')
  final String? givenName;
  @JsonKey(name: 'family_name')
  final String? familyName;
  @JsonKey(name: 'email')
  final String? email;
  static const fromJsonFactory = _$PartnerEndCustomerTechnicalContactFromJson;
  static const toJsonFactory = _$PartnerEndCustomerTechnicalContactToJson;
  Map<String, dynamic> toJson() =>
      _$PartnerEndCustomerTechnicalContactToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PartnerEndCustomerTechnicalContact &&
            (identical(other.givenName, givenName) ||
                const DeepCollectionEquality()
                    .equals(other.givenName, givenName)) &&
            (identical(other.familyName, familyName) ||
                const DeepCollectionEquality()
                    .equals(other.familyName, familyName)) &&
            (identical(other.email, email) ||
                const DeepCollectionEquality().equals(other.email, email)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(givenName) ^
      const DeepCollectionEquality().hash(familyName) ^
      const DeepCollectionEquality().hash(email) ^
      runtimeType.hashCode;
}

extension $PartnerEndCustomerTechnicalContactExtension
    on PartnerEndCustomerTechnicalContact {
  PartnerEndCustomerTechnicalContact copyWith(
      {String? givenName, String? familyName, String? email}) {
    return PartnerEndCustomerTechnicalContact(
        givenName: givenName ?? this.givenName,
        familyName: familyName ?? this.familyName,
        email: email ?? this.email);
  }

  PartnerEndCustomerTechnicalContact copyWithWrapped(
      {Wrapped<String?>? givenName,
      Wrapped<String?>? familyName,
      Wrapped<String?>? email}) {
    return PartnerEndCustomerTechnicalContact(
        givenName: (givenName != null ? givenName.value : this.givenName),
        familyName: (familyName != null ? familyName.value : this.familyName),
        email: (email != null ? email.value : this.email));
  }
}

@JsonSerializable(explicitToJson: true)
class PartnerEndCustomerAssetsUnderManagement {
  PartnerEndCustomerAssetsUnderManagement({
    required this.amount,
    required this.isoCurrencyCode,
  });

  factory PartnerEndCustomerAssetsUnderManagement.fromJson(
          Map<String, dynamic> json) =>
      _$PartnerEndCustomerAssetsUnderManagementFromJson(json);

  @JsonKey(name: 'amount')
  final double amount;
  @JsonKey(name: 'iso_currency_code')
  final String isoCurrencyCode;
  static const fromJsonFactory =
      _$PartnerEndCustomerAssetsUnderManagementFromJson;
  static const toJsonFactory = _$PartnerEndCustomerAssetsUnderManagementToJson;
  Map<String, dynamic> toJson() =>
      _$PartnerEndCustomerAssetsUnderManagementToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PartnerEndCustomerAssetsUnderManagement &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      runtimeType.hashCode;
}

extension $PartnerEndCustomerAssetsUnderManagementExtension
    on PartnerEndCustomerAssetsUnderManagement {
  PartnerEndCustomerAssetsUnderManagement copyWith(
      {double? amount, String? isoCurrencyCode}) {
    return PartnerEndCustomerAssetsUnderManagement(
        amount: amount ?? this.amount,
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode);
  }

  PartnerEndCustomerAssetsUnderManagement copyWithWrapped(
      {Wrapped<double>? amount, Wrapped<String>? isoCurrencyCode}) {
    return PartnerEndCustomerAssetsUnderManagement(
        amount: (amount != null ? amount.value : this.amount),
        isoCurrencyCode: (isoCurrencyCode != null
            ? isoCurrencyCode.value
            : this.isoCurrencyCode));
  }
}

@JsonSerializable(explicitToJson: true)
class PartnerEndCustomerBillingContact {
  PartnerEndCustomerBillingContact({
    this.givenName,
    this.familyName,
    this.email,
  });

  factory PartnerEndCustomerBillingContact.fromJson(
          Map<String, dynamic> json) =>
      _$PartnerEndCustomerBillingContactFromJson(json);

  @JsonKey(name: 'given_name')
  final String? givenName;
  @JsonKey(name: 'family_name')
  final String? familyName;
  @JsonKey(name: 'email')
  final String? email;
  static const fromJsonFactory = _$PartnerEndCustomerBillingContactFromJson;
  static const toJsonFactory = _$PartnerEndCustomerBillingContactToJson;
  Map<String, dynamic> toJson() =>
      _$PartnerEndCustomerBillingContactToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PartnerEndCustomerBillingContact &&
            (identical(other.givenName, givenName) ||
                const DeepCollectionEquality()
                    .equals(other.givenName, givenName)) &&
            (identical(other.familyName, familyName) ||
                const DeepCollectionEquality()
                    .equals(other.familyName, familyName)) &&
            (identical(other.email, email) ||
                const DeepCollectionEquality().equals(other.email, email)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(givenName) ^
      const DeepCollectionEquality().hash(familyName) ^
      const DeepCollectionEquality().hash(email) ^
      runtimeType.hashCode;
}

extension $PartnerEndCustomerBillingContactExtension
    on PartnerEndCustomerBillingContact {
  PartnerEndCustomerBillingContact copyWith(
      {String? givenName, String? familyName, String? email}) {
    return PartnerEndCustomerBillingContact(
        givenName: givenName ?? this.givenName,
        familyName: familyName ?? this.familyName,
        email: email ?? this.email);
  }

  PartnerEndCustomerBillingContact copyWithWrapped(
      {Wrapped<String?>? givenName,
      Wrapped<String?>? familyName,
      Wrapped<String?>? email}) {
    return PartnerEndCustomerBillingContact(
        givenName: (givenName != null ? givenName.value : this.givenName),
        familyName: (familyName != null ? familyName.value : this.familyName),
        email: (email != null ? email.value : this.email));
  }
}

@JsonSerializable(explicitToJson: true)
class PartnerEndCustomerAddress {
  PartnerEndCustomerAddress({
    this.city,
    this.street,
    this.region,
    this.postalCode,
    this.countryCode,
  });

  factory PartnerEndCustomerAddress.fromJson(Map<String, dynamic> json) =>
      _$PartnerEndCustomerAddressFromJson(json);

  @JsonKey(name: 'city')
  final String? city;
  @JsonKey(name: 'street')
  final String? street;
  @JsonKey(name: 'region')
  final String? region;
  @JsonKey(name: 'postal_code')
  final String? postalCode;
  @JsonKey(name: 'country_code')
  final String? countryCode;
  static const fromJsonFactory = _$PartnerEndCustomerAddressFromJson;
  static const toJsonFactory = _$PartnerEndCustomerAddressToJson;
  Map<String, dynamic> toJson() => _$PartnerEndCustomerAddressToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PartnerEndCustomerAddress &&
            (identical(other.city, city) ||
                const DeepCollectionEquality().equals(other.city, city)) &&
            (identical(other.street, street) ||
                const DeepCollectionEquality().equals(other.street, street)) &&
            (identical(other.region, region) ||
                const DeepCollectionEquality().equals(other.region, region)) &&
            (identical(other.postalCode, postalCode) ||
                const DeepCollectionEquality()
                    .equals(other.postalCode, postalCode)) &&
            (identical(other.countryCode, countryCode) ||
                const DeepCollectionEquality()
                    .equals(other.countryCode, countryCode)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(city) ^
      const DeepCollectionEquality().hash(street) ^
      const DeepCollectionEquality().hash(region) ^
      const DeepCollectionEquality().hash(postalCode) ^
      const DeepCollectionEquality().hash(countryCode) ^
      runtimeType.hashCode;
}

extension $PartnerEndCustomerAddressExtension on PartnerEndCustomerAddress {
  PartnerEndCustomerAddress copyWith(
      {String? city,
      String? street,
      String? region,
      String? postalCode,
      String? countryCode}) {
    return PartnerEndCustomerAddress(
        city: city ?? this.city,
        street: street ?? this.street,
        region: region ?? this.region,
        postalCode: postalCode ?? this.postalCode,
        countryCode: countryCode ?? this.countryCode);
  }

  PartnerEndCustomerAddress copyWithWrapped(
      {Wrapped<String?>? city,
      Wrapped<String?>? street,
      Wrapped<String?>? region,
      Wrapped<String?>? postalCode,
      Wrapped<String?>? countryCode}) {
    return PartnerEndCustomerAddress(
        city: (city != null ? city.value : this.city),
        street: (street != null ? street.value : this.street),
        region: (region != null ? region.value : this.region),
        postalCode: (postalCode != null ? postalCode.value : this.postalCode),
        countryCode:
            (countryCode != null ? countryCode.value : this.countryCode));
  }
}

@JsonSerializable(explicitToJson: true)
class LinkDeliveryCreateRequest {
  LinkDeliveryCreateRequest({
    this.clientId,
    this.secret,
    required this.linkToken,
    required this.deliveryMethod,
    required this.deliveryDestination,
  });

  factory LinkDeliveryCreateRequest.fromJson(Map<String, dynamic> json) =>
      _$LinkDeliveryCreateRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'link_token')
  final String linkToken;
  @JsonKey(
    name: 'delivery_method',
    toJson: linkDeliveryDeliveryMethodToJson,
    fromJson: linkDeliveryDeliveryMethodFromJson,
  )
  final enums.LinkDeliveryDeliveryMethod deliveryMethod;
  @JsonKey(name: 'delivery_destination')
  final String deliveryDestination;
  static const fromJsonFactory = _$LinkDeliveryCreateRequestFromJson;
  static const toJsonFactory = _$LinkDeliveryCreateRequestToJson;
  Map<String, dynamic> toJson() => _$LinkDeliveryCreateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LinkDeliveryCreateRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.linkToken, linkToken) ||
                const DeepCollectionEquality()
                    .equals(other.linkToken, linkToken)) &&
            (identical(other.deliveryMethod, deliveryMethod) ||
                const DeepCollectionEquality()
                    .equals(other.deliveryMethod, deliveryMethod)) &&
            (identical(other.deliveryDestination, deliveryDestination) ||
                const DeepCollectionEquality()
                    .equals(other.deliveryDestination, deliveryDestination)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(linkToken) ^
      const DeepCollectionEquality().hash(deliveryMethod) ^
      const DeepCollectionEquality().hash(deliveryDestination) ^
      runtimeType.hashCode;
}

extension $LinkDeliveryCreateRequestExtension on LinkDeliveryCreateRequest {
  LinkDeliveryCreateRequest copyWith(
      {String? clientId,
      String? secret,
      String? linkToken,
      enums.LinkDeliveryDeliveryMethod? deliveryMethod,
      String? deliveryDestination}) {
    return LinkDeliveryCreateRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        linkToken: linkToken ?? this.linkToken,
        deliveryMethod: deliveryMethod ?? this.deliveryMethod,
        deliveryDestination: deliveryDestination ?? this.deliveryDestination);
  }

  LinkDeliveryCreateRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? linkToken,
      Wrapped<enums.LinkDeliveryDeliveryMethod>? deliveryMethod,
      Wrapped<String>? deliveryDestination}) {
    return LinkDeliveryCreateRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        linkToken: (linkToken != null ? linkToken.value : this.linkToken),
        deliveryMethod: (deliveryMethod != null
            ? deliveryMethod.value
            : this.deliveryMethod),
        deliveryDestination: (deliveryDestination != null
            ? deliveryDestination.value
            : this.deliveryDestination));
  }
}

@JsonSerializable(explicitToJson: true)
class LinkDeliveryCreateResponse {
  LinkDeliveryCreateResponse({
    required this.linkDeliveryUrl,
    required this.linkDeliverySessionId,
    required this.requestId,
  });

  factory LinkDeliveryCreateResponse.fromJson(Map<String, dynamic> json) =>
      _$LinkDeliveryCreateResponseFromJson(json);

  @JsonKey(name: 'link_delivery_url')
  final String linkDeliveryUrl;
  @JsonKey(name: 'link_delivery_session_id')
  final String linkDeliverySessionId;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$LinkDeliveryCreateResponseFromJson;
  static const toJsonFactory = _$LinkDeliveryCreateResponseToJson;
  Map<String, dynamic> toJson() => _$LinkDeliveryCreateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LinkDeliveryCreateResponse &&
            (identical(other.linkDeliveryUrl, linkDeliveryUrl) ||
                const DeepCollectionEquality()
                    .equals(other.linkDeliveryUrl, linkDeliveryUrl)) &&
            (identical(other.linkDeliverySessionId, linkDeliverySessionId) ||
                const DeepCollectionEquality().equals(
                    other.linkDeliverySessionId, linkDeliverySessionId)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(linkDeliveryUrl) ^
      const DeepCollectionEquality().hash(linkDeliverySessionId) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $LinkDeliveryCreateResponseExtension on LinkDeliveryCreateResponse {
  LinkDeliveryCreateResponse copyWith(
      {String? linkDeliveryUrl,
      String? linkDeliverySessionId,
      String? requestId}) {
    return LinkDeliveryCreateResponse(
        linkDeliveryUrl: linkDeliveryUrl ?? this.linkDeliveryUrl,
        linkDeliverySessionId:
            linkDeliverySessionId ?? this.linkDeliverySessionId,
        requestId: requestId ?? this.requestId);
  }

  LinkDeliveryCreateResponse copyWithWrapped(
      {Wrapped<String>? linkDeliveryUrl,
      Wrapped<String>? linkDeliverySessionId,
      Wrapped<String>? requestId}) {
    return LinkDeliveryCreateResponse(
        linkDeliveryUrl: (linkDeliveryUrl != null
            ? linkDeliveryUrl.value
            : this.linkDeliveryUrl),
        linkDeliverySessionId: (linkDeliverySessionId != null
            ? linkDeliverySessionId.value
            : this.linkDeliverySessionId),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class LinkDeliveryGetRequest {
  LinkDeliveryGetRequest({
    this.clientId,
    this.secret,
    required this.linkDeliverySessionId,
  });

  factory LinkDeliveryGetRequest.fromJson(Map<String, dynamic> json) =>
      _$LinkDeliveryGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'link_delivery_session_id')
  final String linkDeliverySessionId;
  static const fromJsonFactory = _$LinkDeliveryGetRequestFromJson;
  static const toJsonFactory = _$LinkDeliveryGetRequestToJson;
  Map<String, dynamic> toJson() => _$LinkDeliveryGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LinkDeliveryGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.linkDeliverySessionId, linkDeliverySessionId) ||
                const DeepCollectionEquality().equals(
                    other.linkDeliverySessionId, linkDeliverySessionId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(linkDeliverySessionId) ^
      runtimeType.hashCode;
}

extension $LinkDeliveryGetRequestExtension on LinkDeliveryGetRequest {
  LinkDeliveryGetRequest copyWith(
      {String? clientId, String? secret, String? linkDeliverySessionId}) {
    return LinkDeliveryGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        linkDeliverySessionId:
            linkDeliverySessionId ?? this.linkDeliverySessionId);
  }

  LinkDeliveryGetRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? linkDeliverySessionId}) {
    return LinkDeliveryGetRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        linkDeliverySessionId: (linkDeliverySessionId != null
            ? linkDeliverySessionId.value
            : this.linkDeliverySessionId));
  }
}

@JsonSerializable(explicitToJson: true)
class LinkDeliveryGetResponse {
  LinkDeliveryGetResponse({
    required this.status,
    required this.createdAt,
    this.publicTokens,
    this.completedAt,
    required this.requestId,
  });

  factory LinkDeliveryGetResponse.fromJson(Map<String, dynamic> json) =>
      _$LinkDeliveryGetResponseFromJson(json);

  @JsonKey(
    name: 'status',
    toJson: linkDeliverySessionStatusToJson,
    fromJson: linkDeliverySessionStatusFromJson,
  )
  final enums.LinkDeliverySessionStatus status;
  @JsonKey(name: 'created_at')
  final DateTime createdAt;
  @JsonKey(name: 'public_tokens', defaultValue: <String>[])
  final List<String>? publicTokens;
  @JsonKey(name: 'completed_at')
  final DateTime? completedAt;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$LinkDeliveryGetResponseFromJson;
  static const toJsonFactory = _$LinkDeliveryGetResponseToJson;
  Map<String, dynamic> toJson() => _$LinkDeliveryGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LinkDeliveryGetResponse &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.createdAt, createdAt) ||
                const DeepCollectionEquality()
                    .equals(other.createdAt, createdAt)) &&
            (identical(other.publicTokens, publicTokens) ||
                const DeepCollectionEquality()
                    .equals(other.publicTokens, publicTokens)) &&
            (identical(other.completedAt, completedAt) ||
                const DeepCollectionEquality()
                    .equals(other.completedAt, completedAt)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(createdAt) ^
      const DeepCollectionEquality().hash(publicTokens) ^
      const DeepCollectionEquality().hash(completedAt) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $LinkDeliveryGetResponseExtension on LinkDeliveryGetResponse {
  LinkDeliveryGetResponse copyWith(
      {enums.LinkDeliverySessionStatus? status,
      DateTime? createdAt,
      List<String>? publicTokens,
      DateTime? completedAt,
      String? requestId}) {
    return LinkDeliveryGetResponse(
        status: status ?? this.status,
        createdAt: createdAt ?? this.createdAt,
        publicTokens: publicTokens ?? this.publicTokens,
        completedAt: completedAt ?? this.completedAt,
        requestId: requestId ?? this.requestId);
  }

  LinkDeliveryGetResponse copyWithWrapped(
      {Wrapped<enums.LinkDeliverySessionStatus>? status,
      Wrapped<DateTime>? createdAt,
      Wrapped<List<String>?>? publicTokens,
      Wrapped<DateTime?>? completedAt,
      Wrapped<String>? requestId}) {
    return LinkDeliveryGetResponse(
        status: (status != null ? status.value : this.status),
        createdAt: (createdAt != null ? createdAt.value : this.createdAt),
        publicTokens:
            (publicTokens != null ? publicTokens.value : this.publicTokens),
        completedAt:
            (completedAt != null ? completedAt.value : this.completedAt),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class CreditCategory {
  CreditCategory({
    required this.primary,
    required this.detailed,
  });

  factory CreditCategory.fromJson(Map<String, dynamic> json) =>
      _$CreditCategoryFromJson(json);

  @JsonKey(name: 'primary')
  final String primary;
  @JsonKey(name: 'detailed')
  final String detailed;
  static const fromJsonFactory = _$CreditCategoryFromJson;
  static const toJsonFactory = _$CreditCategoryToJson;
  Map<String, dynamic> toJson() => _$CreditCategoryToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CreditCategory &&
            (identical(other.primary, primary) ||
                const DeepCollectionEquality()
                    .equals(other.primary, primary)) &&
            (identical(other.detailed, detailed) ||
                const DeepCollectionEquality()
                    .equals(other.detailed, detailed)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(primary) ^
      const DeepCollectionEquality().hash(detailed) ^
      runtimeType.hashCode;
}

extension $CreditCategoryExtension on CreditCategory {
  CreditCategory copyWith({String? primary, String? detailed}) {
    return CreditCategory(
        primary: primary ?? this.primary, detailed: detailed ?? this.detailed);
  }

  CreditCategory copyWithWrapped(
      {Wrapped<String>? primary, Wrapped<String>? detailed}) {
    return CreditCategory(
        primary: (primary != null ? primary.value : this.primary),
        detailed: (detailed != null ? detailed.value : this.detailed));
  }
}

@JsonSerializable(explicitToJson: true)
class AssetReportCreateRequest {
  AssetReportCreateRequest({
    this.clientId,
    this.secret,
    required this.accessTokens,
    required this.daysRequested,
    this.options,
  });

  factory AssetReportCreateRequest.fromJson(Map<String, dynamic> json) =>
      _$AssetReportCreateRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'access_tokens', defaultValue: <String>[])
  final List<String> accessTokens;
  @JsonKey(name: 'days_requested')
  final int daysRequested;
  @JsonKey(name: 'options')
  final AssetReportCreateRequestOptions? options;
  static const fromJsonFactory = _$AssetReportCreateRequestFromJson;
  static const toJsonFactory = _$AssetReportCreateRequestToJson;
  Map<String, dynamic> toJson() => _$AssetReportCreateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AssetReportCreateRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.accessTokens, accessTokens) ||
                const DeepCollectionEquality()
                    .equals(other.accessTokens, accessTokens)) &&
            (identical(other.daysRequested, daysRequested) ||
                const DeepCollectionEquality()
                    .equals(other.daysRequested, daysRequested)) &&
            (identical(other.options, options) ||
                const DeepCollectionEquality().equals(other.options, options)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(accessTokens) ^
      const DeepCollectionEquality().hash(daysRequested) ^
      const DeepCollectionEquality().hash(options) ^
      runtimeType.hashCode;
}

extension $AssetReportCreateRequestExtension on AssetReportCreateRequest {
  AssetReportCreateRequest copyWith(
      {String? clientId,
      String? secret,
      List<String>? accessTokens,
      int? daysRequested,
      AssetReportCreateRequestOptions? options}) {
    return AssetReportCreateRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        accessTokens: accessTokens ?? this.accessTokens,
        daysRequested: daysRequested ?? this.daysRequested,
        options: options ?? this.options);
  }

  AssetReportCreateRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<List<String>>? accessTokens,
      Wrapped<int>? daysRequested,
      Wrapped<AssetReportCreateRequestOptions?>? options}) {
    return AssetReportCreateRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        accessTokens:
            (accessTokens != null ? accessTokens.value : this.accessTokens),
        daysRequested:
            (daysRequested != null ? daysRequested.value : this.daysRequested),
        options: (options != null ? options.value : this.options));
  }
}

@JsonSerializable(explicitToJson: true)
class AssetReportCreateRequestOptions {
  AssetReportCreateRequestOptions({
    this.clientReportId,
    this.webhook,
    this.includeFastReport,
    this.products,
    this.user,
  });

  factory AssetReportCreateRequestOptions.fromJson(Map<String, dynamic> json) =>
      _$AssetReportCreateRequestOptionsFromJson(json);

  @JsonKey(name: 'client_report_id')
  final String? clientReportId;
  @JsonKey(name: 'webhook')
  final String? webhook;
  @JsonKey(name: 'include_fast_report')
  final bool? includeFastReport;
  @JsonKey(name: 'products', defaultValue: <String>[])
  final List<String>? products;
  @JsonKey(name: 'user')
  final AssetReportUser? user;
  static const fromJsonFactory = _$AssetReportCreateRequestOptionsFromJson;
  static const toJsonFactory = _$AssetReportCreateRequestOptionsToJson;
  Map<String, dynamic> toJson() =>
      _$AssetReportCreateRequestOptionsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AssetReportCreateRequestOptions &&
            (identical(other.clientReportId, clientReportId) ||
                const DeepCollectionEquality()
                    .equals(other.clientReportId, clientReportId)) &&
            (identical(other.webhook, webhook) ||
                const DeepCollectionEquality()
                    .equals(other.webhook, webhook)) &&
            (identical(other.includeFastReport, includeFastReport) ||
                const DeepCollectionEquality()
                    .equals(other.includeFastReport, includeFastReport)) &&
            (identical(other.products, products) ||
                const DeepCollectionEquality()
                    .equals(other.products, products)) &&
            (identical(other.user, user) ||
                const DeepCollectionEquality().equals(other.user, user)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientReportId) ^
      const DeepCollectionEquality().hash(webhook) ^
      const DeepCollectionEquality().hash(includeFastReport) ^
      const DeepCollectionEquality().hash(products) ^
      const DeepCollectionEquality().hash(user) ^
      runtimeType.hashCode;
}

extension $AssetReportCreateRequestOptionsExtension
    on AssetReportCreateRequestOptions {
  AssetReportCreateRequestOptions copyWith(
      {String? clientReportId,
      String? webhook,
      bool? includeFastReport,
      List<String>? products,
      AssetReportUser? user}) {
    return AssetReportCreateRequestOptions(
        clientReportId: clientReportId ?? this.clientReportId,
        webhook: webhook ?? this.webhook,
        includeFastReport: includeFastReport ?? this.includeFastReport,
        products: products ?? this.products,
        user: user ?? this.user);
  }

  AssetReportCreateRequestOptions copyWithWrapped(
      {Wrapped<String?>? clientReportId,
      Wrapped<String?>? webhook,
      Wrapped<bool?>? includeFastReport,
      Wrapped<List<String>?>? products,
      Wrapped<AssetReportUser?>? user}) {
    return AssetReportCreateRequestOptions(
        clientReportId: (clientReportId != null
            ? clientReportId.value
            : this.clientReportId),
        webhook: (webhook != null ? webhook.value : this.webhook),
        includeFastReport: (includeFastReport != null
            ? includeFastReport.value
            : this.includeFastReport),
        products: (products != null ? products.value : this.products),
        user: (user != null ? user.value : this.user));
  }
}

@JsonSerializable(explicitToJson: true)
class AssetReportCreateResponse {
  AssetReportCreateResponse({
    required this.assetReportToken,
    required this.assetReportId,
    required this.requestId,
  });

  factory AssetReportCreateResponse.fromJson(Map<String, dynamic> json) =>
      _$AssetReportCreateResponseFromJson(json);

  @JsonKey(name: 'asset_report_token')
  final String assetReportToken;
  @JsonKey(name: 'asset_report_id')
  final String assetReportId;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$AssetReportCreateResponseFromJson;
  static const toJsonFactory = _$AssetReportCreateResponseToJson;
  Map<String, dynamic> toJson() => _$AssetReportCreateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AssetReportCreateResponse &&
            (identical(other.assetReportToken, assetReportToken) ||
                const DeepCollectionEquality()
                    .equals(other.assetReportToken, assetReportToken)) &&
            (identical(other.assetReportId, assetReportId) ||
                const DeepCollectionEquality()
                    .equals(other.assetReportId, assetReportId)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(assetReportToken) ^
      const DeepCollectionEquality().hash(assetReportId) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $AssetReportCreateResponseExtension on AssetReportCreateResponse {
  AssetReportCreateResponse copyWith(
      {String? assetReportToken, String? assetReportId, String? requestId}) {
    return AssetReportCreateResponse(
        assetReportToken: assetReportToken ?? this.assetReportToken,
        assetReportId: assetReportId ?? this.assetReportId,
        requestId: requestId ?? this.requestId);
  }

  AssetReportCreateResponse copyWithWrapped(
      {Wrapped<String>? assetReportToken,
      Wrapped<String>? assetReportId,
      Wrapped<String>? requestId}) {
    return AssetReportCreateResponse(
        assetReportToken: (assetReportToken != null
            ? assetReportToken.value
            : this.assetReportToken),
        assetReportId:
            (assetReportId != null ? assetReportId.value : this.assetReportId),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class AssetReportRefreshRequest {
  AssetReportRefreshRequest({
    this.clientId,
    this.secret,
    required this.assetReportToken,
    this.daysRequested,
    this.options,
  });

  factory AssetReportRefreshRequest.fromJson(Map<String, dynamic> json) =>
      _$AssetReportRefreshRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'asset_report_token')
  final String assetReportToken;
  @JsonKey(name: 'days_requested')
  final int? daysRequested;
  @JsonKey(name: 'options')
  final AssetReportRefreshRequestOptions? options;
  static const fromJsonFactory = _$AssetReportRefreshRequestFromJson;
  static const toJsonFactory = _$AssetReportRefreshRequestToJson;
  Map<String, dynamic> toJson() => _$AssetReportRefreshRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AssetReportRefreshRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.assetReportToken, assetReportToken) ||
                const DeepCollectionEquality()
                    .equals(other.assetReportToken, assetReportToken)) &&
            (identical(other.daysRequested, daysRequested) ||
                const DeepCollectionEquality()
                    .equals(other.daysRequested, daysRequested)) &&
            (identical(other.options, options) ||
                const DeepCollectionEquality().equals(other.options, options)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(assetReportToken) ^
      const DeepCollectionEquality().hash(daysRequested) ^
      const DeepCollectionEquality().hash(options) ^
      runtimeType.hashCode;
}

extension $AssetReportRefreshRequestExtension on AssetReportRefreshRequest {
  AssetReportRefreshRequest copyWith(
      {String? clientId,
      String? secret,
      String? assetReportToken,
      int? daysRequested,
      AssetReportRefreshRequestOptions? options}) {
    return AssetReportRefreshRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        assetReportToken: assetReportToken ?? this.assetReportToken,
        daysRequested: daysRequested ?? this.daysRequested,
        options: options ?? this.options);
  }

  AssetReportRefreshRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? assetReportToken,
      Wrapped<int?>? daysRequested,
      Wrapped<AssetReportRefreshRequestOptions?>? options}) {
    return AssetReportRefreshRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        assetReportToken: (assetReportToken != null
            ? assetReportToken.value
            : this.assetReportToken),
        daysRequested:
            (daysRequested != null ? daysRequested.value : this.daysRequested),
        options: (options != null ? options.value : this.options));
  }
}

@JsonSerializable(explicitToJson: true)
class AssetReportRefreshRequestOptions {
  AssetReportRefreshRequestOptions({
    this.clientReportId,
    this.webhook,
    this.user,
  });

  factory AssetReportRefreshRequestOptions.fromJson(
          Map<String, dynamic> json) =>
      _$AssetReportRefreshRequestOptionsFromJson(json);

  @JsonKey(name: 'client_report_id')
  final String? clientReportId;
  @JsonKey(name: 'webhook')
  final String? webhook;
  @JsonKey(name: 'user')
  final AssetReportUser? user;
  static const fromJsonFactory = _$AssetReportRefreshRequestOptionsFromJson;
  static const toJsonFactory = _$AssetReportRefreshRequestOptionsToJson;
  Map<String, dynamic> toJson() =>
      _$AssetReportRefreshRequestOptionsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AssetReportRefreshRequestOptions &&
            (identical(other.clientReportId, clientReportId) ||
                const DeepCollectionEquality()
                    .equals(other.clientReportId, clientReportId)) &&
            (identical(other.webhook, webhook) ||
                const DeepCollectionEquality()
                    .equals(other.webhook, webhook)) &&
            (identical(other.user, user) ||
                const DeepCollectionEquality().equals(other.user, user)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientReportId) ^
      const DeepCollectionEquality().hash(webhook) ^
      const DeepCollectionEquality().hash(user) ^
      runtimeType.hashCode;
}

extension $AssetReportRefreshRequestOptionsExtension
    on AssetReportRefreshRequestOptions {
  AssetReportRefreshRequestOptions copyWith(
      {String? clientReportId, String? webhook, AssetReportUser? user}) {
    return AssetReportRefreshRequestOptions(
        clientReportId: clientReportId ?? this.clientReportId,
        webhook: webhook ?? this.webhook,
        user: user ?? this.user);
  }

  AssetReportRefreshRequestOptions copyWithWrapped(
      {Wrapped<String?>? clientReportId,
      Wrapped<String?>? webhook,
      Wrapped<AssetReportUser?>? user}) {
    return AssetReportRefreshRequestOptions(
        clientReportId: (clientReportId != null
            ? clientReportId.value
            : this.clientReportId),
        webhook: (webhook != null ? webhook.value : this.webhook),
        user: (user != null ? user.value : this.user));
  }
}

@JsonSerializable(explicitToJson: true)
class AssetReportRefreshResponse {
  AssetReportRefreshResponse({
    required this.assetReportId,
    required this.assetReportToken,
    required this.requestId,
  });

  factory AssetReportRefreshResponse.fromJson(Map<String, dynamic> json) =>
      _$AssetReportRefreshResponseFromJson(json);

  @JsonKey(name: 'asset_report_id')
  final String assetReportId;
  @JsonKey(name: 'asset_report_token')
  final String assetReportToken;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$AssetReportRefreshResponseFromJson;
  static const toJsonFactory = _$AssetReportRefreshResponseToJson;
  Map<String, dynamic> toJson() => _$AssetReportRefreshResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AssetReportRefreshResponse &&
            (identical(other.assetReportId, assetReportId) ||
                const DeepCollectionEquality()
                    .equals(other.assetReportId, assetReportId)) &&
            (identical(other.assetReportToken, assetReportToken) ||
                const DeepCollectionEquality()
                    .equals(other.assetReportToken, assetReportToken)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(assetReportId) ^
      const DeepCollectionEquality().hash(assetReportToken) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $AssetReportRefreshResponseExtension on AssetReportRefreshResponse {
  AssetReportRefreshResponse copyWith(
      {String? assetReportId, String? assetReportToken, String? requestId}) {
    return AssetReportRefreshResponse(
        assetReportId: assetReportId ?? this.assetReportId,
        assetReportToken: assetReportToken ?? this.assetReportToken,
        requestId: requestId ?? this.requestId);
  }

  AssetReportRefreshResponse copyWithWrapped(
      {Wrapped<String>? assetReportId,
      Wrapped<String>? assetReportToken,
      Wrapped<String>? requestId}) {
    return AssetReportRefreshResponse(
        assetReportId:
            (assetReportId != null ? assetReportId.value : this.assetReportId),
        assetReportToken: (assetReportToken != null
            ? assetReportToken.value
            : this.assetReportToken),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class AssetReportRemoveRequest {
  AssetReportRemoveRequest({
    this.clientId,
    this.secret,
    required this.assetReportToken,
  });

  factory AssetReportRemoveRequest.fromJson(Map<String, dynamic> json) =>
      _$AssetReportRemoveRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'asset_report_token')
  final String assetReportToken;
  static const fromJsonFactory = _$AssetReportRemoveRequestFromJson;
  static const toJsonFactory = _$AssetReportRemoveRequestToJson;
  Map<String, dynamic> toJson() => _$AssetReportRemoveRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AssetReportRemoveRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.assetReportToken, assetReportToken) ||
                const DeepCollectionEquality()
                    .equals(other.assetReportToken, assetReportToken)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(assetReportToken) ^
      runtimeType.hashCode;
}

extension $AssetReportRemoveRequestExtension on AssetReportRemoveRequest {
  AssetReportRemoveRequest copyWith(
      {String? clientId, String? secret, String? assetReportToken}) {
    return AssetReportRemoveRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        assetReportToken: assetReportToken ?? this.assetReportToken);
  }

  AssetReportRemoveRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? assetReportToken}) {
    return AssetReportRemoveRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        assetReportToken: (assetReportToken != null
            ? assetReportToken.value
            : this.assetReportToken));
  }
}

@JsonSerializable(explicitToJson: true)
class AssetReportRemoveResponse {
  AssetReportRemoveResponse({
    required this.removed,
    required this.requestId,
  });

  factory AssetReportRemoveResponse.fromJson(Map<String, dynamic> json) =>
      _$AssetReportRemoveResponseFromJson(json);

  @JsonKey(name: 'removed')
  final bool removed;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$AssetReportRemoveResponseFromJson;
  static const toJsonFactory = _$AssetReportRemoveResponseToJson;
  Map<String, dynamic> toJson() => _$AssetReportRemoveResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AssetReportRemoveResponse &&
            (identical(other.removed, removed) ||
                const DeepCollectionEquality()
                    .equals(other.removed, removed)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(removed) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $AssetReportRemoveResponseExtension on AssetReportRemoveResponse {
  AssetReportRemoveResponse copyWith({bool? removed, String? requestId}) {
    return AssetReportRemoveResponse(
        removed: removed ?? this.removed,
        requestId: requestId ?? this.requestId);
  }

  AssetReportRemoveResponse copyWithWrapped(
      {Wrapped<bool>? removed, Wrapped<String>? requestId}) {
    return AssetReportRemoveResponse(
        removed: (removed != null ? removed.value : this.removed),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class AssetReportFilterRequest {
  AssetReportFilterRequest({
    this.clientId,
    this.secret,
    required this.assetReportToken,
    required this.accountIdsToExclude,
  });

  factory AssetReportFilterRequest.fromJson(Map<String, dynamic> json) =>
      _$AssetReportFilterRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'asset_report_token')
  final String assetReportToken;
  @JsonKey(name: 'account_ids_to_exclude', defaultValue: <String>[])
  final List<String> accountIdsToExclude;
  static const fromJsonFactory = _$AssetReportFilterRequestFromJson;
  static const toJsonFactory = _$AssetReportFilterRequestToJson;
  Map<String, dynamic> toJson() => _$AssetReportFilterRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AssetReportFilterRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.assetReportToken, assetReportToken) ||
                const DeepCollectionEquality()
                    .equals(other.assetReportToken, assetReportToken)) &&
            (identical(other.accountIdsToExclude, accountIdsToExclude) ||
                const DeepCollectionEquality()
                    .equals(other.accountIdsToExclude, accountIdsToExclude)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(assetReportToken) ^
      const DeepCollectionEquality().hash(accountIdsToExclude) ^
      runtimeType.hashCode;
}

extension $AssetReportFilterRequestExtension on AssetReportFilterRequest {
  AssetReportFilterRequest copyWith(
      {String? clientId,
      String? secret,
      String? assetReportToken,
      List<String>? accountIdsToExclude}) {
    return AssetReportFilterRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        assetReportToken: assetReportToken ?? this.assetReportToken,
        accountIdsToExclude: accountIdsToExclude ?? this.accountIdsToExclude);
  }

  AssetReportFilterRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? assetReportToken,
      Wrapped<List<String>>? accountIdsToExclude}) {
    return AssetReportFilterRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        assetReportToken: (assetReportToken != null
            ? assetReportToken.value
            : this.assetReportToken),
        accountIdsToExclude: (accountIdsToExclude != null
            ? accountIdsToExclude.value
            : this.accountIdsToExclude));
  }
}

@JsonSerializable(explicitToJson: true)
class AssetReportFilterResponse {
  AssetReportFilterResponse({
    required this.assetReportToken,
    required this.assetReportId,
    required this.requestId,
  });

  factory AssetReportFilterResponse.fromJson(Map<String, dynamic> json) =>
      _$AssetReportFilterResponseFromJson(json);

  @JsonKey(name: 'asset_report_token')
  final String assetReportToken;
  @JsonKey(name: 'asset_report_id')
  final String assetReportId;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$AssetReportFilterResponseFromJson;
  static const toJsonFactory = _$AssetReportFilterResponseToJson;
  Map<String, dynamic> toJson() => _$AssetReportFilterResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AssetReportFilterResponse &&
            (identical(other.assetReportToken, assetReportToken) ||
                const DeepCollectionEquality()
                    .equals(other.assetReportToken, assetReportToken)) &&
            (identical(other.assetReportId, assetReportId) ||
                const DeepCollectionEquality()
                    .equals(other.assetReportId, assetReportId)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(assetReportToken) ^
      const DeepCollectionEquality().hash(assetReportId) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $AssetReportFilterResponseExtension on AssetReportFilterResponse {
  AssetReportFilterResponse copyWith(
      {String? assetReportToken, String? assetReportId, String? requestId}) {
    return AssetReportFilterResponse(
        assetReportToken: assetReportToken ?? this.assetReportToken,
        assetReportId: assetReportId ?? this.assetReportId,
        requestId: requestId ?? this.requestId);
  }

  AssetReportFilterResponse copyWithWrapped(
      {Wrapped<String>? assetReportToken,
      Wrapped<String>? assetReportId,
      Wrapped<String>? requestId}) {
    return AssetReportFilterResponse(
        assetReportToken: (assetReportToken != null
            ? assetReportToken.value
            : this.assetReportToken),
        assetReportId:
            (assetReportId != null ? assetReportId.value : this.assetReportId),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class AssetReportGetRequest {
  AssetReportGetRequest({
    this.clientId,
    this.secret,
    required this.assetReportToken,
    this.includeInsights,
    this.fastReport,
    this.options,
  });

  factory AssetReportGetRequest.fromJson(Map<String, dynamic> json) =>
      _$AssetReportGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'asset_report_token')
  final String assetReportToken;
  @JsonKey(name: 'include_insights', defaultValue: false)
  final bool? includeInsights;
  @JsonKey(name: 'fast_report', defaultValue: false)
  final bool? fastReport;
  @JsonKey(name: 'options')
  final AssetReportGetRequestOptions? options;
  static const fromJsonFactory = _$AssetReportGetRequestFromJson;
  static const toJsonFactory = _$AssetReportGetRequestToJson;
  Map<String, dynamic> toJson() => _$AssetReportGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AssetReportGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.assetReportToken, assetReportToken) ||
                const DeepCollectionEquality()
                    .equals(other.assetReportToken, assetReportToken)) &&
            (identical(other.includeInsights, includeInsights) ||
                const DeepCollectionEquality()
                    .equals(other.includeInsights, includeInsights)) &&
            (identical(other.fastReport, fastReport) ||
                const DeepCollectionEquality()
                    .equals(other.fastReport, fastReport)) &&
            (identical(other.options, options) ||
                const DeepCollectionEquality().equals(other.options, options)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(assetReportToken) ^
      const DeepCollectionEquality().hash(includeInsights) ^
      const DeepCollectionEquality().hash(fastReport) ^
      const DeepCollectionEquality().hash(options) ^
      runtimeType.hashCode;
}

extension $AssetReportGetRequestExtension on AssetReportGetRequest {
  AssetReportGetRequest copyWith(
      {String? clientId,
      String? secret,
      String? assetReportToken,
      bool? includeInsights,
      bool? fastReport,
      AssetReportGetRequestOptions? options}) {
    return AssetReportGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        assetReportToken: assetReportToken ?? this.assetReportToken,
        includeInsights: includeInsights ?? this.includeInsights,
        fastReport: fastReport ?? this.fastReport,
        options: options ?? this.options);
  }

  AssetReportGetRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? assetReportToken,
      Wrapped<bool?>? includeInsights,
      Wrapped<bool?>? fastReport,
      Wrapped<AssetReportGetRequestOptions?>? options}) {
    return AssetReportGetRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        assetReportToken: (assetReportToken != null
            ? assetReportToken.value
            : this.assetReportToken),
        includeInsights: (includeInsights != null
            ? includeInsights.value
            : this.includeInsights),
        fastReport: (fastReport != null ? fastReport.value : this.fastReport),
        options: (options != null ? options.value : this.options));
  }
}

@JsonSerializable(explicitToJson: true)
class AssetReportGetRequestOptions {
  AssetReportGetRequestOptions({
    this.daysToInclude,
  });

  factory AssetReportGetRequestOptions.fromJson(Map<String, dynamic> json) =>
      _$AssetReportGetRequestOptionsFromJson(json);

  @JsonKey(name: 'days_to_include')
  final int? daysToInclude;
  static const fromJsonFactory = _$AssetReportGetRequestOptionsFromJson;
  static const toJsonFactory = _$AssetReportGetRequestOptionsToJson;
  Map<String, dynamic> toJson() => _$AssetReportGetRequestOptionsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AssetReportGetRequestOptions &&
            (identical(other.daysToInclude, daysToInclude) ||
                const DeepCollectionEquality()
                    .equals(other.daysToInclude, daysToInclude)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(daysToInclude) ^ runtimeType.hashCode;
}

extension $AssetReportGetRequestOptionsExtension
    on AssetReportGetRequestOptions {
  AssetReportGetRequestOptions copyWith({int? daysToInclude}) {
    return AssetReportGetRequestOptions(
        daysToInclude: daysToInclude ?? this.daysToInclude);
  }

  AssetReportGetRequestOptions copyWithWrapped({Wrapped<int?>? daysToInclude}) {
    return AssetReportGetRequestOptions(
        daysToInclude:
            (daysToInclude != null ? daysToInclude.value : this.daysToInclude));
  }
}

@JsonSerializable(explicitToJson: true)
class AssetReportGetResponse {
  AssetReportGetResponse({
    required this.report,
    required this.warnings,
    required this.requestId,
  });

  factory AssetReportGetResponse.fromJson(Map<String, dynamic> json) =>
      _$AssetReportGetResponseFromJson(json);

  @JsonKey(name: 'report')
  final AssetReport report;
  @JsonKey(name: 'warnings', defaultValue: <Warning>[])
  final List<Warning> warnings;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$AssetReportGetResponseFromJson;
  static const toJsonFactory = _$AssetReportGetResponseToJson;
  Map<String, dynamic> toJson() => _$AssetReportGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AssetReportGetResponse &&
            (identical(other.report, report) ||
                const DeepCollectionEquality().equals(other.report, report)) &&
            (identical(other.warnings, warnings) ||
                const DeepCollectionEquality()
                    .equals(other.warnings, warnings)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(report) ^
      const DeepCollectionEquality().hash(warnings) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $AssetReportGetResponseExtension on AssetReportGetResponse {
  AssetReportGetResponse copyWith(
      {AssetReport? report, List<Warning>? warnings, String? requestId}) {
    return AssetReportGetResponse(
        report: report ?? this.report,
        warnings: warnings ?? this.warnings,
        requestId: requestId ?? this.requestId);
  }

  AssetReportGetResponse copyWithWrapped(
      {Wrapped<AssetReport>? report,
      Wrapped<List<Warning>>? warnings,
      Wrapped<String>? requestId}) {
    return AssetReportGetResponse(
        report: (report != null ? report.value : this.report),
        warnings: (warnings != null ? warnings.value : this.warnings),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class AssetReportPDFGetRequest {
  AssetReportPDFGetRequest({
    this.clientId,
    this.secret,
    required this.assetReportToken,
    this.options,
  });

  factory AssetReportPDFGetRequest.fromJson(Map<String, dynamic> json) =>
      _$AssetReportPDFGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'asset_report_token')
  final String assetReportToken;
  @JsonKey(name: 'options')
  final AssetReportPDFGetRequestOptions? options;
  static const fromJsonFactory = _$AssetReportPDFGetRequestFromJson;
  static const toJsonFactory = _$AssetReportPDFGetRequestToJson;
  Map<String, dynamic> toJson() => _$AssetReportPDFGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AssetReportPDFGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.assetReportToken, assetReportToken) ||
                const DeepCollectionEquality()
                    .equals(other.assetReportToken, assetReportToken)) &&
            (identical(other.options, options) ||
                const DeepCollectionEquality().equals(other.options, options)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(assetReportToken) ^
      const DeepCollectionEquality().hash(options) ^
      runtimeType.hashCode;
}

extension $AssetReportPDFGetRequestExtension on AssetReportPDFGetRequest {
  AssetReportPDFGetRequest copyWith(
      {String? clientId,
      String? secret,
      String? assetReportToken,
      AssetReportPDFGetRequestOptions? options}) {
    return AssetReportPDFGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        assetReportToken: assetReportToken ?? this.assetReportToken,
        options: options ?? this.options);
  }

  AssetReportPDFGetRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? assetReportToken,
      Wrapped<AssetReportPDFGetRequestOptions?>? options}) {
    return AssetReportPDFGetRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        assetReportToken: (assetReportToken != null
            ? assetReportToken.value
            : this.assetReportToken),
        options: (options != null ? options.value : this.options));
  }
}

@JsonSerializable(explicitToJson: true)
class AssetReportPDFGetRequestOptions {
  AssetReportPDFGetRequestOptions({
    this.daysToInclude,
  });

  factory AssetReportPDFGetRequestOptions.fromJson(Map<String, dynamic> json) =>
      _$AssetReportPDFGetRequestOptionsFromJson(json);

  @JsonKey(name: 'days_to_include')
  final int? daysToInclude;
  static const fromJsonFactory = _$AssetReportPDFGetRequestOptionsFromJson;
  static const toJsonFactory = _$AssetReportPDFGetRequestOptionsToJson;
  Map<String, dynamic> toJson() =>
      _$AssetReportPDFGetRequestOptionsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AssetReportPDFGetRequestOptions &&
            (identical(other.daysToInclude, daysToInclude) ||
                const DeepCollectionEquality()
                    .equals(other.daysToInclude, daysToInclude)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(daysToInclude) ^ runtimeType.hashCode;
}

extension $AssetReportPDFGetRequestOptionsExtension
    on AssetReportPDFGetRequestOptions {
  AssetReportPDFGetRequestOptions copyWith({int? daysToInclude}) {
    return AssetReportPDFGetRequestOptions(
        daysToInclude: daysToInclude ?? this.daysToInclude);
  }

  AssetReportPDFGetRequestOptions copyWithWrapped(
      {Wrapped<int?>? daysToInclude}) {
    return AssetReportPDFGetRequestOptions(
        daysToInclude:
            (daysToInclude != null ? daysToInclude.value : this.daysToInclude));
  }
}

@JsonSerializable(explicitToJson: true)
class AssetReportAuditCopyCreateRequest {
  AssetReportAuditCopyCreateRequest({
    this.clientId,
    this.secret,
    required this.assetReportToken,
    this.auditorId,
  });

  factory AssetReportAuditCopyCreateRequest.fromJson(
          Map<String, dynamic> json) =>
      _$AssetReportAuditCopyCreateRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'asset_report_token')
  final String assetReportToken;
  @JsonKey(name: 'auditor_id')
  final String? auditorId;
  static const fromJsonFactory = _$AssetReportAuditCopyCreateRequestFromJson;
  static const toJsonFactory = _$AssetReportAuditCopyCreateRequestToJson;
  Map<String, dynamic> toJson() =>
      _$AssetReportAuditCopyCreateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AssetReportAuditCopyCreateRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.assetReportToken, assetReportToken) ||
                const DeepCollectionEquality()
                    .equals(other.assetReportToken, assetReportToken)) &&
            (identical(other.auditorId, auditorId) ||
                const DeepCollectionEquality()
                    .equals(other.auditorId, auditorId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(assetReportToken) ^
      const DeepCollectionEquality().hash(auditorId) ^
      runtimeType.hashCode;
}

extension $AssetReportAuditCopyCreateRequestExtension
    on AssetReportAuditCopyCreateRequest {
  AssetReportAuditCopyCreateRequest copyWith(
      {String? clientId,
      String? secret,
      String? assetReportToken,
      String? auditorId}) {
    return AssetReportAuditCopyCreateRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        assetReportToken: assetReportToken ?? this.assetReportToken,
        auditorId: auditorId ?? this.auditorId);
  }

  AssetReportAuditCopyCreateRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? assetReportToken,
      Wrapped<String?>? auditorId}) {
    return AssetReportAuditCopyCreateRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        assetReportToken: (assetReportToken != null
            ? assetReportToken.value
            : this.assetReportToken),
        auditorId: (auditorId != null ? auditorId.value : this.auditorId));
  }
}

@JsonSerializable(explicitToJson: true)
class AssetReportAuditCopyCreateResponse {
  AssetReportAuditCopyCreateResponse({
    required this.auditCopyToken,
    required this.requestId,
  });

  factory AssetReportAuditCopyCreateResponse.fromJson(
          Map<String, dynamic> json) =>
      _$AssetReportAuditCopyCreateResponseFromJson(json);

  @JsonKey(name: 'audit_copy_token')
  final String auditCopyToken;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$AssetReportAuditCopyCreateResponseFromJson;
  static const toJsonFactory = _$AssetReportAuditCopyCreateResponseToJson;
  Map<String, dynamic> toJson() =>
      _$AssetReportAuditCopyCreateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AssetReportAuditCopyCreateResponse &&
            (identical(other.auditCopyToken, auditCopyToken) ||
                const DeepCollectionEquality()
                    .equals(other.auditCopyToken, auditCopyToken)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(auditCopyToken) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $AssetReportAuditCopyCreateResponseExtension
    on AssetReportAuditCopyCreateResponse {
  AssetReportAuditCopyCreateResponse copyWith(
      {String? auditCopyToken, String? requestId}) {
    return AssetReportAuditCopyCreateResponse(
        auditCopyToken: auditCopyToken ?? this.auditCopyToken,
        requestId: requestId ?? this.requestId);
  }

  AssetReportAuditCopyCreateResponse copyWithWrapped(
      {Wrapped<String>? auditCopyToken, Wrapped<String>? requestId}) {
    return AssetReportAuditCopyCreateResponse(
        auditCopyToken: (auditCopyToken != null
            ? auditCopyToken.value
            : this.auditCopyToken),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class AssetReportAuditCopyGetRequest {
  AssetReportAuditCopyGetRequest({
    this.clientId,
    this.secret,
    required this.auditCopyToken,
  });

  factory AssetReportAuditCopyGetRequest.fromJson(Map<String, dynamic> json) =>
      _$AssetReportAuditCopyGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'audit_copy_token')
  final String auditCopyToken;
  static const fromJsonFactory = _$AssetReportAuditCopyGetRequestFromJson;
  static const toJsonFactory = _$AssetReportAuditCopyGetRequestToJson;
  Map<String, dynamic> toJson() => _$AssetReportAuditCopyGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AssetReportAuditCopyGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.auditCopyToken, auditCopyToken) ||
                const DeepCollectionEquality()
                    .equals(other.auditCopyToken, auditCopyToken)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(auditCopyToken) ^
      runtimeType.hashCode;
}

extension $AssetReportAuditCopyGetRequestExtension
    on AssetReportAuditCopyGetRequest {
  AssetReportAuditCopyGetRequest copyWith(
      {String? clientId, String? secret, String? auditCopyToken}) {
    return AssetReportAuditCopyGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        auditCopyToken: auditCopyToken ?? this.auditCopyToken);
  }

  AssetReportAuditCopyGetRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? auditCopyToken}) {
    return AssetReportAuditCopyGetRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        auditCopyToken: (auditCopyToken != null
            ? auditCopyToken.value
            : this.auditCopyToken));
  }
}

@JsonSerializable(explicitToJson: true)
class AssetReportAuditCopyRemoveRequest {
  AssetReportAuditCopyRemoveRequest({
    this.clientId,
    this.secret,
    required this.auditCopyToken,
  });

  factory AssetReportAuditCopyRemoveRequest.fromJson(
          Map<String, dynamic> json) =>
      _$AssetReportAuditCopyRemoveRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'audit_copy_token')
  final String auditCopyToken;
  static const fromJsonFactory = _$AssetReportAuditCopyRemoveRequestFromJson;
  static const toJsonFactory = _$AssetReportAuditCopyRemoveRequestToJson;
  Map<String, dynamic> toJson() =>
      _$AssetReportAuditCopyRemoveRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AssetReportAuditCopyRemoveRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.auditCopyToken, auditCopyToken) ||
                const DeepCollectionEquality()
                    .equals(other.auditCopyToken, auditCopyToken)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(auditCopyToken) ^
      runtimeType.hashCode;
}

extension $AssetReportAuditCopyRemoveRequestExtension
    on AssetReportAuditCopyRemoveRequest {
  AssetReportAuditCopyRemoveRequest copyWith(
      {String? clientId, String? secret, String? auditCopyToken}) {
    return AssetReportAuditCopyRemoveRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        auditCopyToken: auditCopyToken ?? this.auditCopyToken);
  }

  AssetReportAuditCopyRemoveRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? auditCopyToken}) {
    return AssetReportAuditCopyRemoveRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        auditCopyToken: (auditCopyToken != null
            ? auditCopyToken.value
            : this.auditCopyToken));
  }
}

@JsonSerializable(explicitToJson: true)
class AssetReportAuditCopyRemoveResponse {
  AssetReportAuditCopyRemoveResponse({
    required this.removed,
    required this.requestId,
  });

  factory AssetReportAuditCopyRemoveResponse.fromJson(
          Map<String, dynamic> json) =>
      _$AssetReportAuditCopyRemoveResponseFromJson(json);

  @JsonKey(name: 'removed')
  final bool removed;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$AssetReportAuditCopyRemoveResponseFromJson;
  static const toJsonFactory = _$AssetReportAuditCopyRemoveResponseToJson;
  Map<String, dynamic> toJson() =>
      _$AssetReportAuditCopyRemoveResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AssetReportAuditCopyRemoveResponse &&
            (identical(other.removed, removed) ||
                const DeepCollectionEquality()
                    .equals(other.removed, removed)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(removed) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $AssetReportAuditCopyRemoveResponseExtension
    on AssetReportAuditCopyRemoveResponse {
  AssetReportAuditCopyRemoveResponse copyWith(
      {bool? removed, String? requestId}) {
    return AssetReportAuditCopyRemoveResponse(
        removed: removed ?? this.removed,
        requestId: requestId ?? this.requestId);
  }

  AssetReportAuditCopyRemoveResponse copyWithWrapped(
      {Wrapped<bool>? removed, Wrapped<String>? requestId}) {
    return AssetReportAuditCopyRemoveResponse(
        removed: (removed != null ? removed.value : this.removed),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class HistoricalBalance {
  HistoricalBalance({
    required this.date,
    required this.current,
    required this.isoCurrencyCode,
    required this.unofficialCurrencyCode,
  });

  factory HistoricalBalance.fromJson(Map<String, dynamic> json) =>
      _$HistoricalBalanceFromJson(json);

  @JsonKey(name: 'date', toJson: _dateToJson)
  final DateTime date;
  @JsonKey(name: 'current')
  final double current;
  @JsonKey(name: 'iso_currency_code')
  final String? isoCurrencyCode;
  @JsonKey(name: 'unofficial_currency_code')
  final String? unofficialCurrencyCode;
  static const fromJsonFactory = _$HistoricalBalanceFromJson;
  static const toJsonFactory = _$HistoricalBalanceToJson;
  Map<String, dynamic> toJson() => _$HistoricalBalanceToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is HistoricalBalance &&
            (identical(other.date, date) ||
                const DeepCollectionEquality().equals(other.date, date)) &&
            (identical(other.current, current) ||
                const DeepCollectionEquality()
                    .equals(other.current, current)) &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)) &&
            (identical(other.unofficialCurrencyCode, unofficialCurrencyCode) ||
                const DeepCollectionEquality().equals(
                    other.unofficialCurrencyCode, unofficialCurrencyCode)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(date) ^
      const DeepCollectionEquality().hash(current) ^
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      const DeepCollectionEquality().hash(unofficialCurrencyCode) ^
      runtimeType.hashCode;
}

extension $HistoricalBalanceExtension on HistoricalBalance {
  HistoricalBalance copyWith(
      {DateTime? date,
      double? current,
      String? isoCurrencyCode,
      String? unofficialCurrencyCode}) {
    return HistoricalBalance(
        date: date ?? this.date,
        current: current ?? this.current,
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode,
        unofficialCurrencyCode:
            unofficialCurrencyCode ?? this.unofficialCurrencyCode);
  }

  HistoricalBalance copyWithWrapped(
      {Wrapped<DateTime>? date,
      Wrapped<double>? current,
      Wrapped<String?>? isoCurrencyCode,
      Wrapped<String?>? unofficialCurrencyCode}) {
    return HistoricalBalance(
        date: (date != null ? date.value : this.date),
        current: (current != null ? current.value : this.current),
        isoCurrencyCode: (isoCurrencyCode != null
            ? isoCurrencyCode.value
            : this.isoCurrencyCode),
        unofficialCurrencyCode: (unofficialCurrencyCode != null
            ? unofficialCurrencyCode.value
            : this.unofficialCurrencyCode));
  }
}

@JsonSerializable(explicitToJson: true)
class AssetsProductReadyWebhook {
  AssetsProductReadyWebhook({
    required this.webhookType,
    required this.webhookCode,
    required this.assetReportId,
  });

  factory AssetsProductReadyWebhook.fromJson(Map<String, dynamic> json) =>
      _$AssetsProductReadyWebhookFromJson(json);

  @JsonKey(name: 'webhook_type')
  final String webhookType;
  @JsonKey(name: 'webhook_code')
  final String webhookCode;
  @JsonKey(name: 'asset_report_id')
  final String assetReportId;
  static const fromJsonFactory = _$AssetsProductReadyWebhookFromJson;
  static const toJsonFactory = _$AssetsProductReadyWebhookToJson;
  Map<String, dynamic> toJson() => _$AssetsProductReadyWebhookToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AssetsProductReadyWebhook &&
            (identical(other.webhookType, webhookType) ||
                const DeepCollectionEquality()
                    .equals(other.webhookType, webhookType)) &&
            (identical(other.webhookCode, webhookCode) ||
                const DeepCollectionEquality()
                    .equals(other.webhookCode, webhookCode)) &&
            (identical(other.assetReportId, assetReportId) ||
                const DeepCollectionEquality()
                    .equals(other.assetReportId, assetReportId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(webhookType) ^
      const DeepCollectionEquality().hash(webhookCode) ^
      const DeepCollectionEquality().hash(assetReportId) ^
      runtimeType.hashCode;
}

extension $AssetsProductReadyWebhookExtension on AssetsProductReadyWebhook {
  AssetsProductReadyWebhook copyWith(
      {String? webhookType, String? webhookCode, String? assetReportId}) {
    return AssetsProductReadyWebhook(
        webhookType: webhookType ?? this.webhookType,
        webhookCode: webhookCode ?? this.webhookCode,
        assetReportId: assetReportId ?? this.assetReportId);
  }

  AssetsProductReadyWebhook copyWithWrapped(
      {Wrapped<String>? webhookType,
      Wrapped<String>? webhookCode,
      Wrapped<String>? assetReportId}) {
    return AssetsProductReadyWebhook(
        webhookType:
            (webhookType != null ? webhookType.value : this.webhookType),
        webhookCode:
            (webhookCode != null ? webhookCode.value : this.webhookCode),
        assetReportId:
            (assetReportId != null ? assetReportId.value : this.assetReportId));
  }
}

@JsonSerializable(explicitToJson: true)
class AssetsErrorWebhook {
  AssetsErrorWebhook({
    required this.webhookType,
    required this.webhookCode,
    required this.error,
    required this.assetReportId,
  });

  factory AssetsErrorWebhook.fromJson(Map<String, dynamic> json) =>
      _$AssetsErrorWebhookFromJson(json);

  @JsonKey(name: 'webhook_type')
  final String webhookType;
  @JsonKey(name: 'webhook_code')
  final String webhookCode;
  @JsonKey(name: 'error')
  final PlaidError? error;
  @JsonKey(name: 'asset_report_id')
  final String assetReportId;
  static const fromJsonFactory = _$AssetsErrorWebhookFromJson;
  static const toJsonFactory = _$AssetsErrorWebhookToJson;
  Map<String, dynamic> toJson() => _$AssetsErrorWebhookToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AssetsErrorWebhook &&
            (identical(other.webhookType, webhookType) ||
                const DeepCollectionEquality()
                    .equals(other.webhookType, webhookType)) &&
            (identical(other.webhookCode, webhookCode) ||
                const DeepCollectionEquality()
                    .equals(other.webhookCode, webhookCode)) &&
            (identical(other.error, error) ||
                const DeepCollectionEquality().equals(other.error, error)) &&
            (identical(other.assetReportId, assetReportId) ||
                const DeepCollectionEquality()
                    .equals(other.assetReportId, assetReportId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(webhookType) ^
      const DeepCollectionEquality().hash(webhookCode) ^
      const DeepCollectionEquality().hash(error) ^
      const DeepCollectionEquality().hash(assetReportId) ^
      runtimeType.hashCode;
}

extension $AssetsErrorWebhookExtension on AssetsErrorWebhook {
  AssetsErrorWebhook copyWith(
      {String? webhookType,
      String? webhookCode,
      PlaidError? error,
      String? assetReportId}) {
    return AssetsErrorWebhook(
        webhookType: webhookType ?? this.webhookType,
        webhookCode: webhookCode ?? this.webhookCode,
        error: error ?? this.error,
        assetReportId: assetReportId ?? this.assetReportId);
  }

  AssetsErrorWebhook copyWithWrapped(
      {Wrapped<String>? webhookType,
      Wrapped<String>? webhookCode,
      Wrapped<PlaidError?>? error,
      Wrapped<String>? assetReportId}) {
    return AssetsErrorWebhook(
        webhookType:
            (webhookType != null ? webhookType.value : this.webhookType),
        webhookCode:
            (webhookCode != null ? webhookCode.value : this.webhookCode),
        error: (error != null ? error.value : this.error),
        assetReportId:
            (assetReportId != null ? assetReportId.value : this.assetReportId));
  }
}

@JsonSerializable(explicitToJson: true)
class Warning {
  Warning({
    required this.warningType,
    required this.warningCode,
    required this.cause,
  });

  factory Warning.fromJson(Map<String, dynamic> json) =>
      _$WarningFromJson(json);

  @JsonKey(name: 'warning_type')
  final String warningType;
  @JsonKey(
    name: 'warning_code',
    toJson: warningWarningCodeToJson,
    fromJson: warningWarningCodeFromJson,
  )
  final enums.WarningWarningCode warningCode;
  @JsonKey(name: 'cause')
  final Cause cause;
  static const fromJsonFactory = _$WarningFromJson;
  static const toJsonFactory = _$WarningToJson;
  Map<String, dynamic> toJson() => _$WarningToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Warning &&
            (identical(other.warningType, warningType) ||
                const DeepCollectionEquality()
                    .equals(other.warningType, warningType)) &&
            (identical(other.warningCode, warningCode) ||
                const DeepCollectionEquality()
                    .equals(other.warningCode, warningCode)) &&
            (identical(other.cause, cause) ||
                const DeepCollectionEquality().equals(other.cause, cause)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(warningType) ^
      const DeepCollectionEquality().hash(warningCode) ^
      const DeepCollectionEquality().hash(cause) ^
      runtimeType.hashCode;
}

extension $WarningExtension on Warning {
  Warning copyWith(
      {String? warningType,
      enums.WarningWarningCode? warningCode,
      Cause? cause}) {
    return Warning(
        warningType: warningType ?? this.warningType,
        warningCode: warningCode ?? this.warningCode,
        cause: cause ?? this.cause);
  }

  Warning copyWithWrapped(
      {Wrapped<String>? warningType,
      Wrapped<enums.WarningWarningCode>? warningCode,
      Wrapped<Cause>? cause}) {
    return Warning(
        warningType:
            (warningType != null ? warningType.value : this.warningType),
        warningCode:
            (warningCode != null ? warningCode.value : this.warningCode),
        cause: (cause != null ? cause.value : this.cause));
  }
}

@JsonSerializable(explicitToJson: true)
class AssetReportUser {
  AssetReportUser({
    this.clientUserId,
    this.firstName,
    this.middleName,
    this.lastName,
    this.ssn,
    this.phoneNumber,
    this.email,
  });

  factory AssetReportUser.fromJson(Map<String, dynamic> json) =>
      _$AssetReportUserFromJson(json);

  @JsonKey(name: 'client_user_id')
  final String? clientUserId;
  @JsonKey(name: 'first_name')
  final String? firstName;
  @JsonKey(name: 'middle_name')
  final String? middleName;
  @JsonKey(name: 'last_name')
  final String? lastName;
  @JsonKey(name: 'ssn')
  final String? ssn;
  @JsonKey(name: 'phone_number')
  final String? phoneNumber;
  @JsonKey(name: 'email')
  final String? email;
  static const fromJsonFactory = _$AssetReportUserFromJson;
  static const toJsonFactory = _$AssetReportUserToJson;
  Map<String, dynamic> toJson() => _$AssetReportUserToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AssetReportUser &&
            (identical(other.clientUserId, clientUserId) ||
                const DeepCollectionEquality()
                    .equals(other.clientUserId, clientUserId)) &&
            (identical(other.firstName, firstName) ||
                const DeepCollectionEquality()
                    .equals(other.firstName, firstName)) &&
            (identical(other.middleName, middleName) ||
                const DeepCollectionEquality()
                    .equals(other.middleName, middleName)) &&
            (identical(other.lastName, lastName) ||
                const DeepCollectionEquality()
                    .equals(other.lastName, lastName)) &&
            (identical(other.ssn, ssn) ||
                const DeepCollectionEquality().equals(other.ssn, ssn)) &&
            (identical(other.phoneNumber, phoneNumber) ||
                const DeepCollectionEquality()
                    .equals(other.phoneNumber, phoneNumber)) &&
            (identical(other.email, email) ||
                const DeepCollectionEquality().equals(other.email, email)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientUserId) ^
      const DeepCollectionEquality().hash(firstName) ^
      const DeepCollectionEquality().hash(middleName) ^
      const DeepCollectionEquality().hash(lastName) ^
      const DeepCollectionEquality().hash(ssn) ^
      const DeepCollectionEquality().hash(phoneNumber) ^
      const DeepCollectionEquality().hash(email) ^
      runtimeType.hashCode;
}

extension $AssetReportUserExtension on AssetReportUser {
  AssetReportUser copyWith(
      {String? clientUserId,
      String? firstName,
      String? middleName,
      String? lastName,
      String? ssn,
      String? phoneNumber,
      String? email}) {
    return AssetReportUser(
        clientUserId: clientUserId ?? this.clientUserId,
        firstName: firstName ?? this.firstName,
        middleName: middleName ?? this.middleName,
        lastName: lastName ?? this.lastName,
        ssn: ssn ?? this.ssn,
        phoneNumber: phoneNumber ?? this.phoneNumber,
        email: email ?? this.email);
  }

  AssetReportUser copyWithWrapped(
      {Wrapped<String?>? clientUserId,
      Wrapped<String?>? firstName,
      Wrapped<String?>? middleName,
      Wrapped<String?>? lastName,
      Wrapped<String?>? ssn,
      Wrapped<String?>? phoneNumber,
      Wrapped<String?>? email}) {
    return AssetReportUser(
        clientUserId:
            (clientUserId != null ? clientUserId.value : this.clientUserId),
        firstName: (firstName != null ? firstName.value : this.firstName),
        middleName: (middleName != null ? middleName.value : this.middleName),
        lastName: (lastName != null ? lastName.value : this.lastName),
        ssn: (ssn != null ? ssn.value : this.ssn),
        phoneNumber:
            (phoneNumber != null ? phoneNumber.value : this.phoneNumber),
        email: (email != null ? email.value : this.email));
  }
}

@JsonSerializable(explicitToJson: true)
class AssetReport {
  AssetReport({
    required this.assetReportId,
    required this.clientReportId,
    required this.dateGenerated,
    required this.daysRequested,
    required this.user,
    required this.items,
  });

  factory AssetReport.fromJson(Map<String, dynamic> json) =>
      _$AssetReportFromJson(json);

  @JsonKey(name: 'asset_report_id')
  final String assetReportId;
  @JsonKey(name: 'client_report_id')
  final String? clientReportId;
  @JsonKey(name: 'date_generated')
  final DateTime dateGenerated;
  @JsonKey(name: 'days_requested')
  final double daysRequested;
  @JsonKey(name: 'user')
  final AssetReportUser user;
  @JsonKey(name: 'items', defaultValue: <AssetReportItem>[])
  final List<AssetReportItem> items;
  static const fromJsonFactory = _$AssetReportFromJson;
  static const toJsonFactory = _$AssetReportToJson;
  Map<String, dynamic> toJson() => _$AssetReportToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AssetReport &&
            (identical(other.assetReportId, assetReportId) ||
                const DeepCollectionEquality()
                    .equals(other.assetReportId, assetReportId)) &&
            (identical(other.clientReportId, clientReportId) ||
                const DeepCollectionEquality()
                    .equals(other.clientReportId, clientReportId)) &&
            (identical(other.dateGenerated, dateGenerated) ||
                const DeepCollectionEquality()
                    .equals(other.dateGenerated, dateGenerated)) &&
            (identical(other.daysRequested, daysRequested) ||
                const DeepCollectionEquality()
                    .equals(other.daysRequested, daysRequested)) &&
            (identical(other.user, user) ||
                const DeepCollectionEquality().equals(other.user, user)) &&
            (identical(other.items, items) ||
                const DeepCollectionEquality().equals(other.items, items)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(assetReportId) ^
      const DeepCollectionEquality().hash(clientReportId) ^
      const DeepCollectionEquality().hash(dateGenerated) ^
      const DeepCollectionEquality().hash(daysRequested) ^
      const DeepCollectionEquality().hash(user) ^
      const DeepCollectionEquality().hash(items) ^
      runtimeType.hashCode;
}

extension $AssetReportExtension on AssetReport {
  AssetReport copyWith(
      {String? assetReportId,
      String? clientReportId,
      DateTime? dateGenerated,
      double? daysRequested,
      AssetReportUser? user,
      List<AssetReportItem>? items}) {
    return AssetReport(
        assetReportId: assetReportId ?? this.assetReportId,
        clientReportId: clientReportId ?? this.clientReportId,
        dateGenerated: dateGenerated ?? this.dateGenerated,
        daysRequested: daysRequested ?? this.daysRequested,
        user: user ?? this.user,
        items: items ?? this.items);
  }

  AssetReport copyWithWrapped(
      {Wrapped<String>? assetReportId,
      Wrapped<String?>? clientReportId,
      Wrapped<DateTime>? dateGenerated,
      Wrapped<double>? daysRequested,
      Wrapped<AssetReportUser>? user,
      Wrapped<List<AssetReportItem>>? items}) {
    return AssetReport(
        assetReportId:
            (assetReportId != null ? assetReportId.value : this.assetReportId),
        clientReportId: (clientReportId != null
            ? clientReportId.value
            : this.clientReportId),
        dateGenerated:
            (dateGenerated != null ? dateGenerated.value : this.dateGenerated),
        daysRequested:
            (daysRequested != null ? daysRequested.value : this.daysRequested),
        user: (user != null ? user.value : this.user),
        items: (items != null ? items.value : this.items));
  }
}

@JsonSerializable(explicitToJson: true)
class AssetReportItem {
  AssetReportItem({
    required this.itemId,
    required this.institutionName,
    required this.institutionId,
    required this.dateLastUpdated,
    required this.accounts,
  });

  factory AssetReportItem.fromJson(Map<String, dynamic> json) =>
      _$AssetReportItemFromJson(json);

  @JsonKey(name: 'item_id')
  final String itemId;
  @JsonKey(name: 'institution_name')
  final String institutionName;
  @JsonKey(name: 'institution_id')
  final String institutionId;
  @JsonKey(name: 'date_last_updated')
  final DateTime dateLastUpdated;
  @JsonKey(name: 'accounts', defaultValue: <AccountAssets>[])
  final List<AccountAssets> accounts;
  static const fromJsonFactory = _$AssetReportItemFromJson;
  static const toJsonFactory = _$AssetReportItemToJson;
  Map<String, dynamic> toJson() => _$AssetReportItemToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AssetReportItem &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)) &&
            (identical(other.institutionName, institutionName) ||
                const DeepCollectionEquality()
                    .equals(other.institutionName, institutionName)) &&
            (identical(other.institutionId, institutionId) ||
                const DeepCollectionEquality()
                    .equals(other.institutionId, institutionId)) &&
            (identical(other.dateLastUpdated, dateLastUpdated) ||
                const DeepCollectionEquality()
                    .equals(other.dateLastUpdated, dateLastUpdated)) &&
            (identical(other.accounts, accounts) ||
                const DeepCollectionEquality()
                    .equals(other.accounts, accounts)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(itemId) ^
      const DeepCollectionEquality().hash(institutionName) ^
      const DeepCollectionEquality().hash(institutionId) ^
      const DeepCollectionEquality().hash(dateLastUpdated) ^
      const DeepCollectionEquality().hash(accounts) ^
      runtimeType.hashCode;
}

extension $AssetReportItemExtension on AssetReportItem {
  AssetReportItem copyWith(
      {String? itemId,
      String? institutionName,
      String? institutionId,
      DateTime? dateLastUpdated,
      List<AccountAssets>? accounts}) {
    return AssetReportItem(
        itemId: itemId ?? this.itemId,
        institutionName: institutionName ?? this.institutionName,
        institutionId: institutionId ?? this.institutionId,
        dateLastUpdated: dateLastUpdated ?? this.dateLastUpdated,
        accounts: accounts ?? this.accounts);
  }

  AssetReportItem copyWithWrapped(
      {Wrapped<String>? itemId,
      Wrapped<String>? institutionName,
      Wrapped<String>? institutionId,
      Wrapped<DateTime>? dateLastUpdated,
      Wrapped<List<AccountAssets>>? accounts}) {
    return AssetReportItem(
        itemId: (itemId != null ? itemId.value : this.itemId),
        institutionName: (institutionName != null
            ? institutionName.value
            : this.institutionName),
        institutionId:
            (institutionId != null ? institutionId.value : this.institutionId),
        dateLastUpdated: (dateLastUpdated != null
            ? dateLastUpdated.value
            : this.dateLastUpdated),
        accounts: (accounts != null ? accounts.value : this.accounts));
  }
}

@JsonSerializable(explicitToJson: true)
class AccountAssets {
  AccountAssets({
    required this.daysAvailable,
    required this.transactions,
    required this.owners,
    this.ownershipType,
    required this.historicalBalances,
    required this.accountId,
    required this.balances,
    required this.mask,
    required this.name,
    required this.officialName,
    required this.type,
    required this.subtype,
    this.verificationStatus,
  });

  factory AccountAssets.fromJson(Map<String, dynamic> json) =>
      _$AccountAssetsFromJson(json);

  @JsonKey(name: 'days_available')
  final double daysAvailable;
  @JsonKey(name: 'transactions', defaultValue: <AssetReportTransaction>[])
  final List<AssetReportTransaction> transactions;
  @JsonKey(name: 'owners', defaultValue: <Owner>[])
  final List<Owner> owners;
  @JsonKey(
    name: 'ownership_type',
    toJson: ownershipTypeToJson,
    fromJson: ownershipTypeFromJson,
  )
  final enums.OwnershipType? ownershipType;
  @JsonKey(name: 'historical_balances', defaultValue: <HistoricalBalance>[])
  final List<HistoricalBalance> historicalBalances;
  @JsonKey(name: 'account_id')
  final String accountId;
  @JsonKey(name: 'balances')
  final AccountBalance balances;
  @JsonKey(name: 'mask')
  final String? mask;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'official_name')
  final String? officialName;
  @JsonKey(
    name: 'type',
    toJson: accountTypeToJson,
    fromJson: accountTypeFromJson,
  )
  final enums.AccountType type;
  @JsonKey(
    name: 'subtype',
    toJson: accountSubtypeToJson,
    fromJson: accountSubtypeFromJson,
  )
  final enums.AccountSubtype? subtype;
  @JsonKey(
    name: 'verification_status',
    toJson: accountAssetsVerificationStatusToJson,
    fromJson: accountAssetsVerificationStatusFromJson,
  )
  final enums.AccountAssetsVerificationStatus? verificationStatus;
  static const fromJsonFactory = _$AccountAssetsFromJson;
  static const toJsonFactory = _$AccountAssetsToJson;
  Map<String, dynamic> toJson() => _$AccountAssetsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AccountAssets &&
            (identical(other.daysAvailable, daysAvailable) ||
                const DeepCollectionEquality()
                    .equals(other.daysAvailable, daysAvailable)) &&
            (identical(other.transactions, transactions) ||
                const DeepCollectionEquality()
                    .equals(other.transactions, transactions)) &&
            (identical(other.owners, owners) ||
                const DeepCollectionEquality().equals(other.owners, owners)) &&
            (identical(other.ownershipType, ownershipType) ||
                const DeepCollectionEquality()
                    .equals(other.ownershipType, ownershipType)) &&
            (identical(other.historicalBalances, historicalBalances) ||
                const DeepCollectionEquality()
                    .equals(other.historicalBalances, historicalBalances)) &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.balances, balances) ||
                const DeepCollectionEquality()
                    .equals(other.balances, balances)) &&
            (identical(other.mask, mask) ||
                const DeepCollectionEquality().equals(other.mask, mask)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.officialName, officialName) ||
                const DeepCollectionEquality()
                    .equals(other.officialName, officialName)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.subtype, subtype) ||
                const DeepCollectionEquality()
                    .equals(other.subtype, subtype)) &&
            (identical(other.verificationStatus, verificationStatus) ||
                const DeepCollectionEquality()
                    .equals(other.verificationStatus, verificationStatus)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(daysAvailable) ^
      const DeepCollectionEquality().hash(transactions) ^
      const DeepCollectionEquality().hash(owners) ^
      const DeepCollectionEquality().hash(ownershipType) ^
      const DeepCollectionEquality().hash(historicalBalances) ^
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(balances) ^
      const DeepCollectionEquality().hash(mask) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(officialName) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(subtype) ^
      const DeepCollectionEquality().hash(verificationStatus) ^
      runtimeType.hashCode;
}

extension $AccountAssetsExtension on AccountAssets {
  AccountAssets copyWith(
      {double? daysAvailable,
      List<AssetReportTransaction>? transactions,
      List<Owner>? owners,
      enums.OwnershipType? ownershipType,
      List<HistoricalBalance>? historicalBalances,
      String? accountId,
      AccountBalance? balances,
      String? mask,
      String? name,
      String? officialName,
      enums.AccountType? type,
      enums.AccountSubtype? subtype,
      enums.AccountAssetsVerificationStatus? verificationStatus}) {
    return AccountAssets(
        daysAvailable: daysAvailable ?? this.daysAvailable,
        transactions: transactions ?? this.transactions,
        owners: owners ?? this.owners,
        ownershipType: ownershipType ?? this.ownershipType,
        historicalBalances: historicalBalances ?? this.historicalBalances,
        accountId: accountId ?? this.accountId,
        balances: balances ?? this.balances,
        mask: mask ?? this.mask,
        name: name ?? this.name,
        officialName: officialName ?? this.officialName,
        type: type ?? this.type,
        subtype: subtype ?? this.subtype,
        verificationStatus: verificationStatus ?? this.verificationStatus);
  }

  AccountAssets copyWithWrapped(
      {Wrapped<double>? daysAvailable,
      Wrapped<List<AssetReportTransaction>>? transactions,
      Wrapped<List<Owner>>? owners,
      Wrapped<enums.OwnershipType?>? ownershipType,
      Wrapped<List<HistoricalBalance>>? historicalBalances,
      Wrapped<String>? accountId,
      Wrapped<AccountBalance>? balances,
      Wrapped<String?>? mask,
      Wrapped<String>? name,
      Wrapped<String?>? officialName,
      Wrapped<enums.AccountType>? type,
      Wrapped<enums.AccountSubtype?>? subtype,
      Wrapped<enums.AccountAssetsVerificationStatus?>? verificationStatus}) {
    return AccountAssets(
        daysAvailable:
            (daysAvailable != null ? daysAvailable.value : this.daysAvailable),
        transactions:
            (transactions != null ? transactions.value : this.transactions),
        owners: (owners != null ? owners.value : this.owners),
        ownershipType:
            (ownershipType != null ? ownershipType.value : this.ownershipType),
        historicalBalances: (historicalBalances != null
            ? historicalBalances.value
            : this.historicalBalances),
        accountId: (accountId != null ? accountId.value : this.accountId),
        balances: (balances != null ? balances.value : this.balances),
        mask: (mask != null ? mask.value : this.mask),
        name: (name != null ? name.value : this.name),
        officialName:
            (officialName != null ? officialName.value : this.officialName),
        type: (type != null ? type.value : this.type),
        subtype: (subtype != null ? subtype.value : this.subtype),
        verificationStatus: (verificationStatus != null
            ? verificationStatus.value
            : this.verificationStatus));
  }
}

@JsonSerializable(explicitToJson: true)
class AssetReportTransaction {
  AssetReportTransaction({
    this.dateTransacted,
    this.creditCategory,
    this.transactionType,
    this.pendingTransactionId,
    this.categoryId,
    this.category,
    this.location,
    this.paymentMeta,
    this.accountOwner,
    this.name,
    required this.originalDescription,
    required this.accountId,
    required this.amount,
    required this.isoCurrencyCode,
    required this.unofficialCurrencyCode,
    required this.date,
    required this.pending,
    required this.transactionId,
    this.merchantName,
    this.checkNumber,
  });

  factory AssetReportTransaction.fromJson(Map<String, dynamic> json) =>
      _$AssetReportTransactionFromJson(json);

  @JsonKey(name: 'date_transacted')
  final String? dateTransacted;
  @JsonKey(name: 'credit_category')
  final CreditCategory? creditCategory;
  @JsonKey(
    name: 'transaction_type',
    toJson: assetReportTransactionTransactionTypeToJson,
    fromJson: assetReportTransactionTransactionTypeFromJson,
  )
  final enums.AssetReportTransactionTransactionType? transactionType;
  @JsonKey(name: 'pending_transaction_id')
  final String? pendingTransactionId;
  @JsonKey(name: 'category_id')
  final String? categoryId;
  @JsonKey(name: 'category', defaultValue: <String>[])
  final List<String>? category;
  @JsonKey(name: 'location')
  final Location? location;
  @JsonKey(name: 'payment_meta')
  final PaymentMeta? paymentMeta;
  @JsonKey(name: 'account_owner')
  final String? accountOwner;
  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'original_description')
  final String? originalDescription;
  @JsonKey(name: 'account_id')
  final String accountId;
  @JsonKey(name: 'amount')
  final double amount;
  @JsonKey(name: 'iso_currency_code')
  final String? isoCurrencyCode;
  @JsonKey(name: 'unofficial_currency_code')
  final String? unofficialCurrencyCode;
  @JsonKey(name: 'date', toJson: _dateToJson)
  final DateTime date;
  @JsonKey(name: 'pending')
  final bool pending;
  @JsonKey(name: 'transaction_id')
  final String transactionId;
  @JsonKey(name: 'merchant_name')
  final String? merchantName;
  @JsonKey(name: 'check_number')
  final String? checkNumber;
  static const fromJsonFactory = _$AssetReportTransactionFromJson;
  static const toJsonFactory = _$AssetReportTransactionToJson;
  Map<String, dynamic> toJson() => _$AssetReportTransactionToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AssetReportTransaction &&
            (identical(other.dateTransacted, dateTransacted) ||
                const DeepCollectionEquality()
                    .equals(other.dateTransacted, dateTransacted)) &&
            (identical(other.creditCategory, creditCategory) ||
                const DeepCollectionEquality()
                    .equals(other.creditCategory, creditCategory)) &&
            (identical(other.transactionType, transactionType) ||
                const DeepCollectionEquality()
                    .equals(other.transactionType, transactionType)) &&
            (identical(other.pendingTransactionId, pendingTransactionId) ||
                const DeepCollectionEquality().equals(
                    other.pendingTransactionId, pendingTransactionId)) &&
            (identical(other.categoryId, categoryId) ||
                const DeepCollectionEquality()
                    .equals(other.categoryId, categoryId)) &&
            (identical(other.category, category) ||
                const DeepCollectionEquality()
                    .equals(other.category, category)) &&
            (identical(other.location, location) ||
                const DeepCollectionEquality()
                    .equals(other.location, location)) &&
            (identical(other.paymentMeta, paymentMeta) ||
                const DeepCollectionEquality()
                    .equals(other.paymentMeta, paymentMeta)) &&
            (identical(other.accountOwner, accountOwner) ||
                const DeepCollectionEquality()
                    .equals(other.accountOwner, accountOwner)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.originalDescription, originalDescription) ||
                const DeepCollectionEquality()
                    .equals(other.originalDescription, originalDescription)) &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)) &&
            (identical(other.unofficialCurrencyCode, unofficialCurrencyCode) ||
                const DeepCollectionEquality().equals(
                    other.unofficialCurrencyCode, unofficialCurrencyCode)) &&
            (identical(other.date, date) ||
                const DeepCollectionEquality().equals(other.date, date)) &&
            (identical(other.pending, pending) ||
                const DeepCollectionEquality()
                    .equals(other.pending, pending)) &&
            (identical(other.transactionId, transactionId) ||
                const DeepCollectionEquality()
                    .equals(other.transactionId, transactionId)) &&
            (identical(other.merchantName, merchantName) ||
                const DeepCollectionEquality()
                    .equals(other.merchantName, merchantName)) &&
            (identical(other.checkNumber, checkNumber) ||
                const DeepCollectionEquality()
                    .equals(other.checkNumber, checkNumber)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(dateTransacted) ^
      const DeepCollectionEquality().hash(creditCategory) ^
      const DeepCollectionEquality().hash(transactionType) ^
      const DeepCollectionEquality().hash(pendingTransactionId) ^
      const DeepCollectionEquality().hash(categoryId) ^
      const DeepCollectionEquality().hash(category) ^
      const DeepCollectionEquality().hash(location) ^
      const DeepCollectionEquality().hash(paymentMeta) ^
      const DeepCollectionEquality().hash(accountOwner) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(originalDescription) ^
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      const DeepCollectionEquality().hash(unofficialCurrencyCode) ^
      const DeepCollectionEquality().hash(date) ^
      const DeepCollectionEquality().hash(pending) ^
      const DeepCollectionEquality().hash(transactionId) ^
      const DeepCollectionEquality().hash(merchantName) ^
      const DeepCollectionEquality().hash(checkNumber) ^
      runtimeType.hashCode;
}

extension $AssetReportTransactionExtension on AssetReportTransaction {
  AssetReportTransaction copyWith(
      {String? dateTransacted,
      CreditCategory? creditCategory,
      enums.AssetReportTransactionTransactionType? transactionType,
      String? pendingTransactionId,
      String? categoryId,
      List<String>? category,
      Location? location,
      PaymentMeta? paymentMeta,
      String? accountOwner,
      String? name,
      String? originalDescription,
      String? accountId,
      double? amount,
      String? isoCurrencyCode,
      String? unofficialCurrencyCode,
      DateTime? date,
      bool? pending,
      String? transactionId,
      String? merchantName,
      String? checkNumber}) {
    return AssetReportTransaction(
        dateTransacted: dateTransacted ?? this.dateTransacted,
        creditCategory: creditCategory ?? this.creditCategory,
        transactionType: transactionType ?? this.transactionType,
        pendingTransactionId: pendingTransactionId ?? this.pendingTransactionId,
        categoryId: categoryId ?? this.categoryId,
        category: category ?? this.category,
        location: location ?? this.location,
        paymentMeta: paymentMeta ?? this.paymentMeta,
        accountOwner: accountOwner ?? this.accountOwner,
        name: name ?? this.name,
        originalDescription: originalDescription ?? this.originalDescription,
        accountId: accountId ?? this.accountId,
        amount: amount ?? this.amount,
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode,
        unofficialCurrencyCode:
            unofficialCurrencyCode ?? this.unofficialCurrencyCode,
        date: date ?? this.date,
        pending: pending ?? this.pending,
        transactionId: transactionId ?? this.transactionId,
        merchantName: merchantName ?? this.merchantName,
        checkNumber: checkNumber ?? this.checkNumber);
  }

  AssetReportTransaction copyWithWrapped(
      {Wrapped<String?>? dateTransacted,
      Wrapped<CreditCategory?>? creditCategory,
      Wrapped<enums.AssetReportTransactionTransactionType?>? transactionType,
      Wrapped<String?>? pendingTransactionId,
      Wrapped<String?>? categoryId,
      Wrapped<List<String>?>? category,
      Wrapped<Location?>? location,
      Wrapped<PaymentMeta?>? paymentMeta,
      Wrapped<String?>? accountOwner,
      Wrapped<String?>? name,
      Wrapped<String?>? originalDescription,
      Wrapped<String>? accountId,
      Wrapped<double>? amount,
      Wrapped<String?>? isoCurrencyCode,
      Wrapped<String?>? unofficialCurrencyCode,
      Wrapped<DateTime>? date,
      Wrapped<bool>? pending,
      Wrapped<String>? transactionId,
      Wrapped<String?>? merchantName,
      Wrapped<String?>? checkNumber}) {
    return AssetReportTransaction(
        dateTransacted: (dateTransacted != null
            ? dateTransacted.value
            : this.dateTransacted),
        creditCategory: (creditCategory != null
            ? creditCategory.value
            : this.creditCategory),
        transactionType: (transactionType != null
            ? transactionType.value
            : this.transactionType),
        pendingTransactionId: (pendingTransactionId != null
            ? pendingTransactionId.value
            : this.pendingTransactionId),
        categoryId: (categoryId != null ? categoryId.value : this.categoryId),
        category: (category != null ? category.value : this.category),
        location: (location != null ? location.value : this.location),
        paymentMeta:
            (paymentMeta != null ? paymentMeta.value : this.paymentMeta),
        accountOwner:
            (accountOwner != null ? accountOwner.value : this.accountOwner),
        name: (name != null ? name.value : this.name),
        originalDescription: (originalDescription != null
            ? originalDescription.value
            : this.originalDescription),
        accountId: (accountId != null ? accountId.value : this.accountId),
        amount: (amount != null ? amount.value : this.amount),
        isoCurrencyCode: (isoCurrencyCode != null
            ? isoCurrencyCode.value
            : this.isoCurrencyCode),
        unofficialCurrencyCode: (unofficialCurrencyCode != null
            ? unofficialCurrencyCode.value
            : this.unofficialCurrencyCode),
        date: (date != null ? date.value : this.date),
        pending: (pending != null ? pending.value : this.pending),
        transactionId:
            (transactionId != null ? transactionId.value : this.transactionId),
        merchantName:
            (merchantName != null ? merchantName.value : this.merchantName),
        checkNumber:
            (checkNumber != null ? checkNumber.value : this.checkNumber));
  }
}

@JsonSerializable(explicitToJson: true)
class DashboardUser {
  DashboardUser({
    required this.id,
    required this.createdAt,
    required this.emailAddress,
    required this.status,
  });

  factory DashboardUser.fromJson(Map<String, dynamic> json) =>
      _$DashboardUserFromJson(json);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'created_at')
  final String createdAt;
  @JsonKey(name: 'email_address')
  final String emailAddress;
  @JsonKey(
    name: 'status',
    toJson: dashboardUserStatusToJson,
    fromJson: dashboardUserStatusFromJson,
  )
  final enums.DashboardUserStatus status;
  static const fromJsonFactory = _$DashboardUserFromJson;
  static const toJsonFactory = _$DashboardUserToJson;
  Map<String, dynamic> toJson() => _$DashboardUserToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is DashboardUser &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.createdAt, createdAt) ||
                const DeepCollectionEquality()
                    .equals(other.createdAt, createdAt)) &&
            (identical(other.emailAddress, emailAddress) ||
                const DeepCollectionEquality()
                    .equals(other.emailAddress, emailAddress)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(createdAt) ^
      const DeepCollectionEquality().hash(emailAddress) ^
      const DeepCollectionEquality().hash(status) ^
      runtimeType.hashCode;
}

extension $DashboardUserExtension on DashboardUser {
  DashboardUser copyWith(
      {String? id,
      String? createdAt,
      String? emailAddress,
      enums.DashboardUserStatus? status}) {
    return DashboardUser(
        id: id ?? this.id,
        createdAt: createdAt ?? this.createdAt,
        emailAddress: emailAddress ?? this.emailAddress,
        status: status ?? this.status);
  }

  DashboardUser copyWithWrapped(
      {Wrapped<String>? id,
      Wrapped<String>? createdAt,
      Wrapped<String>? emailAddress,
      Wrapped<enums.DashboardUserStatus>? status}) {
    return DashboardUser(
        id: (id != null ? id.value : this.id),
        createdAt: (createdAt != null ? createdAt.value : this.createdAt),
        emailAddress:
            (emailAddress != null ? emailAddress.value : this.emailAddress),
        status: (status != null ? status.value : this.status));
  }
}

@JsonSerializable(explicitToJson: true)
class DashboardUserGetRequest {
  DashboardUserGetRequest({
    required this.dashboardUserId,
    this.secret,
    this.clientId,
  });

  factory DashboardUserGetRequest.fromJson(Map<String, dynamic> json) =>
      _$DashboardUserGetRequestFromJson(json);

  @JsonKey(name: 'dashboard_user_id')
  final String dashboardUserId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'client_id')
  final String? clientId;
  static const fromJsonFactory = _$DashboardUserGetRequestFromJson;
  static const toJsonFactory = _$DashboardUserGetRequestToJson;
  Map<String, dynamic> toJson() => _$DashboardUserGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is DashboardUserGetRequest &&
            (identical(other.dashboardUserId, dashboardUserId) ||
                const DeepCollectionEquality()
                    .equals(other.dashboardUserId, dashboardUserId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(dashboardUserId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(clientId) ^
      runtimeType.hashCode;
}

extension $DashboardUserGetRequestExtension on DashboardUserGetRequest {
  DashboardUserGetRequest copyWith(
      {String? dashboardUserId, String? secret, String? clientId}) {
    return DashboardUserGetRequest(
        dashboardUserId: dashboardUserId ?? this.dashboardUserId,
        secret: secret ?? this.secret,
        clientId: clientId ?? this.clientId);
  }

  DashboardUserGetRequest copyWithWrapped(
      {Wrapped<String>? dashboardUserId,
      Wrapped<String?>? secret,
      Wrapped<String?>? clientId}) {
    return DashboardUserGetRequest(
        dashboardUserId: (dashboardUserId != null
            ? dashboardUserId.value
            : this.dashboardUserId),
        secret: (secret != null ? secret.value : this.secret),
        clientId: (clientId != null ? clientId.value : this.clientId));
  }
}

@JsonSerializable(explicitToJson: true)
class DashboardUserGetResponse {
  DashboardUserGetResponse({
    required this.id,
    required this.createdAt,
    required this.emailAddress,
    required this.status,
    required this.requestId,
  });

  factory DashboardUserGetResponse.fromJson(Map<String, dynamic> json) =>
      _$DashboardUserGetResponseFromJson(json);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'created_at')
  final String createdAt;
  @JsonKey(name: 'email_address')
  final String emailAddress;
  @JsonKey(
    name: 'status',
    toJson: dashboardUserStatusToJson,
    fromJson: dashboardUserStatusFromJson,
  )
  final enums.DashboardUserStatus status;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$DashboardUserGetResponseFromJson;
  static const toJsonFactory = _$DashboardUserGetResponseToJson;
  Map<String, dynamic> toJson() => _$DashboardUserGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is DashboardUserGetResponse &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.createdAt, createdAt) ||
                const DeepCollectionEquality()
                    .equals(other.createdAt, createdAt)) &&
            (identical(other.emailAddress, emailAddress) ||
                const DeepCollectionEquality()
                    .equals(other.emailAddress, emailAddress)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(createdAt) ^
      const DeepCollectionEquality().hash(emailAddress) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $DashboardUserGetResponseExtension on DashboardUserGetResponse {
  DashboardUserGetResponse copyWith(
      {String? id,
      String? createdAt,
      String? emailAddress,
      enums.DashboardUserStatus? status,
      String? requestId}) {
    return DashboardUserGetResponse(
        id: id ?? this.id,
        createdAt: createdAt ?? this.createdAt,
        emailAddress: emailAddress ?? this.emailAddress,
        status: status ?? this.status,
        requestId: requestId ?? this.requestId);
  }

  DashboardUserGetResponse copyWithWrapped(
      {Wrapped<String>? id,
      Wrapped<String>? createdAt,
      Wrapped<String>? emailAddress,
      Wrapped<enums.DashboardUserStatus>? status,
      Wrapped<String>? requestId}) {
    return DashboardUserGetResponse(
        id: (id != null ? id.value : this.id),
        createdAt: (createdAt != null ? createdAt.value : this.createdAt),
        emailAddress:
            (emailAddress != null ? emailAddress.value : this.emailAddress),
        status: (status != null ? status.value : this.status),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class DashboardUserListRequest {
  DashboardUserListRequest({
    this.secret,
    this.clientId,
    this.cursor,
  });

  factory DashboardUserListRequest.fromJson(Map<String, dynamic> json) =>
      _$DashboardUserListRequestFromJson(json);

  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'cursor')
  final String? cursor;
  static const fromJsonFactory = _$DashboardUserListRequestFromJson;
  static const toJsonFactory = _$DashboardUserListRequestToJson;
  Map<String, dynamic> toJson() => _$DashboardUserListRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is DashboardUserListRequest &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.cursor, cursor) ||
                const DeepCollectionEquality().equals(other.cursor, cursor)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(cursor) ^
      runtimeType.hashCode;
}

extension $DashboardUserListRequestExtension on DashboardUserListRequest {
  DashboardUserListRequest copyWith(
      {String? secret, String? clientId, String? cursor}) {
    return DashboardUserListRequest(
        secret: secret ?? this.secret,
        clientId: clientId ?? this.clientId,
        cursor: cursor ?? this.cursor);
  }

  DashboardUserListRequest copyWithWrapped(
      {Wrapped<String?>? secret,
      Wrapped<String?>? clientId,
      Wrapped<String?>? cursor}) {
    return DashboardUserListRequest(
        secret: (secret != null ? secret.value : this.secret),
        clientId: (clientId != null ? clientId.value : this.clientId),
        cursor: (cursor != null ? cursor.value : this.cursor));
  }
}

@JsonSerializable(explicitToJson: true)
class DashboardUserListResponse {
  DashboardUserListResponse({
    required this.dashboardUsers,
    required this.nextCursor,
    required this.requestId,
  });

  factory DashboardUserListResponse.fromJson(Map<String, dynamic> json) =>
      _$DashboardUserListResponseFromJson(json);

  @JsonKey(name: 'dashboard_users', defaultValue: <DashboardUser>[])
  final List<DashboardUser> dashboardUsers;
  @JsonKey(name: 'next_cursor')
  final String? nextCursor;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$DashboardUserListResponseFromJson;
  static const toJsonFactory = _$DashboardUserListResponseToJson;
  Map<String, dynamic> toJson() => _$DashboardUserListResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is DashboardUserListResponse &&
            (identical(other.dashboardUsers, dashboardUsers) ||
                const DeepCollectionEquality()
                    .equals(other.dashboardUsers, dashboardUsers)) &&
            (identical(other.nextCursor, nextCursor) ||
                const DeepCollectionEquality()
                    .equals(other.nextCursor, nextCursor)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(dashboardUsers) ^
      const DeepCollectionEquality().hash(nextCursor) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $DashboardUserListResponseExtension on DashboardUserListResponse {
  DashboardUserListResponse copyWith(
      {List<DashboardUser>? dashboardUsers,
      String? nextCursor,
      String? requestId}) {
    return DashboardUserListResponse(
        dashboardUsers: dashboardUsers ?? this.dashboardUsers,
        nextCursor: nextCursor ?? this.nextCursor,
        requestId: requestId ?? this.requestId);
  }

  DashboardUserListResponse copyWithWrapped(
      {Wrapped<List<DashboardUser>>? dashboardUsers,
      Wrapped<String?>? nextCursor,
      Wrapped<String>? requestId}) {
    return DashboardUserListResponse(
        dashboardUsers: (dashboardUsers != null
            ? dashboardUsers.value
            : this.dashboardUsers),
        nextCursor: (nextCursor != null ? nextCursor.value : this.nextCursor),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class DateRange {
  DateRange({
    required this.beginning,
    required this.ending,
  });

  factory DateRange.fromJson(Map<String, dynamic> json) =>
      _$DateRangeFromJson(json);

  @JsonKey(name: 'beginning')
  final String beginning;
  @JsonKey(name: 'ending')
  final String ending;
  static const fromJsonFactory = _$DateRangeFromJson;
  static const toJsonFactory = _$DateRangeToJson;
  Map<String, dynamic> toJson() => _$DateRangeToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is DateRange &&
            (identical(other.beginning, beginning) ||
                const DeepCollectionEquality()
                    .equals(other.beginning, beginning)) &&
            (identical(other.ending, ending) ||
                const DeepCollectionEquality().equals(other.ending, ending)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(beginning) ^
      const DeepCollectionEquality().hash(ending) ^
      runtimeType.hashCode;
}

extension $DateRangeExtension on DateRange {
  DateRange copyWith({String? beginning, String? ending}) {
    return DateRange(
        beginning: beginning ?? this.beginning, ending: ending ?? this.ending);
  }

  DateRange copyWithWrapped(
      {Wrapped<String>? beginning, Wrapped<String>? ending}) {
    return DateRange(
        beginning: (beginning != null ? beginning.value : this.beginning),
        ending: (ending != null ? ending.value : this.ending));
  }
}

@JsonSerializable(explicitToJson: true)
class DocumentAnalysis {
  DocumentAnalysis({
    required this.authenticity,
    required this.imageQuality,
    required this.extractedData,
  });

  factory DocumentAnalysis.fromJson(Map<String, dynamic> json) =>
      _$DocumentAnalysisFromJson(json);

  @JsonKey(
    name: 'authenticity',
    toJson: documentAuthenticityMatchCodeToJson,
    fromJson: documentAuthenticityMatchCodeFromJson,
  )
  final enums.DocumentAuthenticityMatchCode authenticity;
  @JsonKey(
    name: 'image_quality',
    toJson: imageQualityToJson,
    fromJson: imageQualityFromJson,
  )
  final enums.ImageQuality imageQuality;
  @JsonKey(name: 'extracted_data')
  final PhysicalDocumentExtractedDataAnalysis? extractedData;
  static const fromJsonFactory = _$DocumentAnalysisFromJson;
  static const toJsonFactory = _$DocumentAnalysisToJson;
  Map<String, dynamic> toJson() => _$DocumentAnalysisToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is DocumentAnalysis &&
            (identical(other.authenticity, authenticity) ||
                const DeepCollectionEquality()
                    .equals(other.authenticity, authenticity)) &&
            (identical(other.imageQuality, imageQuality) ||
                const DeepCollectionEquality()
                    .equals(other.imageQuality, imageQuality)) &&
            (identical(other.extractedData, extractedData) ||
                const DeepCollectionEquality()
                    .equals(other.extractedData, extractedData)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(authenticity) ^
      const DeepCollectionEquality().hash(imageQuality) ^
      const DeepCollectionEquality().hash(extractedData) ^
      runtimeType.hashCode;
}

extension $DocumentAnalysisExtension on DocumentAnalysis {
  DocumentAnalysis copyWith(
      {enums.DocumentAuthenticityMatchCode? authenticity,
      enums.ImageQuality? imageQuality,
      PhysicalDocumentExtractedDataAnalysis? extractedData}) {
    return DocumentAnalysis(
        authenticity: authenticity ?? this.authenticity,
        imageQuality: imageQuality ?? this.imageQuality,
        extractedData: extractedData ?? this.extractedData);
  }

  DocumentAnalysis copyWithWrapped(
      {Wrapped<enums.DocumentAuthenticityMatchCode>? authenticity,
      Wrapped<enums.ImageQuality>? imageQuality,
      Wrapped<PhysicalDocumentExtractedDataAnalysis?>? extractedData}) {
    return DocumentAnalysis(
        authenticity:
            (authenticity != null ? authenticity.value : this.authenticity),
        imageQuality:
            (imageQuality != null ? imageQuality.value : this.imageQuality),
        extractedData:
            (extractedData != null ? extractedData.value : this.extractedData));
  }
}

@JsonSerializable(explicitToJson: true)
class DocumentaryVerification {
  DocumentaryVerification({
    required this.status,
    required this.documents,
  });

  factory DocumentaryVerification.fromJson(Map<String, dynamic> json) =>
      _$DocumentaryVerificationFromJson(json);

  @JsonKey(name: 'status')
  final String status;
  @JsonKey(name: 'documents', defaultValue: <DocumentaryVerificationDocument>[])
  final List<DocumentaryVerificationDocument> documents;
  static const fromJsonFactory = _$DocumentaryVerificationFromJson;
  static const toJsonFactory = _$DocumentaryVerificationToJson;
  Map<String, dynamic> toJson() => _$DocumentaryVerificationToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is DocumentaryVerification &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.documents, documents) ||
                const DeepCollectionEquality()
                    .equals(other.documents, documents)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(documents) ^
      runtimeType.hashCode;
}

extension $DocumentaryVerificationExtension on DocumentaryVerification {
  DocumentaryVerification copyWith(
      {String? status, List<DocumentaryVerificationDocument>? documents}) {
    return DocumentaryVerification(
        status: status ?? this.status, documents: documents ?? this.documents);
  }

  DocumentaryVerification copyWithWrapped(
      {Wrapped<String>? status,
      Wrapped<List<DocumentaryVerificationDocument>>? documents}) {
    return DocumentaryVerification(
        status: (status != null ? status.value : this.status),
        documents: (documents != null ? documents.value : this.documents));
  }
}

@JsonSerializable(explicitToJson: true)
class DocumentaryVerificationDocument {
  DocumentaryVerificationDocument({
    required this.status,
    required this.attempt,
    required this.images,
    required this.extractedData,
    required this.analysis,
  });

  factory DocumentaryVerificationDocument.fromJson(Map<String, dynamic> json) =>
      _$DocumentaryVerificationDocumentFromJson(json);

  @JsonKey(
    name: 'status',
    toJson: documentStatusToJson,
    fromJson: documentStatusFromJson,
  )
  final enums.DocumentStatus status;
  @JsonKey(name: 'attempt')
  final double attempt;
  @JsonKey(name: 'images')
  final PhysicalDocumentImages images;
  @JsonKey(name: 'extracted_data')
  final PhysicalDocumentExtractedData? extractedData;
  @JsonKey(name: 'analysis')
  final DocumentAnalysis analysis;
  static const fromJsonFactory = _$DocumentaryVerificationDocumentFromJson;
  static const toJsonFactory = _$DocumentaryVerificationDocumentToJson;
  Map<String, dynamic> toJson() =>
      _$DocumentaryVerificationDocumentToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is DocumentaryVerificationDocument &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.attempt, attempt) ||
                const DeepCollectionEquality()
                    .equals(other.attempt, attempt)) &&
            (identical(other.images, images) ||
                const DeepCollectionEquality().equals(other.images, images)) &&
            (identical(other.extractedData, extractedData) ||
                const DeepCollectionEquality()
                    .equals(other.extractedData, extractedData)) &&
            (identical(other.analysis, analysis) ||
                const DeepCollectionEquality()
                    .equals(other.analysis, analysis)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(attempt) ^
      const DeepCollectionEquality().hash(images) ^
      const DeepCollectionEquality().hash(extractedData) ^
      const DeepCollectionEquality().hash(analysis) ^
      runtimeType.hashCode;
}

extension $DocumentaryVerificationDocumentExtension
    on DocumentaryVerificationDocument {
  DocumentaryVerificationDocument copyWith(
      {enums.DocumentStatus? status,
      double? attempt,
      PhysicalDocumentImages? images,
      PhysicalDocumentExtractedData? extractedData,
      DocumentAnalysis? analysis}) {
    return DocumentaryVerificationDocument(
        status: status ?? this.status,
        attempt: attempt ?? this.attempt,
        images: images ?? this.images,
        extractedData: extractedData ?? this.extractedData,
        analysis: analysis ?? this.analysis);
  }

  DocumentaryVerificationDocument copyWithWrapped(
      {Wrapped<enums.DocumentStatus>? status,
      Wrapped<double>? attempt,
      Wrapped<PhysicalDocumentImages>? images,
      Wrapped<PhysicalDocumentExtractedData?>? extractedData,
      Wrapped<DocumentAnalysis>? analysis}) {
    return DocumentaryVerificationDocument(
        status: (status != null ? status.value : this.status),
        attempt: (attempt != null ? attempt.value : this.attempt),
        images: (images != null ? images.value : this.images),
        extractedData:
            (extractedData != null ? extractedData.value : this.extractedData),
        analysis: (analysis != null ? analysis.value : this.analysis));
  }
}

@JsonSerializable(explicitToJson: true)
class EntityDocument {
  EntityDocument({
    required this.type,
    required this.number,
  });

  factory EntityDocument.fromJson(Map<String, dynamic> json) =>
      _$EntityDocumentFromJson(json);

  @JsonKey(
    name: 'type',
    toJson: entityDocumentTypeToJson,
    fromJson: entityDocumentTypeFromJson,
  )
  final enums.EntityDocumentType type;
  @JsonKey(name: 'number')
  final String number;
  static const fromJsonFactory = _$EntityDocumentFromJson;
  static const toJsonFactory = _$EntityDocumentToJson;
  Map<String, dynamic> toJson() => _$EntityDocumentToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is EntityDocument &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.number, number) ||
                const DeepCollectionEquality().equals(other.number, number)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(number) ^
      runtimeType.hashCode;
}

extension $EntityDocumentExtension on EntityDocument {
  EntityDocument copyWith({enums.EntityDocumentType? type, String? number}) {
    return EntityDocument(
        type: type ?? this.type, number: number ?? this.number);
  }

  EntityDocument copyWithWrapped(
      {Wrapped<enums.EntityDocumentType>? type, Wrapped<String>? number}) {
    return EntityDocument(
        type: (type != null ? type.value : this.type),
        number: (number != null ? number.value : this.number));
  }
}

@JsonSerializable(explicitToJson: true)
class EntityScreeningHitAnalysis {
  EntityScreeningHitAnalysis({
    this.documents,
    this.emailAddresses,
    this.locations,
    this.names,
    this.phoneNumbers,
    this.urls,
    required this.searchTermsVersion,
  });

  factory EntityScreeningHitAnalysis.fromJson(Map<String, dynamic> json) =>
      _$EntityScreeningHitAnalysisFromJson(json);

  @JsonKey(
    name: 'documents',
    toJson: matchSummaryCodeToJson,
    fromJson: matchSummaryCodeFromJson,
  )
  final enums.MatchSummaryCode? documents;
  @JsonKey(
    name: 'email_addresses',
    toJson: matchSummaryCodeToJson,
    fromJson: matchSummaryCodeFromJson,
  )
  final enums.MatchSummaryCode? emailAddresses;
  @JsonKey(
    name: 'locations',
    toJson: matchSummaryCodeToJson,
    fromJson: matchSummaryCodeFromJson,
  )
  final enums.MatchSummaryCode? locations;
  @JsonKey(
    name: 'names',
    toJson: matchSummaryCodeToJson,
    fromJson: matchSummaryCodeFromJson,
  )
  final enums.MatchSummaryCode? names;
  @JsonKey(
    name: 'phone_numbers',
    toJson: matchSummaryCodeToJson,
    fromJson: matchSummaryCodeFromJson,
  )
  final enums.MatchSummaryCode? phoneNumbers;
  @JsonKey(
    name: 'urls',
    toJson: matchSummaryCodeToJson,
    fromJson: matchSummaryCodeFromJson,
  )
  final enums.MatchSummaryCode? urls;
  @JsonKey(name: 'search_terms_version')
  final double searchTermsVersion;
  static const fromJsonFactory = _$EntityScreeningHitAnalysisFromJson;
  static const toJsonFactory = _$EntityScreeningHitAnalysisToJson;
  Map<String, dynamic> toJson() => _$EntityScreeningHitAnalysisToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is EntityScreeningHitAnalysis &&
            (identical(other.documents, documents) ||
                const DeepCollectionEquality()
                    .equals(other.documents, documents)) &&
            (identical(other.emailAddresses, emailAddresses) ||
                const DeepCollectionEquality()
                    .equals(other.emailAddresses, emailAddresses)) &&
            (identical(other.locations, locations) ||
                const DeepCollectionEquality()
                    .equals(other.locations, locations)) &&
            (identical(other.names, names) ||
                const DeepCollectionEquality().equals(other.names, names)) &&
            (identical(other.phoneNumbers, phoneNumbers) ||
                const DeepCollectionEquality()
                    .equals(other.phoneNumbers, phoneNumbers)) &&
            (identical(other.urls, urls) ||
                const DeepCollectionEquality().equals(other.urls, urls)) &&
            (identical(other.searchTermsVersion, searchTermsVersion) ||
                const DeepCollectionEquality()
                    .equals(other.searchTermsVersion, searchTermsVersion)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(documents) ^
      const DeepCollectionEquality().hash(emailAddresses) ^
      const DeepCollectionEquality().hash(locations) ^
      const DeepCollectionEquality().hash(names) ^
      const DeepCollectionEquality().hash(phoneNumbers) ^
      const DeepCollectionEquality().hash(urls) ^
      const DeepCollectionEquality().hash(searchTermsVersion) ^
      runtimeType.hashCode;
}

extension $EntityScreeningHitAnalysisExtension on EntityScreeningHitAnalysis {
  EntityScreeningHitAnalysis copyWith(
      {enums.MatchSummaryCode? documents,
      enums.MatchSummaryCode? emailAddresses,
      enums.MatchSummaryCode? locations,
      enums.MatchSummaryCode? names,
      enums.MatchSummaryCode? phoneNumbers,
      enums.MatchSummaryCode? urls,
      double? searchTermsVersion}) {
    return EntityScreeningHitAnalysis(
        documents: documents ?? this.documents,
        emailAddresses: emailAddresses ?? this.emailAddresses,
        locations: locations ?? this.locations,
        names: names ?? this.names,
        phoneNumbers: phoneNumbers ?? this.phoneNumbers,
        urls: urls ?? this.urls,
        searchTermsVersion: searchTermsVersion ?? this.searchTermsVersion);
  }

  EntityScreeningHitAnalysis copyWithWrapped(
      {Wrapped<enums.MatchSummaryCode?>? documents,
      Wrapped<enums.MatchSummaryCode?>? emailAddresses,
      Wrapped<enums.MatchSummaryCode?>? locations,
      Wrapped<enums.MatchSummaryCode?>? names,
      Wrapped<enums.MatchSummaryCode?>? phoneNumbers,
      Wrapped<enums.MatchSummaryCode?>? urls,
      Wrapped<double>? searchTermsVersion}) {
    return EntityScreeningHitAnalysis(
        documents: (documents != null ? documents.value : this.documents),
        emailAddresses: (emailAddresses != null
            ? emailAddresses.value
            : this.emailAddresses),
        locations: (locations != null ? locations.value : this.locations),
        names: (names != null ? names.value : this.names),
        phoneNumbers:
            (phoneNumbers != null ? phoneNumbers.value : this.phoneNumbers),
        urls: (urls != null ? urls.value : this.urls),
        searchTermsVersion: (searchTermsVersion != null
            ? searchTermsVersion.value
            : this.searchTermsVersion));
  }
}

@JsonSerializable(explicitToJson: true)
class EntityScreeningHitData {
  EntityScreeningHitData({
    this.documents,
    this.emailAddresses,
    this.locations,
    this.names,
    this.phoneNumbers,
    this.urls,
  });

  factory EntityScreeningHitData.fromJson(Map<String, dynamic> json) =>
      _$EntityScreeningHitDataFromJson(json);

  @JsonKey(
      name: 'documents', defaultValue: <EntityScreeningHitDocumentsItems>[])
  final List<EntityScreeningHitDocumentsItems>? documents;
  @JsonKey(
      name: 'email_addresses', defaultValue: <EntityScreeningHitEmailsItems>[])
  final List<EntityScreeningHitEmailsItems>? emailAddresses;
  @JsonKey(
      name: 'locations', defaultValue: <GenericScreeningHitLocationItems>[])
  final List<GenericScreeningHitLocationItems>? locations;
  @JsonKey(name: 'names', defaultValue: <EntityScreeningHitNamesItems>[])
  final List<EntityScreeningHitNamesItems>? names;
  @JsonKey(
      name: 'phone_numbers',
      defaultValue: <EntityScreeningHitsPhoneNumberItems>[])
  final List<EntityScreeningHitsPhoneNumberItems>? phoneNumbers;
  @JsonKey(name: 'urls', defaultValue: <EntityScreeningHitUrlsItems>[])
  final List<EntityScreeningHitUrlsItems>? urls;
  static const fromJsonFactory = _$EntityScreeningHitDataFromJson;
  static const toJsonFactory = _$EntityScreeningHitDataToJson;
  Map<String, dynamic> toJson() => _$EntityScreeningHitDataToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is EntityScreeningHitData &&
            (identical(other.documents, documents) ||
                const DeepCollectionEquality()
                    .equals(other.documents, documents)) &&
            (identical(other.emailAddresses, emailAddresses) ||
                const DeepCollectionEquality()
                    .equals(other.emailAddresses, emailAddresses)) &&
            (identical(other.locations, locations) ||
                const DeepCollectionEquality()
                    .equals(other.locations, locations)) &&
            (identical(other.names, names) ||
                const DeepCollectionEquality().equals(other.names, names)) &&
            (identical(other.phoneNumbers, phoneNumbers) ||
                const DeepCollectionEquality()
                    .equals(other.phoneNumbers, phoneNumbers)) &&
            (identical(other.urls, urls) ||
                const DeepCollectionEquality().equals(other.urls, urls)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(documents) ^
      const DeepCollectionEquality().hash(emailAddresses) ^
      const DeepCollectionEquality().hash(locations) ^
      const DeepCollectionEquality().hash(names) ^
      const DeepCollectionEquality().hash(phoneNumbers) ^
      const DeepCollectionEquality().hash(urls) ^
      runtimeType.hashCode;
}

extension $EntityScreeningHitDataExtension on EntityScreeningHitData {
  EntityScreeningHitData copyWith(
      {List<EntityScreeningHitDocumentsItems>? documents,
      List<EntityScreeningHitEmailsItems>? emailAddresses,
      List<GenericScreeningHitLocationItems>? locations,
      List<EntityScreeningHitNamesItems>? names,
      List<EntityScreeningHitsPhoneNumberItems>? phoneNumbers,
      List<EntityScreeningHitUrlsItems>? urls}) {
    return EntityScreeningHitData(
        documents: documents ?? this.documents,
        emailAddresses: emailAddresses ?? this.emailAddresses,
        locations: locations ?? this.locations,
        names: names ?? this.names,
        phoneNumbers: phoneNumbers ?? this.phoneNumbers,
        urls: urls ?? this.urls);
  }

  EntityScreeningHitData copyWithWrapped(
      {Wrapped<List<EntityScreeningHitDocumentsItems>?>? documents,
      Wrapped<List<EntityScreeningHitEmailsItems>?>? emailAddresses,
      Wrapped<List<GenericScreeningHitLocationItems>?>? locations,
      Wrapped<List<EntityScreeningHitNamesItems>?>? names,
      Wrapped<List<EntityScreeningHitsPhoneNumberItems>?>? phoneNumbers,
      Wrapped<List<EntityScreeningHitUrlsItems>?>? urls}) {
    return EntityScreeningHitData(
        documents: (documents != null ? documents.value : this.documents),
        emailAddresses: (emailAddresses != null
            ? emailAddresses.value
            : this.emailAddresses),
        locations: (locations != null ? locations.value : this.locations),
        names: (names != null ? names.value : this.names),
        phoneNumbers:
            (phoneNumbers != null ? phoneNumbers.value : this.phoneNumbers),
        urls: (urls != null ? urls.value : this.urls));
  }
}

@JsonSerializable(explicitToJson: true)
class EntityScreeningHitDocumentsItems {
  EntityScreeningHitDocumentsItems({
    this.analysis,
    this.data,
  });

  factory EntityScreeningHitDocumentsItems.fromJson(
          Map<String, dynamic> json) =>
      _$EntityScreeningHitDocumentsItemsFromJson(json);

  @JsonKey(name: 'analysis')
  final MatchSummary? analysis;
  @JsonKey(name: 'data')
  final EntityDocument? data;
  static const fromJsonFactory = _$EntityScreeningHitDocumentsItemsFromJson;
  static const toJsonFactory = _$EntityScreeningHitDocumentsItemsToJson;
  Map<String, dynamic> toJson() =>
      _$EntityScreeningHitDocumentsItemsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is EntityScreeningHitDocumentsItems &&
            (identical(other.analysis, analysis) ||
                const DeepCollectionEquality()
                    .equals(other.analysis, analysis)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(analysis) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $EntityScreeningHitDocumentsItemsExtension
    on EntityScreeningHitDocumentsItems {
  EntityScreeningHitDocumentsItems copyWith(
      {MatchSummary? analysis, EntityDocument? data}) {
    return EntityScreeningHitDocumentsItems(
        analysis: analysis ?? this.analysis, data: data ?? this.data);
  }

  EntityScreeningHitDocumentsItems copyWithWrapped(
      {Wrapped<MatchSummary?>? analysis, Wrapped<EntityDocument?>? data}) {
    return EntityScreeningHitDocumentsItems(
        analysis: (analysis != null ? analysis.value : this.analysis),
        data: (data != null ? data.value : this.data));
  }
}

@JsonSerializable(explicitToJson: true)
class EntityScreeningHitEmails {
  EntityScreeningHitEmails({
    required this.emailAddress,
  });

  factory EntityScreeningHitEmails.fromJson(Map<String, dynamic> json) =>
      _$EntityScreeningHitEmailsFromJson(json);

  @JsonKey(name: 'email_address')
  final String emailAddress;
  static const fromJsonFactory = _$EntityScreeningHitEmailsFromJson;
  static const toJsonFactory = _$EntityScreeningHitEmailsToJson;
  Map<String, dynamic> toJson() => _$EntityScreeningHitEmailsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is EntityScreeningHitEmails &&
            (identical(other.emailAddress, emailAddress) ||
                const DeepCollectionEquality()
                    .equals(other.emailAddress, emailAddress)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(emailAddress) ^ runtimeType.hashCode;
}

extension $EntityScreeningHitEmailsExtension on EntityScreeningHitEmails {
  EntityScreeningHitEmails copyWith({String? emailAddress}) {
    return EntityScreeningHitEmails(
        emailAddress: emailAddress ?? this.emailAddress);
  }

  EntityScreeningHitEmails copyWithWrapped({Wrapped<String>? emailAddress}) {
    return EntityScreeningHitEmails(
        emailAddress:
            (emailAddress != null ? emailAddress.value : this.emailAddress));
  }
}

@JsonSerializable(explicitToJson: true)
class EntityScreeningHitEmailsItems {
  EntityScreeningHitEmailsItems({
    this.analysis,
    this.data,
  });

  factory EntityScreeningHitEmailsItems.fromJson(Map<String, dynamic> json) =>
      _$EntityScreeningHitEmailsItemsFromJson(json);

  @JsonKey(name: 'analysis')
  final MatchSummary? analysis;
  @JsonKey(name: 'data')
  final EntityScreeningHitEmails? data;
  static const fromJsonFactory = _$EntityScreeningHitEmailsItemsFromJson;
  static const toJsonFactory = _$EntityScreeningHitEmailsItemsToJson;
  Map<String, dynamic> toJson() => _$EntityScreeningHitEmailsItemsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is EntityScreeningHitEmailsItems &&
            (identical(other.analysis, analysis) ||
                const DeepCollectionEquality()
                    .equals(other.analysis, analysis)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(analysis) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $EntityScreeningHitEmailsItemsExtension
    on EntityScreeningHitEmailsItems {
  EntityScreeningHitEmailsItems copyWith(
      {MatchSummary? analysis, EntityScreeningHitEmails? data}) {
    return EntityScreeningHitEmailsItems(
        analysis: analysis ?? this.analysis, data: data ?? this.data);
  }

  EntityScreeningHitEmailsItems copyWithWrapped(
      {Wrapped<MatchSummary?>? analysis,
      Wrapped<EntityScreeningHitEmails?>? data}) {
    return EntityScreeningHitEmailsItems(
        analysis: (analysis != null ? analysis.value : this.analysis),
        data: (data != null ? data.value : this.data));
  }
}

@JsonSerializable(explicitToJson: true)
class EntityScreeningHitNames {
  EntityScreeningHitNames({
    required this.full,
    required this.isPrimary,
    required this.weakAliasDetermination,
  });

  factory EntityScreeningHitNames.fromJson(Map<String, dynamic> json) =>
      _$EntityScreeningHitNamesFromJson(json);

  @JsonKey(name: 'full')
  final String full;
  @JsonKey(name: 'is_primary')
  final bool isPrimary;
  @JsonKey(
    name: 'weak_alias_determination',
    toJson: weakAliasDeterminationToJson,
    fromJson: weakAliasDeterminationFromJson,
  )
  final enums.WeakAliasDetermination weakAliasDetermination;
  static const fromJsonFactory = _$EntityScreeningHitNamesFromJson;
  static const toJsonFactory = _$EntityScreeningHitNamesToJson;
  Map<String, dynamic> toJson() => _$EntityScreeningHitNamesToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is EntityScreeningHitNames &&
            (identical(other.full, full) ||
                const DeepCollectionEquality().equals(other.full, full)) &&
            (identical(other.isPrimary, isPrimary) ||
                const DeepCollectionEquality()
                    .equals(other.isPrimary, isPrimary)) &&
            (identical(other.weakAliasDetermination, weakAliasDetermination) ||
                const DeepCollectionEquality().equals(
                    other.weakAliasDetermination, weakAliasDetermination)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(full) ^
      const DeepCollectionEquality().hash(isPrimary) ^
      const DeepCollectionEquality().hash(weakAliasDetermination) ^
      runtimeType.hashCode;
}

extension $EntityScreeningHitNamesExtension on EntityScreeningHitNames {
  EntityScreeningHitNames copyWith(
      {String? full,
      bool? isPrimary,
      enums.WeakAliasDetermination? weakAliasDetermination}) {
    return EntityScreeningHitNames(
        full: full ?? this.full,
        isPrimary: isPrimary ?? this.isPrimary,
        weakAliasDetermination:
            weakAliasDetermination ?? this.weakAliasDetermination);
  }

  EntityScreeningHitNames copyWithWrapped(
      {Wrapped<String>? full,
      Wrapped<bool>? isPrimary,
      Wrapped<enums.WeakAliasDetermination>? weakAliasDetermination}) {
    return EntityScreeningHitNames(
        full: (full != null ? full.value : this.full),
        isPrimary: (isPrimary != null ? isPrimary.value : this.isPrimary),
        weakAliasDetermination: (weakAliasDetermination != null
            ? weakAliasDetermination.value
            : this.weakAliasDetermination));
  }
}

@JsonSerializable(explicitToJson: true)
class EntityScreeningHitNamesItems {
  EntityScreeningHitNamesItems({
    this.analysis,
    this.data,
  });

  factory EntityScreeningHitNamesItems.fromJson(Map<String, dynamic> json) =>
      _$EntityScreeningHitNamesItemsFromJson(json);

  @JsonKey(name: 'analysis')
  final MatchSummary? analysis;
  @JsonKey(name: 'data')
  final EntityScreeningHitNames? data;
  static const fromJsonFactory = _$EntityScreeningHitNamesItemsFromJson;
  static const toJsonFactory = _$EntityScreeningHitNamesItemsToJson;
  Map<String, dynamic> toJson() => _$EntityScreeningHitNamesItemsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is EntityScreeningHitNamesItems &&
            (identical(other.analysis, analysis) ||
                const DeepCollectionEquality()
                    .equals(other.analysis, analysis)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(analysis) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $EntityScreeningHitNamesItemsExtension
    on EntityScreeningHitNamesItems {
  EntityScreeningHitNamesItems copyWith(
      {MatchSummary? analysis, EntityScreeningHitNames? data}) {
    return EntityScreeningHitNamesItems(
        analysis: analysis ?? this.analysis, data: data ?? this.data);
  }

  EntityScreeningHitNamesItems copyWithWrapped(
      {Wrapped<MatchSummary?>? analysis,
      Wrapped<EntityScreeningHitNames?>? data}) {
    return EntityScreeningHitNamesItems(
        analysis: (analysis != null ? analysis.value : this.analysis),
        data: (data != null ? data.value : this.data));
  }
}

@JsonSerializable(explicitToJson: true)
class EntityScreeningHitPhoneNumbers {
  EntityScreeningHitPhoneNumbers({
    required this.type,
    required this.phoneNumber,
  });

  factory EntityScreeningHitPhoneNumbers.fromJson(Map<String, dynamic> json) =>
      _$EntityScreeningHitPhoneNumbersFromJson(json);

  @JsonKey(
    name: 'type',
    toJson: phoneTypeToJson,
    fromJson: phoneTypeFromJson,
  )
  final enums.PhoneType type;
  @JsonKey(name: 'phone_number')
  final String phoneNumber;
  static const fromJsonFactory = _$EntityScreeningHitPhoneNumbersFromJson;
  static const toJsonFactory = _$EntityScreeningHitPhoneNumbersToJson;
  Map<String, dynamic> toJson() => _$EntityScreeningHitPhoneNumbersToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is EntityScreeningHitPhoneNumbers &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.phoneNumber, phoneNumber) ||
                const DeepCollectionEquality()
                    .equals(other.phoneNumber, phoneNumber)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(phoneNumber) ^
      runtimeType.hashCode;
}

extension $EntityScreeningHitPhoneNumbersExtension
    on EntityScreeningHitPhoneNumbers {
  EntityScreeningHitPhoneNumbers copyWith(
      {enums.PhoneType? type, String? phoneNumber}) {
    return EntityScreeningHitPhoneNumbers(
        type: type ?? this.type, phoneNumber: phoneNumber ?? this.phoneNumber);
  }

  EntityScreeningHitPhoneNumbers copyWithWrapped(
      {Wrapped<enums.PhoneType>? type, Wrapped<String>? phoneNumber}) {
    return EntityScreeningHitPhoneNumbers(
        type: (type != null ? type.value : this.type),
        phoneNumber:
            (phoneNumber != null ? phoneNumber.value : this.phoneNumber));
  }
}

@JsonSerializable(explicitToJson: true)
class EntityScreeningHitUrls {
  EntityScreeningHitUrls({
    required this.url,
  });

  factory EntityScreeningHitUrls.fromJson(Map<String, dynamic> json) =>
      _$EntityScreeningHitUrlsFromJson(json);

  @JsonKey(name: 'url')
  final String url;
  static const fromJsonFactory = _$EntityScreeningHitUrlsFromJson;
  static const toJsonFactory = _$EntityScreeningHitUrlsToJson;
  Map<String, dynamic> toJson() => _$EntityScreeningHitUrlsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is EntityScreeningHitUrls &&
            (identical(other.url, url) ||
                const DeepCollectionEquality().equals(other.url, url)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(url) ^ runtimeType.hashCode;
}

extension $EntityScreeningHitUrlsExtension on EntityScreeningHitUrls {
  EntityScreeningHitUrls copyWith({String? url}) {
    return EntityScreeningHitUrls(url: url ?? this.url);
  }

  EntityScreeningHitUrls copyWithWrapped({Wrapped<String>? url}) {
    return EntityScreeningHitUrls(url: (url != null ? url.value : this.url));
  }
}

@JsonSerializable(explicitToJson: true)
class EntityScreeningHitUrlsItems {
  EntityScreeningHitUrlsItems({
    this.analysis,
    this.data,
  });

  factory EntityScreeningHitUrlsItems.fromJson(Map<String, dynamic> json) =>
      _$EntityScreeningHitUrlsItemsFromJson(json);

  @JsonKey(name: 'analysis')
  final MatchSummary? analysis;
  @JsonKey(name: 'data')
  final EntityScreeningHitUrls? data;
  static const fromJsonFactory = _$EntityScreeningHitUrlsItemsFromJson;
  static const toJsonFactory = _$EntityScreeningHitUrlsItemsToJson;
  Map<String, dynamic> toJson() => _$EntityScreeningHitUrlsItemsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is EntityScreeningHitUrlsItems &&
            (identical(other.analysis, analysis) ||
                const DeepCollectionEquality()
                    .equals(other.analysis, analysis)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(analysis) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $EntityScreeningHitUrlsItemsExtension on EntityScreeningHitUrlsItems {
  EntityScreeningHitUrlsItems copyWith(
      {MatchSummary? analysis, EntityScreeningHitUrls? data}) {
    return EntityScreeningHitUrlsItems(
        analysis: analysis ?? this.analysis, data: data ?? this.data);
  }

  EntityScreeningHitUrlsItems copyWithWrapped(
      {Wrapped<MatchSummary?>? analysis,
      Wrapped<EntityScreeningHitUrls?>? data}) {
    return EntityScreeningHitUrlsItems(
        analysis: (analysis != null ? analysis.value : this.analysis),
        data: (data != null ? data.value : this.data));
  }
}

@JsonSerializable(explicitToJson: true)
class EntityScreeningHitsPhoneNumberItems {
  EntityScreeningHitsPhoneNumberItems({
    this.analysis,
    this.data,
  });

  factory EntityScreeningHitsPhoneNumberItems.fromJson(
          Map<String, dynamic> json) =>
      _$EntityScreeningHitsPhoneNumberItemsFromJson(json);

  @JsonKey(name: 'analysis')
  final MatchSummary? analysis;
  @JsonKey(name: 'data')
  final EntityScreeningHitPhoneNumbers? data;
  static const fromJsonFactory = _$EntityScreeningHitsPhoneNumberItemsFromJson;
  static const toJsonFactory = _$EntityScreeningHitsPhoneNumberItemsToJson;
  Map<String, dynamic> toJson() =>
      _$EntityScreeningHitsPhoneNumberItemsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is EntityScreeningHitsPhoneNumberItems &&
            (identical(other.analysis, analysis) ||
                const DeepCollectionEquality()
                    .equals(other.analysis, analysis)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(analysis) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $EntityScreeningHitsPhoneNumberItemsExtension
    on EntityScreeningHitsPhoneNumberItems {
  EntityScreeningHitsPhoneNumberItems copyWith(
      {MatchSummary? analysis, EntityScreeningHitPhoneNumbers? data}) {
    return EntityScreeningHitsPhoneNumberItems(
        analysis: analysis ?? this.analysis, data: data ?? this.data);
  }

  EntityScreeningHitsPhoneNumberItems copyWithWrapped(
      {Wrapped<MatchSummary?>? analysis,
      Wrapped<EntityScreeningHitPhoneNumbers?>? data}) {
    return EntityScreeningHitsPhoneNumberItems(
        analysis: (analysis != null ? analysis.value : this.analysis),
        data: (data != null ? data.value : this.data));
  }
}

@JsonSerializable(explicitToJson: true)
class EntityWatchlistProgram {
  EntityWatchlistProgram({
    required this.id,
    required this.createdAt,
    required this.isRescanningEnabled,
    required this.listsEnabled,
    required this.name,
    required this.nameSensitivity,
    required this.auditTrail,
    required this.isArchived,
  });

  factory EntityWatchlistProgram.fromJson(Map<String, dynamic> json) =>
      _$EntityWatchlistProgramFromJson(json);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'created_at')
  final String createdAt;
  @JsonKey(name: 'is_rescanning_enabled')
  final bool isRescanningEnabled;
  @JsonKey(
    name: 'lists_enabled',
    toJson: entityWatchlistCodeListToJson,
    fromJson: entityWatchlistCodeListFromJson,
  )
  final List<enums.EntityWatchlistCode> listsEnabled;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(
    name: 'name_sensitivity',
    toJson: programNameSensitivityToJson,
    fromJson: programNameSensitivityFromJson,
  )
  final enums.ProgramNameSensitivity nameSensitivity;
  @JsonKey(name: 'audit_trail')
  final WatchlistScreeningAuditTrail auditTrail;
  @JsonKey(name: 'is_archived')
  final bool isArchived;
  static const fromJsonFactory = _$EntityWatchlistProgramFromJson;
  static const toJsonFactory = _$EntityWatchlistProgramToJson;
  Map<String, dynamic> toJson() => _$EntityWatchlistProgramToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is EntityWatchlistProgram &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.createdAt, createdAt) ||
                const DeepCollectionEquality()
                    .equals(other.createdAt, createdAt)) &&
            (identical(other.isRescanningEnabled, isRescanningEnabled) ||
                const DeepCollectionEquality()
                    .equals(other.isRescanningEnabled, isRescanningEnabled)) &&
            (identical(other.listsEnabled, listsEnabled) ||
                const DeepCollectionEquality()
                    .equals(other.listsEnabled, listsEnabled)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.nameSensitivity, nameSensitivity) ||
                const DeepCollectionEquality()
                    .equals(other.nameSensitivity, nameSensitivity)) &&
            (identical(other.auditTrail, auditTrail) ||
                const DeepCollectionEquality()
                    .equals(other.auditTrail, auditTrail)) &&
            (identical(other.isArchived, isArchived) ||
                const DeepCollectionEquality()
                    .equals(other.isArchived, isArchived)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(createdAt) ^
      const DeepCollectionEquality().hash(isRescanningEnabled) ^
      const DeepCollectionEquality().hash(listsEnabled) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(nameSensitivity) ^
      const DeepCollectionEquality().hash(auditTrail) ^
      const DeepCollectionEquality().hash(isArchived) ^
      runtimeType.hashCode;
}

extension $EntityWatchlistProgramExtension on EntityWatchlistProgram {
  EntityWatchlistProgram copyWith(
      {String? id,
      String? createdAt,
      bool? isRescanningEnabled,
      List<enums.EntityWatchlistCode>? listsEnabled,
      String? name,
      enums.ProgramNameSensitivity? nameSensitivity,
      WatchlistScreeningAuditTrail? auditTrail,
      bool? isArchived}) {
    return EntityWatchlistProgram(
        id: id ?? this.id,
        createdAt: createdAt ?? this.createdAt,
        isRescanningEnabled: isRescanningEnabled ?? this.isRescanningEnabled,
        listsEnabled: listsEnabled ?? this.listsEnabled,
        name: name ?? this.name,
        nameSensitivity: nameSensitivity ?? this.nameSensitivity,
        auditTrail: auditTrail ?? this.auditTrail,
        isArchived: isArchived ?? this.isArchived);
  }

  EntityWatchlistProgram copyWithWrapped(
      {Wrapped<String>? id,
      Wrapped<String>? createdAt,
      Wrapped<bool>? isRescanningEnabled,
      Wrapped<List<enums.EntityWatchlistCode>>? listsEnabled,
      Wrapped<String>? name,
      Wrapped<enums.ProgramNameSensitivity>? nameSensitivity,
      Wrapped<WatchlistScreeningAuditTrail>? auditTrail,
      Wrapped<bool>? isArchived}) {
    return EntityWatchlistProgram(
        id: (id != null ? id.value : this.id),
        createdAt: (createdAt != null ? createdAt.value : this.createdAt),
        isRescanningEnabled: (isRescanningEnabled != null
            ? isRescanningEnabled.value
            : this.isRescanningEnabled),
        listsEnabled:
            (listsEnabled != null ? listsEnabled.value : this.listsEnabled),
        name: (name != null ? name.value : this.name),
        nameSensitivity: (nameSensitivity != null
            ? nameSensitivity.value
            : this.nameSensitivity),
        auditTrail: (auditTrail != null ? auditTrail.value : this.auditTrail),
        isArchived: (isArchived != null ? isArchived.value : this.isArchived));
  }
}

@JsonSerializable(explicitToJson: true)
class EntityWatchlistScreening {
  EntityWatchlistScreening({
    required this.id,
    required this.searchTerms,
    required this.assignee,
    required this.status,
    required this.clientUserId,
    required this.auditTrail,
  });

  factory EntityWatchlistScreening.fromJson(Map<String, dynamic> json) =>
      _$EntityWatchlistScreeningFromJson(json);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'search_terms')
  final EntityWatchlistScreeningSearchTerms searchTerms;
  @JsonKey(name: 'assignee')
  final String? assignee;
  @JsonKey(
    name: 'status',
    toJson: watchlistScreeningStatusToJson,
    fromJson: watchlistScreeningStatusFromJson,
  )
  final enums.WatchlistScreeningStatus status;
  @JsonKey(name: 'client_user_id')
  final String? clientUserId;
  @JsonKey(name: 'audit_trail')
  final WatchlistScreeningAuditTrail auditTrail;
  static const fromJsonFactory = _$EntityWatchlistScreeningFromJson;
  static const toJsonFactory = _$EntityWatchlistScreeningToJson;
  Map<String, dynamic> toJson() => _$EntityWatchlistScreeningToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is EntityWatchlistScreening &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.searchTerms, searchTerms) ||
                const DeepCollectionEquality()
                    .equals(other.searchTerms, searchTerms)) &&
            (identical(other.assignee, assignee) ||
                const DeepCollectionEquality()
                    .equals(other.assignee, assignee)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.clientUserId, clientUserId) ||
                const DeepCollectionEquality()
                    .equals(other.clientUserId, clientUserId)) &&
            (identical(other.auditTrail, auditTrail) ||
                const DeepCollectionEquality()
                    .equals(other.auditTrail, auditTrail)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(searchTerms) ^
      const DeepCollectionEquality().hash(assignee) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(clientUserId) ^
      const DeepCollectionEquality().hash(auditTrail) ^
      runtimeType.hashCode;
}

extension $EntityWatchlistScreeningExtension on EntityWatchlistScreening {
  EntityWatchlistScreening copyWith(
      {String? id,
      EntityWatchlistScreeningSearchTerms? searchTerms,
      String? assignee,
      enums.WatchlistScreeningStatus? status,
      String? clientUserId,
      WatchlistScreeningAuditTrail? auditTrail}) {
    return EntityWatchlistScreening(
        id: id ?? this.id,
        searchTerms: searchTerms ?? this.searchTerms,
        assignee: assignee ?? this.assignee,
        status: status ?? this.status,
        clientUserId: clientUserId ?? this.clientUserId,
        auditTrail: auditTrail ?? this.auditTrail);
  }

  EntityWatchlistScreening copyWithWrapped(
      {Wrapped<String>? id,
      Wrapped<EntityWatchlistScreeningSearchTerms>? searchTerms,
      Wrapped<String?>? assignee,
      Wrapped<enums.WatchlistScreeningStatus>? status,
      Wrapped<String?>? clientUserId,
      Wrapped<WatchlistScreeningAuditTrail>? auditTrail}) {
    return EntityWatchlistScreening(
        id: (id != null ? id.value : this.id),
        searchTerms:
            (searchTerms != null ? searchTerms.value : this.searchTerms),
        assignee: (assignee != null ? assignee.value : this.assignee),
        status: (status != null ? status.value : this.status),
        clientUserId:
            (clientUserId != null ? clientUserId.value : this.clientUserId),
        auditTrail: (auditTrail != null ? auditTrail.value : this.auditTrail));
  }
}

@JsonSerializable(explicitToJson: true)
class EntityWatchlistScreeningHit {
  EntityWatchlistScreeningHit({
    required this.id,
    required this.reviewStatus,
    required this.firstActive,
    required this.inactiveSince,
    required this.historicalSince,
    required this.listCode,
    required this.plaidUid,
    required this.sourceUid,
    this.analysis,
    this.data,
  });

  factory EntityWatchlistScreeningHit.fromJson(Map<String, dynamic> json) =>
      _$EntityWatchlistScreeningHitFromJson(json);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(
    name: 'review_status',
    toJson: watchlistScreeningHitStatusToJson,
    fromJson: watchlistScreeningHitStatusFromJson,
  )
  final enums.WatchlistScreeningHitStatus reviewStatus;
  @JsonKey(name: 'first_active')
  final String firstActive;
  @JsonKey(name: 'inactive_since')
  final String? inactiveSince;
  @JsonKey(name: 'historical_since')
  final String? historicalSince;
  @JsonKey(
    name: 'list_code',
    toJson: entityWatchlistCodeToJson,
    fromJson: entityWatchlistCodeFromJson,
  )
  final enums.EntityWatchlistCode listCode;
  @JsonKey(name: 'plaid_uid')
  final String plaidUid;
  @JsonKey(name: 'source_uid')
  final String? sourceUid;
  @JsonKey(name: 'analysis')
  final EntityScreeningHitAnalysis? analysis;
  @JsonKey(name: 'data')
  final EntityScreeningHitData? data;
  static const fromJsonFactory = _$EntityWatchlistScreeningHitFromJson;
  static const toJsonFactory = _$EntityWatchlistScreeningHitToJson;
  Map<String, dynamic> toJson() => _$EntityWatchlistScreeningHitToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is EntityWatchlistScreeningHit &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.reviewStatus, reviewStatus) ||
                const DeepCollectionEquality()
                    .equals(other.reviewStatus, reviewStatus)) &&
            (identical(other.firstActive, firstActive) ||
                const DeepCollectionEquality()
                    .equals(other.firstActive, firstActive)) &&
            (identical(other.inactiveSince, inactiveSince) ||
                const DeepCollectionEquality()
                    .equals(other.inactiveSince, inactiveSince)) &&
            (identical(other.historicalSince, historicalSince) ||
                const DeepCollectionEquality()
                    .equals(other.historicalSince, historicalSince)) &&
            (identical(other.listCode, listCode) ||
                const DeepCollectionEquality()
                    .equals(other.listCode, listCode)) &&
            (identical(other.plaidUid, plaidUid) ||
                const DeepCollectionEquality()
                    .equals(other.plaidUid, plaidUid)) &&
            (identical(other.sourceUid, sourceUid) ||
                const DeepCollectionEquality()
                    .equals(other.sourceUid, sourceUid)) &&
            (identical(other.analysis, analysis) ||
                const DeepCollectionEquality()
                    .equals(other.analysis, analysis)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(reviewStatus) ^
      const DeepCollectionEquality().hash(firstActive) ^
      const DeepCollectionEquality().hash(inactiveSince) ^
      const DeepCollectionEquality().hash(historicalSince) ^
      const DeepCollectionEquality().hash(listCode) ^
      const DeepCollectionEquality().hash(plaidUid) ^
      const DeepCollectionEquality().hash(sourceUid) ^
      const DeepCollectionEquality().hash(analysis) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $EntityWatchlistScreeningHitExtension on EntityWatchlistScreeningHit {
  EntityWatchlistScreeningHit copyWith(
      {String? id,
      enums.WatchlistScreeningHitStatus? reviewStatus,
      String? firstActive,
      String? inactiveSince,
      String? historicalSince,
      enums.EntityWatchlistCode? listCode,
      String? plaidUid,
      String? sourceUid,
      EntityScreeningHitAnalysis? analysis,
      EntityScreeningHitData? data}) {
    return EntityWatchlistScreeningHit(
        id: id ?? this.id,
        reviewStatus: reviewStatus ?? this.reviewStatus,
        firstActive: firstActive ?? this.firstActive,
        inactiveSince: inactiveSince ?? this.inactiveSince,
        historicalSince: historicalSince ?? this.historicalSince,
        listCode: listCode ?? this.listCode,
        plaidUid: plaidUid ?? this.plaidUid,
        sourceUid: sourceUid ?? this.sourceUid,
        analysis: analysis ?? this.analysis,
        data: data ?? this.data);
  }

  EntityWatchlistScreeningHit copyWithWrapped(
      {Wrapped<String>? id,
      Wrapped<enums.WatchlistScreeningHitStatus>? reviewStatus,
      Wrapped<String>? firstActive,
      Wrapped<String?>? inactiveSince,
      Wrapped<String?>? historicalSince,
      Wrapped<enums.EntityWatchlistCode>? listCode,
      Wrapped<String>? plaidUid,
      Wrapped<String?>? sourceUid,
      Wrapped<EntityScreeningHitAnalysis?>? analysis,
      Wrapped<EntityScreeningHitData?>? data}) {
    return EntityWatchlistScreeningHit(
        id: (id != null ? id.value : this.id),
        reviewStatus:
            (reviewStatus != null ? reviewStatus.value : this.reviewStatus),
        firstActive:
            (firstActive != null ? firstActive.value : this.firstActive),
        inactiveSince:
            (inactiveSince != null ? inactiveSince.value : this.inactiveSince),
        historicalSince: (historicalSince != null
            ? historicalSince.value
            : this.historicalSince),
        listCode: (listCode != null ? listCode.value : this.listCode),
        plaidUid: (plaidUid != null ? plaidUid.value : this.plaidUid),
        sourceUid: (sourceUid != null ? sourceUid.value : this.sourceUid),
        analysis: (analysis != null ? analysis.value : this.analysis),
        data: (data != null ? data.value : this.data));
  }
}

@JsonSerializable(explicitToJson: true)
class EntityWatchlistScreeningReview {
  EntityWatchlistScreeningReview({
    required this.id,
    required this.confirmedHits,
    required this.dismissedHits,
    required this.comment,
    required this.auditTrail,
  });

  factory EntityWatchlistScreeningReview.fromJson(Map<String, dynamic> json) =>
      _$EntityWatchlistScreeningReviewFromJson(json);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'confirmed_hits', defaultValue: <String>[])
  final List<String> confirmedHits;
  @JsonKey(name: 'dismissed_hits', defaultValue: <String>[])
  final List<String> dismissedHits;
  @JsonKey(name: 'comment')
  final String? comment;
  @JsonKey(name: 'audit_trail')
  final WatchlistScreeningAuditTrail auditTrail;
  static const fromJsonFactory = _$EntityWatchlistScreeningReviewFromJson;
  static const toJsonFactory = _$EntityWatchlistScreeningReviewToJson;
  Map<String, dynamic> toJson() => _$EntityWatchlistScreeningReviewToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is EntityWatchlistScreeningReview &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.confirmedHits, confirmedHits) ||
                const DeepCollectionEquality()
                    .equals(other.confirmedHits, confirmedHits)) &&
            (identical(other.dismissedHits, dismissedHits) ||
                const DeepCollectionEquality()
                    .equals(other.dismissedHits, dismissedHits)) &&
            (identical(other.comment, comment) ||
                const DeepCollectionEquality()
                    .equals(other.comment, comment)) &&
            (identical(other.auditTrail, auditTrail) ||
                const DeepCollectionEquality()
                    .equals(other.auditTrail, auditTrail)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(confirmedHits) ^
      const DeepCollectionEquality().hash(dismissedHits) ^
      const DeepCollectionEquality().hash(comment) ^
      const DeepCollectionEquality().hash(auditTrail) ^
      runtimeType.hashCode;
}

extension $EntityWatchlistScreeningReviewExtension
    on EntityWatchlistScreeningReview {
  EntityWatchlistScreeningReview copyWith(
      {String? id,
      List<String>? confirmedHits,
      List<String>? dismissedHits,
      String? comment,
      WatchlistScreeningAuditTrail? auditTrail}) {
    return EntityWatchlistScreeningReview(
        id: id ?? this.id,
        confirmedHits: confirmedHits ?? this.confirmedHits,
        dismissedHits: dismissedHits ?? this.dismissedHits,
        comment: comment ?? this.comment,
        auditTrail: auditTrail ?? this.auditTrail);
  }

  EntityWatchlistScreeningReview copyWithWrapped(
      {Wrapped<String>? id,
      Wrapped<List<String>>? confirmedHits,
      Wrapped<List<String>>? dismissedHits,
      Wrapped<String?>? comment,
      Wrapped<WatchlistScreeningAuditTrail>? auditTrail}) {
    return EntityWatchlistScreeningReview(
        id: (id != null ? id.value : this.id),
        confirmedHits:
            (confirmedHits != null ? confirmedHits.value : this.confirmedHits),
        dismissedHits:
            (dismissedHits != null ? dismissedHits.value : this.dismissedHits),
        comment: (comment != null ? comment.value : this.comment),
        auditTrail: (auditTrail != null ? auditTrail.value : this.auditTrail));
  }
}

@JsonSerializable(explicitToJson: true)
class EntityWatchlistScreeningSearchTerms {
  EntityWatchlistScreeningSearchTerms({
    required this.entityWatchlistProgramId,
    required this.legalName,
    required this.documentNumber,
    required this.emailAddress,
    required this.country,
    required this.phoneNumber,
    required this.url,
    required this.version,
  });

  factory EntityWatchlistScreeningSearchTerms.fromJson(
          Map<String, dynamic> json) =>
      _$EntityWatchlistScreeningSearchTermsFromJson(json);

  @JsonKey(name: 'entity_watchlist_program_id')
  final String entityWatchlistProgramId;
  @JsonKey(name: 'legal_name')
  final String legalName;
  @JsonKey(name: 'document_number')
  final String? documentNumber;
  @JsonKey(name: 'email_address')
  final String? emailAddress;
  @JsonKey(name: 'country')
  final String? country;
  @JsonKey(name: 'phone_number')
  final String? phoneNumber;
  @JsonKey(name: 'url')
  final String? url;
  @JsonKey(name: 'version')
  final double version;
  static const fromJsonFactory = _$EntityWatchlistScreeningSearchTermsFromJson;
  static const toJsonFactory = _$EntityWatchlistScreeningSearchTermsToJson;
  Map<String, dynamic> toJson() =>
      _$EntityWatchlistScreeningSearchTermsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is EntityWatchlistScreeningSearchTerms &&
            (identical(
                    other.entityWatchlistProgramId, entityWatchlistProgramId) ||
                const DeepCollectionEquality().equals(
                    other.entityWatchlistProgramId,
                    entityWatchlistProgramId)) &&
            (identical(other.legalName, legalName) ||
                const DeepCollectionEquality()
                    .equals(other.legalName, legalName)) &&
            (identical(other.documentNumber, documentNumber) ||
                const DeepCollectionEquality()
                    .equals(other.documentNumber, documentNumber)) &&
            (identical(other.emailAddress, emailAddress) ||
                const DeepCollectionEquality()
                    .equals(other.emailAddress, emailAddress)) &&
            (identical(other.country, country) ||
                const DeepCollectionEquality()
                    .equals(other.country, country)) &&
            (identical(other.phoneNumber, phoneNumber) ||
                const DeepCollectionEquality()
                    .equals(other.phoneNumber, phoneNumber)) &&
            (identical(other.url, url) ||
                const DeepCollectionEquality().equals(other.url, url)) &&
            (identical(other.version, version) ||
                const DeepCollectionEquality().equals(other.version, version)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entityWatchlistProgramId) ^
      const DeepCollectionEquality().hash(legalName) ^
      const DeepCollectionEquality().hash(documentNumber) ^
      const DeepCollectionEquality().hash(emailAddress) ^
      const DeepCollectionEquality().hash(country) ^
      const DeepCollectionEquality().hash(phoneNumber) ^
      const DeepCollectionEquality().hash(url) ^
      const DeepCollectionEquality().hash(version) ^
      runtimeType.hashCode;
}

extension $EntityWatchlistScreeningSearchTermsExtension
    on EntityWatchlistScreeningSearchTerms {
  EntityWatchlistScreeningSearchTerms copyWith(
      {String? entityWatchlistProgramId,
      String? legalName,
      String? documentNumber,
      String? emailAddress,
      String? country,
      String? phoneNumber,
      String? url,
      double? version}) {
    return EntityWatchlistScreeningSearchTerms(
        entityWatchlistProgramId:
            entityWatchlistProgramId ?? this.entityWatchlistProgramId,
        legalName: legalName ?? this.legalName,
        documentNumber: documentNumber ?? this.documentNumber,
        emailAddress: emailAddress ?? this.emailAddress,
        country: country ?? this.country,
        phoneNumber: phoneNumber ?? this.phoneNumber,
        url: url ?? this.url,
        version: version ?? this.version);
  }

  EntityWatchlistScreeningSearchTerms copyWithWrapped(
      {Wrapped<String>? entityWatchlistProgramId,
      Wrapped<String>? legalName,
      Wrapped<String?>? documentNumber,
      Wrapped<String?>? emailAddress,
      Wrapped<String?>? country,
      Wrapped<String?>? phoneNumber,
      Wrapped<String?>? url,
      Wrapped<double>? version}) {
    return EntityWatchlistScreeningSearchTerms(
        entityWatchlistProgramId: (entityWatchlistProgramId != null
            ? entityWatchlistProgramId.value
            : this.entityWatchlistProgramId),
        legalName: (legalName != null ? legalName.value : this.legalName),
        documentNumber: (documentNumber != null
            ? documentNumber.value
            : this.documentNumber),
        emailAddress:
            (emailAddress != null ? emailAddress.value : this.emailAddress),
        country: (country != null ? country.value : this.country),
        phoneNumber:
            (phoneNumber != null ? phoneNumber.value : this.phoneNumber),
        url: (url != null ? url.value : this.url),
        version: (version != null ? version.value : this.version));
  }
}

@JsonSerializable(explicitToJson: true)
class EntityWatchlistSearchTerms {
  EntityWatchlistSearchTerms({
    required this.entityWatchlistProgramId,
    required this.legalName,
    this.documentNumber,
    this.emailAddress,
    this.country,
    this.phoneNumber,
    this.url,
  });

  factory EntityWatchlistSearchTerms.fromJson(Map<String, dynamic> json) =>
      _$EntityWatchlistSearchTermsFromJson(json);

  @JsonKey(name: 'entity_watchlist_program_id')
  final String entityWatchlistProgramId;
  @JsonKey(name: 'legal_name')
  final String legalName;
  @JsonKey(name: 'document_number')
  final String? documentNumber;
  @JsonKey(name: 'email_address')
  final String? emailAddress;
  @JsonKey(name: 'country')
  final String? country;
  @JsonKey(name: 'phone_number')
  final String? phoneNumber;
  @JsonKey(name: 'url')
  final String? url;
  static const fromJsonFactory = _$EntityWatchlistSearchTermsFromJson;
  static const toJsonFactory = _$EntityWatchlistSearchTermsToJson;
  Map<String, dynamic> toJson() => _$EntityWatchlistSearchTermsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is EntityWatchlistSearchTerms &&
            (identical(
                    other.entityWatchlistProgramId, entityWatchlistProgramId) ||
                const DeepCollectionEquality().equals(
                    other.entityWatchlistProgramId,
                    entityWatchlistProgramId)) &&
            (identical(other.legalName, legalName) ||
                const DeepCollectionEquality()
                    .equals(other.legalName, legalName)) &&
            (identical(other.documentNumber, documentNumber) ||
                const DeepCollectionEquality()
                    .equals(other.documentNumber, documentNumber)) &&
            (identical(other.emailAddress, emailAddress) ||
                const DeepCollectionEquality()
                    .equals(other.emailAddress, emailAddress)) &&
            (identical(other.country, country) ||
                const DeepCollectionEquality()
                    .equals(other.country, country)) &&
            (identical(other.phoneNumber, phoneNumber) ||
                const DeepCollectionEquality()
                    .equals(other.phoneNumber, phoneNumber)) &&
            (identical(other.url, url) ||
                const DeepCollectionEquality().equals(other.url, url)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entityWatchlistProgramId) ^
      const DeepCollectionEquality().hash(legalName) ^
      const DeepCollectionEquality().hash(documentNumber) ^
      const DeepCollectionEquality().hash(emailAddress) ^
      const DeepCollectionEquality().hash(country) ^
      const DeepCollectionEquality().hash(phoneNumber) ^
      const DeepCollectionEquality().hash(url) ^
      runtimeType.hashCode;
}

extension $EntityWatchlistSearchTermsExtension on EntityWatchlistSearchTerms {
  EntityWatchlistSearchTerms copyWith(
      {String? entityWatchlistProgramId,
      String? legalName,
      String? documentNumber,
      String? emailAddress,
      String? country,
      String? phoneNumber,
      String? url}) {
    return EntityWatchlistSearchTerms(
        entityWatchlistProgramId:
            entityWatchlistProgramId ?? this.entityWatchlistProgramId,
        legalName: legalName ?? this.legalName,
        documentNumber: documentNumber ?? this.documentNumber,
        emailAddress: emailAddress ?? this.emailAddress,
        country: country ?? this.country,
        phoneNumber: phoneNumber ?? this.phoneNumber,
        url: url ?? this.url);
  }

  EntityWatchlistSearchTerms copyWithWrapped(
      {Wrapped<String>? entityWatchlistProgramId,
      Wrapped<String>? legalName,
      Wrapped<String?>? documentNumber,
      Wrapped<String?>? emailAddress,
      Wrapped<String?>? country,
      Wrapped<String?>? phoneNumber,
      Wrapped<String?>? url}) {
    return EntityWatchlistSearchTerms(
        entityWatchlistProgramId: (entityWatchlistProgramId != null
            ? entityWatchlistProgramId.value
            : this.entityWatchlistProgramId),
        legalName: (legalName != null ? legalName.value : this.legalName),
        documentNumber: (documentNumber != null
            ? documentNumber.value
            : this.documentNumber),
        emailAddress:
            (emailAddress != null ? emailAddress.value : this.emailAddress),
        country: (country != null ? country.value : this.country),
        phoneNumber:
            (phoneNumber != null ? phoneNumber.value : this.phoneNumber),
        url: (url != null ? url.value : this.url));
  }
}

@JsonSerializable(explicitToJson: true)
class GenericScreeningHitLocationItems {
  GenericScreeningHitLocationItems({
    this.analysis,
    this.data,
  });

  factory GenericScreeningHitLocationItems.fromJson(
          Map<String, dynamic> json) =>
      _$GenericScreeningHitLocationItemsFromJson(json);

  @JsonKey(name: 'analysis')
  final MatchSummary? analysis;
  @JsonKey(name: 'data')
  final WatchlistScreeningHitLocations? data;
  static const fromJsonFactory = _$GenericScreeningHitLocationItemsFromJson;
  static const toJsonFactory = _$GenericScreeningHitLocationItemsToJson;
  Map<String, dynamic> toJson() =>
      _$GenericScreeningHitLocationItemsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is GenericScreeningHitLocationItems &&
            (identical(other.analysis, analysis) ||
                const DeepCollectionEquality()
                    .equals(other.analysis, analysis)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(analysis) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $GenericScreeningHitLocationItemsExtension
    on GenericScreeningHitLocationItems {
  GenericScreeningHitLocationItems copyWith(
      {MatchSummary? analysis, WatchlistScreeningHitLocations? data}) {
    return GenericScreeningHitLocationItems(
        analysis: analysis ?? this.analysis, data: data ?? this.data);
  }

  GenericScreeningHitLocationItems copyWithWrapped(
      {Wrapped<MatchSummary?>? analysis,
      Wrapped<WatchlistScreeningHitLocations?>? data}) {
    return GenericScreeningHitLocationItems(
        analysis: (analysis != null ? analysis.value : this.analysis),
        data: (data != null ? data.value : this.data));
  }
}

@JsonSerializable(explicitToJson: true)
class IdentityVerification {
  IdentityVerification({
    required this.id,
    required this.clientUserId,
    required this.createdAt,
    required this.completedAt,
    required this.previousAttemptId,
    required this.shareableUrl,
    required this.template,
    required this.user,
    required this.status,
    required this.steps,
    required this.documentaryVerification,
    required this.kycCheck,
    required this.watchlistScreeningId,
  });

  factory IdentityVerification.fromJson(Map<String, dynamic> json) =>
      _$IdentityVerificationFromJson(json);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'client_user_id')
  final String clientUserId;
  @JsonKey(name: 'created_at')
  final String createdAt;
  @JsonKey(name: 'completed_at')
  final String? completedAt;
  @JsonKey(name: 'previous_attempt_id')
  final String? previousAttemptId;
  @JsonKey(name: 'shareable_url')
  final String? shareableUrl;
  @JsonKey(name: 'template')
  final IdentityVerificationTemplateReference template;
  @JsonKey(name: 'user')
  final IdentityVerificationUserData user;
  @JsonKey(
    name: 'status',
    toJson: identityVerificationStatusToJson,
    fromJson: identityVerificationStatusFromJson,
  )
  final enums.IdentityVerificationStatus status;
  @JsonKey(name: 'steps')
  final IdentityVerificationStepSummary steps;
  @JsonKey(name: 'documentary_verification')
  final DocumentaryVerification? documentaryVerification;
  @JsonKey(name: 'kyc_check')
  final KYCCheckDetails? kycCheck;
  @JsonKey(name: 'watchlist_screening_id')
  final String? watchlistScreeningId;
  static const fromJsonFactory = _$IdentityVerificationFromJson;
  static const toJsonFactory = _$IdentityVerificationToJson;
  Map<String, dynamic> toJson() => _$IdentityVerificationToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IdentityVerification &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.clientUserId, clientUserId) ||
                const DeepCollectionEquality()
                    .equals(other.clientUserId, clientUserId)) &&
            (identical(other.createdAt, createdAt) ||
                const DeepCollectionEquality()
                    .equals(other.createdAt, createdAt)) &&
            (identical(other.completedAt, completedAt) ||
                const DeepCollectionEquality()
                    .equals(other.completedAt, completedAt)) &&
            (identical(other.previousAttemptId, previousAttemptId) ||
                const DeepCollectionEquality()
                    .equals(other.previousAttemptId, previousAttemptId)) &&
            (identical(other.shareableUrl, shareableUrl) ||
                const DeepCollectionEquality()
                    .equals(other.shareableUrl, shareableUrl)) &&
            (identical(other.template, template) ||
                const DeepCollectionEquality()
                    .equals(other.template, template)) &&
            (identical(other.user, user) ||
                const DeepCollectionEquality().equals(other.user, user)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.steps, steps) ||
                const DeepCollectionEquality().equals(other.steps, steps)) &&
            (identical(
                    other.documentaryVerification, documentaryVerification) ||
                const DeepCollectionEquality().equals(
                    other.documentaryVerification, documentaryVerification)) &&
            (identical(other.kycCheck, kycCheck) ||
                const DeepCollectionEquality()
                    .equals(other.kycCheck, kycCheck)) &&
            (identical(other.watchlistScreeningId, watchlistScreeningId) ||
                const DeepCollectionEquality()
                    .equals(other.watchlistScreeningId, watchlistScreeningId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(clientUserId) ^
      const DeepCollectionEquality().hash(createdAt) ^
      const DeepCollectionEquality().hash(completedAt) ^
      const DeepCollectionEquality().hash(previousAttemptId) ^
      const DeepCollectionEquality().hash(shareableUrl) ^
      const DeepCollectionEquality().hash(template) ^
      const DeepCollectionEquality().hash(user) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(steps) ^
      const DeepCollectionEquality().hash(documentaryVerification) ^
      const DeepCollectionEquality().hash(kycCheck) ^
      const DeepCollectionEquality().hash(watchlistScreeningId) ^
      runtimeType.hashCode;
}

extension $IdentityVerificationExtension on IdentityVerification {
  IdentityVerification copyWith(
      {String? id,
      String? clientUserId,
      String? createdAt,
      String? completedAt,
      String? previousAttemptId,
      String? shareableUrl,
      IdentityVerificationTemplateReference? template,
      IdentityVerificationUserData? user,
      enums.IdentityVerificationStatus? status,
      IdentityVerificationStepSummary? steps,
      DocumentaryVerification? documentaryVerification,
      KYCCheckDetails? kycCheck,
      String? watchlistScreeningId}) {
    return IdentityVerification(
        id: id ?? this.id,
        clientUserId: clientUserId ?? this.clientUserId,
        createdAt: createdAt ?? this.createdAt,
        completedAt: completedAt ?? this.completedAt,
        previousAttemptId: previousAttemptId ?? this.previousAttemptId,
        shareableUrl: shareableUrl ?? this.shareableUrl,
        template: template ?? this.template,
        user: user ?? this.user,
        status: status ?? this.status,
        steps: steps ?? this.steps,
        documentaryVerification:
            documentaryVerification ?? this.documentaryVerification,
        kycCheck: kycCheck ?? this.kycCheck,
        watchlistScreeningId:
            watchlistScreeningId ?? this.watchlistScreeningId);
  }

  IdentityVerification copyWithWrapped(
      {Wrapped<String>? id,
      Wrapped<String>? clientUserId,
      Wrapped<String>? createdAt,
      Wrapped<String?>? completedAt,
      Wrapped<String?>? previousAttemptId,
      Wrapped<String?>? shareableUrl,
      Wrapped<IdentityVerificationTemplateReference>? template,
      Wrapped<IdentityVerificationUserData>? user,
      Wrapped<enums.IdentityVerificationStatus>? status,
      Wrapped<IdentityVerificationStepSummary>? steps,
      Wrapped<DocumentaryVerification?>? documentaryVerification,
      Wrapped<KYCCheckDetails?>? kycCheck,
      Wrapped<String?>? watchlistScreeningId}) {
    return IdentityVerification(
        id: (id != null ? id.value : this.id),
        clientUserId:
            (clientUserId != null ? clientUserId.value : this.clientUserId),
        createdAt: (createdAt != null ? createdAt.value : this.createdAt),
        completedAt:
            (completedAt != null ? completedAt.value : this.completedAt),
        previousAttemptId: (previousAttemptId != null
            ? previousAttemptId.value
            : this.previousAttemptId),
        shareableUrl:
            (shareableUrl != null ? shareableUrl.value : this.shareableUrl),
        template: (template != null ? template.value : this.template),
        user: (user != null ? user.value : this.user),
        status: (status != null ? status.value : this.status),
        steps: (steps != null ? steps.value : this.steps),
        documentaryVerification: (documentaryVerification != null
            ? documentaryVerification.value
            : this.documentaryVerification),
        kycCheck: (kycCheck != null ? kycCheck.value : this.kycCheck),
        watchlistScreeningId: (watchlistScreeningId != null
            ? watchlistScreeningId.value
            : this.watchlistScreeningId));
  }
}

@JsonSerializable(explicitToJson: true)
class IdentityVerificationCreateRequest {
  IdentityVerificationCreateRequest({
    required this.isShareable,
    required this.templateId,
    required this.gaveConsent,
    required this.user,
    this.clientId,
    this.secret,
    this.isIdempotent,
  });

  factory IdentityVerificationCreateRequest.fromJson(
          Map<String, dynamic> json) =>
      _$IdentityVerificationCreateRequestFromJson(json);

  @JsonKey(name: 'is_shareable')
  final bool isShareable;
  @JsonKey(name: 'template_id')
  final String templateId;
  @JsonKey(name: 'gave_consent')
  final bool gaveConsent;
  @JsonKey(name: 'user')
  final IdentityVerificationRequestUser user;
  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'is_idempotent')
  final bool? isIdempotent;
  static const fromJsonFactory = _$IdentityVerificationCreateRequestFromJson;
  static const toJsonFactory = _$IdentityVerificationCreateRequestToJson;
  Map<String, dynamic> toJson() =>
      _$IdentityVerificationCreateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IdentityVerificationCreateRequest &&
            (identical(other.isShareable, isShareable) ||
                const DeepCollectionEquality()
                    .equals(other.isShareable, isShareable)) &&
            (identical(other.templateId, templateId) ||
                const DeepCollectionEquality()
                    .equals(other.templateId, templateId)) &&
            (identical(other.gaveConsent, gaveConsent) ||
                const DeepCollectionEquality()
                    .equals(other.gaveConsent, gaveConsent)) &&
            (identical(other.user, user) ||
                const DeepCollectionEquality().equals(other.user, user)) &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.isIdempotent, isIdempotent) ||
                const DeepCollectionEquality()
                    .equals(other.isIdempotent, isIdempotent)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(isShareable) ^
      const DeepCollectionEquality().hash(templateId) ^
      const DeepCollectionEquality().hash(gaveConsent) ^
      const DeepCollectionEquality().hash(user) ^
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(isIdempotent) ^
      runtimeType.hashCode;
}

extension $IdentityVerificationCreateRequestExtension
    on IdentityVerificationCreateRequest {
  IdentityVerificationCreateRequest copyWith(
      {bool? isShareable,
      String? templateId,
      bool? gaveConsent,
      IdentityVerificationRequestUser? user,
      String? clientId,
      String? secret,
      bool? isIdempotent}) {
    return IdentityVerificationCreateRequest(
        isShareable: isShareable ?? this.isShareable,
        templateId: templateId ?? this.templateId,
        gaveConsent: gaveConsent ?? this.gaveConsent,
        user: user ?? this.user,
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        isIdempotent: isIdempotent ?? this.isIdempotent);
  }

  IdentityVerificationCreateRequest copyWithWrapped(
      {Wrapped<bool>? isShareable,
      Wrapped<String>? templateId,
      Wrapped<bool>? gaveConsent,
      Wrapped<IdentityVerificationRequestUser>? user,
      Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<bool?>? isIdempotent}) {
    return IdentityVerificationCreateRequest(
        isShareable:
            (isShareable != null ? isShareable.value : this.isShareable),
        templateId: (templateId != null ? templateId.value : this.templateId),
        gaveConsent:
            (gaveConsent != null ? gaveConsent.value : this.gaveConsent),
        user: (user != null ? user.value : this.user),
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        isIdempotent:
            (isIdempotent != null ? isIdempotent.value : this.isIdempotent));
  }
}

@JsonSerializable(explicitToJson: true)
class IdentityVerificationCreateResponse {
  IdentityVerificationCreateResponse({
    required this.id,
    required this.clientUserId,
    required this.createdAt,
    required this.completedAt,
    required this.previousAttemptId,
    required this.shareableUrl,
    required this.template,
    required this.user,
    required this.status,
    required this.steps,
    required this.documentaryVerification,
    required this.kycCheck,
    required this.watchlistScreeningId,
    required this.requestId,
  });

  factory IdentityVerificationCreateResponse.fromJson(
          Map<String, dynamic> json) =>
      _$IdentityVerificationCreateResponseFromJson(json);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'client_user_id')
  final String clientUserId;
  @JsonKey(name: 'created_at')
  final String createdAt;
  @JsonKey(name: 'completed_at')
  final String? completedAt;
  @JsonKey(name: 'previous_attempt_id')
  final String? previousAttemptId;
  @JsonKey(name: 'shareable_url')
  final String? shareableUrl;
  @JsonKey(name: 'template')
  final IdentityVerificationTemplateReference template;
  @JsonKey(name: 'user')
  final IdentityVerificationUserData user;
  @JsonKey(
    name: 'status',
    toJson: identityVerificationStatusToJson,
    fromJson: identityVerificationStatusFromJson,
  )
  final enums.IdentityVerificationStatus status;
  @JsonKey(name: 'steps')
  final IdentityVerificationStepSummary steps;
  @JsonKey(name: 'documentary_verification')
  final DocumentaryVerification? documentaryVerification;
  @JsonKey(name: 'kyc_check')
  final KYCCheckDetails? kycCheck;
  @JsonKey(name: 'watchlist_screening_id')
  final String? watchlistScreeningId;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$IdentityVerificationCreateResponseFromJson;
  static const toJsonFactory = _$IdentityVerificationCreateResponseToJson;
  Map<String, dynamic> toJson() =>
      _$IdentityVerificationCreateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IdentityVerificationCreateResponse &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.clientUserId, clientUserId) ||
                const DeepCollectionEquality()
                    .equals(other.clientUserId, clientUserId)) &&
            (identical(other.createdAt, createdAt) ||
                const DeepCollectionEquality()
                    .equals(other.createdAt, createdAt)) &&
            (identical(other.completedAt, completedAt) ||
                const DeepCollectionEquality()
                    .equals(other.completedAt, completedAt)) &&
            (identical(other.previousAttemptId, previousAttemptId) ||
                const DeepCollectionEquality()
                    .equals(other.previousAttemptId, previousAttemptId)) &&
            (identical(other.shareableUrl, shareableUrl) ||
                const DeepCollectionEquality()
                    .equals(other.shareableUrl, shareableUrl)) &&
            (identical(other.template, template) ||
                const DeepCollectionEquality()
                    .equals(other.template, template)) &&
            (identical(other.user, user) ||
                const DeepCollectionEquality().equals(other.user, user)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.steps, steps) ||
                const DeepCollectionEquality().equals(other.steps, steps)) &&
            (identical(
                    other.documentaryVerification, documentaryVerification) ||
                const DeepCollectionEquality().equals(
                    other.documentaryVerification, documentaryVerification)) &&
            (identical(other.kycCheck, kycCheck) ||
                const DeepCollectionEquality()
                    .equals(other.kycCheck, kycCheck)) &&
            (identical(other.watchlistScreeningId, watchlistScreeningId) ||
                const DeepCollectionEquality().equals(
                    other.watchlistScreeningId, watchlistScreeningId)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(clientUserId) ^
      const DeepCollectionEquality().hash(createdAt) ^
      const DeepCollectionEquality().hash(completedAt) ^
      const DeepCollectionEquality().hash(previousAttemptId) ^
      const DeepCollectionEquality().hash(shareableUrl) ^
      const DeepCollectionEquality().hash(template) ^
      const DeepCollectionEquality().hash(user) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(steps) ^
      const DeepCollectionEquality().hash(documentaryVerification) ^
      const DeepCollectionEquality().hash(kycCheck) ^
      const DeepCollectionEquality().hash(watchlistScreeningId) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $IdentityVerificationCreateResponseExtension
    on IdentityVerificationCreateResponse {
  IdentityVerificationCreateResponse copyWith(
      {String? id,
      String? clientUserId,
      String? createdAt,
      String? completedAt,
      String? previousAttemptId,
      String? shareableUrl,
      IdentityVerificationTemplateReference? template,
      IdentityVerificationUserData? user,
      enums.IdentityVerificationStatus? status,
      IdentityVerificationStepSummary? steps,
      DocumentaryVerification? documentaryVerification,
      KYCCheckDetails? kycCheck,
      String? watchlistScreeningId,
      String? requestId}) {
    return IdentityVerificationCreateResponse(
        id: id ?? this.id,
        clientUserId: clientUserId ?? this.clientUserId,
        createdAt: createdAt ?? this.createdAt,
        completedAt: completedAt ?? this.completedAt,
        previousAttemptId: previousAttemptId ?? this.previousAttemptId,
        shareableUrl: shareableUrl ?? this.shareableUrl,
        template: template ?? this.template,
        user: user ?? this.user,
        status: status ?? this.status,
        steps: steps ?? this.steps,
        documentaryVerification:
            documentaryVerification ?? this.documentaryVerification,
        kycCheck: kycCheck ?? this.kycCheck,
        watchlistScreeningId: watchlistScreeningId ?? this.watchlistScreeningId,
        requestId: requestId ?? this.requestId);
  }

  IdentityVerificationCreateResponse copyWithWrapped(
      {Wrapped<String>? id,
      Wrapped<String>? clientUserId,
      Wrapped<String>? createdAt,
      Wrapped<String?>? completedAt,
      Wrapped<String?>? previousAttemptId,
      Wrapped<String?>? shareableUrl,
      Wrapped<IdentityVerificationTemplateReference>? template,
      Wrapped<IdentityVerificationUserData>? user,
      Wrapped<enums.IdentityVerificationStatus>? status,
      Wrapped<IdentityVerificationStepSummary>? steps,
      Wrapped<DocumentaryVerification?>? documentaryVerification,
      Wrapped<KYCCheckDetails?>? kycCheck,
      Wrapped<String?>? watchlistScreeningId,
      Wrapped<String>? requestId}) {
    return IdentityVerificationCreateResponse(
        id: (id != null ? id.value : this.id),
        clientUserId:
            (clientUserId != null ? clientUserId.value : this.clientUserId),
        createdAt: (createdAt != null ? createdAt.value : this.createdAt),
        completedAt:
            (completedAt != null ? completedAt.value : this.completedAt),
        previousAttemptId: (previousAttemptId != null
            ? previousAttemptId.value
            : this.previousAttemptId),
        shareableUrl:
            (shareableUrl != null ? shareableUrl.value : this.shareableUrl),
        template: (template != null ? template.value : this.template),
        user: (user != null ? user.value : this.user),
        status: (status != null ? status.value : this.status),
        steps: (steps != null ? steps.value : this.steps),
        documentaryVerification: (documentaryVerification != null
            ? documentaryVerification.value
            : this.documentaryVerification),
        kycCheck: (kycCheck != null ? kycCheck.value : this.kycCheck),
        watchlistScreeningId: (watchlistScreeningId != null
            ? watchlistScreeningId.value
            : this.watchlistScreeningId),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class IdentityVerificationGetRequest {
  IdentityVerificationGetRequest({
    required this.identityVerificationId,
    this.secret,
    this.clientId,
  });

  factory IdentityVerificationGetRequest.fromJson(Map<String, dynamic> json) =>
      _$IdentityVerificationGetRequestFromJson(json);

  @JsonKey(name: 'identity_verification_id')
  final String identityVerificationId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'client_id')
  final String? clientId;
  static const fromJsonFactory = _$IdentityVerificationGetRequestFromJson;
  static const toJsonFactory = _$IdentityVerificationGetRequestToJson;
  Map<String, dynamic> toJson() => _$IdentityVerificationGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IdentityVerificationGetRequest &&
            (identical(other.identityVerificationId, identityVerificationId) ||
                const DeepCollectionEquality().equals(
                    other.identityVerificationId, identityVerificationId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(identityVerificationId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(clientId) ^
      runtimeType.hashCode;
}

extension $IdentityVerificationGetRequestExtension
    on IdentityVerificationGetRequest {
  IdentityVerificationGetRequest copyWith(
      {String? identityVerificationId, String? secret, String? clientId}) {
    return IdentityVerificationGetRequest(
        identityVerificationId:
            identityVerificationId ?? this.identityVerificationId,
        secret: secret ?? this.secret,
        clientId: clientId ?? this.clientId);
  }

  IdentityVerificationGetRequest copyWithWrapped(
      {Wrapped<String>? identityVerificationId,
      Wrapped<String?>? secret,
      Wrapped<String?>? clientId}) {
    return IdentityVerificationGetRequest(
        identityVerificationId: (identityVerificationId != null
            ? identityVerificationId.value
            : this.identityVerificationId),
        secret: (secret != null ? secret.value : this.secret),
        clientId: (clientId != null ? clientId.value : this.clientId));
  }
}

@JsonSerializable(explicitToJson: true)
class IdentityVerificationGetResponse {
  IdentityVerificationGetResponse({
    required this.id,
    required this.clientUserId,
    required this.createdAt,
    required this.completedAt,
    required this.previousAttemptId,
    required this.shareableUrl,
    required this.template,
    required this.user,
    required this.status,
    required this.steps,
    required this.documentaryVerification,
    required this.kycCheck,
    required this.watchlistScreeningId,
    required this.requestId,
  });

  factory IdentityVerificationGetResponse.fromJson(Map<String, dynamic> json) =>
      _$IdentityVerificationGetResponseFromJson(json);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'client_user_id')
  final String clientUserId;
  @JsonKey(name: 'created_at')
  final String createdAt;
  @JsonKey(name: 'completed_at')
  final String? completedAt;
  @JsonKey(name: 'previous_attempt_id')
  final String? previousAttemptId;
  @JsonKey(name: 'shareable_url')
  final String? shareableUrl;
  @JsonKey(name: 'template')
  final IdentityVerificationTemplateReference template;
  @JsonKey(name: 'user')
  final IdentityVerificationUserData user;
  @JsonKey(
    name: 'status',
    toJson: identityVerificationStatusToJson,
    fromJson: identityVerificationStatusFromJson,
  )
  final enums.IdentityVerificationStatus status;
  @JsonKey(name: 'steps')
  final IdentityVerificationStepSummary steps;
  @JsonKey(name: 'documentary_verification')
  final DocumentaryVerification? documentaryVerification;
  @JsonKey(name: 'kyc_check')
  final KYCCheckDetails? kycCheck;
  @JsonKey(name: 'watchlist_screening_id')
  final String? watchlistScreeningId;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$IdentityVerificationGetResponseFromJson;
  static const toJsonFactory = _$IdentityVerificationGetResponseToJson;
  Map<String, dynamic> toJson() =>
      _$IdentityVerificationGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IdentityVerificationGetResponse &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.clientUserId, clientUserId) ||
                const DeepCollectionEquality()
                    .equals(other.clientUserId, clientUserId)) &&
            (identical(other.createdAt, createdAt) ||
                const DeepCollectionEquality()
                    .equals(other.createdAt, createdAt)) &&
            (identical(other.completedAt, completedAt) ||
                const DeepCollectionEquality()
                    .equals(other.completedAt, completedAt)) &&
            (identical(other.previousAttemptId, previousAttemptId) ||
                const DeepCollectionEquality()
                    .equals(other.previousAttemptId, previousAttemptId)) &&
            (identical(other.shareableUrl, shareableUrl) ||
                const DeepCollectionEquality()
                    .equals(other.shareableUrl, shareableUrl)) &&
            (identical(other.template, template) ||
                const DeepCollectionEquality()
                    .equals(other.template, template)) &&
            (identical(other.user, user) ||
                const DeepCollectionEquality().equals(other.user, user)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.steps, steps) ||
                const DeepCollectionEquality().equals(other.steps, steps)) &&
            (identical(
                    other.documentaryVerification, documentaryVerification) ||
                const DeepCollectionEquality().equals(
                    other.documentaryVerification, documentaryVerification)) &&
            (identical(other.kycCheck, kycCheck) ||
                const DeepCollectionEquality()
                    .equals(other.kycCheck, kycCheck)) &&
            (identical(other.watchlistScreeningId, watchlistScreeningId) ||
                const DeepCollectionEquality().equals(
                    other.watchlistScreeningId, watchlistScreeningId)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(clientUserId) ^
      const DeepCollectionEquality().hash(createdAt) ^
      const DeepCollectionEquality().hash(completedAt) ^
      const DeepCollectionEquality().hash(previousAttemptId) ^
      const DeepCollectionEquality().hash(shareableUrl) ^
      const DeepCollectionEquality().hash(template) ^
      const DeepCollectionEquality().hash(user) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(steps) ^
      const DeepCollectionEquality().hash(documentaryVerification) ^
      const DeepCollectionEquality().hash(kycCheck) ^
      const DeepCollectionEquality().hash(watchlistScreeningId) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $IdentityVerificationGetResponseExtension
    on IdentityVerificationGetResponse {
  IdentityVerificationGetResponse copyWith(
      {String? id,
      String? clientUserId,
      String? createdAt,
      String? completedAt,
      String? previousAttemptId,
      String? shareableUrl,
      IdentityVerificationTemplateReference? template,
      IdentityVerificationUserData? user,
      enums.IdentityVerificationStatus? status,
      IdentityVerificationStepSummary? steps,
      DocumentaryVerification? documentaryVerification,
      KYCCheckDetails? kycCheck,
      String? watchlistScreeningId,
      String? requestId}) {
    return IdentityVerificationGetResponse(
        id: id ?? this.id,
        clientUserId: clientUserId ?? this.clientUserId,
        createdAt: createdAt ?? this.createdAt,
        completedAt: completedAt ?? this.completedAt,
        previousAttemptId: previousAttemptId ?? this.previousAttemptId,
        shareableUrl: shareableUrl ?? this.shareableUrl,
        template: template ?? this.template,
        user: user ?? this.user,
        status: status ?? this.status,
        steps: steps ?? this.steps,
        documentaryVerification:
            documentaryVerification ?? this.documentaryVerification,
        kycCheck: kycCheck ?? this.kycCheck,
        watchlistScreeningId: watchlistScreeningId ?? this.watchlistScreeningId,
        requestId: requestId ?? this.requestId);
  }

  IdentityVerificationGetResponse copyWithWrapped(
      {Wrapped<String>? id,
      Wrapped<String>? clientUserId,
      Wrapped<String>? createdAt,
      Wrapped<String?>? completedAt,
      Wrapped<String?>? previousAttemptId,
      Wrapped<String?>? shareableUrl,
      Wrapped<IdentityVerificationTemplateReference>? template,
      Wrapped<IdentityVerificationUserData>? user,
      Wrapped<enums.IdentityVerificationStatus>? status,
      Wrapped<IdentityVerificationStepSummary>? steps,
      Wrapped<DocumentaryVerification?>? documentaryVerification,
      Wrapped<KYCCheckDetails?>? kycCheck,
      Wrapped<String?>? watchlistScreeningId,
      Wrapped<String>? requestId}) {
    return IdentityVerificationGetResponse(
        id: (id != null ? id.value : this.id),
        clientUserId:
            (clientUserId != null ? clientUserId.value : this.clientUserId),
        createdAt: (createdAt != null ? createdAt.value : this.createdAt),
        completedAt:
            (completedAt != null ? completedAt.value : this.completedAt),
        previousAttemptId: (previousAttemptId != null
            ? previousAttemptId.value
            : this.previousAttemptId),
        shareableUrl:
            (shareableUrl != null ? shareableUrl.value : this.shareableUrl),
        template: (template != null ? template.value : this.template),
        user: (user != null ? user.value : this.user),
        status: (status != null ? status.value : this.status),
        steps: (steps != null ? steps.value : this.steps),
        documentaryVerification: (documentaryVerification != null
            ? documentaryVerification.value
            : this.documentaryVerification),
        kycCheck: (kycCheck != null ? kycCheck.value : this.kycCheck),
        watchlistScreeningId: (watchlistScreeningId != null
            ? watchlistScreeningId.value
            : this.watchlistScreeningId),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class IdentityVerificationListRequest {
  IdentityVerificationListRequest({
    this.secret,
    this.clientId,
    required this.templateId,
    required this.clientUserId,
    this.cursor,
  });

  factory IdentityVerificationListRequest.fromJson(Map<String, dynamic> json) =>
      _$IdentityVerificationListRequestFromJson(json);

  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'template_id')
  final String templateId;
  @JsonKey(name: 'client_user_id')
  final String clientUserId;
  @JsonKey(name: 'cursor')
  final String? cursor;
  static const fromJsonFactory = _$IdentityVerificationListRequestFromJson;
  static const toJsonFactory = _$IdentityVerificationListRequestToJson;
  Map<String, dynamic> toJson() =>
      _$IdentityVerificationListRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IdentityVerificationListRequest &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.templateId, templateId) ||
                const DeepCollectionEquality()
                    .equals(other.templateId, templateId)) &&
            (identical(other.clientUserId, clientUserId) ||
                const DeepCollectionEquality()
                    .equals(other.clientUserId, clientUserId)) &&
            (identical(other.cursor, cursor) ||
                const DeepCollectionEquality().equals(other.cursor, cursor)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(templateId) ^
      const DeepCollectionEquality().hash(clientUserId) ^
      const DeepCollectionEquality().hash(cursor) ^
      runtimeType.hashCode;
}

extension $IdentityVerificationListRequestExtension
    on IdentityVerificationListRequest {
  IdentityVerificationListRequest copyWith(
      {String? secret,
      String? clientId,
      String? templateId,
      String? clientUserId,
      String? cursor}) {
    return IdentityVerificationListRequest(
        secret: secret ?? this.secret,
        clientId: clientId ?? this.clientId,
        templateId: templateId ?? this.templateId,
        clientUserId: clientUserId ?? this.clientUserId,
        cursor: cursor ?? this.cursor);
  }

  IdentityVerificationListRequest copyWithWrapped(
      {Wrapped<String?>? secret,
      Wrapped<String?>? clientId,
      Wrapped<String>? templateId,
      Wrapped<String>? clientUserId,
      Wrapped<String?>? cursor}) {
    return IdentityVerificationListRequest(
        secret: (secret != null ? secret.value : this.secret),
        clientId: (clientId != null ? clientId.value : this.clientId),
        templateId: (templateId != null ? templateId.value : this.templateId),
        clientUserId:
            (clientUserId != null ? clientUserId.value : this.clientUserId),
        cursor: (cursor != null ? cursor.value : this.cursor));
  }
}

@JsonSerializable(explicitToJson: true)
class IdentityVerificationListResponse {
  IdentityVerificationListResponse({
    required this.identityVerifications,
    required this.nextCursor,
    required this.requestId,
  });

  factory IdentityVerificationListResponse.fromJson(
          Map<String, dynamic> json) =>
      _$IdentityVerificationListResponseFromJson(json);

  @JsonKey(
      name: 'identity_verifications', defaultValue: <IdentityVerification>[])
  final List<IdentityVerification> identityVerifications;
  @JsonKey(name: 'next_cursor')
  final String? nextCursor;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$IdentityVerificationListResponseFromJson;
  static const toJsonFactory = _$IdentityVerificationListResponseToJson;
  Map<String, dynamic> toJson() =>
      _$IdentityVerificationListResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IdentityVerificationListResponse &&
            (identical(other.identityVerifications, identityVerifications) ||
                const DeepCollectionEquality().equals(
                    other.identityVerifications, identityVerifications)) &&
            (identical(other.nextCursor, nextCursor) ||
                const DeepCollectionEquality()
                    .equals(other.nextCursor, nextCursor)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(identityVerifications) ^
      const DeepCollectionEquality().hash(nextCursor) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $IdentityVerificationListResponseExtension
    on IdentityVerificationListResponse {
  IdentityVerificationListResponse copyWith(
      {List<IdentityVerification>? identityVerifications,
      String? nextCursor,
      String? requestId}) {
    return IdentityVerificationListResponse(
        identityVerifications:
            identityVerifications ?? this.identityVerifications,
        nextCursor: nextCursor ?? this.nextCursor,
        requestId: requestId ?? this.requestId);
  }

  IdentityVerificationListResponse copyWithWrapped(
      {Wrapped<List<IdentityVerification>>? identityVerifications,
      Wrapped<String?>? nextCursor,
      Wrapped<String>? requestId}) {
    return IdentityVerificationListResponse(
        identityVerifications: (identityVerifications != null
            ? identityVerifications.value
            : this.identityVerifications),
        nextCursor: (nextCursor != null ? nextCursor.value : this.nextCursor),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class IdentityVerificationRequestUser {
  IdentityVerificationRequestUser({
    required this.clientUserId,
    this.emailAddress,
    this.phoneNumber,
    this.dateOfBirth,
    this.name,
    this.address,
    this.idNumber,
  });

  factory IdentityVerificationRequestUser.fromJson(Map<String, dynamic> json) =>
      _$IdentityVerificationRequestUserFromJson(json);

  @JsonKey(name: 'client_user_id')
  final String clientUserId;
  @JsonKey(name: 'email_address')
  final String? emailAddress;
  @JsonKey(name: 'phone_number')
  final String? phoneNumber;
  @JsonKey(name: 'date_of_birth')
  final String? dateOfBirth;
  @JsonKey(name: 'name')
  final UserName? name;
  @JsonKey(name: 'address')
  final UserAddress? address;
  @JsonKey(name: 'id_number')
  final UserIDNumber? idNumber;
  static const fromJsonFactory = _$IdentityVerificationRequestUserFromJson;
  static const toJsonFactory = _$IdentityVerificationRequestUserToJson;
  Map<String, dynamic> toJson() =>
      _$IdentityVerificationRequestUserToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IdentityVerificationRequestUser &&
            (identical(other.clientUserId, clientUserId) ||
                const DeepCollectionEquality()
                    .equals(other.clientUserId, clientUserId)) &&
            (identical(other.emailAddress, emailAddress) ||
                const DeepCollectionEquality()
                    .equals(other.emailAddress, emailAddress)) &&
            (identical(other.phoneNumber, phoneNumber) ||
                const DeepCollectionEquality()
                    .equals(other.phoneNumber, phoneNumber)) &&
            (identical(other.dateOfBirth, dateOfBirth) ||
                const DeepCollectionEquality()
                    .equals(other.dateOfBirth, dateOfBirth)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality()
                    .equals(other.address, address)) &&
            (identical(other.idNumber, idNumber) ||
                const DeepCollectionEquality()
                    .equals(other.idNumber, idNumber)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientUserId) ^
      const DeepCollectionEquality().hash(emailAddress) ^
      const DeepCollectionEquality().hash(phoneNumber) ^
      const DeepCollectionEquality().hash(dateOfBirth) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(idNumber) ^
      runtimeType.hashCode;
}

extension $IdentityVerificationRequestUserExtension
    on IdentityVerificationRequestUser {
  IdentityVerificationRequestUser copyWith(
      {String? clientUserId,
      String? emailAddress,
      String? phoneNumber,
      String? dateOfBirth,
      UserName? name,
      UserAddress? address,
      UserIDNumber? idNumber}) {
    return IdentityVerificationRequestUser(
        clientUserId: clientUserId ?? this.clientUserId,
        emailAddress: emailAddress ?? this.emailAddress,
        phoneNumber: phoneNumber ?? this.phoneNumber,
        dateOfBirth: dateOfBirth ?? this.dateOfBirth,
        name: name ?? this.name,
        address: address ?? this.address,
        idNumber: idNumber ?? this.idNumber);
  }

  IdentityVerificationRequestUser copyWithWrapped(
      {Wrapped<String>? clientUserId,
      Wrapped<String?>? emailAddress,
      Wrapped<String?>? phoneNumber,
      Wrapped<String?>? dateOfBirth,
      Wrapped<UserName?>? name,
      Wrapped<UserAddress?>? address,
      Wrapped<UserIDNumber?>? idNumber}) {
    return IdentityVerificationRequestUser(
        clientUserId:
            (clientUserId != null ? clientUserId.value : this.clientUserId),
        emailAddress:
            (emailAddress != null ? emailAddress.value : this.emailAddress),
        phoneNumber:
            (phoneNumber != null ? phoneNumber.value : this.phoneNumber),
        dateOfBirth:
            (dateOfBirth != null ? dateOfBirth.value : this.dateOfBirth),
        name: (name != null ? name.value : this.name),
        address: (address != null ? address.value : this.address),
        idNumber: (idNumber != null ? idNumber.value : this.idNumber));
  }
}

@JsonSerializable(explicitToJson: true)
class IdentityVerificationRetryRequest {
  IdentityVerificationRetryRequest({
    required this.clientUserId,
    required this.templateId,
    required this.strategy,
    this.steps,
    this.clientId,
    this.secret,
  });

  factory IdentityVerificationRetryRequest.fromJson(
          Map<String, dynamic> json) =>
      _$IdentityVerificationRetryRequestFromJson(json);

  @JsonKey(name: 'client_user_id')
  final String clientUserId;
  @JsonKey(name: 'template_id')
  final String templateId;
  @JsonKey(
    name: 'strategy',
    toJson: strategyToJson,
    fromJson: strategyFromJson,
  )
  final enums.Strategy strategy;
  @JsonKey(name: 'steps')
  final IdentityVerificationRetryRequestStepsObject? steps;
  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  static const fromJsonFactory = _$IdentityVerificationRetryRequestFromJson;
  static const toJsonFactory = _$IdentityVerificationRetryRequestToJson;
  Map<String, dynamic> toJson() =>
      _$IdentityVerificationRetryRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IdentityVerificationRetryRequest &&
            (identical(other.clientUserId, clientUserId) ||
                const DeepCollectionEquality()
                    .equals(other.clientUserId, clientUserId)) &&
            (identical(other.templateId, templateId) ||
                const DeepCollectionEquality()
                    .equals(other.templateId, templateId)) &&
            (identical(other.strategy, strategy) ||
                const DeepCollectionEquality()
                    .equals(other.strategy, strategy)) &&
            (identical(other.steps, steps) ||
                const DeepCollectionEquality().equals(other.steps, steps)) &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientUserId) ^
      const DeepCollectionEquality().hash(templateId) ^
      const DeepCollectionEquality().hash(strategy) ^
      const DeepCollectionEquality().hash(steps) ^
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      runtimeType.hashCode;
}

extension $IdentityVerificationRetryRequestExtension
    on IdentityVerificationRetryRequest {
  IdentityVerificationRetryRequest copyWith(
      {String? clientUserId,
      String? templateId,
      enums.Strategy? strategy,
      IdentityVerificationRetryRequestStepsObject? steps,
      String? clientId,
      String? secret}) {
    return IdentityVerificationRetryRequest(
        clientUserId: clientUserId ?? this.clientUserId,
        templateId: templateId ?? this.templateId,
        strategy: strategy ?? this.strategy,
        steps: steps ?? this.steps,
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret);
  }

  IdentityVerificationRetryRequest copyWithWrapped(
      {Wrapped<String>? clientUserId,
      Wrapped<String>? templateId,
      Wrapped<enums.Strategy>? strategy,
      Wrapped<IdentityVerificationRetryRequestStepsObject?>? steps,
      Wrapped<String?>? clientId,
      Wrapped<String?>? secret}) {
    return IdentityVerificationRetryRequest(
        clientUserId:
            (clientUserId != null ? clientUserId.value : this.clientUserId),
        templateId: (templateId != null ? templateId.value : this.templateId),
        strategy: (strategy != null ? strategy.value : this.strategy),
        steps: (steps != null ? steps.value : this.steps),
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret));
  }
}

@JsonSerializable(explicitToJson: true)
class IdentityVerificationRetryRequestStepsObject {
  IdentityVerificationRetryRequestStepsObject({
    required this.verifySms,
    required this.kycCheck,
    required this.documentaryVerification,
    required this.selfieCheck,
  });

  factory IdentityVerificationRetryRequestStepsObject.fromJson(
          Map<String, dynamic> json) =>
      _$IdentityVerificationRetryRequestStepsObjectFromJson(json);

  @JsonKey(name: 'verify_sms')
  final bool verifySms;
  @JsonKey(name: 'kyc_check')
  final bool kycCheck;
  @JsonKey(name: 'documentary_verification')
  final bool documentaryVerification;
  @JsonKey(name: 'selfie_check')
  final bool selfieCheck;
  static const fromJsonFactory =
      _$IdentityVerificationRetryRequestStepsObjectFromJson;
  static const toJsonFactory =
      _$IdentityVerificationRetryRequestStepsObjectToJson;
  Map<String, dynamic> toJson() =>
      _$IdentityVerificationRetryRequestStepsObjectToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IdentityVerificationRetryRequestStepsObject &&
            (identical(other.verifySms, verifySms) ||
                const DeepCollectionEquality()
                    .equals(other.verifySms, verifySms)) &&
            (identical(other.kycCheck, kycCheck) ||
                const DeepCollectionEquality()
                    .equals(other.kycCheck, kycCheck)) &&
            (identical(
                    other.documentaryVerification, documentaryVerification) ||
                const DeepCollectionEquality().equals(
                    other.documentaryVerification, documentaryVerification)) &&
            (identical(other.selfieCheck, selfieCheck) ||
                const DeepCollectionEquality()
                    .equals(other.selfieCheck, selfieCheck)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(verifySms) ^
      const DeepCollectionEquality().hash(kycCheck) ^
      const DeepCollectionEquality().hash(documentaryVerification) ^
      const DeepCollectionEquality().hash(selfieCheck) ^
      runtimeType.hashCode;
}

extension $IdentityVerificationRetryRequestStepsObjectExtension
    on IdentityVerificationRetryRequestStepsObject {
  IdentityVerificationRetryRequestStepsObject copyWith(
      {bool? verifySms,
      bool? kycCheck,
      bool? documentaryVerification,
      bool? selfieCheck}) {
    return IdentityVerificationRetryRequestStepsObject(
        verifySms: verifySms ?? this.verifySms,
        kycCheck: kycCheck ?? this.kycCheck,
        documentaryVerification:
            documentaryVerification ?? this.documentaryVerification,
        selfieCheck: selfieCheck ?? this.selfieCheck);
  }

  IdentityVerificationRetryRequestStepsObject copyWithWrapped(
      {Wrapped<bool>? verifySms,
      Wrapped<bool>? kycCheck,
      Wrapped<bool>? documentaryVerification,
      Wrapped<bool>? selfieCheck}) {
    return IdentityVerificationRetryRequestStepsObject(
        verifySms: (verifySms != null ? verifySms.value : this.verifySms),
        kycCheck: (kycCheck != null ? kycCheck.value : this.kycCheck),
        documentaryVerification: (documentaryVerification != null
            ? documentaryVerification.value
            : this.documentaryVerification),
        selfieCheck:
            (selfieCheck != null ? selfieCheck.value : this.selfieCheck));
  }
}

@JsonSerializable(explicitToJson: true)
class IdentityVerificationRetryResponse {
  IdentityVerificationRetryResponse({
    required this.id,
    required this.clientUserId,
    required this.createdAt,
    required this.completedAt,
    required this.previousAttemptId,
    required this.shareableUrl,
    required this.template,
    required this.user,
    required this.status,
    required this.steps,
    required this.documentaryVerification,
    required this.kycCheck,
    required this.watchlistScreeningId,
    required this.requestId,
  });

  factory IdentityVerificationRetryResponse.fromJson(
          Map<String, dynamic> json) =>
      _$IdentityVerificationRetryResponseFromJson(json);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'client_user_id')
  final String clientUserId;
  @JsonKey(name: 'created_at')
  final String createdAt;
  @JsonKey(name: 'completed_at')
  final String? completedAt;
  @JsonKey(name: 'previous_attempt_id')
  final String? previousAttemptId;
  @JsonKey(name: 'shareable_url')
  final String? shareableUrl;
  @JsonKey(name: 'template')
  final IdentityVerificationTemplateReference template;
  @JsonKey(name: 'user')
  final IdentityVerificationUserData user;
  @JsonKey(
    name: 'status',
    toJson: identityVerificationStatusToJson,
    fromJson: identityVerificationStatusFromJson,
  )
  final enums.IdentityVerificationStatus status;
  @JsonKey(name: 'steps')
  final IdentityVerificationStepSummary steps;
  @JsonKey(name: 'documentary_verification')
  final DocumentaryVerification? documentaryVerification;
  @JsonKey(name: 'kyc_check')
  final KYCCheckDetails? kycCheck;
  @JsonKey(name: 'watchlist_screening_id')
  final String? watchlistScreeningId;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$IdentityVerificationRetryResponseFromJson;
  static const toJsonFactory = _$IdentityVerificationRetryResponseToJson;
  Map<String, dynamic> toJson() =>
      _$IdentityVerificationRetryResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IdentityVerificationRetryResponse &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.clientUserId, clientUserId) ||
                const DeepCollectionEquality()
                    .equals(other.clientUserId, clientUserId)) &&
            (identical(other.createdAt, createdAt) ||
                const DeepCollectionEquality()
                    .equals(other.createdAt, createdAt)) &&
            (identical(other.completedAt, completedAt) ||
                const DeepCollectionEquality()
                    .equals(other.completedAt, completedAt)) &&
            (identical(other.previousAttemptId, previousAttemptId) ||
                const DeepCollectionEquality()
                    .equals(other.previousAttemptId, previousAttemptId)) &&
            (identical(other.shareableUrl, shareableUrl) ||
                const DeepCollectionEquality()
                    .equals(other.shareableUrl, shareableUrl)) &&
            (identical(other.template, template) ||
                const DeepCollectionEquality()
                    .equals(other.template, template)) &&
            (identical(other.user, user) ||
                const DeepCollectionEquality().equals(other.user, user)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.steps, steps) ||
                const DeepCollectionEquality().equals(other.steps, steps)) &&
            (identical(
                    other.documentaryVerification, documentaryVerification) ||
                const DeepCollectionEquality().equals(
                    other.documentaryVerification, documentaryVerification)) &&
            (identical(other.kycCheck, kycCheck) ||
                const DeepCollectionEquality()
                    .equals(other.kycCheck, kycCheck)) &&
            (identical(other.watchlistScreeningId, watchlistScreeningId) ||
                const DeepCollectionEquality().equals(
                    other.watchlistScreeningId, watchlistScreeningId)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(clientUserId) ^
      const DeepCollectionEquality().hash(createdAt) ^
      const DeepCollectionEquality().hash(completedAt) ^
      const DeepCollectionEquality().hash(previousAttemptId) ^
      const DeepCollectionEquality().hash(shareableUrl) ^
      const DeepCollectionEquality().hash(template) ^
      const DeepCollectionEquality().hash(user) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(steps) ^
      const DeepCollectionEquality().hash(documentaryVerification) ^
      const DeepCollectionEquality().hash(kycCheck) ^
      const DeepCollectionEquality().hash(watchlistScreeningId) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $IdentityVerificationRetryResponseExtension
    on IdentityVerificationRetryResponse {
  IdentityVerificationRetryResponse copyWith(
      {String? id,
      String? clientUserId,
      String? createdAt,
      String? completedAt,
      String? previousAttemptId,
      String? shareableUrl,
      IdentityVerificationTemplateReference? template,
      IdentityVerificationUserData? user,
      enums.IdentityVerificationStatus? status,
      IdentityVerificationStepSummary? steps,
      DocumentaryVerification? documentaryVerification,
      KYCCheckDetails? kycCheck,
      String? watchlistScreeningId,
      String? requestId}) {
    return IdentityVerificationRetryResponse(
        id: id ?? this.id,
        clientUserId: clientUserId ?? this.clientUserId,
        createdAt: createdAt ?? this.createdAt,
        completedAt: completedAt ?? this.completedAt,
        previousAttemptId: previousAttemptId ?? this.previousAttemptId,
        shareableUrl: shareableUrl ?? this.shareableUrl,
        template: template ?? this.template,
        user: user ?? this.user,
        status: status ?? this.status,
        steps: steps ?? this.steps,
        documentaryVerification:
            documentaryVerification ?? this.documentaryVerification,
        kycCheck: kycCheck ?? this.kycCheck,
        watchlistScreeningId: watchlistScreeningId ?? this.watchlistScreeningId,
        requestId: requestId ?? this.requestId);
  }

  IdentityVerificationRetryResponse copyWithWrapped(
      {Wrapped<String>? id,
      Wrapped<String>? clientUserId,
      Wrapped<String>? createdAt,
      Wrapped<String?>? completedAt,
      Wrapped<String?>? previousAttemptId,
      Wrapped<String?>? shareableUrl,
      Wrapped<IdentityVerificationTemplateReference>? template,
      Wrapped<IdentityVerificationUserData>? user,
      Wrapped<enums.IdentityVerificationStatus>? status,
      Wrapped<IdentityVerificationStepSummary>? steps,
      Wrapped<DocumentaryVerification?>? documentaryVerification,
      Wrapped<KYCCheckDetails?>? kycCheck,
      Wrapped<String?>? watchlistScreeningId,
      Wrapped<String>? requestId}) {
    return IdentityVerificationRetryResponse(
        id: (id != null ? id.value : this.id),
        clientUserId:
            (clientUserId != null ? clientUserId.value : this.clientUserId),
        createdAt: (createdAt != null ? createdAt.value : this.createdAt),
        completedAt:
            (completedAt != null ? completedAt.value : this.completedAt),
        previousAttemptId: (previousAttemptId != null
            ? previousAttemptId.value
            : this.previousAttemptId),
        shareableUrl:
            (shareableUrl != null ? shareableUrl.value : this.shareableUrl),
        template: (template != null ? template.value : this.template),
        user: (user != null ? user.value : this.user),
        status: (status != null ? status.value : this.status),
        steps: (steps != null ? steps.value : this.steps),
        documentaryVerification: (documentaryVerification != null
            ? documentaryVerification.value
            : this.documentaryVerification),
        kycCheck: (kycCheck != null ? kycCheck.value : this.kycCheck),
        watchlistScreeningId: (watchlistScreeningId != null
            ? watchlistScreeningId.value
            : this.watchlistScreeningId),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class IdentityVerificationStepSummary {
  IdentityVerificationStepSummary({
    required this.acceptTos,
    required this.verifySms,
    required this.kycCheck,
    required this.documentaryVerification,
    required this.selfieCheck,
    required this.watchlistScreening,
    required this.riskCheck,
  });

  factory IdentityVerificationStepSummary.fromJson(Map<String, dynamic> json) =>
      _$IdentityVerificationStepSummaryFromJson(json);

  @JsonKey(
    name: 'accept_tos',
    toJson: identityVerificationStepStatusToJson,
    fromJson: identityVerificationStepStatusFromJson,
  )
  final enums.IdentityVerificationStepStatus acceptTos;
  @JsonKey(
    name: 'verify_sms',
    toJson: identityVerificationStepStatusToJson,
    fromJson: identityVerificationStepStatusFromJson,
  )
  final enums.IdentityVerificationStepStatus verifySms;
  @JsonKey(
    name: 'kyc_check',
    toJson: identityVerificationStepStatusToJson,
    fromJson: identityVerificationStepStatusFromJson,
  )
  final enums.IdentityVerificationStepStatus kycCheck;
  @JsonKey(
    name: 'documentary_verification',
    toJson: identityVerificationStepStatusToJson,
    fromJson: identityVerificationStepStatusFromJson,
  )
  final enums.IdentityVerificationStepStatus documentaryVerification;
  @JsonKey(
    name: 'selfie_check',
    toJson: identityVerificationStepStatusToJson,
    fromJson: identityVerificationStepStatusFromJson,
  )
  final enums.IdentityVerificationStepStatus selfieCheck;
  @JsonKey(
    name: 'watchlist_screening',
    toJson: identityVerificationStepStatusToJson,
    fromJson: identityVerificationStepStatusFromJson,
  )
  final enums.IdentityVerificationStepStatus watchlistScreening;
  @JsonKey(
    name: 'risk_check',
    toJson: identityVerificationStepStatusToJson,
    fromJson: identityVerificationStepStatusFromJson,
  )
  final enums.IdentityVerificationStepStatus riskCheck;
  static const fromJsonFactory = _$IdentityVerificationStepSummaryFromJson;
  static const toJsonFactory = _$IdentityVerificationStepSummaryToJson;
  Map<String, dynamic> toJson() =>
      _$IdentityVerificationStepSummaryToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IdentityVerificationStepSummary &&
            (identical(other.acceptTos, acceptTos) ||
                const DeepCollectionEquality()
                    .equals(other.acceptTos, acceptTos)) &&
            (identical(other.verifySms, verifySms) ||
                const DeepCollectionEquality()
                    .equals(other.verifySms, verifySms)) &&
            (identical(other.kycCheck, kycCheck) ||
                const DeepCollectionEquality()
                    .equals(other.kycCheck, kycCheck)) &&
            (identical(
                    other.documentaryVerification, documentaryVerification) ||
                const DeepCollectionEquality().equals(
                    other.documentaryVerification, documentaryVerification)) &&
            (identical(other.selfieCheck, selfieCheck) ||
                const DeepCollectionEquality()
                    .equals(other.selfieCheck, selfieCheck)) &&
            (identical(other.watchlistScreening, watchlistScreening) ||
                const DeepCollectionEquality()
                    .equals(other.watchlistScreening, watchlistScreening)) &&
            (identical(other.riskCheck, riskCheck) ||
                const DeepCollectionEquality()
                    .equals(other.riskCheck, riskCheck)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(acceptTos) ^
      const DeepCollectionEquality().hash(verifySms) ^
      const DeepCollectionEquality().hash(kycCheck) ^
      const DeepCollectionEquality().hash(documentaryVerification) ^
      const DeepCollectionEquality().hash(selfieCheck) ^
      const DeepCollectionEquality().hash(watchlistScreening) ^
      const DeepCollectionEquality().hash(riskCheck) ^
      runtimeType.hashCode;
}

extension $IdentityVerificationStepSummaryExtension
    on IdentityVerificationStepSummary {
  IdentityVerificationStepSummary copyWith(
      {enums.IdentityVerificationStepStatus? acceptTos,
      enums.IdentityVerificationStepStatus? verifySms,
      enums.IdentityVerificationStepStatus? kycCheck,
      enums.IdentityVerificationStepStatus? documentaryVerification,
      enums.IdentityVerificationStepStatus? selfieCheck,
      enums.IdentityVerificationStepStatus? watchlistScreening,
      enums.IdentityVerificationStepStatus? riskCheck}) {
    return IdentityVerificationStepSummary(
        acceptTos: acceptTos ?? this.acceptTos,
        verifySms: verifySms ?? this.verifySms,
        kycCheck: kycCheck ?? this.kycCheck,
        documentaryVerification:
            documentaryVerification ?? this.documentaryVerification,
        selfieCheck: selfieCheck ?? this.selfieCheck,
        watchlistScreening: watchlistScreening ?? this.watchlistScreening,
        riskCheck: riskCheck ?? this.riskCheck);
  }

  IdentityVerificationStepSummary copyWithWrapped(
      {Wrapped<enums.IdentityVerificationStepStatus>? acceptTos,
      Wrapped<enums.IdentityVerificationStepStatus>? verifySms,
      Wrapped<enums.IdentityVerificationStepStatus>? kycCheck,
      Wrapped<enums.IdentityVerificationStepStatus>? documentaryVerification,
      Wrapped<enums.IdentityVerificationStepStatus>? selfieCheck,
      Wrapped<enums.IdentityVerificationStepStatus>? watchlistScreening,
      Wrapped<enums.IdentityVerificationStepStatus>? riskCheck}) {
    return IdentityVerificationStepSummary(
        acceptTos: (acceptTos != null ? acceptTos.value : this.acceptTos),
        verifySms: (verifySms != null ? verifySms.value : this.verifySms),
        kycCheck: (kycCheck != null ? kycCheck.value : this.kycCheck),
        documentaryVerification: (documentaryVerification != null
            ? documentaryVerification.value
            : this.documentaryVerification),
        selfieCheck:
            (selfieCheck != null ? selfieCheck.value : this.selfieCheck),
        watchlistScreening: (watchlistScreening != null
            ? watchlistScreening.value
            : this.watchlistScreening),
        riskCheck: (riskCheck != null ? riskCheck.value : this.riskCheck));
  }
}

@JsonSerializable(explicitToJson: true)
class IdentityVerificationTemplateReference {
  IdentityVerificationTemplateReference({
    required this.id,
    required this.version,
  });

  factory IdentityVerificationTemplateReference.fromJson(
          Map<String, dynamic> json) =>
      _$IdentityVerificationTemplateReferenceFromJson(json);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'version')
  final num version;
  static const fromJsonFactory =
      _$IdentityVerificationTemplateReferenceFromJson;
  static const toJsonFactory = _$IdentityVerificationTemplateReferenceToJson;
  Map<String, dynamic> toJson() =>
      _$IdentityVerificationTemplateReferenceToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IdentityVerificationTemplateReference &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.version, version) ||
                const DeepCollectionEquality().equals(other.version, version)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(version) ^
      runtimeType.hashCode;
}

extension $IdentityVerificationTemplateReferenceExtension
    on IdentityVerificationTemplateReference {
  IdentityVerificationTemplateReference copyWith({String? id, num? version}) {
    return IdentityVerificationTemplateReference(
        id: id ?? this.id, version: version ?? this.version);
  }

  IdentityVerificationTemplateReference copyWithWrapped(
      {Wrapped<String>? id, Wrapped<num>? version}) {
    return IdentityVerificationTemplateReference(
        id: (id != null ? id.value : this.id),
        version: (version != null ? version.value : this.version));
  }
}

@JsonSerializable(explicitToJson: true)
class IdentityVerificationTemplateVersion {
  IdentityVerificationTemplateVersion();

  factory IdentityVerificationTemplateVersion.fromJson(
          Map<String, dynamic> json) =>
      _$IdentityVerificationTemplateVersionFromJson(json);

  static const fromJsonFactory = _$IdentityVerificationTemplateVersionFromJson;
  static const toJsonFactory = _$IdentityVerificationTemplateVersionToJson;
  Map<String, dynamic> toJson() =>
      _$IdentityVerificationTemplateVersionToJson(this);

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => runtimeType.hashCode;
}

@JsonSerializable(explicitToJson: true)
class IdentityVerificationUserAddress {
  IdentityVerificationUserAddress({
    required this.street,
    required this.street2,
    required this.city,
    required this.region,
    required this.postalCode,
    required this.country,
  });

  factory IdentityVerificationUserAddress.fromJson(Map<String, dynamic> json) =>
      _$IdentityVerificationUserAddressFromJson(json);

  @JsonKey(name: 'street')
  final String? street;
  @JsonKey(name: 'street2')
  final String? street2;
  @JsonKey(name: 'city')
  final String? city;
  @JsonKey(name: 'region')
  final String? region;
  @JsonKey(name: 'postal_code')
  final String? postalCode;
  @JsonKey(name: 'country')
  final String country;
  static const fromJsonFactory = _$IdentityVerificationUserAddressFromJson;
  static const toJsonFactory = _$IdentityVerificationUserAddressToJson;
  Map<String, dynamic> toJson() =>
      _$IdentityVerificationUserAddressToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IdentityVerificationUserAddress &&
            (identical(other.street, street) ||
                const DeepCollectionEquality().equals(other.street, street)) &&
            (identical(other.street2, street2) ||
                const DeepCollectionEquality()
                    .equals(other.street2, street2)) &&
            (identical(other.city, city) ||
                const DeepCollectionEquality().equals(other.city, city)) &&
            (identical(other.region, region) ||
                const DeepCollectionEquality().equals(other.region, region)) &&
            (identical(other.postalCode, postalCode) ||
                const DeepCollectionEquality()
                    .equals(other.postalCode, postalCode)) &&
            (identical(other.country, country) ||
                const DeepCollectionEquality().equals(other.country, country)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(street) ^
      const DeepCollectionEquality().hash(street2) ^
      const DeepCollectionEquality().hash(city) ^
      const DeepCollectionEquality().hash(region) ^
      const DeepCollectionEquality().hash(postalCode) ^
      const DeepCollectionEquality().hash(country) ^
      runtimeType.hashCode;
}

extension $IdentityVerificationUserAddressExtension
    on IdentityVerificationUserAddress {
  IdentityVerificationUserAddress copyWith(
      {String? street,
      String? street2,
      String? city,
      String? region,
      String? postalCode,
      String? country}) {
    return IdentityVerificationUserAddress(
        street: street ?? this.street,
        street2: street2 ?? this.street2,
        city: city ?? this.city,
        region: region ?? this.region,
        postalCode: postalCode ?? this.postalCode,
        country: country ?? this.country);
  }

  IdentityVerificationUserAddress copyWithWrapped(
      {Wrapped<String?>? street,
      Wrapped<String?>? street2,
      Wrapped<String?>? city,
      Wrapped<String?>? region,
      Wrapped<String?>? postalCode,
      Wrapped<String>? country}) {
    return IdentityVerificationUserAddress(
        street: (street != null ? street.value : this.street),
        street2: (street2 != null ? street2.value : this.street2),
        city: (city != null ? city.value : this.city),
        region: (region != null ? region.value : this.region),
        postalCode: (postalCode != null ? postalCode.value : this.postalCode),
        country: (country != null ? country.value : this.country));
  }
}

@JsonSerializable(explicitToJson: true)
class IdentityVerificationUserData {
  IdentityVerificationUserData({
    this.phoneNumber,
    required this.dateOfBirth,
    required this.ipAddress,
    required this.emailAddress,
    required this.name,
    required this.address,
    required this.idNumber,
  });

  factory IdentityVerificationUserData.fromJson(Map<String, dynamic> json) =>
      _$IdentityVerificationUserDataFromJson(json);

  @JsonKey(name: 'phone_number')
  final String? phoneNumber;
  @JsonKey(name: 'date_of_birth')
  final String? dateOfBirth;
  @JsonKey(name: 'ip_address')
  final String? ipAddress;
  @JsonKey(name: 'email_address')
  final String? emailAddress;
  @JsonKey(name: 'name')
  final UserName? name;
  @JsonKey(name: 'address')
  final IdentityVerificationUserAddress? address;
  @JsonKey(name: 'id_number')
  final UserIDNumber? idNumber;
  static const fromJsonFactory = _$IdentityVerificationUserDataFromJson;
  static const toJsonFactory = _$IdentityVerificationUserDataToJson;
  Map<String, dynamic> toJson() => _$IdentityVerificationUserDataToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IdentityVerificationUserData &&
            (identical(other.phoneNumber, phoneNumber) ||
                const DeepCollectionEquality()
                    .equals(other.phoneNumber, phoneNumber)) &&
            (identical(other.dateOfBirth, dateOfBirth) ||
                const DeepCollectionEquality()
                    .equals(other.dateOfBirth, dateOfBirth)) &&
            (identical(other.ipAddress, ipAddress) ||
                const DeepCollectionEquality()
                    .equals(other.ipAddress, ipAddress)) &&
            (identical(other.emailAddress, emailAddress) ||
                const DeepCollectionEquality()
                    .equals(other.emailAddress, emailAddress)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality()
                    .equals(other.address, address)) &&
            (identical(other.idNumber, idNumber) ||
                const DeepCollectionEquality()
                    .equals(other.idNumber, idNumber)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(phoneNumber) ^
      const DeepCollectionEquality().hash(dateOfBirth) ^
      const DeepCollectionEquality().hash(ipAddress) ^
      const DeepCollectionEquality().hash(emailAddress) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(idNumber) ^
      runtimeType.hashCode;
}

extension $IdentityVerificationUserDataExtension
    on IdentityVerificationUserData {
  IdentityVerificationUserData copyWith(
      {String? phoneNumber,
      String? dateOfBirth,
      String? ipAddress,
      String? emailAddress,
      UserName? name,
      IdentityVerificationUserAddress? address,
      UserIDNumber? idNumber}) {
    return IdentityVerificationUserData(
        phoneNumber: phoneNumber ?? this.phoneNumber,
        dateOfBirth: dateOfBirth ?? this.dateOfBirth,
        ipAddress: ipAddress ?? this.ipAddress,
        emailAddress: emailAddress ?? this.emailAddress,
        name: name ?? this.name,
        address: address ?? this.address,
        idNumber: idNumber ?? this.idNumber);
  }

  IdentityVerificationUserData copyWithWrapped(
      {Wrapped<String?>? phoneNumber,
      Wrapped<String?>? dateOfBirth,
      Wrapped<String?>? ipAddress,
      Wrapped<String?>? emailAddress,
      Wrapped<UserName?>? name,
      Wrapped<IdentityVerificationUserAddress?>? address,
      Wrapped<UserIDNumber?>? idNumber}) {
    return IdentityVerificationUserData(
        phoneNumber:
            (phoneNumber != null ? phoneNumber.value : this.phoneNumber),
        dateOfBirth:
            (dateOfBirth != null ? dateOfBirth.value : this.dateOfBirth),
        ipAddress: (ipAddress != null ? ipAddress.value : this.ipAddress),
        emailAddress:
            (emailAddress != null ? emailAddress.value : this.emailAddress),
        name: (name != null ? name.value : this.name),
        address: (address != null ? address.value : this.address),
        idNumber: (idNumber != null ? idNumber.value : this.idNumber));
  }
}

@JsonSerializable(explicitToJson: true)
class IndividualScreeningHitNames {
  IndividualScreeningHitNames({
    required this.full,
    required this.isPrimary,
    required this.weakAliasDetermination,
  });

  factory IndividualScreeningHitNames.fromJson(Map<String, dynamic> json) =>
      _$IndividualScreeningHitNamesFromJson(json);

  @JsonKey(name: 'full')
  final String full;
  @JsonKey(name: 'is_primary')
  final bool isPrimary;
  @JsonKey(
    name: 'weak_alias_determination',
    toJson: weakAliasDeterminationToJson,
    fromJson: weakAliasDeterminationFromJson,
  )
  final enums.WeakAliasDetermination weakAliasDetermination;
  static const fromJsonFactory = _$IndividualScreeningHitNamesFromJson;
  static const toJsonFactory = _$IndividualScreeningHitNamesToJson;
  Map<String, dynamic> toJson() => _$IndividualScreeningHitNamesToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IndividualScreeningHitNames &&
            (identical(other.full, full) ||
                const DeepCollectionEquality().equals(other.full, full)) &&
            (identical(other.isPrimary, isPrimary) ||
                const DeepCollectionEquality()
                    .equals(other.isPrimary, isPrimary)) &&
            (identical(other.weakAliasDetermination, weakAliasDetermination) ||
                const DeepCollectionEquality().equals(
                    other.weakAliasDetermination, weakAliasDetermination)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(full) ^
      const DeepCollectionEquality().hash(isPrimary) ^
      const DeepCollectionEquality().hash(weakAliasDetermination) ^
      runtimeType.hashCode;
}

extension $IndividualScreeningHitNamesExtension on IndividualScreeningHitNames {
  IndividualScreeningHitNames copyWith(
      {String? full,
      bool? isPrimary,
      enums.WeakAliasDetermination? weakAliasDetermination}) {
    return IndividualScreeningHitNames(
        full: full ?? this.full,
        isPrimary: isPrimary ?? this.isPrimary,
        weakAliasDetermination:
            weakAliasDetermination ?? this.weakAliasDetermination);
  }

  IndividualScreeningHitNames copyWithWrapped(
      {Wrapped<String>? full,
      Wrapped<bool>? isPrimary,
      Wrapped<enums.WeakAliasDetermination>? weakAliasDetermination}) {
    return IndividualScreeningHitNames(
        full: (full != null ? full.value : this.full),
        isPrimary: (isPrimary != null ? isPrimary.value : this.isPrimary),
        weakAliasDetermination: (weakAliasDetermination != null
            ? weakAliasDetermination.value
            : this.weakAliasDetermination));
  }
}

@JsonSerializable(explicitToJson: true)
class IndividualWatchlistProgram {
  IndividualWatchlistProgram({
    required this.id,
    required this.createdAt,
    required this.isRescanningEnabled,
    required this.listsEnabled,
    required this.name,
    required this.nameSensitivity,
    required this.auditTrail,
    required this.isArchived,
  });

  factory IndividualWatchlistProgram.fromJson(Map<String, dynamic> json) =>
      _$IndividualWatchlistProgramFromJson(json);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'created_at')
  final String createdAt;
  @JsonKey(name: 'is_rescanning_enabled')
  final bool isRescanningEnabled;
  @JsonKey(
    name: 'lists_enabled',
    toJson: individualWatchlistCodeListToJson,
    fromJson: individualWatchlistCodeListFromJson,
  )
  final List<enums.IndividualWatchlistCode> listsEnabled;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(
    name: 'name_sensitivity',
    toJson: programNameSensitivityToJson,
    fromJson: programNameSensitivityFromJson,
  )
  final enums.ProgramNameSensitivity nameSensitivity;
  @JsonKey(name: 'audit_trail')
  final WatchlistScreeningAuditTrail auditTrail;
  @JsonKey(name: 'is_archived')
  final bool isArchived;
  static const fromJsonFactory = _$IndividualWatchlistProgramFromJson;
  static const toJsonFactory = _$IndividualWatchlistProgramToJson;
  Map<String, dynamic> toJson() => _$IndividualWatchlistProgramToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IndividualWatchlistProgram &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.createdAt, createdAt) ||
                const DeepCollectionEquality()
                    .equals(other.createdAt, createdAt)) &&
            (identical(other.isRescanningEnabled, isRescanningEnabled) ||
                const DeepCollectionEquality()
                    .equals(other.isRescanningEnabled, isRescanningEnabled)) &&
            (identical(other.listsEnabled, listsEnabled) ||
                const DeepCollectionEquality()
                    .equals(other.listsEnabled, listsEnabled)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.nameSensitivity, nameSensitivity) ||
                const DeepCollectionEquality()
                    .equals(other.nameSensitivity, nameSensitivity)) &&
            (identical(other.auditTrail, auditTrail) ||
                const DeepCollectionEquality()
                    .equals(other.auditTrail, auditTrail)) &&
            (identical(other.isArchived, isArchived) ||
                const DeepCollectionEquality()
                    .equals(other.isArchived, isArchived)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(createdAt) ^
      const DeepCollectionEquality().hash(isRescanningEnabled) ^
      const DeepCollectionEquality().hash(listsEnabled) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(nameSensitivity) ^
      const DeepCollectionEquality().hash(auditTrail) ^
      const DeepCollectionEquality().hash(isArchived) ^
      runtimeType.hashCode;
}

extension $IndividualWatchlistProgramExtension on IndividualWatchlistProgram {
  IndividualWatchlistProgram copyWith(
      {String? id,
      String? createdAt,
      bool? isRescanningEnabled,
      List<enums.IndividualWatchlistCode>? listsEnabled,
      String? name,
      enums.ProgramNameSensitivity? nameSensitivity,
      WatchlistScreeningAuditTrail? auditTrail,
      bool? isArchived}) {
    return IndividualWatchlistProgram(
        id: id ?? this.id,
        createdAt: createdAt ?? this.createdAt,
        isRescanningEnabled: isRescanningEnabled ?? this.isRescanningEnabled,
        listsEnabled: listsEnabled ?? this.listsEnabled,
        name: name ?? this.name,
        nameSensitivity: nameSensitivity ?? this.nameSensitivity,
        auditTrail: auditTrail ?? this.auditTrail,
        isArchived: isArchived ?? this.isArchived);
  }

  IndividualWatchlistProgram copyWithWrapped(
      {Wrapped<String>? id,
      Wrapped<String>? createdAt,
      Wrapped<bool>? isRescanningEnabled,
      Wrapped<List<enums.IndividualWatchlistCode>>? listsEnabled,
      Wrapped<String>? name,
      Wrapped<enums.ProgramNameSensitivity>? nameSensitivity,
      Wrapped<WatchlistScreeningAuditTrail>? auditTrail,
      Wrapped<bool>? isArchived}) {
    return IndividualWatchlistProgram(
        id: (id != null ? id.value : this.id),
        createdAt: (createdAt != null ? createdAt.value : this.createdAt),
        isRescanningEnabled: (isRescanningEnabled != null
            ? isRescanningEnabled.value
            : this.isRescanningEnabled),
        listsEnabled:
            (listsEnabled != null ? listsEnabled.value : this.listsEnabled),
        name: (name != null ? name.value : this.name),
        nameSensitivity: (nameSensitivity != null
            ? nameSensitivity.value
            : this.nameSensitivity),
        auditTrail: (auditTrail != null ? auditTrail.value : this.auditTrail),
        isArchived: (isArchived != null ? isArchived.value : this.isArchived));
  }
}

@JsonSerializable(explicitToJson: true)
class KYCCheckAddressSummary {
  KYCCheckAddressSummary({
    required this.summary,
    required this.poBox,
    required this.type,
  });

  factory KYCCheckAddressSummary.fromJson(Map<String, dynamic> json) =>
      _$KYCCheckAddressSummaryFromJson(json);

  @JsonKey(
    name: 'summary',
    toJson: matchSummaryCodeToJson,
    fromJson: matchSummaryCodeFromJson,
  )
  final enums.MatchSummaryCode summary;
  @JsonKey(
    name: 'po_box',
    toJson: pOBoxStatusToJson,
    fromJson: pOBoxStatusFromJson,
  )
  final enums.POBoxStatus poBox;
  @JsonKey(
    name: 'type',
    toJson: addressPurposeLabelToJson,
    fromJson: addressPurposeLabelFromJson,
  )
  final enums.AddressPurposeLabel type;
  static const fromJsonFactory = _$KYCCheckAddressSummaryFromJson;
  static const toJsonFactory = _$KYCCheckAddressSummaryToJson;
  Map<String, dynamic> toJson() => _$KYCCheckAddressSummaryToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is KYCCheckAddressSummary &&
            (identical(other.summary, summary) ||
                const DeepCollectionEquality()
                    .equals(other.summary, summary)) &&
            (identical(other.poBox, poBox) ||
                const DeepCollectionEquality().equals(other.poBox, poBox)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(summary) ^
      const DeepCollectionEquality().hash(poBox) ^
      const DeepCollectionEquality().hash(type) ^
      runtimeType.hashCode;
}

extension $KYCCheckAddressSummaryExtension on KYCCheckAddressSummary {
  KYCCheckAddressSummary copyWith(
      {enums.MatchSummaryCode? summary,
      enums.POBoxStatus? poBox,
      enums.AddressPurposeLabel? type}) {
    return KYCCheckAddressSummary(
        summary: summary ?? this.summary,
        poBox: poBox ?? this.poBox,
        type: type ?? this.type);
  }

  KYCCheckAddressSummary copyWithWrapped(
      {Wrapped<enums.MatchSummaryCode>? summary,
      Wrapped<enums.POBoxStatus>? poBox,
      Wrapped<enums.AddressPurposeLabel>? type}) {
    return KYCCheckAddressSummary(
        summary: (summary != null ? summary.value : this.summary),
        poBox: (poBox != null ? poBox.value : this.poBox),
        type: (type != null ? type.value : this.type));
  }
}

@JsonSerializable(explicitToJson: true)
class KYCCheckDateOfBirthSummary {
  KYCCheckDateOfBirthSummary({
    required this.summary,
  });

  factory KYCCheckDateOfBirthSummary.fromJson(Map<String, dynamic> json) =>
      _$KYCCheckDateOfBirthSummaryFromJson(json);

  @JsonKey(
    name: 'summary',
    toJson: matchSummaryCodeToJson,
    fromJson: matchSummaryCodeFromJson,
  )
  final enums.MatchSummaryCode summary;
  static const fromJsonFactory = _$KYCCheckDateOfBirthSummaryFromJson;
  static const toJsonFactory = _$KYCCheckDateOfBirthSummaryToJson;
  Map<String, dynamic> toJson() => _$KYCCheckDateOfBirthSummaryToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is KYCCheckDateOfBirthSummary &&
            (identical(other.summary, summary) ||
                const DeepCollectionEquality().equals(other.summary, summary)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(summary) ^ runtimeType.hashCode;
}

extension $KYCCheckDateOfBirthSummaryExtension on KYCCheckDateOfBirthSummary {
  KYCCheckDateOfBirthSummary copyWith({enums.MatchSummaryCode? summary}) {
    return KYCCheckDateOfBirthSummary(summary: summary ?? this.summary);
  }

  KYCCheckDateOfBirthSummary copyWithWrapped(
      {Wrapped<enums.MatchSummaryCode>? summary}) {
    return KYCCheckDateOfBirthSummary(
        summary: (summary != null ? summary.value : this.summary));
  }
}

@JsonSerializable(explicitToJson: true)
class KYCCheckDetails {
  KYCCheckDetails({
    required this.status,
    required this.address,
    required this.name,
    required this.dateOfBirth,
    required this.idNumber,
    required this.phoneNumber,
  });

  factory KYCCheckDetails.fromJson(Map<String, dynamic> json) =>
      _$KYCCheckDetailsFromJson(json);

  @JsonKey(name: 'status')
  final String status;
  @JsonKey(name: 'address')
  final KYCCheckAddressSummary address;
  @JsonKey(name: 'name')
  final KYCCheckNameSummary name;
  @JsonKey(name: 'date_of_birth')
  final KYCCheckDateOfBirthSummary dateOfBirth;
  @JsonKey(name: 'id_number')
  final KYCCheckIDNumberSummary idNumber;
  @JsonKey(name: 'phone_number')
  final KYCCheckPhoneSummary phoneNumber;
  static const fromJsonFactory = _$KYCCheckDetailsFromJson;
  static const toJsonFactory = _$KYCCheckDetailsToJson;
  Map<String, dynamic> toJson() => _$KYCCheckDetailsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is KYCCheckDetails &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality()
                    .equals(other.address, address)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.dateOfBirth, dateOfBirth) ||
                const DeepCollectionEquality()
                    .equals(other.dateOfBirth, dateOfBirth)) &&
            (identical(other.idNumber, idNumber) ||
                const DeepCollectionEquality()
                    .equals(other.idNumber, idNumber)) &&
            (identical(other.phoneNumber, phoneNumber) ||
                const DeepCollectionEquality()
                    .equals(other.phoneNumber, phoneNumber)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(dateOfBirth) ^
      const DeepCollectionEquality().hash(idNumber) ^
      const DeepCollectionEquality().hash(phoneNumber) ^
      runtimeType.hashCode;
}

extension $KYCCheckDetailsExtension on KYCCheckDetails {
  KYCCheckDetails copyWith(
      {String? status,
      KYCCheckAddressSummary? address,
      KYCCheckNameSummary? name,
      KYCCheckDateOfBirthSummary? dateOfBirth,
      KYCCheckIDNumberSummary? idNumber,
      KYCCheckPhoneSummary? phoneNumber}) {
    return KYCCheckDetails(
        status: status ?? this.status,
        address: address ?? this.address,
        name: name ?? this.name,
        dateOfBirth: dateOfBirth ?? this.dateOfBirth,
        idNumber: idNumber ?? this.idNumber,
        phoneNumber: phoneNumber ?? this.phoneNumber);
  }

  KYCCheckDetails copyWithWrapped(
      {Wrapped<String>? status,
      Wrapped<KYCCheckAddressSummary>? address,
      Wrapped<KYCCheckNameSummary>? name,
      Wrapped<KYCCheckDateOfBirthSummary>? dateOfBirth,
      Wrapped<KYCCheckIDNumberSummary>? idNumber,
      Wrapped<KYCCheckPhoneSummary>? phoneNumber}) {
    return KYCCheckDetails(
        status: (status != null ? status.value : this.status),
        address: (address != null ? address.value : this.address),
        name: (name != null ? name.value : this.name),
        dateOfBirth:
            (dateOfBirth != null ? dateOfBirth.value : this.dateOfBirth),
        idNumber: (idNumber != null ? idNumber.value : this.idNumber),
        phoneNumber:
            (phoneNumber != null ? phoneNumber.value : this.phoneNumber));
  }
}

@JsonSerializable(explicitToJson: true)
class KYCCheckIDNumberSummary {
  KYCCheckIDNumberSummary({
    required this.summary,
  });

  factory KYCCheckIDNumberSummary.fromJson(Map<String, dynamic> json) =>
      _$KYCCheckIDNumberSummaryFromJson(json);

  @JsonKey(
    name: 'summary',
    toJson: matchSummaryCodeToJson,
    fromJson: matchSummaryCodeFromJson,
  )
  final enums.MatchSummaryCode summary;
  static const fromJsonFactory = _$KYCCheckIDNumberSummaryFromJson;
  static const toJsonFactory = _$KYCCheckIDNumberSummaryToJson;
  Map<String, dynamic> toJson() => _$KYCCheckIDNumberSummaryToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is KYCCheckIDNumberSummary &&
            (identical(other.summary, summary) ||
                const DeepCollectionEquality().equals(other.summary, summary)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(summary) ^ runtimeType.hashCode;
}

extension $KYCCheckIDNumberSummaryExtension on KYCCheckIDNumberSummary {
  KYCCheckIDNumberSummary copyWith({enums.MatchSummaryCode? summary}) {
    return KYCCheckIDNumberSummary(summary: summary ?? this.summary);
  }

  KYCCheckIDNumberSummary copyWithWrapped(
      {Wrapped<enums.MatchSummaryCode>? summary}) {
    return KYCCheckIDNumberSummary(
        summary: (summary != null ? summary.value : this.summary));
  }
}

@JsonSerializable(explicitToJson: true)
class KYCCheckNameSummary {
  KYCCheckNameSummary({
    required this.summary,
  });

  factory KYCCheckNameSummary.fromJson(Map<String, dynamic> json) =>
      _$KYCCheckNameSummaryFromJson(json);

  @JsonKey(
    name: 'summary',
    toJson: matchSummaryCodeToJson,
    fromJson: matchSummaryCodeFromJson,
  )
  final enums.MatchSummaryCode summary;
  static const fromJsonFactory = _$KYCCheckNameSummaryFromJson;
  static const toJsonFactory = _$KYCCheckNameSummaryToJson;
  Map<String, dynamic> toJson() => _$KYCCheckNameSummaryToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is KYCCheckNameSummary &&
            (identical(other.summary, summary) ||
                const DeepCollectionEquality().equals(other.summary, summary)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(summary) ^ runtimeType.hashCode;
}

extension $KYCCheckNameSummaryExtension on KYCCheckNameSummary {
  KYCCheckNameSummary copyWith({enums.MatchSummaryCode? summary}) {
    return KYCCheckNameSummary(summary: summary ?? this.summary);
  }

  KYCCheckNameSummary copyWithWrapped(
      {Wrapped<enums.MatchSummaryCode>? summary}) {
    return KYCCheckNameSummary(
        summary: (summary != null ? summary.value : this.summary));
  }
}

@JsonSerializable(explicitToJson: true)
class KYCCheckPhoneSummary {
  KYCCheckPhoneSummary({
    required this.summary,
  });

  factory KYCCheckPhoneSummary.fromJson(Map<String, dynamic> json) =>
      _$KYCCheckPhoneSummaryFromJson(json);

  @JsonKey(
    name: 'summary',
    toJson: matchSummaryCodeToJson,
    fromJson: matchSummaryCodeFromJson,
  )
  final enums.MatchSummaryCode summary;
  static const fromJsonFactory = _$KYCCheckPhoneSummaryFromJson;
  static const toJsonFactory = _$KYCCheckPhoneSummaryToJson;
  Map<String, dynamic> toJson() => _$KYCCheckPhoneSummaryToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is KYCCheckPhoneSummary &&
            (identical(other.summary, summary) ||
                const DeepCollectionEquality().equals(other.summary, summary)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(summary) ^ runtimeType.hashCode;
}

extension $KYCCheckPhoneSummaryExtension on KYCCheckPhoneSummary {
  KYCCheckPhoneSummary copyWith({enums.MatchSummaryCode? summary}) {
    return KYCCheckPhoneSummary(summary: summary ?? this.summary);
  }

  KYCCheckPhoneSummary copyWithWrapped(
      {Wrapped<enums.MatchSummaryCode>? summary}) {
    return KYCCheckPhoneSummary(
        summary: (summary != null ? summary.value : this.summary));
  }
}

@JsonSerializable(explicitToJson: true)
class MatchSummary {
  MatchSummary({
    required this.summary,
  });

  factory MatchSummary.fromJson(Map<String, dynamic> json) =>
      _$MatchSummaryFromJson(json);

  @JsonKey(
    name: 'summary',
    toJson: matchSummaryCodeToJson,
    fromJson: matchSummaryCodeFromJson,
  )
  final enums.MatchSummaryCode summary;
  static const fromJsonFactory = _$MatchSummaryFromJson;
  static const toJsonFactory = _$MatchSummaryToJson;
  Map<String, dynamic> toJson() => _$MatchSummaryToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is MatchSummary &&
            (identical(other.summary, summary) ||
                const DeepCollectionEquality().equals(other.summary, summary)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(summary) ^ runtimeType.hashCode;
}

extension $MatchSummaryExtension on MatchSummary {
  MatchSummary copyWith({enums.MatchSummaryCode? summary}) {
    return MatchSummary(summary: summary ?? this.summary);
  }

  MatchSummary copyWithWrapped({Wrapped<enums.MatchSummaryCode>? summary}) {
    return MatchSummary(
        summary: (summary != null ? summary.value : this.summary));
  }
}

@JsonSerializable(explicitToJson: true)
class PhysicalDocumentExtractedData {
  PhysicalDocumentExtractedData({
    required this.idNumber,
    required this.category,
    required this.expirationDate,
    required this.issuingCountry,
    required this.issuingRegion,
  });

  factory PhysicalDocumentExtractedData.fromJson(Map<String, dynamic> json) =>
      _$PhysicalDocumentExtractedDataFromJson(json);

  @JsonKey(name: 'id_number')
  final String? idNumber;
  @JsonKey(
    name: 'category',
    toJson: physicalDocumentCategoryToJson,
    fromJson: physicalDocumentCategoryFromJson,
  )
  final enums.PhysicalDocumentCategory category;
  @JsonKey(name: 'expiration_date')
  final String? expirationDate;
  @JsonKey(name: 'issuing_country')
  final String issuingCountry;
  @JsonKey(name: 'issuing_region')
  final String? issuingRegion;
  static const fromJsonFactory = _$PhysicalDocumentExtractedDataFromJson;
  static const toJsonFactory = _$PhysicalDocumentExtractedDataToJson;
  Map<String, dynamic> toJson() => _$PhysicalDocumentExtractedDataToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PhysicalDocumentExtractedData &&
            (identical(other.idNumber, idNumber) ||
                const DeepCollectionEquality()
                    .equals(other.idNumber, idNumber)) &&
            (identical(other.category, category) ||
                const DeepCollectionEquality()
                    .equals(other.category, category)) &&
            (identical(other.expirationDate, expirationDate) ||
                const DeepCollectionEquality()
                    .equals(other.expirationDate, expirationDate)) &&
            (identical(other.issuingCountry, issuingCountry) ||
                const DeepCollectionEquality()
                    .equals(other.issuingCountry, issuingCountry)) &&
            (identical(other.issuingRegion, issuingRegion) ||
                const DeepCollectionEquality()
                    .equals(other.issuingRegion, issuingRegion)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(idNumber) ^
      const DeepCollectionEquality().hash(category) ^
      const DeepCollectionEquality().hash(expirationDate) ^
      const DeepCollectionEquality().hash(issuingCountry) ^
      const DeepCollectionEquality().hash(issuingRegion) ^
      runtimeType.hashCode;
}

extension $PhysicalDocumentExtractedDataExtension
    on PhysicalDocumentExtractedData {
  PhysicalDocumentExtractedData copyWith(
      {String? idNumber,
      enums.PhysicalDocumentCategory? category,
      String? expirationDate,
      String? issuingCountry,
      String? issuingRegion}) {
    return PhysicalDocumentExtractedData(
        idNumber: idNumber ?? this.idNumber,
        category: category ?? this.category,
        expirationDate: expirationDate ?? this.expirationDate,
        issuingCountry: issuingCountry ?? this.issuingCountry,
        issuingRegion: issuingRegion ?? this.issuingRegion);
  }

  PhysicalDocumentExtractedData copyWithWrapped(
      {Wrapped<String?>? idNumber,
      Wrapped<enums.PhysicalDocumentCategory>? category,
      Wrapped<String?>? expirationDate,
      Wrapped<String>? issuingCountry,
      Wrapped<String?>? issuingRegion}) {
    return PhysicalDocumentExtractedData(
        idNumber: (idNumber != null ? idNumber.value : this.idNumber),
        category: (category != null ? category.value : this.category),
        expirationDate: (expirationDate != null
            ? expirationDate.value
            : this.expirationDate),
        issuingCountry: (issuingCountry != null
            ? issuingCountry.value
            : this.issuingCountry),
        issuingRegion:
            (issuingRegion != null ? issuingRegion.value : this.issuingRegion));
  }
}

@JsonSerializable(explicitToJson: true)
class PhysicalDocumentExtractedDataAnalysis {
  PhysicalDocumentExtractedDataAnalysis({
    required this.name,
    required this.dateOfBirth,
    required this.expirationDate,
    required this.issuingCountry,
  });

  factory PhysicalDocumentExtractedDataAnalysis.fromJson(
          Map<String, dynamic> json) =>
      _$PhysicalDocumentExtractedDataAnalysisFromJson(json);

  @JsonKey(
    name: 'name',
    toJson: documentNameMatchCodeToJson,
    fromJson: documentNameMatchCodeFromJson,
  )
  final enums.DocumentNameMatchCode name;
  @JsonKey(
    name: 'date_of_birth',
    toJson: documentDateOfBirthMatchCodeToJson,
    fromJson: documentDateOfBirthMatchCodeFromJson,
  )
  final enums.DocumentDateOfBirthMatchCode dateOfBirth;
  @JsonKey(
    name: 'expiration_date',
    toJson: expirationDateToJson,
    fromJson: expirationDateFromJson,
  )
  final enums.ExpirationDate expirationDate;
  @JsonKey(
    name: 'issuing_country',
    toJson: issuingCountryToJson,
    fromJson: issuingCountryFromJson,
  )
  final enums.IssuingCountry issuingCountry;
  static const fromJsonFactory =
      _$PhysicalDocumentExtractedDataAnalysisFromJson;
  static const toJsonFactory = _$PhysicalDocumentExtractedDataAnalysisToJson;
  Map<String, dynamic> toJson() =>
      _$PhysicalDocumentExtractedDataAnalysisToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PhysicalDocumentExtractedDataAnalysis &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.dateOfBirth, dateOfBirth) ||
                const DeepCollectionEquality()
                    .equals(other.dateOfBirth, dateOfBirth)) &&
            (identical(other.expirationDate, expirationDate) ||
                const DeepCollectionEquality()
                    .equals(other.expirationDate, expirationDate)) &&
            (identical(other.issuingCountry, issuingCountry) ||
                const DeepCollectionEquality()
                    .equals(other.issuingCountry, issuingCountry)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(dateOfBirth) ^
      const DeepCollectionEquality().hash(expirationDate) ^
      const DeepCollectionEquality().hash(issuingCountry) ^
      runtimeType.hashCode;
}

extension $PhysicalDocumentExtractedDataAnalysisExtension
    on PhysicalDocumentExtractedDataAnalysis {
  PhysicalDocumentExtractedDataAnalysis copyWith(
      {enums.DocumentNameMatchCode? name,
      enums.DocumentDateOfBirthMatchCode? dateOfBirth,
      enums.ExpirationDate? expirationDate,
      enums.IssuingCountry? issuingCountry}) {
    return PhysicalDocumentExtractedDataAnalysis(
        name: name ?? this.name,
        dateOfBirth: dateOfBirth ?? this.dateOfBirth,
        expirationDate: expirationDate ?? this.expirationDate,
        issuingCountry: issuingCountry ?? this.issuingCountry);
  }

  PhysicalDocumentExtractedDataAnalysis copyWithWrapped(
      {Wrapped<enums.DocumentNameMatchCode>? name,
      Wrapped<enums.DocumentDateOfBirthMatchCode>? dateOfBirth,
      Wrapped<enums.ExpirationDate>? expirationDate,
      Wrapped<enums.IssuingCountry>? issuingCountry}) {
    return PhysicalDocumentExtractedDataAnalysis(
        name: (name != null ? name.value : this.name),
        dateOfBirth:
            (dateOfBirth != null ? dateOfBirth.value : this.dateOfBirth),
        expirationDate: (expirationDate != null
            ? expirationDate.value
            : this.expirationDate),
        issuingCountry: (issuingCountry != null
            ? issuingCountry.value
            : this.issuingCountry));
  }
}

@JsonSerializable(explicitToJson: true)
class PhysicalDocumentImages {
  PhysicalDocumentImages({
    required this.originalFront,
    required this.originalBack,
    required this.croppedFront,
    required this.croppedBack,
    required this.face,
  });

  factory PhysicalDocumentImages.fromJson(Map<String, dynamic> json) =>
      _$PhysicalDocumentImagesFromJson(json);

  @JsonKey(name: 'original_front')
  final String originalFront;
  @JsonKey(name: 'original_back')
  final String? originalBack;
  @JsonKey(name: 'cropped_front')
  final String? croppedFront;
  @JsonKey(name: 'cropped_back')
  final String? croppedBack;
  @JsonKey(name: 'face')
  final String? face;
  static const fromJsonFactory = _$PhysicalDocumentImagesFromJson;
  static const toJsonFactory = _$PhysicalDocumentImagesToJson;
  Map<String, dynamic> toJson() => _$PhysicalDocumentImagesToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PhysicalDocumentImages &&
            (identical(other.originalFront, originalFront) ||
                const DeepCollectionEquality()
                    .equals(other.originalFront, originalFront)) &&
            (identical(other.originalBack, originalBack) ||
                const DeepCollectionEquality()
                    .equals(other.originalBack, originalBack)) &&
            (identical(other.croppedFront, croppedFront) ||
                const DeepCollectionEquality()
                    .equals(other.croppedFront, croppedFront)) &&
            (identical(other.croppedBack, croppedBack) ||
                const DeepCollectionEquality()
                    .equals(other.croppedBack, croppedBack)) &&
            (identical(other.face, face) ||
                const DeepCollectionEquality().equals(other.face, face)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(originalFront) ^
      const DeepCollectionEquality().hash(originalBack) ^
      const DeepCollectionEquality().hash(croppedFront) ^
      const DeepCollectionEquality().hash(croppedBack) ^
      const DeepCollectionEquality().hash(face) ^
      runtimeType.hashCode;
}

extension $PhysicalDocumentImagesExtension on PhysicalDocumentImages {
  PhysicalDocumentImages copyWith(
      {String? originalFront,
      String? originalBack,
      String? croppedFront,
      String? croppedBack,
      String? face}) {
    return PhysicalDocumentImages(
        originalFront: originalFront ?? this.originalFront,
        originalBack: originalBack ?? this.originalBack,
        croppedFront: croppedFront ?? this.croppedFront,
        croppedBack: croppedBack ?? this.croppedBack,
        face: face ?? this.face);
  }

  PhysicalDocumentImages copyWithWrapped(
      {Wrapped<String>? originalFront,
      Wrapped<String?>? originalBack,
      Wrapped<String?>? croppedFront,
      Wrapped<String?>? croppedBack,
      Wrapped<String?>? face}) {
    return PhysicalDocumentImages(
        originalFront:
            (originalFront != null ? originalFront.value : this.originalFront),
        originalBack:
            (originalBack != null ? originalBack.value : this.originalBack),
        croppedFront:
            (croppedFront != null ? croppedFront.value : this.croppedFront),
        croppedBack:
            (croppedBack != null ? croppedBack.value : this.croppedBack),
        face: (face != null ? face.value : this.face));
  }
}

@JsonSerializable(explicitToJson: true)
class ScreeningHitAnalysis {
  ScreeningHitAnalysis({
    this.datesOfBirth,
    this.documents,
    this.locations,
    this.names,
    required this.searchTermsVersion,
  });

  factory ScreeningHitAnalysis.fromJson(Map<String, dynamic> json) =>
      _$ScreeningHitAnalysisFromJson(json);

  @JsonKey(
    name: 'dates_of_birth',
    toJson: matchSummaryCodeToJson,
    fromJson: matchSummaryCodeFromJson,
  )
  final enums.MatchSummaryCode? datesOfBirth;
  @JsonKey(
    name: 'documents',
    toJson: matchSummaryCodeToJson,
    fromJson: matchSummaryCodeFromJson,
  )
  final enums.MatchSummaryCode? documents;
  @JsonKey(
    name: 'locations',
    toJson: matchSummaryCodeToJson,
    fromJson: matchSummaryCodeFromJson,
  )
  final enums.MatchSummaryCode? locations;
  @JsonKey(
    name: 'names',
    toJson: matchSummaryCodeToJson,
    fromJson: matchSummaryCodeFromJson,
  )
  final enums.MatchSummaryCode? names;
  @JsonKey(name: 'search_terms_version')
  final double searchTermsVersion;
  static const fromJsonFactory = _$ScreeningHitAnalysisFromJson;
  static const toJsonFactory = _$ScreeningHitAnalysisToJson;
  Map<String, dynamic> toJson() => _$ScreeningHitAnalysisToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ScreeningHitAnalysis &&
            (identical(other.datesOfBirth, datesOfBirth) ||
                const DeepCollectionEquality()
                    .equals(other.datesOfBirth, datesOfBirth)) &&
            (identical(other.documents, documents) ||
                const DeepCollectionEquality()
                    .equals(other.documents, documents)) &&
            (identical(other.locations, locations) ||
                const DeepCollectionEquality()
                    .equals(other.locations, locations)) &&
            (identical(other.names, names) ||
                const DeepCollectionEquality().equals(other.names, names)) &&
            (identical(other.searchTermsVersion, searchTermsVersion) ||
                const DeepCollectionEquality()
                    .equals(other.searchTermsVersion, searchTermsVersion)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(datesOfBirth) ^
      const DeepCollectionEquality().hash(documents) ^
      const DeepCollectionEquality().hash(locations) ^
      const DeepCollectionEquality().hash(names) ^
      const DeepCollectionEquality().hash(searchTermsVersion) ^
      runtimeType.hashCode;
}

extension $ScreeningHitAnalysisExtension on ScreeningHitAnalysis {
  ScreeningHitAnalysis copyWith(
      {enums.MatchSummaryCode? datesOfBirth,
      enums.MatchSummaryCode? documents,
      enums.MatchSummaryCode? locations,
      enums.MatchSummaryCode? names,
      double? searchTermsVersion}) {
    return ScreeningHitAnalysis(
        datesOfBirth: datesOfBirth ?? this.datesOfBirth,
        documents: documents ?? this.documents,
        locations: locations ?? this.locations,
        names: names ?? this.names,
        searchTermsVersion: searchTermsVersion ?? this.searchTermsVersion);
  }

  ScreeningHitAnalysis copyWithWrapped(
      {Wrapped<enums.MatchSummaryCode?>? datesOfBirth,
      Wrapped<enums.MatchSummaryCode?>? documents,
      Wrapped<enums.MatchSummaryCode?>? locations,
      Wrapped<enums.MatchSummaryCode?>? names,
      Wrapped<double>? searchTermsVersion}) {
    return ScreeningHitAnalysis(
        datesOfBirth:
            (datesOfBirth != null ? datesOfBirth.value : this.datesOfBirth),
        documents: (documents != null ? documents.value : this.documents),
        locations: (locations != null ? locations.value : this.locations),
        names: (names != null ? names.value : this.names),
        searchTermsVersion: (searchTermsVersion != null
            ? searchTermsVersion.value
            : this.searchTermsVersion));
  }
}

@JsonSerializable(explicitToJson: true)
class ScreeningHitData {
  ScreeningHitData({
    this.datesOfBirth,
    this.documents,
    this.locations,
    this.names,
  });

  factory ScreeningHitData.fromJson(Map<String, dynamic> json) =>
      _$ScreeningHitDataFromJson(json);

  @JsonKey(
      name: 'dates_of_birth', defaultValue: <ScreeningHitDateOfBirthItem>[])
  final List<ScreeningHitDateOfBirthItem>? datesOfBirth;
  @JsonKey(name: 'documents', defaultValue: <ScreeningHitDocumentsItems>[])
  final List<ScreeningHitDocumentsItems>? documents;
  @JsonKey(
      name: 'locations', defaultValue: <GenericScreeningHitLocationItems>[])
  final List<GenericScreeningHitLocationItems>? locations;
  @JsonKey(name: 'names', defaultValue: <ScreeningHitNamesItems>[])
  final List<ScreeningHitNamesItems>? names;
  static const fromJsonFactory = _$ScreeningHitDataFromJson;
  static const toJsonFactory = _$ScreeningHitDataToJson;
  Map<String, dynamic> toJson() => _$ScreeningHitDataToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ScreeningHitData &&
            (identical(other.datesOfBirth, datesOfBirth) ||
                const DeepCollectionEquality()
                    .equals(other.datesOfBirth, datesOfBirth)) &&
            (identical(other.documents, documents) ||
                const DeepCollectionEquality()
                    .equals(other.documents, documents)) &&
            (identical(other.locations, locations) ||
                const DeepCollectionEquality()
                    .equals(other.locations, locations)) &&
            (identical(other.names, names) ||
                const DeepCollectionEquality().equals(other.names, names)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(datesOfBirth) ^
      const DeepCollectionEquality().hash(documents) ^
      const DeepCollectionEquality().hash(locations) ^
      const DeepCollectionEquality().hash(names) ^
      runtimeType.hashCode;
}

extension $ScreeningHitDataExtension on ScreeningHitData {
  ScreeningHitData copyWith(
      {List<ScreeningHitDateOfBirthItem>? datesOfBirth,
      List<ScreeningHitDocumentsItems>? documents,
      List<GenericScreeningHitLocationItems>? locations,
      List<ScreeningHitNamesItems>? names}) {
    return ScreeningHitData(
        datesOfBirth: datesOfBirth ?? this.datesOfBirth,
        documents: documents ?? this.documents,
        locations: locations ?? this.locations,
        names: names ?? this.names);
  }

  ScreeningHitData copyWithWrapped(
      {Wrapped<List<ScreeningHitDateOfBirthItem>?>? datesOfBirth,
      Wrapped<List<ScreeningHitDocumentsItems>?>? documents,
      Wrapped<List<GenericScreeningHitLocationItems>?>? locations,
      Wrapped<List<ScreeningHitNamesItems>?>? names}) {
    return ScreeningHitData(
        datesOfBirth:
            (datesOfBirth != null ? datesOfBirth.value : this.datesOfBirth),
        documents: (documents != null ? documents.value : this.documents),
        locations: (locations != null ? locations.value : this.locations),
        names: (names != null ? names.value : this.names));
  }
}

@JsonSerializable(explicitToJson: true)
class ScreeningHitDateOfBirthItem {
  ScreeningHitDateOfBirthItem({
    this.analysis,
    this.data,
  });

  factory ScreeningHitDateOfBirthItem.fromJson(Map<String, dynamic> json) =>
      _$ScreeningHitDateOfBirthItemFromJson(json);

  @JsonKey(name: 'analysis')
  final MatchSummary? analysis;
  @JsonKey(name: 'data')
  final DateRange? data;
  static const fromJsonFactory = _$ScreeningHitDateOfBirthItemFromJson;
  static const toJsonFactory = _$ScreeningHitDateOfBirthItemToJson;
  Map<String, dynamic> toJson() => _$ScreeningHitDateOfBirthItemToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ScreeningHitDateOfBirthItem &&
            (identical(other.analysis, analysis) ||
                const DeepCollectionEquality()
                    .equals(other.analysis, analysis)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(analysis) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $ScreeningHitDateOfBirthItemExtension on ScreeningHitDateOfBirthItem {
  ScreeningHitDateOfBirthItem copyWith(
      {MatchSummary? analysis, DateRange? data}) {
    return ScreeningHitDateOfBirthItem(
        analysis: analysis ?? this.analysis, data: data ?? this.data);
  }

  ScreeningHitDateOfBirthItem copyWithWrapped(
      {Wrapped<MatchSummary?>? analysis, Wrapped<DateRange?>? data}) {
    return ScreeningHitDateOfBirthItem(
        analysis: (analysis != null ? analysis.value : this.analysis),
        data: (data != null ? data.value : this.data));
  }
}

@JsonSerializable(explicitToJson: true)
class ScreeningHitDocumentsItems {
  ScreeningHitDocumentsItems({
    this.analysis,
    this.data,
  });

  factory ScreeningHitDocumentsItems.fromJson(Map<String, dynamic> json) =>
      _$ScreeningHitDocumentsItemsFromJson(json);

  @JsonKey(name: 'analysis')
  final MatchSummary? analysis;
  @JsonKey(name: 'data')
  final WatchlistScreeningDocument? data;
  static const fromJsonFactory = _$ScreeningHitDocumentsItemsFromJson;
  static const toJsonFactory = _$ScreeningHitDocumentsItemsToJson;
  Map<String, dynamic> toJson() => _$ScreeningHitDocumentsItemsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ScreeningHitDocumentsItems &&
            (identical(other.analysis, analysis) ||
                const DeepCollectionEquality()
                    .equals(other.analysis, analysis)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(analysis) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $ScreeningHitDocumentsItemsExtension on ScreeningHitDocumentsItems {
  ScreeningHitDocumentsItems copyWith(
      {MatchSummary? analysis, WatchlistScreeningDocument? data}) {
    return ScreeningHitDocumentsItems(
        analysis: analysis ?? this.analysis, data: data ?? this.data);
  }

  ScreeningHitDocumentsItems copyWithWrapped(
      {Wrapped<MatchSummary?>? analysis,
      Wrapped<WatchlistScreeningDocument?>? data}) {
    return ScreeningHitDocumentsItems(
        analysis: (analysis != null ? analysis.value : this.analysis),
        data: (data != null ? data.value : this.data));
  }
}

@JsonSerializable(explicitToJson: true)
class ScreeningHitNamesItems {
  ScreeningHitNamesItems({
    this.analysis,
    this.data,
  });

  factory ScreeningHitNamesItems.fromJson(Map<String, dynamic> json) =>
      _$ScreeningHitNamesItemsFromJson(json);

  @JsonKey(name: 'analysis')
  final MatchSummary? analysis;
  @JsonKey(name: 'data')
  final IndividualScreeningHitNames? data;
  static const fromJsonFactory = _$ScreeningHitNamesItemsFromJson;
  static const toJsonFactory = _$ScreeningHitNamesItemsToJson;
  Map<String, dynamic> toJson() => _$ScreeningHitNamesItemsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ScreeningHitNamesItems &&
            (identical(other.analysis, analysis) ||
                const DeepCollectionEquality()
                    .equals(other.analysis, analysis)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(analysis) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $ScreeningHitNamesItemsExtension on ScreeningHitNamesItems {
  ScreeningHitNamesItems copyWith(
      {MatchSummary? analysis, IndividualScreeningHitNames? data}) {
    return ScreeningHitNamesItems(
        analysis: analysis ?? this.analysis, data: data ?? this.data);
  }

  ScreeningHitNamesItems copyWithWrapped(
      {Wrapped<MatchSummary?>? analysis,
      Wrapped<IndividualScreeningHitNames?>? data}) {
    return ScreeningHitNamesItems(
        analysis: (analysis != null ? analysis.value : this.analysis),
        data: (data != null ? data.value : this.data));
  }
}

@JsonSerializable(explicitToJson: true)
class UpdateEntityScreeningRequestSearchTerms {
  UpdateEntityScreeningRequestSearchTerms({
    required this.entityWatchlistProgramId,
    this.legalName,
    this.documentNumber,
    this.emailAddress,
    this.country,
    this.phoneNumber,
    this.url,
    required this.clientId,
    required this.secret,
  });

  factory UpdateEntityScreeningRequestSearchTerms.fromJson(
          Map<String, dynamic> json) =>
      _$UpdateEntityScreeningRequestSearchTermsFromJson(json);

  @JsonKey(name: 'entity_watchlist_program_id')
  final String entityWatchlistProgramId;
  @JsonKey(name: 'legal_name')
  final String? legalName;
  @JsonKey(name: 'document_number')
  final String? documentNumber;
  @JsonKey(name: 'email_address')
  final String? emailAddress;
  @JsonKey(name: 'country')
  final String? country;
  @JsonKey(name: 'phone_number')
  final String? phoneNumber;
  @JsonKey(name: 'url')
  final String? url;
  @JsonKey(name: 'client_id')
  final String clientId;
  @JsonKey(name: 'secret')
  final String secret;
  static const fromJsonFactory =
      _$UpdateEntityScreeningRequestSearchTermsFromJson;
  static const toJsonFactory = _$UpdateEntityScreeningRequestSearchTermsToJson;
  Map<String, dynamic> toJson() =>
      _$UpdateEntityScreeningRequestSearchTermsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is UpdateEntityScreeningRequestSearchTerms &&
            (identical(
                    other.entityWatchlistProgramId, entityWatchlistProgramId) ||
                const DeepCollectionEquality().equals(
                    other.entityWatchlistProgramId,
                    entityWatchlistProgramId)) &&
            (identical(other.legalName, legalName) ||
                const DeepCollectionEquality()
                    .equals(other.legalName, legalName)) &&
            (identical(other.documentNumber, documentNumber) ||
                const DeepCollectionEquality()
                    .equals(other.documentNumber, documentNumber)) &&
            (identical(other.emailAddress, emailAddress) ||
                const DeepCollectionEquality()
                    .equals(other.emailAddress, emailAddress)) &&
            (identical(other.country, country) ||
                const DeepCollectionEquality()
                    .equals(other.country, country)) &&
            (identical(other.phoneNumber, phoneNumber) ||
                const DeepCollectionEquality()
                    .equals(other.phoneNumber, phoneNumber)) &&
            (identical(other.url, url) ||
                const DeepCollectionEquality().equals(other.url, url)) &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entityWatchlistProgramId) ^
      const DeepCollectionEquality().hash(legalName) ^
      const DeepCollectionEquality().hash(documentNumber) ^
      const DeepCollectionEquality().hash(emailAddress) ^
      const DeepCollectionEquality().hash(country) ^
      const DeepCollectionEquality().hash(phoneNumber) ^
      const DeepCollectionEquality().hash(url) ^
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      runtimeType.hashCode;
}

extension $UpdateEntityScreeningRequestSearchTermsExtension
    on UpdateEntityScreeningRequestSearchTerms {
  UpdateEntityScreeningRequestSearchTerms copyWith(
      {String? entityWatchlistProgramId,
      String? legalName,
      String? documentNumber,
      String? emailAddress,
      String? country,
      String? phoneNumber,
      String? url,
      String? clientId,
      String? secret}) {
    return UpdateEntityScreeningRequestSearchTerms(
        entityWatchlistProgramId:
            entityWatchlistProgramId ?? this.entityWatchlistProgramId,
        legalName: legalName ?? this.legalName,
        documentNumber: documentNumber ?? this.documentNumber,
        emailAddress: emailAddress ?? this.emailAddress,
        country: country ?? this.country,
        phoneNumber: phoneNumber ?? this.phoneNumber,
        url: url ?? this.url,
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret);
  }

  UpdateEntityScreeningRequestSearchTerms copyWithWrapped(
      {Wrapped<String>? entityWatchlistProgramId,
      Wrapped<String?>? legalName,
      Wrapped<String?>? documentNumber,
      Wrapped<String?>? emailAddress,
      Wrapped<String?>? country,
      Wrapped<String?>? phoneNumber,
      Wrapped<String?>? url,
      Wrapped<String>? clientId,
      Wrapped<String>? secret}) {
    return UpdateEntityScreeningRequestSearchTerms(
        entityWatchlistProgramId: (entityWatchlistProgramId != null
            ? entityWatchlistProgramId.value
            : this.entityWatchlistProgramId),
        legalName: (legalName != null ? legalName.value : this.legalName),
        documentNumber: (documentNumber != null
            ? documentNumber.value
            : this.documentNumber),
        emailAddress:
            (emailAddress != null ? emailAddress.value : this.emailAddress),
        country: (country != null ? country.value : this.country),
        phoneNumber:
            (phoneNumber != null ? phoneNumber.value : this.phoneNumber),
        url: (url != null ? url.value : this.url),
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret));
  }
}

@JsonSerializable(explicitToJson: true)
class UpdateIndividualScreeningRequestSearchTerms {
  UpdateIndividualScreeningRequestSearchTerms({
    this.watchlistProgramId,
    this.legalName,
    this.dateOfBirth,
    this.documentNumber,
    this.country,
  });

  factory UpdateIndividualScreeningRequestSearchTerms.fromJson(
          Map<String, dynamic> json) =>
      _$UpdateIndividualScreeningRequestSearchTermsFromJson(json);

  @JsonKey(name: 'watchlist_program_id')
  final String? watchlistProgramId;
  @JsonKey(name: 'legal_name')
  final String? legalName;
  @JsonKey(name: 'date_of_birth')
  final String? dateOfBirth;
  @JsonKey(name: 'document_number')
  final String? documentNumber;
  @JsonKey(name: 'country')
  final String? country;
  static const fromJsonFactory =
      _$UpdateIndividualScreeningRequestSearchTermsFromJson;
  static const toJsonFactory =
      _$UpdateIndividualScreeningRequestSearchTermsToJson;
  Map<String, dynamic> toJson() =>
      _$UpdateIndividualScreeningRequestSearchTermsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is UpdateIndividualScreeningRequestSearchTerms &&
            (identical(other.watchlistProgramId, watchlistProgramId) ||
                const DeepCollectionEquality()
                    .equals(other.watchlistProgramId, watchlistProgramId)) &&
            (identical(other.legalName, legalName) ||
                const DeepCollectionEquality()
                    .equals(other.legalName, legalName)) &&
            (identical(other.dateOfBirth, dateOfBirth) ||
                const DeepCollectionEquality()
                    .equals(other.dateOfBirth, dateOfBirth)) &&
            (identical(other.documentNumber, documentNumber) ||
                const DeepCollectionEquality()
                    .equals(other.documentNumber, documentNumber)) &&
            (identical(other.country, country) ||
                const DeepCollectionEquality().equals(other.country, country)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(watchlistProgramId) ^
      const DeepCollectionEquality().hash(legalName) ^
      const DeepCollectionEquality().hash(dateOfBirth) ^
      const DeepCollectionEquality().hash(documentNumber) ^
      const DeepCollectionEquality().hash(country) ^
      runtimeType.hashCode;
}

extension $UpdateIndividualScreeningRequestSearchTermsExtension
    on UpdateIndividualScreeningRequestSearchTerms {
  UpdateIndividualScreeningRequestSearchTerms copyWith(
      {String? watchlistProgramId,
      String? legalName,
      String? dateOfBirth,
      String? documentNumber,
      String? country}) {
    return UpdateIndividualScreeningRequestSearchTerms(
        watchlistProgramId: watchlistProgramId ?? this.watchlistProgramId,
        legalName: legalName ?? this.legalName,
        dateOfBirth: dateOfBirth ?? this.dateOfBirth,
        documentNumber: documentNumber ?? this.documentNumber,
        country: country ?? this.country);
  }

  UpdateIndividualScreeningRequestSearchTerms copyWithWrapped(
      {Wrapped<String?>? watchlistProgramId,
      Wrapped<String?>? legalName,
      Wrapped<String?>? dateOfBirth,
      Wrapped<String?>? documentNumber,
      Wrapped<String?>? country}) {
    return UpdateIndividualScreeningRequestSearchTerms(
        watchlistProgramId: (watchlistProgramId != null
            ? watchlistProgramId.value
            : this.watchlistProgramId),
        legalName: (legalName != null ? legalName.value : this.legalName),
        dateOfBirth:
            (dateOfBirth != null ? dateOfBirth.value : this.dateOfBirth),
        documentNumber: (documentNumber != null
            ? documentNumber.value
            : this.documentNumber),
        country: (country != null ? country.value : this.country));
  }
}

@JsonSerializable(explicitToJson: true)
class UserAddress {
  UserAddress({
    required this.street,
    this.street2,
    required this.city,
    required this.region,
    required this.postalCode,
    required this.country,
  });

  factory UserAddress.fromJson(Map<String, dynamic> json) =>
      _$UserAddressFromJson(json);

  @JsonKey(name: 'street')
  final String street;
  @JsonKey(name: 'street2')
  final String? street2;
  @JsonKey(name: 'city')
  final String city;
  @JsonKey(name: 'region')
  final String region;
  @JsonKey(name: 'postal_code')
  final String postalCode;
  @JsonKey(name: 'country')
  final String country;
  static const fromJsonFactory = _$UserAddressFromJson;
  static const toJsonFactory = _$UserAddressToJson;
  Map<String, dynamic> toJson() => _$UserAddressToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is UserAddress &&
            (identical(other.street, street) ||
                const DeepCollectionEquality().equals(other.street, street)) &&
            (identical(other.street2, street2) ||
                const DeepCollectionEquality()
                    .equals(other.street2, street2)) &&
            (identical(other.city, city) ||
                const DeepCollectionEquality().equals(other.city, city)) &&
            (identical(other.region, region) ||
                const DeepCollectionEquality().equals(other.region, region)) &&
            (identical(other.postalCode, postalCode) ||
                const DeepCollectionEquality()
                    .equals(other.postalCode, postalCode)) &&
            (identical(other.country, country) ||
                const DeepCollectionEquality().equals(other.country, country)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(street) ^
      const DeepCollectionEquality().hash(street2) ^
      const DeepCollectionEquality().hash(city) ^
      const DeepCollectionEquality().hash(region) ^
      const DeepCollectionEquality().hash(postalCode) ^
      const DeepCollectionEquality().hash(country) ^
      runtimeType.hashCode;
}

extension $UserAddressExtension on UserAddress {
  UserAddress copyWith(
      {String? street,
      String? street2,
      String? city,
      String? region,
      String? postalCode,
      String? country}) {
    return UserAddress(
        street: street ?? this.street,
        street2: street2 ?? this.street2,
        city: city ?? this.city,
        region: region ?? this.region,
        postalCode: postalCode ?? this.postalCode,
        country: country ?? this.country);
  }

  UserAddress copyWithWrapped(
      {Wrapped<String>? street,
      Wrapped<String?>? street2,
      Wrapped<String>? city,
      Wrapped<String>? region,
      Wrapped<String>? postalCode,
      Wrapped<String>? country}) {
    return UserAddress(
        street: (street != null ? street.value : this.street),
        street2: (street2 != null ? street2.value : this.street2),
        city: (city != null ? city.value : this.city),
        region: (region != null ? region.value : this.region),
        postalCode: (postalCode != null ? postalCode.value : this.postalCode),
        country: (country != null ? country.value : this.country));
  }
}

@JsonSerializable(explicitToJson: true)
class UserIDNumber {
  UserIDNumber({
    required this.value,
    required this.type,
  });

  factory UserIDNumber.fromJson(Map<String, dynamic> json) =>
      _$UserIDNumberFromJson(json);

  @JsonKey(name: 'value')
  final String value;
  @JsonKey(
    name: 'type',
    toJson: iDNumberTypeToJson,
    fromJson: iDNumberTypeFromJson,
  )
  final enums.IDNumberType type;
  static const fromJsonFactory = _$UserIDNumberFromJson;
  static const toJsonFactory = _$UserIDNumberToJson;
  Map<String, dynamic> toJson() => _$UserIDNumberToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is UserIDNumber &&
            (identical(other.value, value) ||
                const DeepCollectionEquality().equals(other.value, value)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(value) ^
      const DeepCollectionEquality().hash(type) ^
      runtimeType.hashCode;
}

extension $UserIDNumberExtension on UserIDNumber {
  UserIDNumber copyWith({String? value, enums.IDNumberType? type}) {
    return UserIDNumber(value: value ?? this.value, type: type ?? this.type);
  }

  UserIDNumber copyWithWrapped(
      {Wrapped<String>? value, Wrapped<enums.IDNumberType>? type}) {
    return UserIDNumber(
        value: (value != null ? value.value : this.value),
        type: (type != null ? type.value : this.type));
  }
}

@JsonSerializable(explicitToJson: true)
class UserName {
  UserName({
    required this.givenName,
    required this.familyName,
  });

  factory UserName.fromJson(Map<String, dynamic> json) =>
      _$UserNameFromJson(json);

  @JsonKey(name: 'given_name')
  final String givenName;
  @JsonKey(name: 'family_name')
  final String familyName;
  static const fromJsonFactory = _$UserNameFromJson;
  static const toJsonFactory = _$UserNameToJson;
  Map<String, dynamic> toJson() => _$UserNameToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is UserName &&
            (identical(other.givenName, givenName) ||
                const DeepCollectionEquality()
                    .equals(other.givenName, givenName)) &&
            (identical(other.familyName, familyName) ||
                const DeepCollectionEquality()
                    .equals(other.familyName, familyName)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(givenName) ^
      const DeepCollectionEquality().hash(familyName) ^
      runtimeType.hashCode;
}

extension $UserNameExtension on UserName {
  UserName copyWith({String? givenName, String? familyName}) {
    return UserName(
        givenName: givenName ?? this.givenName,
        familyName: familyName ?? this.familyName);
  }

  UserName copyWithWrapped(
      {Wrapped<String>? givenName, Wrapped<String>? familyName}) {
    return UserName(
        givenName: (givenName != null ? givenName.value : this.givenName),
        familyName: (familyName != null ? familyName.value : this.familyName));
  }
}

@JsonSerializable(explicitToJson: true)
class WatchlistScreeningAuditTrail {
  WatchlistScreeningAuditTrail({
    required this.source,
    required this.dashboardUserId,
    required this.timestamp,
  });

  factory WatchlistScreeningAuditTrail.fromJson(Map<String, dynamic> json) =>
      _$WatchlistScreeningAuditTrailFromJson(json);

  @JsonKey(
    name: 'source',
    toJson: sourceToJson,
    fromJson: sourceFromJson,
  )
  final enums.Source source;
  @JsonKey(name: 'dashboard_user_id')
  final String? dashboardUserId;
  @JsonKey(name: 'timestamp')
  final String timestamp;
  static const fromJsonFactory = _$WatchlistScreeningAuditTrailFromJson;
  static const toJsonFactory = _$WatchlistScreeningAuditTrailToJson;
  Map<String, dynamic> toJson() => _$WatchlistScreeningAuditTrailToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WatchlistScreeningAuditTrail &&
            (identical(other.source, source) ||
                const DeepCollectionEquality().equals(other.source, source)) &&
            (identical(other.dashboardUserId, dashboardUserId) ||
                const DeepCollectionEquality()
                    .equals(other.dashboardUserId, dashboardUserId)) &&
            (identical(other.timestamp, timestamp) ||
                const DeepCollectionEquality()
                    .equals(other.timestamp, timestamp)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(source) ^
      const DeepCollectionEquality().hash(dashboardUserId) ^
      const DeepCollectionEquality().hash(timestamp) ^
      runtimeType.hashCode;
}

extension $WatchlistScreeningAuditTrailExtension
    on WatchlistScreeningAuditTrail {
  WatchlistScreeningAuditTrail copyWith(
      {enums.Source? source, String? dashboardUserId, String? timestamp}) {
    return WatchlistScreeningAuditTrail(
        source: source ?? this.source,
        dashboardUserId: dashboardUserId ?? this.dashboardUserId,
        timestamp: timestamp ?? this.timestamp);
  }

  WatchlistScreeningAuditTrail copyWithWrapped(
      {Wrapped<enums.Source>? source,
      Wrapped<String?>? dashboardUserId,
      Wrapped<String>? timestamp}) {
    return WatchlistScreeningAuditTrail(
        source: (source != null ? source.value : this.source),
        dashboardUserId: (dashboardUserId != null
            ? dashboardUserId.value
            : this.dashboardUserId),
        timestamp: (timestamp != null ? timestamp.value : this.timestamp));
  }
}

@JsonSerializable(explicitToJson: true)
class WatchlistScreeningDocument {
  WatchlistScreeningDocument({
    required this.type,
    required this.number,
  });

  factory WatchlistScreeningDocument.fromJson(Map<String, dynamic> json) =>
      _$WatchlistScreeningDocumentFromJson(json);

  @JsonKey(
    name: 'type',
    toJson: watchlistScreeningDocumentTypeToJson,
    fromJson: watchlistScreeningDocumentTypeFromJson,
  )
  final enums.WatchlistScreeningDocumentType type;
  @JsonKey(name: 'number')
  final String number;
  static const fromJsonFactory = _$WatchlistScreeningDocumentFromJson;
  static const toJsonFactory = _$WatchlistScreeningDocumentToJson;
  Map<String, dynamic> toJson() => _$WatchlistScreeningDocumentToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WatchlistScreeningDocument &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.number, number) ||
                const DeepCollectionEquality().equals(other.number, number)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(number) ^
      runtimeType.hashCode;
}

extension $WatchlistScreeningDocumentExtension on WatchlistScreeningDocument {
  WatchlistScreeningDocument copyWith(
      {enums.WatchlistScreeningDocumentType? type, String? number}) {
    return WatchlistScreeningDocument(
        type: type ?? this.type, number: number ?? this.number);
  }

  WatchlistScreeningDocument copyWithWrapped(
      {Wrapped<enums.WatchlistScreeningDocumentType>? type,
      Wrapped<String>? number}) {
    return WatchlistScreeningDocument(
        type: (type != null ? type.value : this.type),
        number: (number != null ? number.value : this.number));
  }
}

@JsonSerializable(explicitToJson: true)
class WatchlistScreeningEntityCreateRequest {
  WatchlistScreeningEntityCreateRequest({
    required this.searchTerms,
    this.clientUserId,
    this.clientId,
    this.secret,
  });

  factory WatchlistScreeningEntityCreateRequest.fromJson(
          Map<String, dynamic> json) =>
      _$WatchlistScreeningEntityCreateRequestFromJson(json);

  @JsonKey(name: 'search_terms')
  final EntityWatchlistSearchTerms searchTerms;
  @JsonKey(name: 'client_user_id')
  final String? clientUserId;
  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  static const fromJsonFactory =
      _$WatchlistScreeningEntityCreateRequestFromJson;
  static const toJsonFactory = _$WatchlistScreeningEntityCreateRequestToJson;
  Map<String, dynamic> toJson() =>
      _$WatchlistScreeningEntityCreateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WatchlistScreeningEntityCreateRequest &&
            (identical(other.searchTerms, searchTerms) ||
                const DeepCollectionEquality()
                    .equals(other.searchTerms, searchTerms)) &&
            (identical(other.clientUserId, clientUserId) ||
                const DeepCollectionEquality()
                    .equals(other.clientUserId, clientUserId)) &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(searchTerms) ^
      const DeepCollectionEquality().hash(clientUserId) ^
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      runtimeType.hashCode;
}

extension $WatchlistScreeningEntityCreateRequestExtension
    on WatchlistScreeningEntityCreateRequest {
  WatchlistScreeningEntityCreateRequest copyWith(
      {EntityWatchlistSearchTerms? searchTerms,
      String? clientUserId,
      String? clientId,
      String? secret}) {
    return WatchlistScreeningEntityCreateRequest(
        searchTerms: searchTerms ?? this.searchTerms,
        clientUserId: clientUserId ?? this.clientUserId,
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret);
  }

  WatchlistScreeningEntityCreateRequest copyWithWrapped(
      {Wrapped<EntityWatchlistSearchTerms>? searchTerms,
      Wrapped<String?>? clientUserId,
      Wrapped<String?>? clientId,
      Wrapped<String?>? secret}) {
    return WatchlistScreeningEntityCreateRequest(
        searchTerms:
            (searchTerms != null ? searchTerms.value : this.searchTerms),
        clientUserId:
            (clientUserId != null ? clientUserId.value : this.clientUserId),
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret));
  }
}

@JsonSerializable(explicitToJson: true)
class WatchlistScreeningEntityCreateResponse {
  WatchlistScreeningEntityCreateResponse({
    required this.id,
    required this.searchTerms,
    required this.assignee,
    required this.status,
    required this.clientUserId,
    required this.auditTrail,
    required this.requestId,
  });

  factory WatchlistScreeningEntityCreateResponse.fromJson(
          Map<String, dynamic> json) =>
      _$WatchlistScreeningEntityCreateResponseFromJson(json);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'search_terms')
  final EntityWatchlistScreeningSearchTerms searchTerms;
  @JsonKey(name: 'assignee')
  final String? assignee;
  @JsonKey(
    name: 'status',
    toJson: watchlistScreeningStatusToJson,
    fromJson: watchlistScreeningStatusFromJson,
  )
  final enums.WatchlistScreeningStatus status;
  @JsonKey(name: 'client_user_id')
  final String? clientUserId;
  @JsonKey(name: 'audit_trail')
  final WatchlistScreeningAuditTrail auditTrail;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory =
      _$WatchlistScreeningEntityCreateResponseFromJson;
  static const toJsonFactory = _$WatchlistScreeningEntityCreateResponseToJson;
  Map<String, dynamic> toJson() =>
      _$WatchlistScreeningEntityCreateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WatchlistScreeningEntityCreateResponse &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.searchTerms, searchTerms) ||
                const DeepCollectionEquality()
                    .equals(other.searchTerms, searchTerms)) &&
            (identical(other.assignee, assignee) ||
                const DeepCollectionEquality()
                    .equals(other.assignee, assignee)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.clientUserId, clientUserId) ||
                const DeepCollectionEquality()
                    .equals(other.clientUserId, clientUserId)) &&
            (identical(other.auditTrail, auditTrail) ||
                const DeepCollectionEquality()
                    .equals(other.auditTrail, auditTrail)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(searchTerms) ^
      const DeepCollectionEquality().hash(assignee) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(clientUserId) ^
      const DeepCollectionEquality().hash(auditTrail) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $WatchlistScreeningEntityCreateResponseExtension
    on WatchlistScreeningEntityCreateResponse {
  WatchlistScreeningEntityCreateResponse copyWith(
      {String? id,
      EntityWatchlistScreeningSearchTerms? searchTerms,
      String? assignee,
      enums.WatchlistScreeningStatus? status,
      String? clientUserId,
      WatchlistScreeningAuditTrail? auditTrail,
      String? requestId}) {
    return WatchlistScreeningEntityCreateResponse(
        id: id ?? this.id,
        searchTerms: searchTerms ?? this.searchTerms,
        assignee: assignee ?? this.assignee,
        status: status ?? this.status,
        clientUserId: clientUserId ?? this.clientUserId,
        auditTrail: auditTrail ?? this.auditTrail,
        requestId: requestId ?? this.requestId);
  }

  WatchlistScreeningEntityCreateResponse copyWithWrapped(
      {Wrapped<String>? id,
      Wrapped<EntityWatchlistScreeningSearchTerms>? searchTerms,
      Wrapped<String?>? assignee,
      Wrapped<enums.WatchlistScreeningStatus>? status,
      Wrapped<String?>? clientUserId,
      Wrapped<WatchlistScreeningAuditTrail>? auditTrail,
      Wrapped<String>? requestId}) {
    return WatchlistScreeningEntityCreateResponse(
        id: (id != null ? id.value : this.id),
        searchTerms:
            (searchTerms != null ? searchTerms.value : this.searchTerms),
        assignee: (assignee != null ? assignee.value : this.assignee),
        status: (status != null ? status.value : this.status),
        clientUserId:
            (clientUserId != null ? clientUserId.value : this.clientUserId),
        auditTrail: (auditTrail != null ? auditTrail.value : this.auditTrail),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class WatchlistScreeningEntityGetRequest {
  WatchlistScreeningEntityGetRequest({
    required this.entityWatchlistScreeningId,
    this.secret,
    this.clientId,
  });

  factory WatchlistScreeningEntityGetRequest.fromJson(
          Map<String, dynamic> json) =>
      _$WatchlistScreeningEntityGetRequestFromJson(json);

  @JsonKey(name: 'entity_watchlist_screening_id')
  final String entityWatchlistScreeningId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'client_id')
  final String? clientId;
  static const fromJsonFactory = _$WatchlistScreeningEntityGetRequestFromJson;
  static const toJsonFactory = _$WatchlistScreeningEntityGetRequestToJson;
  Map<String, dynamic> toJson() =>
      _$WatchlistScreeningEntityGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WatchlistScreeningEntityGetRequest &&
            (identical(other.entityWatchlistScreeningId,
                    entityWatchlistScreeningId) ||
                const DeepCollectionEquality().equals(
                    other.entityWatchlistScreeningId,
                    entityWatchlistScreeningId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entityWatchlistScreeningId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(clientId) ^
      runtimeType.hashCode;
}

extension $WatchlistScreeningEntityGetRequestExtension
    on WatchlistScreeningEntityGetRequest {
  WatchlistScreeningEntityGetRequest copyWith(
      {String? entityWatchlistScreeningId, String? secret, String? clientId}) {
    return WatchlistScreeningEntityGetRequest(
        entityWatchlistScreeningId:
            entityWatchlistScreeningId ?? this.entityWatchlistScreeningId,
        secret: secret ?? this.secret,
        clientId: clientId ?? this.clientId);
  }

  WatchlistScreeningEntityGetRequest copyWithWrapped(
      {Wrapped<String>? entityWatchlistScreeningId,
      Wrapped<String?>? secret,
      Wrapped<String?>? clientId}) {
    return WatchlistScreeningEntityGetRequest(
        entityWatchlistScreeningId: (entityWatchlistScreeningId != null
            ? entityWatchlistScreeningId.value
            : this.entityWatchlistScreeningId),
        secret: (secret != null ? secret.value : this.secret),
        clientId: (clientId != null ? clientId.value : this.clientId));
  }
}

@JsonSerializable(explicitToJson: true)
class WatchlistScreeningEntityGetResponse {
  WatchlistScreeningEntityGetResponse({
    required this.id,
    required this.searchTerms,
    required this.assignee,
    required this.status,
    required this.clientUserId,
    required this.auditTrail,
    required this.requestId,
  });

  factory WatchlistScreeningEntityGetResponse.fromJson(
          Map<String, dynamic> json) =>
      _$WatchlistScreeningEntityGetResponseFromJson(json);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'search_terms')
  final EntityWatchlistScreeningSearchTerms searchTerms;
  @JsonKey(name: 'assignee')
  final String? assignee;
  @JsonKey(
    name: 'status',
    toJson: watchlistScreeningStatusToJson,
    fromJson: watchlistScreeningStatusFromJson,
  )
  final enums.WatchlistScreeningStatus status;
  @JsonKey(name: 'client_user_id')
  final String? clientUserId;
  @JsonKey(name: 'audit_trail')
  final WatchlistScreeningAuditTrail auditTrail;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$WatchlistScreeningEntityGetResponseFromJson;
  static const toJsonFactory = _$WatchlistScreeningEntityGetResponseToJson;
  Map<String, dynamic> toJson() =>
      _$WatchlistScreeningEntityGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WatchlistScreeningEntityGetResponse &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.searchTerms, searchTerms) ||
                const DeepCollectionEquality()
                    .equals(other.searchTerms, searchTerms)) &&
            (identical(other.assignee, assignee) ||
                const DeepCollectionEquality()
                    .equals(other.assignee, assignee)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.clientUserId, clientUserId) ||
                const DeepCollectionEquality()
                    .equals(other.clientUserId, clientUserId)) &&
            (identical(other.auditTrail, auditTrail) ||
                const DeepCollectionEquality()
                    .equals(other.auditTrail, auditTrail)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(searchTerms) ^
      const DeepCollectionEquality().hash(assignee) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(clientUserId) ^
      const DeepCollectionEquality().hash(auditTrail) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $WatchlistScreeningEntityGetResponseExtension
    on WatchlistScreeningEntityGetResponse {
  WatchlistScreeningEntityGetResponse copyWith(
      {String? id,
      EntityWatchlistScreeningSearchTerms? searchTerms,
      String? assignee,
      enums.WatchlistScreeningStatus? status,
      String? clientUserId,
      WatchlistScreeningAuditTrail? auditTrail,
      String? requestId}) {
    return WatchlistScreeningEntityGetResponse(
        id: id ?? this.id,
        searchTerms: searchTerms ?? this.searchTerms,
        assignee: assignee ?? this.assignee,
        status: status ?? this.status,
        clientUserId: clientUserId ?? this.clientUserId,
        auditTrail: auditTrail ?? this.auditTrail,
        requestId: requestId ?? this.requestId);
  }

  WatchlistScreeningEntityGetResponse copyWithWrapped(
      {Wrapped<String>? id,
      Wrapped<EntityWatchlistScreeningSearchTerms>? searchTerms,
      Wrapped<String?>? assignee,
      Wrapped<enums.WatchlistScreeningStatus>? status,
      Wrapped<String?>? clientUserId,
      Wrapped<WatchlistScreeningAuditTrail>? auditTrail,
      Wrapped<String>? requestId}) {
    return WatchlistScreeningEntityGetResponse(
        id: (id != null ? id.value : this.id),
        searchTerms:
            (searchTerms != null ? searchTerms.value : this.searchTerms),
        assignee: (assignee != null ? assignee.value : this.assignee),
        status: (status != null ? status.value : this.status),
        clientUserId:
            (clientUserId != null ? clientUserId.value : this.clientUserId),
        auditTrail: (auditTrail != null ? auditTrail.value : this.auditTrail),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class WatchlistScreeningEntityHistoryListRequest {
  WatchlistScreeningEntityHistoryListRequest({
    this.secret,
    this.clientId,
    required this.entityWatchlistScreeningId,
    this.cursor,
  });

  factory WatchlistScreeningEntityHistoryListRequest.fromJson(
          Map<String, dynamic> json) =>
      _$WatchlistScreeningEntityHistoryListRequestFromJson(json);

  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'entity_watchlist_screening_id')
  final String entityWatchlistScreeningId;
  @JsonKey(name: 'cursor')
  final String? cursor;
  static const fromJsonFactory =
      _$WatchlistScreeningEntityHistoryListRequestFromJson;
  static const toJsonFactory =
      _$WatchlistScreeningEntityHistoryListRequestToJson;
  Map<String, dynamic> toJson() =>
      _$WatchlistScreeningEntityHistoryListRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WatchlistScreeningEntityHistoryListRequest &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.entityWatchlistScreeningId,
                    entityWatchlistScreeningId) ||
                const DeepCollectionEquality().equals(
                    other.entityWatchlistScreeningId,
                    entityWatchlistScreeningId)) &&
            (identical(other.cursor, cursor) ||
                const DeepCollectionEquality().equals(other.cursor, cursor)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(entityWatchlistScreeningId) ^
      const DeepCollectionEquality().hash(cursor) ^
      runtimeType.hashCode;
}

extension $WatchlistScreeningEntityHistoryListRequestExtension
    on WatchlistScreeningEntityHistoryListRequest {
  WatchlistScreeningEntityHistoryListRequest copyWith(
      {String? secret,
      String? clientId,
      String? entityWatchlistScreeningId,
      String? cursor}) {
    return WatchlistScreeningEntityHistoryListRequest(
        secret: secret ?? this.secret,
        clientId: clientId ?? this.clientId,
        entityWatchlistScreeningId:
            entityWatchlistScreeningId ?? this.entityWatchlistScreeningId,
        cursor: cursor ?? this.cursor);
  }

  WatchlistScreeningEntityHistoryListRequest copyWithWrapped(
      {Wrapped<String?>? secret,
      Wrapped<String?>? clientId,
      Wrapped<String>? entityWatchlistScreeningId,
      Wrapped<String?>? cursor}) {
    return WatchlistScreeningEntityHistoryListRequest(
        secret: (secret != null ? secret.value : this.secret),
        clientId: (clientId != null ? clientId.value : this.clientId),
        entityWatchlistScreeningId: (entityWatchlistScreeningId != null
            ? entityWatchlistScreeningId.value
            : this.entityWatchlistScreeningId),
        cursor: (cursor != null ? cursor.value : this.cursor));
  }
}

@JsonSerializable(explicitToJson: true)
class WatchlistScreeningEntityHistoryListResponse {
  WatchlistScreeningEntityHistoryListResponse({
    required this.entityWatchlistScreenings,
    required this.nextCursor,
    required this.requestId,
  });

  factory WatchlistScreeningEntityHistoryListResponse.fromJson(
          Map<String, dynamic> json) =>
      _$WatchlistScreeningEntityHistoryListResponseFromJson(json);

  @JsonKey(
      name: 'entity_watchlist_screenings',
      defaultValue: <EntityWatchlistScreening>[])
  final List<EntityWatchlistScreening> entityWatchlistScreenings;
  @JsonKey(name: 'next_cursor')
  final String? nextCursor;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory =
      _$WatchlistScreeningEntityHistoryListResponseFromJson;
  static const toJsonFactory =
      _$WatchlistScreeningEntityHistoryListResponseToJson;
  Map<String, dynamic> toJson() =>
      _$WatchlistScreeningEntityHistoryListResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WatchlistScreeningEntityHistoryListResponse &&
            (identical(other.entityWatchlistScreenings,
                    entityWatchlistScreenings) ||
                const DeepCollectionEquality().equals(
                    other.entityWatchlistScreenings,
                    entityWatchlistScreenings)) &&
            (identical(other.nextCursor, nextCursor) ||
                const DeepCollectionEquality()
                    .equals(other.nextCursor, nextCursor)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entityWatchlistScreenings) ^
      const DeepCollectionEquality().hash(nextCursor) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $WatchlistScreeningEntityHistoryListResponseExtension
    on WatchlistScreeningEntityHistoryListResponse {
  WatchlistScreeningEntityHistoryListResponse copyWith(
      {List<EntityWatchlistScreening>? entityWatchlistScreenings,
      String? nextCursor,
      String? requestId}) {
    return WatchlistScreeningEntityHistoryListResponse(
        entityWatchlistScreenings:
            entityWatchlistScreenings ?? this.entityWatchlistScreenings,
        nextCursor: nextCursor ?? this.nextCursor,
        requestId: requestId ?? this.requestId);
  }

  WatchlistScreeningEntityHistoryListResponse copyWithWrapped(
      {Wrapped<List<EntityWatchlistScreening>>? entityWatchlistScreenings,
      Wrapped<String?>? nextCursor,
      Wrapped<String>? requestId}) {
    return WatchlistScreeningEntityHistoryListResponse(
        entityWatchlistScreenings: (entityWatchlistScreenings != null
            ? entityWatchlistScreenings.value
            : this.entityWatchlistScreenings),
        nextCursor: (nextCursor != null ? nextCursor.value : this.nextCursor),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class WatchlistScreeningEntityHitListRequest {
  WatchlistScreeningEntityHitListRequest({
    this.secret,
    this.clientId,
    required this.entityWatchlistScreeningId,
    this.cursor,
  });

  factory WatchlistScreeningEntityHitListRequest.fromJson(
          Map<String, dynamic> json) =>
      _$WatchlistScreeningEntityHitListRequestFromJson(json);

  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'entity_watchlist_screening_id')
  final String entityWatchlistScreeningId;
  @JsonKey(name: 'cursor')
  final String? cursor;
  static const fromJsonFactory =
      _$WatchlistScreeningEntityHitListRequestFromJson;
  static const toJsonFactory = _$WatchlistScreeningEntityHitListRequestToJson;
  Map<String, dynamic> toJson() =>
      _$WatchlistScreeningEntityHitListRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WatchlistScreeningEntityHitListRequest &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.entityWatchlistScreeningId,
                    entityWatchlistScreeningId) ||
                const DeepCollectionEquality().equals(
                    other.entityWatchlistScreeningId,
                    entityWatchlistScreeningId)) &&
            (identical(other.cursor, cursor) ||
                const DeepCollectionEquality().equals(other.cursor, cursor)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(entityWatchlistScreeningId) ^
      const DeepCollectionEquality().hash(cursor) ^
      runtimeType.hashCode;
}

extension $WatchlistScreeningEntityHitListRequestExtension
    on WatchlistScreeningEntityHitListRequest {
  WatchlistScreeningEntityHitListRequest copyWith(
      {String? secret,
      String? clientId,
      String? entityWatchlistScreeningId,
      String? cursor}) {
    return WatchlistScreeningEntityHitListRequest(
        secret: secret ?? this.secret,
        clientId: clientId ?? this.clientId,
        entityWatchlistScreeningId:
            entityWatchlistScreeningId ?? this.entityWatchlistScreeningId,
        cursor: cursor ?? this.cursor);
  }

  WatchlistScreeningEntityHitListRequest copyWithWrapped(
      {Wrapped<String?>? secret,
      Wrapped<String?>? clientId,
      Wrapped<String>? entityWatchlistScreeningId,
      Wrapped<String?>? cursor}) {
    return WatchlistScreeningEntityHitListRequest(
        secret: (secret != null ? secret.value : this.secret),
        clientId: (clientId != null ? clientId.value : this.clientId),
        entityWatchlistScreeningId: (entityWatchlistScreeningId != null
            ? entityWatchlistScreeningId.value
            : this.entityWatchlistScreeningId),
        cursor: (cursor != null ? cursor.value : this.cursor));
  }
}

@JsonSerializable(explicitToJson: true)
class WatchlistScreeningEntityHitListResponse {
  WatchlistScreeningEntityHitListResponse({
    required this.entityWatchlistScreeningHits,
    required this.nextCursor,
    required this.requestId,
  });

  factory WatchlistScreeningEntityHitListResponse.fromJson(
          Map<String, dynamic> json) =>
      _$WatchlistScreeningEntityHitListResponseFromJson(json);

  @JsonKey(
      name: 'entity_watchlist_screening_hits',
      defaultValue: <EntityWatchlistScreeningHit>[])
  final List<EntityWatchlistScreeningHit> entityWatchlistScreeningHits;
  @JsonKey(name: 'next_cursor')
  final String? nextCursor;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory =
      _$WatchlistScreeningEntityHitListResponseFromJson;
  static const toJsonFactory = _$WatchlistScreeningEntityHitListResponseToJson;
  Map<String, dynamic> toJson() =>
      _$WatchlistScreeningEntityHitListResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WatchlistScreeningEntityHitListResponse &&
            (identical(other.entityWatchlistScreeningHits,
                    entityWatchlistScreeningHits) ||
                const DeepCollectionEquality().equals(
                    other.entityWatchlistScreeningHits,
                    entityWatchlistScreeningHits)) &&
            (identical(other.nextCursor, nextCursor) ||
                const DeepCollectionEquality()
                    .equals(other.nextCursor, nextCursor)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entityWatchlistScreeningHits) ^
      const DeepCollectionEquality().hash(nextCursor) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $WatchlistScreeningEntityHitListResponseExtension
    on WatchlistScreeningEntityHitListResponse {
  WatchlistScreeningEntityHitListResponse copyWith(
      {List<EntityWatchlistScreeningHit>? entityWatchlistScreeningHits,
      String? nextCursor,
      String? requestId}) {
    return WatchlistScreeningEntityHitListResponse(
        entityWatchlistScreeningHits:
            entityWatchlistScreeningHits ?? this.entityWatchlistScreeningHits,
        nextCursor: nextCursor ?? this.nextCursor,
        requestId: requestId ?? this.requestId);
  }

  WatchlistScreeningEntityHitListResponse copyWithWrapped(
      {Wrapped<List<EntityWatchlistScreeningHit>>? entityWatchlistScreeningHits,
      Wrapped<String?>? nextCursor,
      Wrapped<String>? requestId}) {
    return WatchlistScreeningEntityHitListResponse(
        entityWatchlistScreeningHits: (entityWatchlistScreeningHits != null
            ? entityWatchlistScreeningHits.value
            : this.entityWatchlistScreeningHits),
        nextCursor: (nextCursor != null ? nextCursor.value : this.nextCursor),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class WatchlistScreeningEntityListRequest {
  WatchlistScreeningEntityListRequest({
    this.secret,
    this.clientId,
    required this.entityWatchlistProgramId,
    this.clientUserId,
    this.status,
    this.assignee,
    this.cursor,
  });

  factory WatchlistScreeningEntityListRequest.fromJson(
          Map<String, dynamic> json) =>
      _$WatchlistScreeningEntityListRequestFromJson(json);

  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'entity_watchlist_program_id')
  final String entityWatchlistProgramId;
  @JsonKey(name: 'client_user_id')
  final String? clientUserId;
  @JsonKey(
    name: 'status',
    toJson: watchlistScreeningStatusToJson,
    fromJson: watchlistScreeningStatusFromJson,
  )
  final enums.WatchlistScreeningStatus? status;
  @JsonKey(name: 'assignee')
  final String? assignee;
  @JsonKey(name: 'cursor')
  final String? cursor;
  static const fromJsonFactory = _$WatchlistScreeningEntityListRequestFromJson;
  static const toJsonFactory = _$WatchlistScreeningEntityListRequestToJson;
  Map<String, dynamic> toJson() =>
      _$WatchlistScreeningEntityListRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WatchlistScreeningEntityListRequest &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(
                    other.entityWatchlistProgramId, entityWatchlistProgramId) ||
                const DeepCollectionEquality().equals(
                    other.entityWatchlistProgramId,
                    entityWatchlistProgramId)) &&
            (identical(other.clientUserId, clientUserId) ||
                const DeepCollectionEquality()
                    .equals(other.clientUserId, clientUserId)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.assignee, assignee) ||
                const DeepCollectionEquality()
                    .equals(other.assignee, assignee)) &&
            (identical(other.cursor, cursor) ||
                const DeepCollectionEquality().equals(other.cursor, cursor)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(entityWatchlistProgramId) ^
      const DeepCollectionEquality().hash(clientUserId) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(assignee) ^
      const DeepCollectionEquality().hash(cursor) ^
      runtimeType.hashCode;
}

extension $WatchlistScreeningEntityListRequestExtension
    on WatchlistScreeningEntityListRequest {
  WatchlistScreeningEntityListRequest copyWith(
      {String? secret,
      String? clientId,
      String? entityWatchlistProgramId,
      String? clientUserId,
      enums.WatchlistScreeningStatus? status,
      String? assignee,
      String? cursor}) {
    return WatchlistScreeningEntityListRequest(
        secret: secret ?? this.secret,
        clientId: clientId ?? this.clientId,
        entityWatchlistProgramId:
            entityWatchlistProgramId ?? this.entityWatchlistProgramId,
        clientUserId: clientUserId ?? this.clientUserId,
        status: status ?? this.status,
        assignee: assignee ?? this.assignee,
        cursor: cursor ?? this.cursor);
  }

  WatchlistScreeningEntityListRequest copyWithWrapped(
      {Wrapped<String?>? secret,
      Wrapped<String?>? clientId,
      Wrapped<String>? entityWatchlistProgramId,
      Wrapped<String?>? clientUserId,
      Wrapped<enums.WatchlistScreeningStatus?>? status,
      Wrapped<String?>? assignee,
      Wrapped<String?>? cursor}) {
    return WatchlistScreeningEntityListRequest(
        secret: (secret != null ? secret.value : this.secret),
        clientId: (clientId != null ? clientId.value : this.clientId),
        entityWatchlistProgramId: (entityWatchlistProgramId != null
            ? entityWatchlistProgramId.value
            : this.entityWatchlistProgramId),
        clientUserId:
            (clientUserId != null ? clientUserId.value : this.clientUserId),
        status: (status != null ? status.value : this.status),
        assignee: (assignee != null ? assignee.value : this.assignee),
        cursor: (cursor != null ? cursor.value : this.cursor));
  }
}

@JsonSerializable(explicitToJson: true)
class WatchlistScreeningEntityListResponse {
  WatchlistScreeningEntityListResponse({
    required this.entityWatchlistScreenings,
    required this.nextCursor,
    required this.requestId,
  });

  factory WatchlistScreeningEntityListResponse.fromJson(
          Map<String, dynamic> json) =>
      _$WatchlistScreeningEntityListResponseFromJson(json);

  @JsonKey(
      name: 'entity_watchlist_screenings',
      defaultValue: <EntityWatchlistScreening>[])
  final List<EntityWatchlistScreening> entityWatchlistScreenings;
  @JsonKey(name: 'next_cursor')
  final String? nextCursor;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$WatchlistScreeningEntityListResponseFromJson;
  static const toJsonFactory = _$WatchlistScreeningEntityListResponseToJson;
  Map<String, dynamic> toJson() =>
      _$WatchlistScreeningEntityListResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WatchlistScreeningEntityListResponse &&
            (identical(other.entityWatchlistScreenings,
                    entityWatchlistScreenings) ||
                const DeepCollectionEquality().equals(
                    other.entityWatchlistScreenings,
                    entityWatchlistScreenings)) &&
            (identical(other.nextCursor, nextCursor) ||
                const DeepCollectionEquality()
                    .equals(other.nextCursor, nextCursor)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entityWatchlistScreenings) ^
      const DeepCollectionEquality().hash(nextCursor) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $WatchlistScreeningEntityListResponseExtension
    on WatchlistScreeningEntityListResponse {
  WatchlistScreeningEntityListResponse copyWith(
      {List<EntityWatchlistScreening>? entityWatchlistScreenings,
      String? nextCursor,
      String? requestId}) {
    return WatchlistScreeningEntityListResponse(
        entityWatchlistScreenings:
            entityWatchlistScreenings ?? this.entityWatchlistScreenings,
        nextCursor: nextCursor ?? this.nextCursor,
        requestId: requestId ?? this.requestId);
  }

  WatchlistScreeningEntityListResponse copyWithWrapped(
      {Wrapped<List<EntityWatchlistScreening>>? entityWatchlistScreenings,
      Wrapped<String?>? nextCursor,
      Wrapped<String>? requestId}) {
    return WatchlistScreeningEntityListResponse(
        entityWatchlistScreenings: (entityWatchlistScreenings != null
            ? entityWatchlistScreenings.value
            : this.entityWatchlistScreenings),
        nextCursor: (nextCursor != null ? nextCursor.value : this.nextCursor),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class WatchlistScreeningEntityProgramGetRequest {
  WatchlistScreeningEntityProgramGetRequest({
    required this.entityWatchlistProgramId,
    this.secret,
    this.clientId,
  });

  factory WatchlistScreeningEntityProgramGetRequest.fromJson(
          Map<String, dynamic> json) =>
      _$WatchlistScreeningEntityProgramGetRequestFromJson(json);

  @JsonKey(name: 'entity_watchlist_program_id')
  final String entityWatchlistProgramId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'client_id')
  final String? clientId;
  static const fromJsonFactory =
      _$WatchlistScreeningEntityProgramGetRequestFromJson;
  static const toJsonFactory =
      _$WatchlistScreeningEntityProgramGetRequestToJson;
  Map<String, dynamic> toJson() =>
      _$WatchlistScreeningEntityProgramGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WatchlistScreeningEntityProgramGetRequest &&
            (identical(
                    other.entityWatchlistProgramId, entityWatchlistProgramId) ||
                const DeepCollectionEquality().equals(
                    other.entityWatchlistProgramId,
                    entityWatchlistProgramId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entityWatchlistProgramId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(clientId) ^
      runtimeType.hashCode;
}

extension $WatchlistScreeningEntityProgramGetRequestExtension
    on WatchlistScreeningEntityProgramGetRequest {
  WatchlistScreeningEntityProgramGetRequest copyWith(
      {String? entityWatchlistProgramId, String? secret, String? clientId}) {
    return WatchlistScreeningEntityProgramGetRequest(
        entityWatchlistProgramId:
            entityWatchlistProgramId ?? this.entityWatchlistProgramId,
        secret: secret ?? this.secret,
        clientId: clientId ?? this.clientId);
  }

  WatchlistScreeningEntityProgramGetRequest copyWithWrapped(
      {Wrapped<String>? entityWatchlistProgramId,
      Wrapped<String?>? secret,
      Wrapped<String?>? clientId}) {
    return WatchlistScreeningEntityProgramGetRequest(
        entityWatchlistProgramId: (entityWatchlistProgramId != null
            ? entityWatchlistProgramId.value
            : this.entityWatchlistProgramId),
        secret: (secret != null ? secret.value : this.secret),
        clientId: (clientId != null ? clientId.value : this.clientId));
  }
}

@JsonSerializable(explicitToJson: true)
class WatchlistScreeningEntityProgramGetResponse {
  WatchlistScreeningEntityProgramGetResponse({
    required this.id,
    required this.createdAt,
    required this.isRescanningEnabled,
    required this.listsEnabled,
    required this.name,
    required this.nameSensitivity,
    required this.auditTrail,
    required this.isArchived,
    required this.requestId,
  });

  factory WatchlistScreeningEntityProgramGetResponse.fromJson(
          Map<String, dynamic> json) =>
      _$WatchlistScreeningEntityProgramGetResponseFromJson(json);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'created_at')
  final String createdAt;
  @JsonKey(name: 'is_rescanning_enabled')
  final bool isRescanningEnabled;
  @JsonKey(
    name: 'lists_enabled',
    toJson: entityWatchlistCodeListToJson,
    fromJson: entityWatchlistCodeListFromJson,
  )
  final List<enums.EntityWatchlistCode> listsEnabled;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(
    name: 'name_sensitivity',
    toJson: programNameSensitivityToJson,
    fromJson: programNameSensitivityFromJson,
  )
  final enums.ProgramNameSensitivity nameSensitivity;
  @JsonKey(name: 'audit_trail')
  final WatchlistScreeningAuditTrail auditTrail;
  @JsonKey(name: 'is_archived')
  final bool isArchived;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory =
      _$WatchlistScreeningEntityProgramGetResponseFromJson;
  static const toJsonFactory =
      _$WatchlistScreeningEntityProgramGetResponseToJson;
  Map<String, dynamic> toJson() =>
      _$WatchlistScreeningEntityProgramGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WatchlistScreeningEntityProgramGetResponse &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.createdAt, createdAt) ||
                const DeepCollectionEquality()
                    .equals(other.createdAt, createdAt)) &&
            (identical(other.isRescanningEnabled, isRescanningEnabled) ||
                const DeepCollectionEquality()
                    .equals(other.isRescanningEnabled, isRescanningEnabled)) &&
            (identical(other.listsEnabled, listsEnabled) ||
                const DeepCollectionEquality()
                    .equals(other.listsEnabled, listsEnabled)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.nameSensitivity, nameSensitivity) ||
                const DeepCollectionEquality()
                    .equals(other.nameSensitivity, nameSensitivity)) &&
            (identical(other.auditTrail, auditTrail) ||
                const DeepCollectionEquality()
                    .equals(other.auditTrail, auditTrail)) &&
            (identical(other.isArchived, isArchived) ||
                const DeepCollectionEquality()
                    .equals(other.isArchived, isArchived)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(createdAt) ^
      const DeepCollectionEquality().hash(isRescanningEnabled) ^
      const DeepCollectionEquality().hash(listsEnabled) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(nameSensitivity) ^
      const DeepCollectionEquality().hash(auditTrail) ^
      const DeepCollectionEquality().hash(isArchived) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $WatchlistScreeningEntityProgramGetResponseExtension
    on WatchlistScreeningEntityProgramGetResponse {
  WatchlistScreeningEntityProgramGetResponse copyWith(
      {String? id,
      String? createdAt,
      bool? isRescanningEnabled,
      List<enums.EntityWatchlistCode>? listsEnabled,
      String? name,
      enums.ProgramNameSensitivity? nameSensitivity,
      WatchlistScreeningAuditTrail? auditTrail,
      bool? isArchived,
      String? requestId}) {
    return WatchlistScreeningEntityProgramGetResponse(
        id: id ?? this.id,
        createdAt: createdAt ?? this.createdAt,
        isRescanningEnabled: isRescanningEnabled ?? this.isRescanningEnabled,
        listsEnabled: listsEnabled ?? this.listsEnabled,
        name: name ?? this.name,
        nameSensitivity: nameSensitivity ?? this.nameSensitivity,
        auditTrail: auditTrail ?? this.auditTrail,
        isArchived: isArchived ?? this.isArchived,
        requestId: requestId ?? this.requestId);
  }

  WatchlistScreeningEntityProgramGetResponse copyWithWrapped(
      {Wrapped<String>? id,
      Wrapped<String>? createdAt,
      Wrapped<bool>? isRescanningEnabled,
      Wrapped<List<enums.EntityWatchlistCode>>? listsEnabled,
      Wrapped<String>? name,
      Wrapped<enums.ProgramNameSensitivity>? nameSensitivity,
      Wrapped<WatchlistScreeningAuditTrail>? auditTrail,
      Wrapped<bool>? isArchived,
      Wrapped<String>? requestId}) {
    return WatchlistScreeningEntityProgramGetResponse(
        id: (id != null ? id.value : this.id),
        createdAt: (createdAt != null ? createdAt.value : this.createdAt),
        isRescanningEnabled: (isRescanningEnabled != null
            ? isRescanningEnabled.value
            : this.isRescanningEnabled),
        listsEnabled:
            (listsEnabled != null ? listsEnabled.value : this.listsEnabled),
        name: (name != null ? name.value : this.name),
        nameSensitivity: (nameSensitivity != null
            ? nameSensitivity.value
            : this.nameSensitivity),
        auditTrail: (auditTrail != null ? auditTrail.value : this.auditTrail),
        isArchived: (isArchived != null ? isArchived.value : this.isArchived),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class WatchlistScreeningEntityProgramListRequest {
  WatchlistScreeningEntityProgramListRequest({
    this.secret,
    this.clientId,
    this.cursor,
  });

  factory WatchlistScreeningEntityProgramListRequest.fromJson(
          Map<String, dynamic> json) =>
      _$WatchlistScreeningEntityProgramListRequestFromJson(json);

  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'cursor')
  final String? cursor;
  static const fromJsonFactory =
      _$WatchlistScreeningEntityProgramListRequestFromJson;
  static const toJsonFactory =
      _$WatchlistScreeningEntityProgramListRequestToJson;
  Map<String, dynamic> toJson() =>
      _$WatchlistScreeningEntityProgramListRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WatchlistScreeningEntityProgramListRequest &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.cursor, cursor) ||
                const DeepCollectionEquality().equals(other.cursor, cursor)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(cursor) ^
      runtimeType.hashCode;
}

extension $WatchlistScreeningEntityProgramListRequestExtension
    on WatchlistScreeningEntityProgramListRequest {
  WatchlistScreeningEntityProgramListRequest copyWith(
      {String? secret, String? clientId, String? cursor}) {
    return WatchlistScreeningEntityProgramListRequest(
        secret: secret ?? this.secret,
        clientId: clientId ?? this.clientId,
        cursor: cursor ?? this.cursor);
  }

  WatchlistScreeningEntityProgramListRequest copyWithWrapped(
      {Wrapped<String?>? secret,
      Wrapped<String?>? clientId,
      Wrapped<String?>? cursor}) {
    return WatchlistScreeningEntityProgramListRequest(
        secret: (secret != null ? secret.value : this.secret),
        clientId: (clientId != null ? clientId.value : this.clientId),
        cursor: (cursor != null ? cursor.value : this.cursor));
  }
}

@JsonSerializable(explicitToJson: true)
class WatchlistScreeningEntityProgramListResponse {
  WatchlistScreeningEntityProgramListResponse({
    required this.entityWatchlistPrograms,
    required this.nextCursor,
    required this.requestId,
  });

  factory WatchlistScreeningEntityProgramListResponse.fromJson(
          Map<String, dynamic> json) =>
      _$WatchlistScreeningEntityProgramListResponseFromJson(json);

  @JsonKey(
      name: 'entity_watchlist_programs',
      defaultValue: <EntityWatchlistProgram>[])
  final List<EntityWatchlistProgram> entityWatchlistPrograms;
  @JsonKey(name: 'next_cursor')
  final String? nextCursor;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory =
      _$WatchlistScreeningEntityProgramListResponseFromJson;
  static const toJsonFactory =
      _$WatchlistScreeningEntityProgramListResponseToJson;
  Map<String, dynamic> toJson() =>
      _$WatchlistScreeningEntityProgramListResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WatchlistScreeningEntityProgramListResponse &&
            (identical(
                    other.entityWatchlistPrograms, entityWatchlistPrograms) ||
                const DeepCollectionEquality().equals(
                    other.entityWatchlistPrograms, entityWatchlistPrograms)) &&
            (identical(other.nextCursor, nextCursor) ||
                const DeepCollectionEquality()
                    .equals(other.nextCursor, nextCursor)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entityWatchlistPrograms) ^
      const DeepCollectionEquality().hash(nextCursor) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $WatchlistScreeningEntityProgramListResponseExtension
    on WatchlistScreeningEntityProgramListResponse {
  WatchlistScreeningEntityProgramListResponse copyWith(
      {List<EntityWatchlistProgram>? entityWatchlistPrograms,
      String? nextCursor,
      String? requestId}) {
    return WatchlistScreeningEntityProgramListResponse(
        entityWatchlistPrograms:
            entityWatchlistPrograms ?? this.entityWatchlistPrograms,
        nextCursor: nextCursor ?? this.nextCursor,
        requestId: requestId ?? this.requestId);
  }

  WatchlistScreeningEntityProgramListResponse copyWithWrapped(
      {Wrapped<List<EntityWatchlistProgram>>? entityWatchlistPrograms,
      Wrapped<String?>? nextCursor,
      Wrapped<String>? requestId}) {
    return WatchlistScreeningEntityProgramListResponse(
        entityWatchlistPrograms: (entityWatchlistPrograms != null
            ? entityWatchlistPrograms.value
            : this.entityWatchlistPrograms),
        nextCursor: (nextCursor != null ? nextCursor.value : this.nextCursor),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class WatchlistScreeningEntityReviewCreateRequest {
  WatchlistScreeningEntityReviewCreateRequest({
    required this.confirmedHits,
    required this.dismissedHits,
    this.comment,
    this.clientId,
    this.secret,
    required this.entityWatchlistScreeningId,
  });

  factory WatchlistScreeningEntityReviewCreateRequest.fromJson(
          Map<String, dynamic> json) =>
      _$WatchlistScreeningEntityReviewCreateRequestFromJson(json);

  @JsonKey(name: 'confirmed_hits', defaultValue: <String>[])
  final List<String> confirmedHits;
  @JsonKey(name: 'dismissed_hits', defaultValue: <String>[])
  final List<String> dismissedHits;
  @JsonKey(name: 'comment')
  final String? comment;
  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'entity_watchlist_screening_id')
  final String entityWatchlistScreeningId;
  static const fromJsonFactory =
      _$WatchlistScreeningEntityReviewCreateRequestFromJson;
  static const toJsonFactory =
      _$WatchlistScreeningEntityReviewCreateRequestToJson;
  Map<String, dynamic> toJson() =>
      _$WatchlistScreeningEntityReviewCreateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WatchlistScreeningEntityReviewCreateRequest &&
            (identical(other.confirmedHits, confirmedHits) ||
                const DeepCollectionEquality()
                    .equals(other.confirmedHits, confirmedHits)) &&
            (identical(other.dismissedHits, dismissedHits) ||
                const DeepCollectionEquality()
                    .equals(other.dismissedHits, dismissedHits)) &&
            (identical(other.comment, comment) ||
                const DeepCollectionEquality()
                    .equals(other.comment, comment)) &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.entityWatchlistScreeningId,
                    entityWatchlistScreeningId) ||
                const DeepCollectionEquality().equals(
                    other.entityWatchlistScreeningId,
                    entityWatchlistScreeningId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(confirmedHits) ^
      const DeepCollectionEquality().hash(dismissedHits) ^
      const DeepCollectionEquality().hash(comment) ^
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(entityWatchlistScreeningId) ^
      runtimeType.hashCode;
}

extension $WatchlistScreeningEntityReviewCreateRequestExtension
    on WatchlistScreeningEntityReviewCreateRequest {
  WatchlistScreeningEntityReviewCreateRequest copyWith(
      {List<String>? confirmedHits,
      List<String>? dismissedHits,
      String? comment,
      String? clientId,
      String? secret,
      String? entityWatchlistScreeningId}) {
    return WatchlistScreeningEntityReviewCreateRequest(
        confirmedHits: confirmedHits ?? this.confirmedHits,
        dismissedHits: dismissedHits ?? this.dismissedHits,
        comment: comment ?? this.comment,
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        entityWatchlistScreeningId:
            entityWatchlistScreeningId ?? this.entityWatchlistScreeningId);
  }

  WatchlistScreeningEntityReviewCreateRequest copyWithWrapped(
      {Wrapped<List<String>>? confirmedHits,
      Wrapped<List<String>>? dismissedHits,
      Wrapped<String?>? comment,
      Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? entityWatchlistScreeningId}) {
    return WatchlistScreeningEntityReviewCreateRequest(
        confirmedHits:
            (confirmedHits != null ? confirmedHits.value : this.confirmedHits),
        dismissedHits:
            (dismissedHits != null ? dismissedHits.value : this.dismissedHits),
        comment: (comment != null ? comment.value : this.comment),
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        entityWatchlistScreeningId: (entityWatchlistScreeningId != null
            ? entityWatchlistScreeningId.value
            : this.entityWatchlistScreeningId));
  }
}

@JsonSerializable(explicitToJson: true)
class WatchlistScreeningEntityReviewCreateResponse {
  WatchlistScreeningEntityReviewCreateResponse({
    required this.id,
    required this.confirmedHits,
    required this.dismissedHits,
    required this.comment,
    required this.auditTrail,
    required this.requestId,
  });

  factory WatchlistScreeningEntityReviewCreateResponse.fromJson(
          Map<String, dynamic> json) =>
      _$WatchlistScreeningEntityReviewCreateResponseFromJson(json);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'confirmed_hits', defaultValue: <String>[])
  final List<String> confirmedHits;
  @JsonKey(name: 'dismissed_hits', defaultValue: <String>[])
  final List<String> dismissedHits;
  @JsonKey(name: 'comment')
  final String? comment;
  @JsonKey(name: 'audit_trail')
  final WatchlistScreeningAuditTrail auditTrail;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory =
      _$WatchlistScreeningEntityReviewCreateResponseFromJson;
  static const toJsonFactory =
      _$WatchlistScreeningEntityReviewCreateResponseToJson;
  Map<String, dynamic> toJson() =>
      _$WatchlistScreeningEntityReviewCreateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WatchlistScreeningEntityReviewCreateResponse &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.confirmedHits, confirmedHits) ||
                const DeepCollectionEquality()
                    .equals(other.confirmedHits, confirmedHits)) &&
            (identical(other.dismissedHits, dismissedHits) ||
                const DeepCollectionEquality()
                    .equals(other.dismissedHits, dismissedHits)) &&
            (identical(other.comment, comment) ||
                const DeepCollectionEquality()
                    .equals(other.comment, comment)) &&
            (identical(other.auditTrail, auditTrail) ||
                const DeepCollectionEquality()
                    .equals(other.auditTrail, auditTrail)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(confirmedHits) ^
      const DeepCollectionEquality().hash(dismissedHits) ^
      const DeepCollectionEquality().hash(comment) ^
      const DeepCollectionEquality().hash(auditTrail) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $WatchlistScreeningEntityReviewCreateResponseExtension
    on WatchlistScreeningEntityReviewCreateResponse {
  WatchlistScreeningEntityReviewCreateResponse copyWith(
      {String? id,
      List<String>? confirmedHits,
      List<String>? dismissedHits,
      String? comment,
      WatchlistScreeningAuditTrail? auditTrail,
      String? requestId}) {
    return WatchlistScreeningEntityReviewCreateResponse(
        id: id ?? this.id,
        confirmedHits: confirmedHits ?? this.confirmedHits,
        dismissedHits: dismissedHits ?? this.dismissedHits,
        comment: comment ?? this.comment,
        auditTrail: auditTrail ?? this.auditTrail,
        requestId: requestId ?? this.requestId);
  }

  WatchlistScreeningEntityReviewCreateResponse copyWithWrapped(
      {Wrapped<String>? id,
      Wrapped<List<String>>? confirmedHits,
      Wrapped<List<String>>? dismissedHits,
      Wrapped<String?>? comment,
      Wrapped<WatchlistScreeningAuditTrail>? auditTrail,
      Wrapped<String>? requestId}) {
    return WatchlistScreeningEntityReviewCreateResponse(
        id: (id != null ? id.value : this.id),
        confirmedHits:
            (confirmedHits != null ? confirmedHits.value : this.confirmedHits),
        dismissedHits:
            (dismissedHits != null ? dismissedHits.value : this.dismissedHits),
        comment: (comment != null ? comment.value : this.comment),
        auditTrail: (auditTrail != null ? auditTrail.value : this.auditTrail),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class WatchlistScreeningEntityReviewListRequest {
  WatchlistScreeningEntityReviewListRequest({
    this.secret,
    this.clientId,
    required this.entityWatchlistScreeningId,
    this.cursor,
  });

  factory WatchlistScreeningEntityReviewListRequest.fromJson(
          Map<String, dynamic> json) =>
      _$WatchlistScreeningEntityReviewListRequestFromJson(json);

  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'entity_watchlist_screening_id')
  final String entityWatchlistScreeningId;
  @JsonKey(name: 'cursor')
  final String? cursor;
  static const fromJsonFactory =
      _$WatchlistScreeningEntityReviewListRequestFromJson;
  static const toJsonFactory =
      _$WatchlistScreeningEntityReviewListRequestToJson;
  Map<String, dynamic> toJson() =>
      _$WatchlistScreeningEntityReviewListRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WatchlistScreeningEntityReviewListRequest &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.entityWatchlistScreeningId,
                    entityWatchlistScreeningId) ||
                const DeepCollectionEquality().equals(
                    other.entityWatchlistScreeningId,
                    entityWatchlistScreeningId)) &&
            (identical(other.cursor, cursor) ||
                const DeepCollectionEquality().equals(other.cursor, cursor)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(entityWatchlistScreeningId) ^
      const DeepCollectionEquality().hash(cursor) ^
      runtimeType.hashCode;
}

extension $WatchlistScreeningEntityReviewListRequestExtension
    on WatchlistScreeningEntityReviewListRequest {
  WatchlistScreeningEntityReviewListRequest copyWith(
      {String? secret,
      String? clientId,
      String? entityWatchlistScreeningId,
      String? cursor}) {
    return WatchlistScreeningEntityReviewListRequest(
        secret: secret ?? this.secret,
        clientId: clientId ?? this.clientId,
        entityWatchlistScreeningId:
            entityWatchlistScreeningId ?? this.entityWatchlistScreeningId,
        cursor: cursor ?? this.cursor);
  }

  WatchlistScreeningEntityReviewListRequest copyWithWrapped(
      {Wrapped<String?>? secret,
      Wrapped<String?>? clientId,
      Wrapped<String>? entityWatchlistScreeningId,
      Wrapped<String?>? cursor}) {
    return WatchlistScreeningEntityReviewListRequest(
        secret: (secret != null ? secret.value : this.secret),
        clientId: (clientId != null ? clientId.value : this.clientId),
        entityWatchlistScreeningId: (entityWatchlistScreeningId != null
            ? entityWatchlistScreeningId.value
            : this.entityWatchlistScreeningId),
        cursor: (cursor != null ? cursor.value : this.cursor));
  }
}

@JsonSerializable(explicitToJson: true)
class WatchlistScreeningEntityReviewListResponse {
  WatchlistScreeningEntityReviewListResponse({
    required this.entityWatchlistScreeningReviews,
    required this.nextCursor,
    required this.requestId,
  });

  factory WatchlistScreeningEntityReviewListResponse.fromJson(
          Map<String, dynamic> json) =>
      _$WatchlistScreeningEntityReviewListResponseFromJson(json);

  @JsonKey(
      name: 'entity_watchlist_screening_reviews',
      defaultValue: <EntityWatchlistScreeningReview>[])
  final List<EntityWatchlistScreeningReview> entityWatchlistScreeningReviews;
  @JsonKey(name: 'next_cursor')
  final String? nextCursor;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory =
      _$WatchlistScreeningEntityReviewListResponseFromJson;
  static const toJsonFactory =
      _$WatchlistScreeningEntityReviewListResponseToJson;
  Map<String, dynamic> toJson() =>
      _$WatchlistScreeningEntityReviewListResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WatchlistScreeningEntityReviewListResponse &&
            (identical(other.entityWatchlistScreeningReviews,
                    entityWatchlistScreeningReviews) ||
                const DeepCollectionEquality().equals(
                    other.entityWatchlistScreeningReviews,
                    entityWatchlistScreeningReviews)) &&
            (identical(other.nextCursor, nextCursor) ||
                const DeepCollectionEquality()
                    .equals(other.nextCursor, nextCursor)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entityWatchlistScreeningReviews) ^
      const DeepCollectionEquality().hash(nextCursor) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $WatchlistScreeningEntityReviewListResponseExtension
    on WatchlistScreeningEntityReviewListResponse {
  WatchlistScreeningEntityReviewListResponse copyWith(
      {List<EntityWatchlistScreeningReview>? entityWatchlistScreeningReviews,
      String? nextCursor,
      String? requestId}) {
    return WatchlistScreeningEntityReviewListResponse(
        entityWatchlistScreeningReviews: entityWatchlistScreeningReviews ??
            this.entityWatchlistScreeningReviews,
        nextCursor: nextCursor ?? this.nextCursor,
        requestId: requestId ?? this.requestId);
  }

  WatchlistScreeningEntityReviewListResponse copyWithWrapped(
      {Wrapped<List<EntityWatchlistScreeningReview>>?
          entityWatchlistScreeningReviews,
      Wrapped<String?>? nextCursor,
      Wrapped<String>? requestId}) {
    return WatchlistScreeningEntityReviewListResponse(
        entityWatchlistScreeningReviews:
            (entityWatchlistScreeningReviews != null
                ? entityWatchlistScreeningReviews.value
                : this.entityWatchlistScreeningReviews),
        nextCursor: (nextCursor != null ? nextCursor.value : this.nextCursor),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class WatchlistScreeningEntityUpdateRequest {
  WatchlistScreeningEntityUpdateRequest({
    required this.entityWatchlistScreeningId,
    this.searchTerms,
    this.assignee,
    this.status,
    this.clientUserId,
    this.clientId,
    this.secret,
    this.resetFields,
  });

  factory WatchlistScreeningEntityUpdateRequest.fromJson(
          Map<String, dynamic> json) =>
      _$WatchlistScreeningEntityUpdateRequestFromJson(json);

  @JsonKey(name: 'entity_watchlist_screening_id')
  final String entityWatchlistScreeningId;
  @JsonKey(name: 'search_terms')
  final UpdateEntityScreeningRequestSearchTerms? searchTerms;
  @JsonKey(name: 'assignee')
  final String? assignee;
  @JsonKey(
    name: 'status',
    toJson: watchlistScreeningStatusToJson,
    fromJson: watchlistScreeningStatusFromJson,
  )
  final enums.WatchlistScreeningStatus? status;
  @JsonKey(name: 'client_user_id')
  final String? clientUserId;
  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'reset_fields')
  final List<String>? resetFields;
  static const fromJsonFactory =
      _$WatchlistScreeningEntityUpdateRequestFromJson;
  static const toJsonFactory = _$WatchlistScreeningEntityUpdateRequestToJson;
  Map<String, dynamic> toJson() =>
      _$WatchlistScreeningEntityUpdateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WatchlistScreeningEntityUpdateRequest &&
            (identical(other.entityWatchlistScreeningId,
                    entityWatchlistScreeningId) ||
                const DeepCollectionEquality().equals(
                    other.entityWatchlistScreeningId,
                    entityWatchlistScreeningId)) &&
            (identical(other.searchTerms, searchTerms) ||
                const DeepCollectionEquality()
                    .equals(other.searchTerms, searchTerms)) &&
            (identical(other.assignee, assignee) ||
                const DeepCollectionEquality()
                    .equals(other.assignee, assignee)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.clientUserId, clientUserId) ||
                const DeepCollectionEquality()
                    .equals(other.clientUserId, clientUserId)) &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.resetFields, resetFields) ||
                const DeepCollectionEquality()
                    .equals(other.resetFields, resetFields)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(entityWatchlistScreeningId) ^
      const DeepCollectionEquality().hash(searchTerms) ^
      const DeepCollectionEquality().hash(assignee) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(clientUserId) ^
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(resetFields) ^
      runtimeType.hashCode;
}

extension $WatchlistScreeningEntityUpdateRequestExtension
    on WatchlistScreeningEntityUpdateRequest {
  WatchlistScreeningEntityUpdateRequest copyWith(
      {String? entityWatchlistScreeningId,
      UpdateEntityScreeningRequestSearchTerms? searchTerms,
      String? assignee,
      enums.WatchlistScreeningStatus? status,
      String? clientUserId,
      String? clientId,
      String? secret,
      List<String>? resetFields}) {
    return WatchlistScreeningEntityUpdateRequest(
        entityWatchlistScreeningId:
            entityWatchlistScreeningId ?? this.entityWatchlistScreeningId,
        searchTerms: searchTerms ?? this.searchTerms,
        assignee: assignee ?? this.assignee,
        status: status ?? this.status,
        clientUserId: clientUserId ?? this.clientUserId,
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        resetFields: resetFields ?? this.resetFields);
  }

  WatchlistScreeningEntityUpdateRequest copyWithWrapped(
      {Wrapped<String>? entityWatchlistScreeningId,
      Wrapped<UpdateEntityScreeningRequestSearchTerms?>? searchTerms,
      Wrapped<String?>? assignee,
      Wrapped<enums.WatchlistScreeningStatus?>? status,
      Wrapped<String?>? clientUserId,
      Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<List<String>?>? resetFields}) {
    return WatchlistScreeningEntityUpdateRequest(
        entityWatchlistScreeningId: (entityWatchlistScreeningId != null
            ? entityWatchlistScreeningId.value
            : this.entityWatchlistScreeningId),
        searchTerms:
            (searchTerms != null ? searchTerms.value : this.searchTerms),
        assignee: (assignee != null ? assignee.value : this.assignee),
        status: (status != null ? status.value : this.status),
        clientUserId:
            (clientUserId != null ? clientUserId.value : this.clientUserId),
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        resetFields:
            (resetFields != null ? resetFields.value : this.resetFields));
  }
}

typedef WatchlistScreeningEntityUpdateRequestResettableFieldList = List<String>;

@JsonSerializable(explicitToJson: true)
class WatchlistScreeningEntityUpdateResponse {
  WatchlistScreeningEntityUpdateResponse({
    required this.id,
    required this.searchTerms,
    required this.assignee,
    required this.status,
    required this.clientUserId,
    required this.auditTrail,
    required this.requestId,
  });

  factory WatchlistScreeningEntityUpdateResponse.fromJson(
          Map<String, dynamic> json) =>
      _$WatchlistScreeningEntityUpdateResponseFromJson(json);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'search_terms')
  final EntityWatchlistScreeningSearchTerms searchTerms;
  @JsonKey(name: 'assignee')
  final String? assignee;
  @JsonKey(
    name: 'status',
    toJson: watchlistScreeningStatusToJson,
    fromJson: watchlistScreeningStatusFromJson,
  )
  final enums.WatchlistScreeningStatus status;
  @JsonKey(name: 'client_user_id')
  final String? clientUserId;
  @JsonKey(name: 'audit_trail')
  final WatchlistScreeningAuditTrail auditTrail;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory =
      _$WatchlistScreeningEntityUpdateResponseFromJson;
  static const toJsonFactory = _$WatchlistScreeningEntityUpdateResponseToJson;
  Map<String, dynamic> toJson() =>
      _$WatchlistScreeningEntityUpdateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WatchlistScreeningEntityUpdateResponse &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.searchTerms, searchTerms) ||
                const DeepCollectionEquality()
                    .equals(other.searchTerms, searchTerms)) &&
            (identical(other.assignee, assignee) ||
                const DeepCollectionEquality()
                    .equals(other.assignee, assignee)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.clientUserId, clientUserId) ||
                const DeepCollectionEquality()
                    .equals(other.clientUserId, clientUserId)) &&
            (identical(other.auditTrail, auditTrail) ||
                const DeepCollectionEquality()
                    .equals(other.auditTrail, auditTrail)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(searchTerms) ^
      const DeepCollectionEquality().hash(assignee) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(clientUserId) ^
      const DeepCollectionEquality().hash(auditTrail) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $WatchlistScreeningEntityUpdateResponseExtension
    on WatchlistScreeningEntityUpdateResponse {
  WatchlistScreeningEntityUpdateResponse copyWith(
      {String? id,
      EntityWatchlistScreeningSearchTerms? searchTerms,
      String? assignee,
      enums.WatchlistScreeningStatus? status,
      String? clientUserId,
      WatchlistScreeningAuditTrail? auditTrail,
      String? requestId}) {
    return WatchlistScreeningEntityUpdateResponse(
        id: id ?? this.id,
        searchTerms: searchTerms ?? this.searchTerms,
        assignee: assignee ?? this.assignee,
        status: status ?? this.status,
        clientUserId: clientUserId ?? this.clientUserId,
        auditTrail: auditTrail ?? this.auditTrail,
        requestId: requestId ?? this.requestId);
  }

  WatchlistScreeningEntityUpdateResponse copyWithWrapped(
      {Wrapped<String>? id,
      Wrapped<EntityWatchlistScreeningSearchTerms>? searchTerms,
      Wrapped<String?>? assignee,
      Wrapped<enums.WatchlistScreeningStatus>? status,
      Wrapped<String?>? clientUserId,
      Wrapped<WatchlistScreeningAuditTrail>? auditTrail,
      Wrapped<String>? requestId}) {
    return WatchlistScreeningEntityUpdateResponse(
        id: (id != null ? id.value : this.id),
        searchTerms:
            (searchTerms != null ? searchTerms.value : this.searchTerms),
        assignee: (assignee != null ? assignee.value : this.assignee),
        status: (status != null ? status.value : this.status),
        clientUserId:
            (clientUserId != null ? clientUserId.value : this.clientUserId),
        auditTrail: (auditTrail != null ? auditTrail.value : this.auditTrail),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class WatchlistScreeningHit {
  WatchlistScreeningHit({
    required this.id,
    required this.reviewStatus,
    required this.firstActive,
    required this.inactiveSince,
    required this.historicalSince,
    required this.listCode,
    required this.plaidUid,
    required this.sourceUid,
    this.analysis,
    this.data,
  });

  factory WatchlistScreeningHit.fromJson(Map<String, dynamic> json) =>
      _$WatchlistScreeningHitFromJson(json);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(
    name: 'review_status',
    toJson: watchlistScreeningHitStatusToJson,
    fromJson: watchlistScreeningHitStatusFromJson,
  )
  final enums.WatchlistScreeningHitStatus reviewStatus;
  @JsonKey(name: 'first_active')
  final String firstActive;
  @JsonKey(name: 'inactive_since')
  final String? inactiveSince;
  @JsonKey(name: 'historical_since')
  final String? historicalSince;
  @JsonKey(
    name: 'list_code',
    toJson: individualWatchlistCodeToJson,
    fromJson: individualWatchlistCodeFromJson,
  )
  final enums.IndividualWatchlistCode listCode;
  @JsonKey(name: 'plaid_uid')
  final String plaidUid;
  @JsonKey(name: 'source_uid')
  final String? sourceUid;
  @JsonKey(name: 'analysis')
  final ScreeningHitAnalysis? analysis;
  @JsonKey(name: 'data')
  final ScreeningHitData? data;
  static const fromJsonFactory = _$WatchlistScreeningHitFromJson;
  static const toJsonFactory = _$WatchlistScreeningHitToJson;
  Map<String, dynamic> toJson() => _$WatchlistScreeningHitToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WatchlistScreeningHit &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.reviewStatus, reviewStatus) ||
                const DeepCollectionEquality()
                    .equals(other.reviewStatus, reviewStatus)) &&
            (identical(other.firstActive, firstActive) ||
                const DeepCollectionEquality()
                    .equals(other.firstActive, firstActive)) &&
            (identical(other.inactiveSince, inactiveSince) ||
                const DeepCollectionEquality()
                    .equals(other.inactiveSince, inactiveSince)) &&
            (identical(other.historicalSince, historicalSince) ||
                const DeepCollectionEquality()
                    .equals(other.historicalSince, historicalSince)) &&
            (identical(other.listCode, listCode) ||
                const DeepCollectionEquality()
                    .equals(other.listCode, listCode)) &&
            (identical(other.plaidUid, plaidUid) ||
                const DeepCollectionEquality()
                    .equals(other.plaidUid, plaidUid)) &&
            (identical(other.sourceUid, sourceUid) ||
                const DeepCollectionEquality()
                    .equals(other.sourceUid, sourceUid)) &&
            (identical(other.analysis, analysis) ||
                const DeepCollectionEquality()
                    .equals(other.analysis, analysis)) &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(reviewStatus) ^
      const DeepCollectionEquality().hash(firstActive) ^
      const DeepCollectionEquality().hash(inactiveSince) ^
      const DeepCollectionEquality().hash(historicalSince) ^
      const DeepCollectionEquality().hash(listCode) ^
      const DeepCollectionEquality().hash(plaidUid) ^
      const DeepCollectionEquality().hash(sourceUid) ^
      const DeepCollectionEquality().hash(analysis) ^
      const DeepCollectionEquality().hash(data) ^
      runtimeType.hashCode;
}

extension $WatchlistScreeningHitExtension on WatchlistScreeningHit {
  WatchlistScreeningHit copyWith(
      {String? id,
      enums.WatchlistScreeningHitStatus? reviewStatus,
      String? firstActive,
      String? inactiveSince,
      String? historicalSince,
      enums.IndividualWatchlistCode? listCode,
      String? plaidUid,
      String? sourceUid,
      ScreeningHitAnalysis? analysis,
      ScreeningHitData? data}) {
    return WatchlistScreeningHit(
        id: id ?? this.id,
        reviewStatus: reviewStatus ?? this.reviewStatus,
        firstActive: firstActive ?? this.firstActive,
        inactiveSince: inactiveSince ?? this.inactiveSince,
        historicalSince: historicalSince ?? this.historicalSince,
        listCode: listCode ?? this.listCode,
        plaidUid: plaidUid ?? this.plaidUid,
        sourceUid: sourceUid ?? this.sourceUid,
        analysis: analysis ?? this.analysis,
        data: data ?? this.data);
  }

  WatchlistScreeningHit copyWithWrapped(
      {Wrapped<String>? id,
      Wrapped<enums.WatchlistScreeningHitStatus>? reviewStatus,
      Wrapped<String>? firstActive,
      Wrapped<String?>? inactiveSince,
      Wrapped<String?>? historicalSince,
      Wrapped<enums.IndividualWatchlistCode>? listCode,
      Wrapped<String>? plaidUid,
      Wrapped<String?>? sourceUid,
      Wrapped<ScreeningHitAnalysis?>? analysis,
      Wrapped<ScreeningHitData?>? data}) {
    return WatchlistScreeningHit(
        id: (id != null ? id.value : this.id),
        reviewStatus:
            (reviewStatus != null ? reviewStatus.value : this.reviewStatus),
        firstActive:
            (firstActive != null ? firstActive.value : this.firstActive),
        inactiveSince:
            (inactiveSince != null ? inactiveSince.value : this.inactiveSince),
        historicalSince: (historicalSince != null
            ? historicalSince.value
            : this.historicalSince),
        listCode: (listCode != null ? listCode.value : this.listCode),
        plaidUid: (plaidUid != null ? plaidUid.value : this.plaidUid),
        sourceUid: (sourceUid != null ? sourceUid.value : this.sourceUid),
        analysis: (analysis != null ? analysis.value : this.analysis),
        data: (data != null ? data.value : this.data));
  }
}

@JsonSerializable(explicitToJson: true)
class WatchlistScreeningHitLocations {
  WatchlistScreeningHitLocations({
    required this.full,
    required this.country,
  });

  factory WatchlistScreeningHitLocations.fromJson(Map<String, dynamic> json) =>
      _$WatchlistScreeningHitLocationsFromJson(json);

  @JsonKey(name: 'full')
  final String full;
  @JsonKey(name: 'country')
  final String country;
  static const fromJsonFactory = _$WatchlistScreeningHitLocationsFromJson;
  static const toJsonFactory = _$WatchlistScreeningHitLocationsToJson;
  Map<String, dynamic> toJson() => _$WatchlistScreeningHitLocationsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WatchlistScreeningHitLocations &&
            (identical(other.full, full) ||
                const DeepCollectionEquality().equals(other.full, full)) &&
            (identical(other.country, country) ||
                const DeepCollectionEquality().equals(other.country, country)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(full) ^
      const DeepCollectionEquality().hash(country) ^
      runtimeType.hashCode;
}

extension $WatchlistScreeningHitLocationsExtension
    on WatchlistScreeningHitLocations {
  WatchlistScreeningHitLocations copyWith({String? full, String? country}) {
    return WatchlistScreeningHitLocations(
        full: full ?? this.full, country: country ?? this.country);
  }

  WatchlistScreeningHitLocations copyWithWrapped(
      {Wrapped<String>? full, Wrapped<String>? country}) {
    return WatchlistScreeningHitLocations(
        full: (full != null ? full.value : this.full),
        country: (country != null ? country.value : this.country));
  }
}

@JsonSerializable(explicitToJson: true)
class WatchlistScreeningIndividual {
  WatchlistScreeningIndividual({
    required this.id,
    required this.searchTerms,
    required this.assignee,
    required this.status,
    required this.clientUserId,
    required this.auditTrail,
  });

  factory WatchlistScreeningIndividual.fromJson(Map<String, dynamic> json) =>
      _$WatchlistScreeningIndividualFromJson(json);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'search_terms')
  final WatchlistScreeningSearchTerms searchTerms;
  @JsonKey(name: 'assignee')
  final String? assignee;
  @JsonKey(
    name: 'status',
    toJson: watchlistScreeningStatusToJson,
    fromJson: watchlistScreeningStatusFromJson,
  )
  final enums.WatchlistScreeningStatus status;
  @JsonKey(name: 'client_user_id')
  final String? clientUserId;
  @JsonKey(name: 'audit_trail')
  final WatchlistScreeningAuditTrail auditTrail;
  static const fromJsonFactory = _$WatchlistScreeningIndividualFromJson;
  static const toJsonFactory = _$WatchlistScreeningIndividualToJson;
  Map<String, dynamic> toJson() => _$WatchlistScreeningIndividualToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WatchlistScreeningIndividual &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.searchTerms, searchTerms) ||
                const DeepCollectionEquality()
                    .equals(other.searchTerms, searchTerms)) &&
            (identical(other.assignee, assignee) ||
                const DeepCollectionEquality()
                    .equals(other.assignee, assignee)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.clientUserId, clientUserId) ||
                const DeepCollectionEquality()
                    .equals(other.clientUserId, clientUserId)) &&
            (identical(other.auditTrail, auditTrail) ||
                const DeepCollectionEquality()
                    .equals(other.auditTrail, auditTrail)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(searchTerms) ^
      const DeepCollectionEquality().hash(assignee) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(clientUserId) ^
      const DeepCollectionEquality().hash(auditTrail) ^
      runtimeType.hashCode;
}

extension $WatchlistScreeningIndividualExtension
    on WatchlistScreeningIndividual {
  WatchlistScreeningIndividual copyWith(
      {String? id,
      WatchlistScreeningSearchTerms? searchTerms,
      String? assignee,
      enums.WatchlistScreeningStatus? status,
      String? clientUserId,
      WatchlistScreeningAuditTrail? auditTrail}) {
    return WatchlistScreeningIndividual(
        id: id ?? this.id,
        searchTerms: searchTerms ?? this.searchTerms,
        assignee: assignee ?? this.assignee,
        status: status ?? this.status,
        clientUserId: clientUserId ?? this.clientUserId,
        auditTrail: auditTrail ?? this.auditTrail);
  }

  WatchlistScreeningIndividual copyWithWrapped(
      {Wrapped<String>? id,
      Wrapped<WatchlistScreeningSearchTerms>? searchTerms,
      Wrapped<String?>? assignee,
      Wrapped<enums.WatchlistScreeningStatus>? status,
      Wrapped<String?>? clientUserId,
      Wrapped<WatchlistScreeningAuditTrail>? auditTrail}) {
    return WatchlistScreeningIndividual(
        id: (id != null ? id.value : this.id),
        searchTerms:
            (searchTerms != null ? searchTerms.value : this.searchTerms),
        assignee: (assignee != null ? assignee.value : this.assignee),
        status: (status != null ? status.value : this.status),
        clientUserId:
            (clientUserId != null ? clientUserId.value : this.clientUserId),
        auditTrail: (auditTrail != null ? auditTrail.value : this.auditTrail));
  }
}

@JsonSerializable(explicitToJson: true)
class WatchlistScreeningIndividualCreateRequest {
  WatchlistScreeningIndividualCreateRequest({
    required this.searchTerms,
    this.clientUserId,
    this.clientId,
    this.secret,
  });

  factory WatchlistScreeningIndividualCreateRequest.fromJson(
          Map<String, dynamic> json) =>
      _$WatchlistScreeningIndividualCreateRequestFromJson(json);

  @JsonKey(name: 'search_terms')
  final WatchlistScreeningRequestSearchTerms searchTerms;
  @JsonKey(name: 'client_user_id')
  final String? clientUserId;
  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  static const fromJsonFactory =
      _$WatchlistScreeningIndividualCreateRequestFromJson;
  static const toJsonFactory =
      _$WatchlistScreeningIndividualCreateRequestToJson;
  Map<String, dynamic> toJson() =>
      _$WatchlistScreeningIndividualCreateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WatchlistScreeningIndividualCreateRequest &&
            (identical(other.searchTerms, searchTerms) ||
                const DeepCollectionEquality()
                    .equals(other.searchTerms, searchTerms)) &&
            (identical(other.clientUserId, clientUserId) ||
                const DeepCollectionEquality()
                    .equals(other.clientUserId, clientUserId)) &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(searchTerms) ^
      const DeepCollectionEquality().hash(clientUserId) ^
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      runtimeType.hashCode;
}

extension $WatchlistScreeningIndividualCreateRequestExtension
    on WatchlistScreeningIndividualCreateRequest {
  WatchlistScreeningIndividualCreateRequest copyWith(
      {WatchlistScreeningRequestSearchTerms? searchTerms,
      String? clientUserId,
      String? clientId,
      String? secret}) {
    return WatchlistScreeningIndividualCreateRequest(
        searchTerms: searchTerms ?? this.searchTerms,
        clientUserId: clientUserId ?? this.clientUserId,
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret);
  }

  WatchlistScreeningIndividualCreateRequest copyWithWrapped(
      {Wrapped<WatchlistScreeningRequestSearchTerms>? searchTerms,
      Wrapped<String?>? clientUserId,
      Wrapped<String?>? clientId,
      Wrapped<String?>? secret}) {
    return WatchlistScreeningIndividualCreateRequest(
        searchTerms:
            (searchTerms != null ? searchTerms.value : this.searchTerms),
        clientUserId:
            (clientUserId != null ? clientUserId.value : this.clientUserId),
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret));
  }
}

@JsonSerializable(explicitToJson: true)
class WatchlistScreeningIndividualCreateResponse {
  WatchlistScreeningIndividualCreateResponse({
    required this.id,
    required this.searchTerms,
    required this.assignee,
    required this.status,
    required this.clientUserId,
    required this.auditTrail,
    required this.requestId,
  });

  factory WatchlistScreeningIndividualCreateResponse.fromJson(
          Map<String, dynamic> json) =>
      _$WatchlistScreeningIndividualCreateResponseFromJson(json);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'search_terms')
  final WatchlistScreeningSearchTerms searchTerms;
  @JsonKey(name: 'assignee')
  final String? assignee;
  @JsonKey(
    name: 'status',
    toJson: watchlistScreeningStatusToJson,
    fromJson: watchlistScreeningStatusFromJson,
  )
  final enums.WatchlistScreeningStatus status;
  @JsonKey(name: 'client_user_id')
  final String? clientUserId;
  @JsonKey(name: 'audit_trail')
  final WatchlistScreeningAuditTrail auditTrail;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory =
      _$WatchlistScreeningIndividualCreateResponseFromJson;
  static const toJsonFactory =
      _$WatchlistScreeningIndividualCreateResponseToJson;
  Map<String, dynamic> toJson() =>
      _$WatchlistScreeningIndividualCreateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WatchlistScreeningIndividualCreateResponse &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.searchTerms, searchTerms) ||
                const DeepCollectionEquality()
                    .equals(other.searchTerms, searchTerms)) &&
            (identical(other.assignee, assignee) ||
                const DeepCollectionEquality()
                    .equals(other.assignee, assignee)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.clientUserId, clientUserId) ||
                const DeepCollectionEquality()
                    .equals(other.clientUserId, clientUserId)) &&
            (identical(other.auditTrail, auditTrail) ||
                const DeepCollectionEquality()
                    .equals(other.auditTrail, auditTrail)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(searchTerms) ^
      const DeepCollectionEquality().hash(assignee) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(clientUserId) ^
      const DeepCollectionEquality().hash(auditTrail) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $WatchlistScreeningIndividualCreateResponseExtension
    on WatchlistScreeningIndividualCreateResponse {
  WatchlistScreeningIndividualCreateResponse copyWith(
      {String? id,
      WatchlistScreeningSearchTerms? searchTerms,
      String? assignee,
      enums.WatchlistScreeningStatus? status,
      String? clientUserId,
      WatchlistScreeningAuditTrail? auditTrail,
      String? requestId}) {
    return WatchlistScreeningIndividualCreateResponse(
        id: id ?? this.id,
        searchTerms: searchTerms ?? this.searchTerms,
        assignee: assignee ?? this.assignee,
        status: status ?? this.status,
        clientUserId: clientUserId ?? this.clientUserId,
        auditTrail: auditTrail ?? this.auditTrail,
        requestId: requestId ?? this.requestId);
  }

  WatchlistScreeningIndividualCreateResponse copyWithWrapped(
      {Wrapped<String>? id,
      Wrapped<WatchlistScreeningSearchTerms>? searchTerms,
      Wrapped<String?>? assignee,
      Wrapped<enums.WatchlistScreeningStatus>? status,
      Wrapped<String?>? clientUserId,
      Wrapped<WatchlistScreeningAuditTrail>? auditTrail,
      Wrapped<String>? requestId}) {
    return WatchlistScreeningIndividualCreateResponse(
        id: (id != null ? id.value : this.id),
        searchTerms:
            (searchTerms != null ? searchTerms.value : this.searchTerms),
        assignee: (assignee != null ? assignee.value : this.assignee),
        status: (status != null ? status.value : this.status),
        clientUserId:
            (clientUserId != null ? clientUserId.value : this.clientUserId),
        auditTrail: (auditTrail != null ? auditTrail.value : this.auditTrail),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class WatchlistScreeningIndividualGetRequest {
  WatchlistScreeningIndividualGetRequest({
    required this.watchlistScreeningId,
    this.secret,
    this.clientId,
  });

  factory WatchlistScreeningIndividualGetRequest.fromJson(
          Map<String, dynamic> json) =>
      _$WatchlistScreeningIndividualGetRequestFromJson(json);

  @JsonKey(name: 'watchlist_screening_id')
  final String watchlistScreeningId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'client_id')
  final String? clientId;
  static const fromJsonFactory =
      _$WatchlistScreeningIndividualGetRequestFromJson;
  static const toJsonFactory = _$WatchlistScreeningIndividualGetRequestToJson;
  Map<String, dynamic> toJson() =>
      _$WatchlistScreeningIndividualGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WatchlistScreeningIndividualGetRequest &&
            (identical(other.watchlistScreeningId, watchlistScreeningId) ||
                const DeepCollectionEquality().equals(
                    other.watchlistScreeningId, watchlistScreeningId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(watchlistScreeningId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(clientId) ^
      runtimeType.hashCode;
}

extension $WatchlistScreeningIndividualGetRequestExtension
    on WatchlistScreeningIndividualGetRequest {
  WatchlistScreeningIndividualGetRequest copyWith(
      {String? watchlistScreeningId, String? secret, String? clientId}) {
    return WatchlistScreeningIndividualGetRequest(
        watchlistScreeningId: watchlistScreeningId ?? this.watchlistScreeningId,
        secret: secret ?? this.secret,
        clientId: clientId ?? this.clientId);
  }

  WatchlistScreeningIndividualGetRequest copyWithWrapped(
      {Wrapped<String>? watchlistScreeningId,
      Wrapped<String?>? secret,
      Wrapped<String?>? clientId}) {
    return WatchlistScreeningIndividualGetRequest(
        watchlistScreeningId: (watchlistScreeningId != null
            ? watchlistScreeningId.value
            : this.watchlistScreeningId),
        secret: (secret != null ? secret.value : this.secret),
        clientId: (clientId != null ? clientId.value : this.clientId));
  }
}

@JsonSerializable(explicitToJson: true)
class WatchlistScreeningIndividualGetResponse {
  WatchlistScreeningIndividualGetResponse({
    required this.id,
    required this.searchTerms,
    required this.assignee,
    required this.status,
    required this.clientUserId,
    required this.auditTrail,
    required this.requestId,
  });

  factory WatchlistScreeningIndividualGetResponse.fromJson(
          Map<String, dynamic> json) =>
      _$WatchlistScreeningIndividualGetResponseFromJson(json);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'search_terms')
  final WatchlistScreeningSearchTerms searchTerms;
  @JsonKey(name: 'assignee')
  final String? assignee;
  @JsonKey(
    name: 'status',
    toJson: watchlistScreeningStatusToJson,
    fromJson: watchlistScreeningStatusFromJson,
  )
  final enums.WatchlistScreeningStatus status;
  @JsonKey(name: 'client_user_id')
  final String? clientUserId;
  @JsonKey(name: 'audit_trail')
  final WatchlistScreeningAuditTrail auditTrail;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory =
      _$WatchlistScreeningIndividualGetResponseFromJson;
  static const toJsonFactory = _$WatchlistScreeningIndividualGetResponseToJson;
  Map<String, dynamic> toJson() =>
      _$WatchlistScreeningIndividualGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WatchlistScreeningIndividualGetResponse &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.searchTerms, searchTerms) ||
                const DeepCollectionEquality()
                    .equals(other.searchTerms, searchTerms)) &&
            (identical(other.assignee, assignee) ||
                const DeepCollectionEquality()
                    .equals(other.assignee, assignee)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.clientUserId, clientUserId) ||
                const DeepCollectionEquality()
                    .equals(other.clientUserId, clientUserId)) &&
            (identical(other.auditTrail, auditTrail) ||
                const DeepCollectionEquality()
                    .equals(other.auditTrail, auditTrail)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(searchTerms) ^
      const DeepCollectionEquality().hash(assignee) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(clientUserId) ^
      const DeepCollectionEquality().hash(auditTrail) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $WatchlistScreeningIndividualGetResponseExtension
    on WatchlistScreeningIndividualGetResponse {
  WatchlistScreeningIndividualGetResponse copyWith(
      {String? id,
      WatchlistScreeningSearchTerms? searchTerms,
      String? assignee,
      enums.WatchlistScreeningStatus? status,
      String? clientUserId,
      WatchlistScreeningAuditTrail? auditTrail,
      String? requestId}) {
    return WatchlistScreeningIndividualGetResponse(
        id: id ?? this.id,
        searchTerms: searchTerms ?? this.searchTerms,
        assignee: assignee ?? this.assignee,
        status: status ?? this.status,
        clientUserId: clientUserId ?? this.clientUserId,
        auditTrail: auditTrail ?? this.auditTrail,
        requestId: requestId ?? this.requestId);
  }

  WatchlistScreeningIndividualGetResponse copyWithWrapped(
      {Wrapped<String>? id,
      Wrapped<WatchlistScreeningSearchTerms>? searchTerms,
      Wrapped<String?>? assignee,
      Wrapped<enums.WatchlistScreeningStatus>? status,
      Wrapped<String?>? clientUserId,
      Wrapped<WatchlistScreeningAuditTrail>? auditTrail,
      Wrapped<String>? requestId}) {
    return WatchlistScreeningIndividualGetResponse(
        id: (id != null ? id.value : this.id),
        searchTerms:
            (searchTerms != null ? searchTerms.value : this.searchTerms),
        assignee: (assignee != null ? assignee.value : this.assignee),
        status: (status != null ? status.value : this.status),
        clientUserId:
            (clientUserId != null ? clientUserId.value : this.clientUserId),
        auditTrail: (auditTrail != null ? auditTrail.value : this.auditTrail),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class WatchlistScreeningIndividualHistoryListRequest {
  WatchlistScreeningIndividualHistoryListRequest({
    this.secret,
    this.clientId,
    required this.watchlistScreeningId,
    this.cursor,
  });

  factory WatchlistScreeningIndividualHistoryListRequest.fromJson(
          Map<String, dynamic> json) =>
      _$WatchlistScreeningIndividualHistoryListRequestFromJson(json);

  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'watchlist_screening_id')
  final String watchlistScreeningId;
  @JsonKey(name: 'cursor')
  final String? cursor;
  static const fromJsonFactory =
      _$WatchlistScreeningIndividualHistoryListRequestFromJson;
  static const toJsonFactory =
      _$WatchlistScreeningIndividualHistoryListRequestToJson;
  Map<String, dynamic> toJson() =>
      _$WatchlistScreeningIndividualHistoryListRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WatchlistScreeningIndividualHistoryListRequest &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.watchlistScreeningId, watchlistScreeningId) ||
                const DeepCollectionEquality().equals(
                    other.watchlistScreeningId, watchlistScreeningId)) &&
            (identical(other.cursor, cursor) ||
                const DeepCollectionEquality().equals(other.cursor, cursor)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(watchlistScreeningId) ^
      const DeepCollectionEquality().hash(cursor) ^
      runtimeType.hashCode;
}

extension $WatchlistScreeningIndividualHistoryListRequestExtension
    on WatchlistScreeningIndividualHistoryListRequest {
  WatchlistScreeningIndividualHistoryListRequest copyWith(
      {String? secret,
      String? clientId,
      String? watchlistScreeningId,
      String? cursor}) {
    return WatchlistScreeningIndividualHistoryListRequest(
        secret: secret ?? this.secret,
        clientId: clientId ?? this.clientId,
        watchlistScreeningId: watchlistScreeningId ?? this.watchlistScreeningId,
        cursor: cursor ?? this.cursor);
  }

  WatchlistScreeningIndividualHistoryListRequest copyWithWrapped(
      {Wrapped<String?>? secret,
      Wrapped<String?>? clientId,
      Wrapped<String>? watchlistScreeningId,
      Wrapped<String?>? cursor}) {
    return WatchlistScreeningIndividualHistoryListRequest(
        secret: (secret != null ? secret.value : this.secret),
        clientId: (clientId != null ? clientId.value : this.clientId),
        watchlistScreeningId: (watchlistScreeningId != null
            ? watchlistScreeningId.value
            : this.watchlistScreeningId),
        cursor: (cursor != null ? cursor.value : this.cursor));
  }
}

@JsonSerializable(explicitToJson: true)
class WatchlistScreeningIndividualHistoryListResponse {
  WatchlistScreeningIndividualHistoryListResponse({
    required this.watchlistScreenings,
    required this.nextCursor,
    required this.requestId,
  });

  factory WatchlistScreeningIndividualHistoryListResponse.fromJson(
          Map<String, dynamic> json) =>
      _$WatchlistScreeningIndividualHistoryListResponseFromJson(json);

  @JsonKey(
      name: 'watchlist_screenings',
      defaultValue: <WatchlistScreeningIndividual>[])
  final List<WatchlistScreeningIndividual> watchlistScreenings;
  @JsonKey(name: 'next_cursor')
  final String? nextCursor;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory =
      _$WatchlistScreeningIndividualHistoryListResponseFromJson;
  static const toJsonFactory =
      _$WatchlistScreeningIndividualHistoryListResponseToJson;
  Map<String, dynamic> toJson() =>
      _$WatchlistScreeningIndividualHistoryListResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WatchlistScreeningIndividualHistoryListResponse &&
            (identical(other.watchlistScreenings, watchlistScreenings) ||
                const DeepCollectionEquality()
                    .equals(other.watchlistScreenings, watchlistScreenings)) &&
            (identical(other.nextCursor, nextCursor) ||
                const DeepCollectionEquality()
                    .equals(other.nextCursor, nextCursor)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(watchlistScreenings) ^
      const DeepCollectionEquality().hash(nextCursor) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $WatchlistScreeningIndividualHistoryListResponseExtension
    on WatchlistScreeningIndividualHistoryListResponse {
  WatchlistScreeningIndividualHistoryListResponse copyWith(
      {List<WatchlistScreeningIndividual>? watchlistScreenings,
      String? nextCursor,
      String? requestId}) {
    return WatchlistScreeningIndividualHistoryListResponse(
        watchlistScreenings: watchlistScreenings ?? this.watchlistScreenings,
        nextCursor: nextCursor ?? this.nextCursor,
        requestId: requestId ?? this.requestId);
  }

  WatchlistScreeningIndividualHistoryListResponse copyWithWrapped(
      {Wrapped<List<WatchlistScreeningIndividual>>? watchlistScreenings,
      Wrapped<String?>? nextCursor,
      Wrapped<String>? requestId}) {
    return WatchlistScreeningIndividualHistoryListResponse(
        watchlistScreenings: (watchlistScreenings != null
            ? watchlistScreenings.value
            : this.watchlistScreenings),
        nextCursor: (nextCursor != null ? nextCursor.value : this.nextCursor),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class WatchlistScreeningIndividualHitListRequest {
  WatchlistScreeningIndividualHitListRequest({
    this.secret,
    this.clientId,
    required this.watchlistScreeningId,
    this.cursor,
  });

  factory WatchlistScreeningIndividualHitListRequest.fromJson(
          Map<String, dynamic> json) =>
      _$WatchlistScreeningIndividualHitListRequestFromJson(json);

  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'watchlist_screening_id')
  final String watchlistScreeningId;
  @JsonKey(name: 'cursor')
  final String? cursor;
  static const fromJsonFactory =
      _$WatchlistScreeningIndividualHitListRequestFromJson;
  static const toJsonFactory =
      _$WatchlistScreeningIndividualHitListRequestToJson;
  Map<String, dynamic> toJson() =>
      _$WatchlistScreeningIndividualHitListRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WatchlistScreeningIndividualHitListRequest &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.watchlistScreeningId, watchlistScreeningId) ||
                const DeepCollectionEquality().equals(
                    other.watchlistScreeningId, watchlistScreeningId)) &&
            (identical(other.cursor, cursor) ||
                const DeepCollectionEquality().equals(other.cursor, cursor)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(watchlistScreeningId) ^
      const DeepCollectionEquality().hash(cursor) ^
      runtimeType.hashCode;
}

extension $WatchlistScreeningIndividualHitListRequestExtension
    on WatchlistScreeningIndividualHitListRequest {
  WatchlistScreeningIndividualHitListRequest copyWith(
      {String? secret,
      String? clientId,
      String? watchlistScreeningId,
      String? cursor}) {
    return WatchlistScreeningIndividualHitListRequest(
        secret: secret ?? this.secret,
        clientId: clientId ?? this.clientId,
        watchlistScreeningId: watchlistScreeningId ?? this.watchlistScreeningId,
        cursor: cursor ?? this.cursor);
  }

  WatchlistScreeningIndividualHitListRequest copyWithWrapped(
      {Wrapped<String?>? secret,
      Wrapped<String?>? clientId,
      Wrapped<String>? watchlistScreeningId,
      Wrapped<String?>? cursor}) {
    return WatchlistScreeningIndividualHitListRequest(
        secret: (secret != null ? secret.value : this.secret),
        clientId: (clientId != null ? clientId.value : this.clientId),
        watchlistScreeningId: (watchlistScreeningId != null
            ? watchlistScreeningId.value
            : this.watchlistScreeningId),
        cursor: (cursor != null ? cursor.value : this.cursor));
  }
}

@JsonSerializable(explicitToJson: true)
class WatchlistScreeningIndividualHitListResponse {
  WatchlistScreeningIndividualHitListResponse({
    required this.watchlistScreeningHits,
    required this.nextCursor,
    required this.requestId,
  });

  factory WatchlistScreeningIndividualHitListResponse.fromJson(
          Map<String, dynamic> json) =>
      _$WatchlistScreeningIndividualHitListResponseFromJson(json);

  @JsonKey(
      name: 'watchlist_screening_hits', defaultValue: <WatchlistScreeningHit>[])
  final List<WatchlistScreeningHit> watchlistScreeningHits;
  @JsonKey(name: 'next_cursor')
  final String? nextCursor;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory =
      _$WatchlistScreeningIndividualHitListResponseFromJson;
  static const toJsonFactory =
      _$WatchlistScreeningIndividualHitListResponseToJson;
  Map<String, dynamic> toJson() =>
      _$WatchlistScreeningIndividualHitListResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WatchlistScreeningIndividualHitListResponse &&
            (identical(other.watchlistScreeningHits, watchlistScreeningHits) ||
                const DeepCollectionEquality().equals(
                    other.watchlistScreeningHits, watchlistScreeningHits)) &&
            (identical(other.nextCursor, nextCursor) ||
                const DeepCollectionEquality()
                    .equals(other.nextCursor, nextCursor)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(watchlistScreeningHits) ^
      const DeepCollectionEquality().hash(nextCursor) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $WatchlistScreeningIndividualHitListResponseExtension
    on WatchlistScreeningIndividualHitListResponse {
  WatchlistScreeningIndividualHitListResponse copyWith(
      {List<WatchlistScreeningHit>? watchlistScreeningHits,
      String? nextCursor,
      String? requestId}) {
    return WatchlistScreeningIndividualHitListResponse(
        watchlistScreeningHits:
            watchlistScreeningHits ?? this.watchlistScreeningHits,
        nextCursor: nextCursor ?? this.nextCursor,
        requestId: requestId ?? this.requestId);
  }

  WatchlistScreeningIndividualHitListResponse copyWithWrapped(
      {Wrapped<List<WatchlistScreeningHit>>? watchlistScreeningHits,
      Wrapped<String?>? nextCursor,
      Wrapped<String>? requestId}) {
    return WatchlistScreeningIndividualHitListResponse(
        watchlistScreeningHits: (watchlistScreeningHits != null
            ? watchlistScreeningHits.value
            : this.watchlistScreeningHits),
        nextCursor: (nextCursor != null ? nextCursor.value : this.nextCursor),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class WatchlistScreeningIndividualListRequest {
  WatchlistScreeningIndividualListRequest({
    this.secret,
    this.clientId,
    required this.watchlistProgramId,
    this.clientUserId,
    this.status,
    this.assignee,
    this.cursor,
  });

  factory WatchlistScreeningIndividualListRequest.fromJson(
          Map<String, dynamic> json) =>
      _$WatchlistScreeningIndividualListRequestFromJson(json);

  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'watchlist_program_id')
  final String watchlistProgramId;
  @JsonKey(name: 'client_user_id')
  final String? clientUserId;
  @JsonKey(
    name: 'status',
    toJson: watchlistScreeningStatusToJson,
    fromJson: watchlistScreeningStatusFromJson,
  )
  final enums.WatchlistScreeningStatus? status;
  @JsonKey(name: 'assignee')
  final String? assignee;
  @JsonKey(name: 'cursor')
  final String? cursor;
  static const fromJsonFactory =
      _$WatchlistScreeningIndividualListRequestFromJson;
  static const toJsonFactory = _$WatchlistScreeningIndividualListRequestToJson;
  Map<String, dynamic> toJson() =>
      _$WatchlistScreeningIndividualListRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WatchlistScreeningIndividualListRequest &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.watchlistProgramId, watchlistProgramId) ||
                const DeepCollectionEquality()
                    .equals(other.watchlistProgramId, watchlistProgramId)) &&
            (identical(other.clientUserId, clientUserId) ||
                const DeepCollectionEquality()
                    .equals(other.clientUserId, clientUserId)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.assignee, assignee) ||
                const DeepCollectionEquality()
                    .equals(other.assignee, assignee)) &&
            (identical(other.cursor, cursor) ||
                const DeepCollectionEquality().equals(other.cursor, cursor)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(watchlistProgramId) ^
      const DeepCollectionEquality().hash(clientUserId) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(assignee) ^
      const DeepCollectionEquality().hash(cursor) ^
      runtimeType.hashCode;
}

extension $WatchlistScreeningIndividualListRequestExtension
    on WatchlistScreeningIndividualListRequest {
  WatchlistScreeningIndividualListRequest copyWith(
      {String? secret,
      String? clientId,
      String? watchlistProgramId,
      String? clientUserId,
      enums.WatchlistScreeningStatus? status,
      String? assignee,
      String? cursor}) {
    return WatchlistScreeningIndividualListRequest(
        secret: secret ?? this.secret,
        clientId: clientId ?? this.clientId,
        watchlistProgramId: watchlistProgramId ?? this.watchlistProgramId,
        clientUserId: clientUserId ?? this.clientUserId,
        status: status ?? this.status,
        assignee: assignee ?? this.assignee,
        cursor: cursor ?? this.cursor);
  }

  WatchlistScreeningIndividualListRequest copyWithWrapped(
      {Wrapped<String?>? secret,
      Wrapped<String?>? clientId,
      Wrapped<String>? watchlistProgramId,
      Wrapped<String?>? clientUserId,
      Wrapped<enums.WatchlistScreeningStatus?>? status,
      Wrapped<String?>? assignee,
      Wrapped<String?>? cursor}) {
    return WatchlistScreeningIndividualListRequest(
        secret: (secret != null ? secret.value : this.secret),
        clientId: (clientId != null ? clientId.value : this.clientId),
        watchlistProgramId: (watchlistProgramId != null
            ? watchlistProgramId.value
            : this.watchlistProgramId),
        clientUserId:
            (clientUserId != null ? clientUserId.value : this.clientUserId),
        status: (status != null ? status.value : this.status),
        assignee: (assignee != null ? assignee.value : this.assignee),
        cursor: (cursor != null ? cursor.value : this.cursor));
  }
}

@JsonSerializable(explicitToJson: true)
class WatchlistScreeningIndividualListResponse {
  WatchlistScreeningIndividualListResponse({
    required this.watchlistScreenings,
    required this.nextCursor,
    required this.requestId,
  });

  factory WatchlistScreeningIndividualListResponse.fromJson(
          Map<String, dynamic> json) =>
      _$WatchlistScreeningIndividualListResponseFromJson(json);

  @JsonKey(
      name: 'watchlist_screenings',
      defaultValue: <WatchlistScreeningIndividual>[])
  final List<WatchlistScreeningIndividual> watchlistScreenings;
  @JsonKey(name: 'next_cursor')
  final String? nextCursor;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory =
      _$WatchlistScreeningIndividualListResponseFromJson;
  static const toJsonFactory = _$WatchlistScreeningIndividualListResponseToJson;
  Map<String, dynamic> toJson() =>
      _$WatchlistScreeningIndividualListResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WatchlistScreeningIndividualListResponse &&
            (identical(other.watchlistScreenings, watchlistScreenings) ||
                const DeepCollectionEquality()
                    .equals(other.watchlistScreenings, watchlistScreenings)) &&
            (identical(other.nextCursor, nextCursor) ||
                const DeepCollectionEquality()
                    .equals(other.nextCursor, nextCursor)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(watchlistScreenings) ^
      const DeepCollectionEquality().hash(nextCursor) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $WatchlistScreeningIndividualListResponseExtension
    on WatchlistScreeningIndividualListResponse {
  WatchlistScreeningIndividualListResponse copyWith(
      {List<WatchlistScreeningIndividual>? watchlistScreenings,
      String? nextCursor,
      String? requestId}) {
    return WatchlistScreeningIndividualListResponse(
        watchlistScreenings: watchlistScreenings ?? this.watchlistScreenings,
        nextCursor: nextCursor ?? this.nextCursor,
        requestId: requestId ?? this.requestId);
  }

  WatchlistScreeningIndividualListResponse copyWithWrapped(
      {Wrapped<List<WatchlistScreeningIndividual>>? watchlistScreenings,
      Wrapped<String?>? nextCursor,
      Wrapped<String>? requestId}) {
    return WatchlistScreeningIndividualListResponse(
        watchlistScreenings: (watchlistScreenings != null
            ? watchlistScreenings.value
            : this.watchlistScreenings),
        nextCursor: (nextCursor != null ? nextCursor.value : this.nextCursor),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class WatchlistScreeningIndividualProgramGetRequest {
  WatchlistScreeningIndividualProgramGetRequest({
    required this.watchlistProgramId,
    this.secret,
    this.clientId,
  });

  factory WatchlistScreeningIndividualProgramGetRequest.fromJson(
          Map<String, dynamic> json) =>
      _$WatchlistScreeningIndividualProgramGetRequestFromJson(json);

  @JsonKey(name: 'watchlist_program_id')
  final String watchlistProgramId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'client_id')
  final String? clientId;
  static const fromJsonFactory =
      _$WatchlistScreeningIndividualProgramGetRequestFromJson;
  static const toJsonFactory =
      _$WatchlistScreeningIndividualProgramGetRequestToJson;
  Map<String, dynamic> toJson() =>
      _$WatchlistScreeningIndividualProgramGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WatchlistScreeningIndividualProgramGetRequest &&
            (identical(other.watchlistProgramId, watchlistProgramId) ||
                const DeepCollectionEquality()
                    .equals(other.watchlistProgramId, watchlistProgramId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(watchlistProgramId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(clientId) ^
      runtimeType.hashCode;
}

extension $WatchlistScreeningIndividualProgramGetRequestExtension
    on WatchlistScreeningIndividualProgramGetRequest {
  WatchlistScreeningIndividualProgramGetRequest copyWith(
      {String? watchlistProgramId, String? secret, String? clientId}) {
    return WatchlistScreeningIndividualProgramGetRequest(
        watchlistProgramId: watchlistProgramId ?? this.watchlistProgramId,
        secret: secret ?? this.secret,
        clientId: clientId ?? this.clientId);
  }

  WatchlistScreeningIndividualProgramGetRequest copyWithWrapped(
      {Wrapped<String>? watchlistProgramId,
      Wrapped<String?>? secret,
      Wrapped<String?>? clientId}) {
    return WatchlistScreeningIndividualProgramGetRequest(
        watchlistProgramId: (watchlistProgramId != null
            ? watchlistProgramId.value
            : this.watchlistProgramId),
        secret: (secret != null ? secret.value : this.secret),
        clientId: (clientId != null ? clientId.value : this.clientId));
  }
}

@JsonSerializable(explicitToJson: true)
class WatchlistScreeningIndividualProgramGetResponse {
  WatchlistScreeningIndividualProgramGetResponse({
    required this.id,
    required this.createdAt,
    required this.isRescanningEnabled,
    required this.listsEnabled,
    required this.name,
    required this.nameSensitivity,
    required this.auditTrail,
    required this.isArchived,
    required this.requestId,
  });

  factory WatchlistScreeningIndividualProgramGetResponse.fromJson(
          Map<String, dynamic> json) =>
      _$WatchlistScreeningIndividualProgramGetResponseFromJson(json);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'created_at')
  final String createdAt;
  @JsonKey(name: 'is_rescanning_enabled')
  final bool isRescanningEnabled;
  @JsonKey(
    name: 'lists_enabled',
    toJson: individualWatchlistCodeListToJson,
    fromJson: individualWatchlistCodeListFromJson,
  )
  final List<enums.IndividualWatchlistCode> listsEnabled;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(
    name: 'name_sensitivity',
    toJson: programNameSensitivityToJson,
    fromJson: programNameSensitivityFromJson,
  )
  final enums.ProgramNameSensitivity nameSensitivity;
  @JsonKey(name: 'audit_trail')
  final WatchlistScreeningAuditTrail auditTrail;
  @JsonKey(name: 'is_archived')
  final bool isArchived;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory =
      _$WatchlistScreeningIndividualProgramGetResponseFromJson;
  static const toJsonFactory =
      _$WatchlistScreeningIndividualProgramGetResponseToJson;
  Map<String, dynamic> toJson() =>
      _$WatchlistScreeningIndividualProgramGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WatchlistScreeningIndividualProgramGetResponse &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.createdAt, createdAt) ||
                const DeepCollectionEquality()
                    .equals(other.createdAt, createdAt)) &&
            (identical(other.isRescanningEnabled, isRescanningEnabled) ||
                const DeepCollectionEquality()
                    .equals(other.isRescanningEnabled, isRescanningEnabled)) &&
            (identical(other.listsEnabled, listsEnabled) ||
                const DeepCollectionEquality()
                    .equals(other.listsEnabled, listsEnabled)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.nameSensitivity, nameSensitivity) ||
                const DeepCollectionEquality()
                    .equals(other.nameSensitivity, nameSensitivity)) &&
            (identical(other.auditTrail, auditTrail) ||
                const DeepCollectionEquality()
                    .equals(other.auditTrail, auditTrail)) &&
            (identical(other.isArchived, isArchived) ||
                const DeepCollectionEquality()
                    .equals(other.isArchived, isArchived)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(createdAt) ^
      const DeepCollectionEquality().hash(isRescanningEnabled) ^
      const DeepCollectionEquality().hash(listsEnabled) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(nameSensitivity) ^
      const DeepCollectionEquality().hash(auditTrail) ^
      const DeepCollectionEquality().hash(isArchived) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $WatchlistScreeningIndividualProgramGetResponseExtension
    on WatchlistScreeningIndividualProgramGetResponse {
  WatchlistScreeningIndividualProgramGetResponse copyWith(
      {String? id,
      String? createdAt,
      bool? isRescanningEnabled,
      List<enums.IndividualWatchlistCode>? listsEnabled,
      String? name,
      enums.ProgramNameSensitivity? nameSensitivity,
      WatchlistScreeningAuditTrail? auditTrail,
      bool? isArchived,
      String? requestId}) {
    return WatchlistScreeningIndividualProgramGetResponse(
        id: id ?? this.id,
        createdAt: createdAt ?? this.createdAt,
        isRescanningEnabled: isRescanningEnabled ?? this.isRescanningEnabled,
        listsEnabled: listsEnabled ?? this.listsEnabled,
        name: name ?? this.name,
        nameSensitivity: nameSensitivity ?? this.nameSensitivity,
        auditTrail: auditTrail ?? this.auditTrail,
        isArchived: isArchived ?? this.isArchived,
        requestId: requestId ?? this.requestId);
  }

  WatchlistScreeningIndividualProgramGetResponse copyWithWrapped(
      {Wrapped<String>? id,
      Wrapped<String>? createdAt,
      Wrapped<bool>? isRescanningEnabled,
      Wrapped<List<enums.IndividualWatchlistCode>>? listsEnabled,
      Wrapped<String>? name,
      Wrapped<enums.ProgramNameSensitivity>? nameSensitivity,
      Wrapped<WatchlistScreeningAuditTrail>? auditTrail,
      Wrapped<bool>? isArchived,
      Wrapped<String>? requestId}) {
    return WatchlistScreeningIndividualProgramGetResponse(
        id: (id != null ? id.value : this.id),
        createdAt: (createdAt != null ? createdAt.value : this.createdAt),
        isRescanningEnabled: (isRescanningEnabled != null
            ? isRescanningEnabled.value
            : this.isRescanningEnabled),
        listsEnabled:
            (listsEnabled != null ? listsEnabled.value : this.listsEnabled),
        name: (name != null ? name.value : this.name),
        nameSensitivity: (nameSensitivity != null
            ? nameSensitivity.value
            : this.nameSensitivity),
        auditTrail: (auditTrail != null ? auditTrail.value : this.auditTrail),
        isArchived: (isArchived != null ? isArchived.value : this.isArchived),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class WatchlistScreeningIndividualProgramListRequest {
  WatchlistScreeningIndividualProgramListRequest({
    this.secret,
    this.clientId,
    this.cursor,
  });

  factory WatchlistScreeningIndividualProgramListRequest.fromJson(
          Map<String, dynamic> json) =>
      _$WatchlistScreeningIndividualProgramListRequestFromJson(json);

  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'cursor')
  final String? cursor;
  static const fromJsonFactory =
      _$WatchlistScreeningIndividualProgramListRequestFromJson;
  static const toJsonFactory =
      _$WatchlistScreeningIndividualProgramListRequestToJson;
  Map<String, dynamic> toJson() =>
      _$WatchlistScreeningIndividualProgramListRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WatchlistScreeningIndividualProgramListRequest &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.cursor, cursor) ||
                const DeepCollectionEquality().equals(other.cursor, cursor)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(cursor) ^
      runtimeType.hashCode;
}

extension $WatchlistScreeningIndividualProgramListRequestExtension
    on WatchlistScreeningIndividualProgramListRequest {
  WatchlistScreeningIndividualProgramListRequest copyWith(
      {String? secret, String? clientId, String? cursor}) {
    return WatchlistScreeningIndividualProgramListRequest(
        secret: secret ?? this.secret,
        clientId: clientId ?? this.clientId,
        cursor: cursor ?? this.cursor);
  }

  WatchlistScreeningIndividualProgramListRequest copyWithWrapped(
      {Wrapped<String?>? secret,
      Wrapped<String?>? clientId,
      Wrapped<String?>? cursor}) {
    return WatchlistScreeningIndividualProgramListRequest(
        secret: (secret != null ? secret.value : this.secret),
        clientId: (clientId != null ? clientId.value : this.clientId),
        cursor: (cursor != null ? cursor.value : this.cursor));
  }
}

@JsonSerializable(explicitToJson: true)
class WatchlistScreeningIndividualProgramListResponse {
  WatchlistScreeningIndividualProgramListResponse({
    required this.watchlistPrograms,
    required this.nextCursor,
    required this.requestId,
  });

  factory WatchlistScreeningIndividualProgramListResponse.fromJson(
          Map<String, dynamic> json) =>
      _$WatchlistScreeningIndividualProgramListResponseFromJson(json);

  @JsonKey(
      name: 'watchlist_programs', defaultValue: <IndividualWatchlistProgram>[])
  final List<IndividualWatchlistProgram> watchlistPrograms;
  @JsonKey(name: 'next_cursor')
  final String? nextCursor;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory =
      _$WatchlistScreeningIndividualProgramListResponseFromJson;
  static const toJsonFactory =
      _$WatchlistScreeningIndividualProgramListResponseToJson;
  Map<String, dynamic> toJson() =>
      _$WatchlistScreeningIndividualProgramListResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WatchlistScreeningIndividualProgramListResponse &&
            (identical(other.watchlistPrograms, watchlistPrograms) ||
                const DeepCollectionEquality()
                    .equals(other.watchlistPrograms, watchlistPrograms)) &&
            (identical(other.nextCursor, nextCursor) ||
                const DeepCollectionEquality()
                    .equals(other.nextCursor, nextCursor)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(watchlistPrograms) ^
      const DeepCollectionEquality().hash(nextCursor) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $WatchlistScreeningIndividualProgramListResponseExtension
    on WatchlistScreeningIndividualProgramListResponse {
  WatchlistScreeningIndividualProgramListResponse copyWith(
      {List<IndividualWatchlistProgram>? watchlistPrograms,
      String? nextCursor,
      String? requestId}) {
    return WatchlistScreeningIndividualProgramListResponse(
        watchlistPrograms: watchlistPrograms ?? this.watchlistPrograms,
        nextCursor: nextCursor ?? this.nextCursor,
        requestId: requestId ?? this.requestId);
  }

  WatchlistScreeningIndividualProgramListResponse copyWithWrapped(
      {Wrapped<List<IndividualWatchlistProgram>>? watchlistPrograms,
      Wrapped<String?>? nextCursor,
      Wrapped<String>? requestId}) {
    return WatchlistScreeningIndividualProgramListResponse(
        watchlistPrograms: (watchlistPrograms != null
            ? watchlistPrograms.value
            : this.watchlistPrograms),
        nextCursor: (nextCursor != null ? nextCursor.value : this.nextCursor),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class WatchlistScreeningIndividualReviewCreateRequest {
  WatchlistScreeningIndividualReviewCreateRequest({
    required this.confirmedHits,
    required this.dismissedHits,
    this.comment,
    this.clientId,
    this.secret,
    required this.watchlistScreeningId,
  });

  factory WatchlistScreeningIndividualReviewCreateRequest.fromJson(
          Map<String, dynamic> json) =>
      _$WatchlistScreeningIndividualReviewCreateRequestFromJson(json);

  @JsonKey(name: 'confirmed_hits', defaultValue: <String>[])
  final List<String> confirmedHits;
  @JsonKey(name: 'dismissed_hits', defaultValue: <String>[])
  final List<String> dismissedHits;
  @JsonKey(name: 'comment')
  final String? comment;
  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'watchlist_screening_id')
  final String watchlistScreeningId;
  static const fromJsonFactory =
      _$WatchlistScreeningIndividualReviewCreateRequestFromJson;
  static const toJsonFactory =
      _$WatchlistScreeningIndividualReviewCreateRequestToJson;
  Map<String, dynamic> toJson() =>
      _$WatchlistScreeningIndividualReviewCreateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WatchlistScreeningIndividualReviewCreateRequest &&
            (identical(other.confirmedHits, confirmedHits) ||
                const DeepCollectionEquality()
                    .equals(other.confirmedHits, confirmedHits)) &&
            (identical(other.dismissedHits, dismissedHits) ||
                const DeepCollectionEquality()
                    .equals(other.dismissedHits, dismissedHits)) &&
            (identical(other.comment, comment) ||
                const DeepCollectionEquality()
                    .equals(other.comment, comment)) &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.watchlistScreeningId, watchlistScreeningId) ||
                const DeepCollectionEquality()
                    .equals(other.watchlistScreeningId, watchlistScreeningId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(confirmedHits) ^
      const DeepCollectionEquality().hash(dismissedHits) ^
      const DeepCollectionEquality().hash(comment) ^
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(watchlistScreeningId) ^
      runtimeType.hashCode;
}

extension $WatchlistScreeningIndividualReviewCreateRequestExtension
    on WatchlistScreeningIndividualReviewCreateRequest {
  WatchlistScreeningIndividualReviewCreateRequest copyWith(
      {List<String>? confirmedHits,
      List<String>? dismissedHits,
      String? comment,
      String? clientId,
      String? secret,
      String? watchlistScreeningId}) {
    return WatchlistScreeningIndividualReviewCreateRequest(
        confirmedHits: confirmedHits ?? this.confirmedHits,
        dismissedHits: dismissedHits ?? this.dismissedHits,
        comment: comment ?? this.comment,
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        watchlistScreeningId:
            watchlistScreeningId ?? this.watchlistScreeningId);
  }

  WatchlistScreeningIndividualReviewCreateRequest copyWithWrapped(
      {Wrapped<List<String>>? confirmedHits,
      Wrapped<List<String>>? dismissedHits,
      Wrapped<String?>? comment,
      Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? watchlistScreeningId}) {
    return WatchlistScreeningIndividualReviewCreateRequest(
        confirmedHits:
            (confirmedHits != null ? confirmedHits.value : this.confirmedHits),
        dismissedHits:
            (dismissedHits != null ? dismissedHits.value : this.dismissedHits),
        comment: (comment != null ? comment.value : this.comment),
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        watchlistScreeningId: (watchlistScreeningId != null
            ? watchlistScreeningId.value
            : this.watchlistScreeningId));
  }
}

@JsonSerializable(explicitToJson: true)
class WatchlistScreeningIndividualReviewCreateResponse {
  WatchlistScreeningIndividualReviewCreateResponse({
    required this.id,
    required this.confirmedHits,
    required this.dismissedHits,
    required this.comment,
    required this.auditTrail,
    required this.requestId,
  });

  factory WatchlistScreeningIndividualReviewCreateResponse.fromJson(
          Map<String, dynamic> json) =>
      _$WatchlistScreeningIndividualReviewCreateResponseFromJson(json);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'confirmed_hits', defaultValue: <String>[])
  final List<String> confirmedHits;
  @JsonKey(name: 'dismissed_hits', defaultValue: <String>[])
  final List<String> dismissedHits;
  @JsonKey(name: 'comment')
  final String? comment;
  @JsonKey(name: 'audit_trail')
  final WatchlistScreeningAuditTrail auditTrail;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory =
      _$WatchlistScreeningIndividualReviewCreateResponseFromJson;
  static const toJsonFactory =
      _$WatchlistScreeningIndividualReviewCreateResponseToJson;
  Map<String, dynamic> toJson() =>
      _$WatchlistScreeningIndividualReviewCreateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WatchlistScreeningIndividualReviewCreateResponse &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.confirmedHits, confirmedHits) ||
                const DeepCollectionEquality()
                    .equals(other.confirmedHits, confirmedHits)) &&
            (identical(other.dismissedHits, dismissedHits) ||
                const DeepCollectionEquality()
                    .equals(other.dismissedHits, dismissedHits)) &&
            (identical(other.comment, comment) ||
                const DeepCollectionEquality()
                    .equals(other.comment, comment)) &&
            (identical(other.auditTrail, auditTrail) ||
                const DeepCollectionEquality()
                    .equals(other.auditTrail, auditTrail)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(confirmedHits) ^
      const DeepCollectionEquality().hash(dismissedHits) ^
      const DeepCollectionEquality().hash(comment) ^
      const DeepCollectionEquality().hash(auditTrail) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $WatchlistScreeningIndividualReviewCreateResponseExtension
    on WatchlistScreeningIndividualReviewCreateResponse {
  WatchlistScreeningIndividualReviewCreateResponse copyWith(
      {String? id,
      List<String>? confirmedHits,
      List<String>? dismissedHits,
      String? comment,
      WatchlistScreeningAuditTrail? auditTrail,
      String? requestId}) {
    return WatchlistScreeningIndividualReviewCreateResponse(
        id: id ?? this.id,
        confirmedHits: confirmedHits ?? this.confirmedHits,
        dismissedHits: dismissedHits ?? this.dismissedHits,
        comment: comment ?? this.comment,
        auditTrail: auditTrail ?? this.auditTrail,
        requestId: requestId ?? this.requestId);
  }

  WatchlistScreeningIndividualReviewCreateResponse copyWithWrapped(
      {Wrapped<String>? id,
      Wrapped<List<String>>? confirmedHits,
      Wrapped<List<String>>? dismissedHits,
      Wrapped<String?>? comment,
      Wrapped<WatchlistScreeningAuditTrail>? auditTrail,
      Wrapped<String>? requestId}) {
    return WatchlistScreeningIndividualReviewCreateResponse(
        id: (id != null ? id.value : this.id),
        confirmedHits:
            (confirmedHits != null ? confirmedHits.value : this.confirmedHits),
        dismissedHits:
            (dismissedHits != null ? dismissedHits.value : this.dismissedHits),
        comment: (comment != null ? comment.value : this.comment),
        auditTrail: (auditTrail != null ? auditTrail.value : this.auditTrail),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class WatchlistScreeningIndividualReviewListRequest {
  WatchlistScreeningIndividualReviewListRequest({
    this.secret,
    this.clientId,
    required this.watchlistScreeningId,
    this.cursor,
  });

  factory WatchlistScreeningIndividualReviewListRequest.fromJson(
          Map<String, dynamic> json) =>
      _$WatchlistScreeningIndividualReviewListRequestFromJson(json);

  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'watchlist_screening_id')
  final String watchlistScreeningId;
  @JsonKey(name: 'cursor')
  final String? cursor;
  static const fromJsonFactory =
      _$WatchlistScreeningIndividualReviewListRequestFromJson;
  static const toJsonFactory =
      _$WatchlistScreeningIndividualReviewListRequestToJson;
  Map<String, dynamic> toJson() =>
      _$WatchlistScreeningIndividualReviewListRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WatchlistScreeningIndividualReviewListRequest &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.watchlistScreeningId, watchlistScreeningId) ||
                const DeepCollectionEquality().equals(
                    other.watchlistScreeningId, watchlistScreeningId)) &&
            (identical(other.cursor, cursor) ||
                const DeepCollectionEquality().equals(other.cursor, cursor)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(watchlistScreeningId) ^
      const DeepCollectionEquality().hash(cursor) ^
      runtimeType.hashCode;
}

extension $WatchlistScreeningIndividualReviewListRequestExtension
    on WatchlistScreeningIndividualReviewListRequest {
  WatchlistScreeningIndividualReviewListRequest copyWith(
      {String? secret,
      String? clientId,
      String? watchlistScreeningId,
      String? cursor}) {
    return WatchlistScreeningIndividualReviewListRequest(
        secret: secret ?? this.secret,
        clientId: clientId ?? this.clientId,
        watchlistScreeningId: watchlistScreeningId ?? this.watchlistScreeningId,
        cursor: cursor ?? this.cursor);
  }

  WatchlistScreeningIndividualReviewListRequest copyWithWrapped(
      {Wrapped<String?>? secret,
      Wrapped<String?>? clientId,
      Wrapped<String>? watchlistScreeningId,
      Wrapped<String?>? cursor}) {
    return WatchlistScreeningIndividualReviewListRequest(
        secret: (secret != null ? secret.value : this.secret),
        clientId: (clientId != null ? clientId.value : this.clientId),
        watchlistScreeningId: (watchlistScreeningId != null
            ? watchlistScreeningId.value
            : this.watchlistScreeningId),
        cursor: (cursor != null ? cursor.value : this.cursor));
  }
}

@JsonSerializable(explicitToJson: true)
class WatchlistScreeningIndividualReviewListResponse {
  WatchlistScreeningIndividualReviewListResponse({
    required this.watchlistScreeningReviews,
    required this.nextCursor,
    required this.requestId,
  });

  factory WatchlistScreeningIndividualReviewListResponse.fromJson(
          Map<String, dynamic> json) =>
      _$WatchlistScreeningIndividualReviewListResponseFromJson(json);

  @JsonKey(
      name: 'watchlist_screening_reviews',
      defaultValue: <WatchlistScreeningReview>[])
  final List<WatchlistScreeningReview> watchlistScreeningReviews;
  @JsonKey(name: 'next_cursor')
  final String? nextCursor;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory =
      _$WatchlistScreeningIndividualReviewListResponseFromJson;
  static const toJsonFactory =
      _$WatchlistScreeningIndividualReviewListResponseToJson;
  Map<String, dynamic> toJson() =>
      _$WatchlistScreeningIndividualReviewListResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WatchlistScreeningIndividualReviewListResponse &&
            (identical(other.watchlistScreeningReviews,
                    watchlistScreeningReviews) ||
                const DeepCollectionEquality().equals(
                    other.watchlistScreeningReviews,
                    watchlistScreeningReviews)) &&
            (identical(other.nextCursor, nextCursor) ||
                const DeepCollectionEquality()
                    .equals(other.nextCursor, nextCursor)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(watchlistScreeningReviews) ^
      const DeepCollectionEquality().hash(nextCursor) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $WatchlistScreeningIndividualReviewListResponseExtension
    on WatchlistScreeningIndividualReviewListResponse {
  WatchlistScreeningIndividualReviewListResponse copyWith(
      {List<WatchlistScreeningReview>? watchlistScreeningReviews,
      String? nextCursor,
      String? requestId}) {
    return WatchlistScreeningIndividualReviewListResponse(
        watchlistScreeningReviews:
            watchlistScreeningReviews ?? this.watchlistScreeningReviews,
        nextCursor: nextCursor ?? this.nextCursor,
        requestId: requestId ?? this.requestId);
  }

  WatchlistScreeningIndividualReviewListResponse copyWithWrapped(
      {Wrapped<List<WatchlistScreeningReview>>? watchlistScreeningReviews,
      Wrapped<String?>? nextCursor,
      Wrapped<String>? requestId}) {
    return WatchlistScreeningIndividualReviewListResponse(
        watchlistScreeningReviews: (watchlistScreeningReviews != null
            ? watchlistScreeningReviews.value
            : this.watchlistScreeningReviews),
        nextCursor: (nextCursor != null ? nextCursor.value : this.nextCursor),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class WatchlistScreeningIndividualUpdateRequest {
  WatchlistScreeningIndividualUpdateRequest({
    required this.watchlistScreeningId,
    this.searchTerms,
    this.assignee,
    this.status,
    this.clientUserId,
    this.clientId,
    this.secret,
    this.resetFields,
  });

  factory WatchlistScreeningIndividualUpdateRequest.fromJson(
          Map<String, dynamic> json) =>
      _$WatchlistScreeningIndividualUpdateRequestFromJson(json);

  @JsonKey(name: 'watchlist_screening_id')
  final String watchlistScreeningId;
  @JsonKey(name: 'search_terms')
  final UpdateIndividualScreeningRequestSearchTerms? searchTerms;
  @JsonKey(name: 'assignee')
  final String? assignee;
  @JsonKey(
    name: 'status',
    toJson: watchlistScreeningStatusToJson,
    fromJson: watchlistScreeningStatusFromJson,
  )
  final enums.WatchlistScreeningStatus? status;
  @JsonKey(name: 'client_user_id')
  final String? clientUserId;
  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'reset_fields')
  final List<String>? resetFields;
  static const fromJsonFactory =
      _$WatchlistScreeningIndividualUpdateRequestFromJson;
  static const toJsonFactory =
      _$WatchlistScreeningIndividualUpdateRequestToJson;
  Map<String, dynamic> toJson() =>
      _$WatchlistScreeningIndividualUpdateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WatchlistScreeningIndividualUpdateRequest &&
            (identical(other.watchlistScreeningId, watchlistScreeningId) ||
                const DeepCollectionEquality().equals(
                    other.watchlistScreeningId, watchlistScreeningId)) &&
            (identical(other.searchTerms, searchTerms) ||
                const DeepCollectionEquality()
                    .equals(other.searchTerms, searchTerms)) &&
            (identical(other.assignee, assignee) ||
                const DeepCollectionEquality()
                    .equals(other.assignee, assignee)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.clientUserId, clientUserId) ||
                const DeepCollectionEquality()
                    .equals(other.clientUserId, clientUserId)) &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.resetFields, resetFields) ||
                const DeepCollectionEquality()
                    .equals(other.resetFields, resetFields)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(watchlistScreeningId) ^
      const DeepCollectionEquality().hash(searchTerms) ^
      const DeepCollectionEquality().hash(assignee) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(clientUserId) ^
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(resetFields) ^
      runtimeType.hashCode;
}

extension $WatchlistScreeningIndividualUpdateRequestExtension
    on WatchlistScreeningIndividualUpdateRequest {
  WatchlistScreeningIndividualUpdateRequest copyWith(
      {String? watchlistScreeningId,
      UpdateIndividualScreeningRequestSearchTerms? searchTerms,
      String? assignee,
      enums.WatchlistScreeningStatus? status,
      String? clientUserId,
      String? clientId,
      String? secret,
      List<String>? resetFields}) {
    return WatchlistScreeningIndividualUpdateRequest(
        watchlistScreeningId: watchlistScreeningId ?? this.watchlistScreeningId,
        searchTerms: searchTerms ?? this.searchTerms,
        assignee: assignee ?? this.assignee,
        status: status ?? this.status,
        clientUserId: clientUserId ?? this.clientUserId,
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        resetFields: resetFields ?? this.resetFields);
  }

  WatchlistScreeningIndividualUpdateRequest copyWithWrapped(
      {Wrapped<String>? watchlistScreeningId,
      Wrapped<UpdateIndividualScreeningRequestSearchTerms?>? searchTerms,
      Wrapped<String?>? assignee,
      Wrapped<enums.WatchlistScreeningStatus?>? status,
      Wrapped<String?>? clientUserId,
      Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<List<String>?>? resetFields}) {
    return WatchlistScreeningIndividualUpdateRequest(
        watchlistScreeningId: (watchlistScreeningId != null
            ? watchlistScreeningId.value
            : this.watchlistScreeningId),
        searchTerms:
            (searchTerms != null ? searchTerms.value : this.searchTerms),
        assignee: (assignee != null ? assignee.value : this.assignee),
        status: (status != null ? status.value : this.status),
        clientUserId:
            (clientUserId != null ? clientUserId.value : this.clientUserId),
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        resetFields:
            (resetFields != null ? resetFields.value : this.resetFields));
  }
}

typedef WatchlistScreeningIndividualUpdateRequestResettableFieldList
    = List<String>;

@JsonSerializable(explicitToJson: true)
class WatchlistScreeningIndividualUpdateResponse {
  WatchlistScreeningIndividualUpdateResponse({
    required this.id,
    required this.searchTerms,
    required this.assignee,
    required this.status,
    required this.clientUserId,
    required this.auditTrail,
    required this.requestId,
  });

  factory WatchlistScreeningIndividualUpdateResponse.fromJson(
          Map<String, dynamic> json) =>
      _$WatchlistScreeningIndividualUpdateResponseFromJson(json);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'search_terms')
  final WatchlistScreeningSearchTerms searchTerms;
  @JsonKey(name: 'assignee')
  final String? assignee;
  @JsonKey(
    name: 'status',
    toJson: watchlistScreeningStatusToJson,
    fromJson: watchlistScreeningStatusFromJson,
  )
  final enums.WatchlistScreeningStatus status;
  @JsonKey(name: 'client_user_id')
  final String? clientUserId;
  @JsonKey(name: 'audit_trail')
  final WatchlistScreeningAuditTrail auditTrail;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory =
      _$WatchlistScreeningIndividualUpdateResponseFromJson;
  static const toJsonFactory =
      _$WatchlistScreeningIndividualUpdateResponseToJson;
  Map<String, dynamic> toJson() =>
      _$WatchlistScreeningIndividualUpdateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WatchlistScreeningIndividualUpdateResponse &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.searchTerms, searchTerms) ||
                const DeepCollectionEquality()
                    .equals(other.searchTerms, searchTerms)) &&
            (identical(other.assignee, assignee) ||
                const DeepCollectionEquality()
                    .equals(other.assignee, assignee)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.clientUserId, clientUserId) ||
                const DeepCollectionEquality()
                    .equals(other.clientUserId, clientUserId)) &&
            (identical(other.auditTrail, auditTrail) ||
                const DeepCollectionEquality()
                    .equals(other.auditTrail, auditTrail)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(searchTerms) ^
      const DeepCollectionEquality().hash(assignee) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(clientUserId) ^
      const DeepCollectionEquality().hash(auditTrail) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $WatchlistScreeningIndividualUpdateResponseExtension
    on WatchlistScreeningIndividualUpdateResponse {
  WatchlistScreeningIndividualUpdateResponse copyWith(
      {String? id,
      WatchlistScreeningSearchTerms? searchTerms,
      String? assignee,
      enums.WatchlistScreeningStatus? status,
      String? clientUserId,
      WatchlistScreeningAuditTrail? auditTrail,
      String? requestId}) {
    return WatchlistScreeningIndividualUpdateResponse(
        id: id ?? this.id,
        searchTerms: searchTerms ?? this.searchTerms,
        assignee: assignee ?? this.assignee,
        status: status ?? this.status,
        clientUserId: clientUserId ?? this.clientUserId,
        auditTrail: auditTrail ?? this.auditTrail,
        requestId: requestId ?? this.requestId);
  }

  WatchlistScreeningIndividualUpdateResponse copyWithWrapped(
      {Wrapped<String>? id,
      Wrapped<WatchlistScreeningSearchTerms>? searchTerms,
      Wrapped<String?>? assignee,
      Wrapped<enums.WatchlistScreeningStatus>? status,
      Wrapped<String?>? clientUserId,
      Wrapped<WatchlistScreeningAuditTrail>? auditTrail,
      Wrapped<String>? requestId}) {
    return WatchlistScreeningIndividualUpdateResponse(
        id: (id != null ? id.value : this.id),
        searchTerms:
            (searchTerms != null ? searchTerms.value : this.searchTerms),
        assignee: (assignee != null ? assignee.value : this.assignee),
        status: (status != null ? status.value : this.status),
        clientUserId:
            (clientUserId != null ? clientUserId.value : this.clientUserId),
        auditTrail: (auditTrail != null ? auditTrail.value : this.auditTrail),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class WatchlistScreeningRequestSearchTerms {
  WatchlistScreeningRequestSearchTerms({
    required this.watchlistProgramId,
    required this.legalName,
    this.dateOfBirth,
    this.documentNumber,
    this.country,
  });

  factory WatchlistScreeningRequestSearchTerms.fromJson(
          Map<String, dynamic> json) =>
      _$WatchlistScreeningRequestSearchTermsFromJson(json);

  @JsonKey(name: 'watchlist_program_id')
  final String watchlistProgramId;
  @JsonKey(name: 'legal_name')
  final String legalName;
  @JsonKey(name: 'date_of_birth')
  final String? dateOfBirth;
  @JsonKey(name: 'document_number')
  final String? documentNumber;
  @JsonKey(name: 'country')
  final String? country;
  static const fromJsonFactory = _$WatchlistScreeningRequestSearchTermsFromJson;
  static const toJsonFactory = _$WatchlistScreeningRequestSearchTermsToJson;
  Map<String, dynamic> toJson() =>
      _$WatchlistScreeningRequestSearchTermsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WatchlistScreeningRequestSearchTerms &&
            (identical(other.watchlistProgramId, watchlistProgramId) ||
                const DeepCollectionEquality()
                    .equals(other.watchlistProgramId, watchlistProgramId)) &&
            (identical(other.legalName, legalName) ||
                const DeepCollectionEquality()
                    .equals(other.legalName, legalName)) &&
            (identical(other.dateOfBirth, dateOfBirth) ||
                const DeepCollectionEquality()
                    .equals(other.dateOfBirth, dateOfBirth)) &&
            (identical(other.documentNumber, documentNumber) ||
                const DeepCollectionEquality()
                    .equals(other.documentNumber, documentNumber)) &&
            (identical(other.country, country) ||
                const DeepCollectionEquality().equals(other.country, country)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(watchlistProgramId) ^
      const DeepCollectionEquality().hash(legalName) ^
      const DeepCollectionEquality().hash(dateOfBirth) ^
      const DeepCollectionEquality().hash(documentNumber) ^
      const DeepCollectionEquality().hash(country) ^
      runtimeType.hashCode;
}

extension $WatchlistScreeningRequestSearchTermsExtension
    on WatchlistScreeningRequestSearchTerms {
  WatchlistScreeningRequestSearchTerms copyWith(
      {String? watchlistProgramId,
      String? legalName,
      String? dateOfBirth,
      String? documentNumber,
      String? country}) {
    return WatchlistScreeningRequestSearchTerms(
        watchlistProgramId: watchlistProgramId ?? this.watchlistProgramId,
        legalName: legalName ?? this.legalName,
        dateOfBirth: dateOfBirth ?? this.dateOfBirth,
        documentNumber: documentNumber ?? this.documentNumber,
        country: country ?? this.country);
  }

  WatchlistScreeningRequestSearchTerms copyWithWrapped(
      {Wrapped<String>? watchlistProgramId,
      Wrapped<String>? legalName,
      Wrapped<String?>? dateOfBirth,
      Wrapped<String?>? documentNumber,
      Wrapped<String?>? country}) {
    return WatchlistScreeningRequestSearchTerms(
        watchlistProgramId: (watchlistProgramId != null
            ? watchlistProgramId.value
            : this.watchlistProgramId),
        legalName: (legalName != null ? legalName.value : this.legalName),
        dateOfBirth:
            (dateOfBirth != null ? dateOfBirth.value : this.dateOfBirth),
        documentNumber: (documentNumber != null
            ? documentNumber.value
            : this.documentNumber),
        country: (country != null ? country.value : this.country));
  }
}

@JsonSerializable(explicitToJson: true)
class WatchlistScreeningReview {
  WatchlistScreeningReview({
    required this.id,
    required this.confirmedHits,
    required this.dismissedHits,
    required this.comment,
    required this.auditTrail,
  });

  factory WatchlistScreeningReview.fromJson(Map<String, dynamic> json) =>
      _$WatchlistScreeningReviewFromJson(json);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'confirmed_hits', defaultValue: <String>[])
  final List<String> confirmedHits;
  @JsonKey(name: 'dismissed_hits', defaultValue: <String>[])
  final List<String> dismissedHits;
  @JsonKey(name: 'comment')
  final String? comment;
  @JsonKey(name: 'audit_trail')
  final WatchlistScreeningAuditTrail auditTrail;
  static const fromJsonFactory = _$WatchlistScreeningReviewFromJson;
  static const toJsonFactory = _$WatchlistScreeningReviewToJson;
  Map<String, dynamic> toJson() => _$WatchlistScreeningReviewToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WatchlistScreeningReview &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.confirmedHits, confirmedHits) ||
                const DeepCollectionEquality()
                    .equals(other.confirmedHits, confirmedHits)) &&
            (identical(other.dismissedHits, dismissedHits) ||
                const DeepCollectionEquality()
                    .equals(other.dismissedHits, dismissedHits)) &&
            (identical(other.comment, comment) ||
                const DeepCollectionEquality()
                    .equals(other.comment, comment)) &&
            (identical(other.auditTrail, auditTrail) ||
                const DeepCollectionEquality()
                    .equals(other.auditTrail, auditTrail)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(confirmedHits) ^
      const DeepCollectionEquality().hash(dismissedHits) ^
      const DeepCollectionEquality().hash(comment) ^
      const DeepCollectionEquality().hash(auditTrail) ^
      runtimeType.hashCode;
}

extension $WatchlistScreeningReviewExtension on WatchlistScreeningReview {
  WatchlistScreeningReview copyWith(
      {String? id,
      List<String>? confirmedHits,
      List<String>? dismissedHits,
      String? comment,
      WatchlistScreeningAuditTrail? auditTrail}) {
    return WatchlistScreeningReview(
        id: id ?? this.id,
        confirmedHits: confirmedHits ?? this.confirmedHits,
        dismissedHits: dismissedHits ?? this.dismissedHits,
        comment: comment ?? this.comment,
        auditTrail: auditTrail ?? this.auditTrail);
  }

  WatchlistScreeningReview copyWithWrapped(
      {Wrapped<String>? id,
      Wrapped<List<String>>? confirmedHits,
      Wrapped<List<String>>? dismissedHits,
      Wrapped<String?>? comment,
      Wrapped<WatchlistScreeningAuditTrail>? auditTrail}) {
    return WatchlistScreeningReview(
        id: (id != null ? id.value : this.id),
        confirmedHits:
            (confirmedHits != null ? confirmedHits.value : this.confirmedHits),
        dismissedHits:
            (dismissedHits != null ? dismissedHits.value : this.dismissedHits),
        comment: (comment != null ? comment.value : this.comment),
        auditTrail: (auditTrail != null ? auditTrail.value : this.auditTrail));
  }
}

@JsonSerializable(explicitToJson: true)
class WatchlistScreeningSearchTerms {
  WatchlistScreeningSearchTerms({
    required this.watchlistProgramId,
    required this.legalName,
    required this.dateOfBirth,
    required this.documentNumber,
    required this.country,
    required this.version,
  });

  factory WatchlistScreeningSearchTerms.fromJson(Map<String, dynamic> json) =>
      _$WatchlistScreeningSearchTermsFromJson(json);

  @JsonKey(name: 'watchlist_program_id')
  final String watchlistProgramId;
  @JsonKey(name: 'legal_name')
  final String legalName;
  @JsonKey(name: 'date_of_birth')
  final String? dateOfBirth;
  @JsonKey(name: 'document_number')
  final String? documentNumber;
  @JsonKey(name: 'country')
  final String? country;
  @JsonKey(name: 'version')
  final double version;
  static const fromJsonFactory = _$WatchlistScreeningSearchTermsFromJson;
  static const toJsonFactory = _$WatchlistScreeningSearchTermsToJson;
  Map<String, dynamic> toJson() => _$WatchlistScreeningSearchTermsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WatchlistScreeningSearchTerms &&
            (identical(other.watchlistProgramId, watchlistProgramId) ||
                const DeepCollectionEquality()
                    .equals(other.watchlistProgramId, watchlistProgramId)) &&
            (identical(other.legalName, legalName) ||
                const DeepCollectionEquality()
                    .equals(other.legalName, legalName)) &&
            (identical(other.dateOfBirth, dateOfBirth) ||
                const DeepCollectionEquality()
                    .equals(other.dateOfBirth, dateOfBirth)) &&
            (identical(other.documentNumber, documentNumber) ||
                const DeepCollectionEquality()
                    .equals(other.documentNumber, documentNumber)) &&
            (identical(other.country, country) ||
                const DeepCollectionEquality()
                    .equals(other.country, country)) &&
            (identical(other.version, version) ||
                const DeepCollectionEquality().equals(other.version, version)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(watchlistProgramId) ^
      const DeepCollectionEquality().hash(legalName) ^
      const DeepCollectionEquality().hash(dateOfBirth) ^
      const DeepCollectionEquality().hash(documentNumber) ^
      const DeepCollectionEquality().hash(country) ^
      const DeepCollectionEquality().hash(version) ^
      runtimeType.hashCode;
}

extension $WatchlistScreeningSearchTermsExtension
    on WatchlistScreeningSearchTerms {
  WatchlistScreeningSearchTerms copyWith(
      {String? watchlistProgramId,
      String? legalName,
      String? dateOfBirth,
      String? documentNumber,
      String? country,
      double? version}) {
    return WatchlistScreeningSearchTerms(
        watchlistProgramId: watchlistProgramId ?? this.watchlistProgramId,
        legalName: legalName ?? this.legalName,
        dateOfBirth: dateOfBirth ?? this.dateOfBirth,
        documentNumber: documentNumber ?? this.documentNumber,
        country: country ?? this.country,
        version: version ?? this.version);
  }

  WatchlistScreeningSearchTerms copyWithWrapped(
      {Wrapped<String>? watchlistProgramId,
      Wrapped<String>? legalName,
      Wrapped<String?>? dateOfBirth,
      Wrapped<String?>? documentNumber,
      Wrapped<String?>? country,
      Wrapped<double>? version}) {
    return WatchlistScreeningSearchTerms(
        watchlistProgramId: (watchlistProgramId != null
            ? watchlistProgramId.value
            : this.watchlistProgramId),
        legalName: (legalName != null ? legalName.value : this.legalName),
        dateOfBirth:
            (dateOfBirth != null ? dateOfBirth.value : this.dateOfBirth),
        documentNumber: (documentNumber != null
            ? documentNumber.value
            : this.documentNumber),
        country: (country != null ? country.value : this.country),
        version: (version != null ? version.value : this.version));
  }
}

@JsonSerializable(explicitToJson: true)
class AssetReportFreddieGetRequest {
  AssetReportFreddieGetRequest({
    required this.auditCopyToken,
    this.clientId,
    this.secret,
  });

  factory AssetReportFreddieGetRequest.fromJson(Map<String, dynamic> json) =>
      _$AssetReportFreddieGetRequestFromJson(json);

  @JsonKey(name: 'audit_copy_token')
  final String auditCopyToken;
  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  static const fromJsonFactory = _$AssetReportFreddieGetRequestFromJson;
  static const toJsonFactory = _$AssetReportFreddieGetRequestToJson;
  Map<String, dynamic> toJson() => _$AssetReportFreddieGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AssetReportFreddieGetRequest &&
            (identical(other.auditCopyToken, auditCopyToken) ||
                const DeepCollectionEquality()
                    .equals(other.auditCopyToken, auditCopyToken)) &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(auditCopyToken) ^
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      runtimeType.hashCode;
}

extension $AssetReportFreddieGetRequestExtension
    on AssetReportFreddieGetRequest {
  AssetReportFreddieGetRequest copyWith(
      {String? auditCopyToken, String? clientId, String? secret}) {
    return AssetReportFreddieGetRequest(
        auditCopyToken: auditCopyToken ?? this.auditCopyToken,
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret);
  }

  AssetReportFreddieGetRequest copyWithWrapped(
      {Wrapped<String>? auditCopyToken,
      Wrapped<String?>? clientId,
      Wrapped<String?>? secret}) {
    return AssetReportFreddieGetRequest(
        auditCopyToken: (auditCopyToken != null
            ? auditCopyToken.value
            : this.auditCopyToken),
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret));
  }
}

@JsonSerializable(explicitToJson: true)
class AssetReportFreddieGetResponse {
  AssetReportFreddieGetResponse({
    required this.deal,
    required this.requestId,
    required this.schemaVersion,
  });

  factory AssetReportFreddieGetResponse.fromJson(Map<String, dynamic> json) =>
      _$AssetReportFreddieGetResponseFromJson(json);

  @JsonKey(name: 'DEAL')
  final AssetReportFreddie deal;
  @JsonKey(name: 'request_id')
  final String requestId;
  @JsonKey(name: 'SchemaVersion')
  final double schemaVersion;
  static const fromJsonFactory = _$AssetReportFreddieGetResponseFromJson;
  static const toJsonFactory = _$AssetReportFreddieGetResponseToJson;
  Map<String, dynamic> toJson() => _$AssetReportFreddieGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AssetReportFreddieGetResponse &&
            (identical(other.deal, deal) ||
                const DeepCollectionEquality().equals(other.deal, deal)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)) &&
            (identical(other.schemaVersion, schemaVersion) ||
                const DeepCollectionEquality()
                    .equals(other.schemaVersion, schemaVersion)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(deal) ^
      const DeepCollectionEquality().hash(requestId) ^
      const DeepCollectionEquality().hash(schemaVersion) ^
      runtimeType.hashCode;
}

extension $AssetReportFreddieGetResponseExtension
    on AssetReportFreddieGetResponse {
  AssetReportFreddieGetResponse copyWith(
      {AssetReportFreddie? deal, String? requestId, double? schemaVersion}) {
    return AssetReportFreddieGetResponse(
        deal: deal ?? this.deal,
        requestId: requestId ?? this.requestId,
        schemaVersion: schemaVersion ?? this.schemaVersion);
  }

  AssetReportFreddieGetResponse copyWithWrapped(
      {Wrapped<AssetReportFreddie>? deal,
      Wrapped<String>? requestId,
      Wrapped<double>? schemaVersion}) {
    return AssetReportFreddieGetResponse(
        deal: (deal != null ? deal.value : this.deal),
        requestId: (requestId != null ? requestId.value : this.requestId),
        schemaVersion:
            (schemaVersion != null ? schemaVersion.value : this.schemaVersion));
  }
}

@JsonSerializable(explicitToJson: true)
class AssetReportFreddie {
  AssetReportFreddie({
    required this.loans,
    required this.parties,
    required this.services,
  });

  factory AssetReportFreddie.fromJson(Map<String, dynamic> json) =>
      _$AssetReportFreddieFromJson(json);

  @JsonKey(name: 'LOANS')
  final Loans loans;
  @JsonKey(name: 'PARTIES')
  final Parties parties;
  @JsonKey(name: 'SERVICES')
  final Services services;
  static const fromJsonFactory = _$AssetReportFreddieFromJson;
  static const toJsonFactory = _$AssetReportFreddieToJson;
  Map<String, dynamic> toJson() => _$AssetReportFreddieToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AssetReportFreddie &&
            (identical(other.loans, loans) ||
                const DeepCollectionEquality().equals(other.loans, loans)) &&
            (identical(other.parties, parties) ||
                const DeepCollectionEquality()
                    .equals(other.parties, parties)) &&
            (identical(other.services, services) ||
                const DeepCollectionEquality()
                    .equals(other.services, services)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(loans) ^
      const DeepCollectionEquality().hash(parties) ^
      const DeepCollectionEquality().hash(services) ^
      runtimeType.hashCode;
}

extension $AssetReportFreddieExtension on AssetReportFreddie {
  AssetReportFreddie copyWith(
      {Loans? loans, Parties? parties, Services? services}) {
    return AssetReportFreddie(
        loans: loans ?? this.loans,
        parties: parties ?? this.parties,
        services: services ?? this.services);
  }

  AssetReportFreddie copyWithWrapped(
      {Wrapped<Loans>? loans,
      Wrapped<Parties>? parties,
      Wrapped<Services>? services}) {
    return AssetReportFreddie(
        loans: (loans != null ? loans.value : this.loans),
        parties: (parties != null ? parties.value : this.parties),
        services: (services != null ? services.value : this.services));
  }
}

@JsonSerializable(explicitToJson: true)
class Loans {
  Loans({
    required this.loan,
  });

  factory Loans.fromJson(Map<String, dynamic> json) => _$LoansFromJson(json);

  @JsonKey(name: 'LOAN')
  final Loan loan;
  static const fromJsonFactory = _$LoansFromJson;
  static const toJsonFactory = _$LoansToJson;
  Map<String, dynamic> toJson() => _$LoansToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Loans &&
            (identical(other.loan, loan) ||
                const DeepCollectionEquality().equals(other.loan, loan)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(loan) ^ runtimeType.hashCode;
}

extension $LoansExtension on Loans {
  Loans copyWith({Loan? loan}) {
    return Loans(loan: loan ?? this.loan);
  }

  Loans copyWithWrapped({Wrapped<Loan>? loan}) {
    return Loans(loan: (loan != null ? loan.value : this.loan));
  }
}

@JsonSerializable(explicitToJson: true)
class Loan {
  Loan({
    required this.loanidentifiers,
  });

  factory Loan.fromJson(Map<String, dynamic> json) => _$LoanFromJson(json);

  @JsonKey(name: 'LOAN_IDENTIFIERS')
  final LoanIdentifiers loanidentifiers;
  static const fromJsonFactory = _$LoanFromJson;
  static const toJsonFactory = _$LoanToJson;
  Map<String, dynamic> toJson() => _$LoanToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Loan &&
            (identical(other.loanidentifiers, loanidentifiers) ||
                const DeepCollectionEquality()
                    .equals(other.loanidentifiers, loanidentifiers)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(loanidentifiers) ^
      runtimeType.hashCode;
}

extension $LoanExtension on Loan {
  Loan copyWith({LoanIdentifiers? loanidentifiers}) {
    return Loan(loanidentifiers: loanidentifiers ?? this.loanidentifiers);
  }

  Loan copyWithWrapped({Wrapped<LoanIdentifiers>? loanidentifiers}) {
    return Loan(
        loanidentifiers: (loanidentifiers != null
            ? loanidentifiers.value
            : this.loanidentifiers));
  }
}

@JsonSerializable(explicitToJson: true)
class LoanIdentifiers {
  LoanIdentifiers({
    required this.loanidentifier,
  });

  factory LoanIdentifiers.fromJson(Map<String, dynamic> json) =>
      _$LoanIdentifiersFromJson(json);

  @JsonKey(name: 'LOAN_IDENTIFIER')
  final LoanIdentifier loanidentifier;
  static const fromJsonFactory = _$LoanIdentifiersFromJson;
  static const toJsonFactory = _$LoanIdentifiersToJson;
  Map<String, dynamic> toJson() => _$LoanIdentifiersToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LoanIdentifiers &&
            (identical(other.loanidentifier, loanidentifier) ||
                const DeepCollectionEquality()
                    .equals(other.loanidentifier, loanidentifier)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(loanidentifier) ^
      runtimeType.hashCode;
}

extension $LoanIdentifiersExtension on LoanIdentifiers {
  LoanIdentifiers copyWith({LoanIdentifier? loanidentifier}) {
    return LoanIdentifiers(
        loanidentifier: loanidentifier ?? this.loanidentifier);
  }

  LoanIdentifiers copyWithWrapped({Wrapped<LoanIdentifier>? loanidentifier}) {
    return LoanIdentifiers(
        loanidentifier: (loanidentifier != null
            ? loanidentifier.value
            : this.loanidentifier));
  }
}

@JsonSerializable(explicitToJson: true)
class LoanIdentifier {
  LoanIdentifier({
    required this.loanIdentifier,
    required this.loanIdentifierType,
  });

  factory LoanIdentifier.fromJson(Map<String, dynamic> json) =>
      _$LoanIdentifierFromJson(json);

  @JsonKey(name: 'LoanIdentifier')
  final String? loanIdentifier;
  @JsonKey(
    name: 'LoanIdentifierType',
    toJson: loanIdentifierTypeToJson,
    fromJson: loanIdentifierTypeFromJson,
  )
  final enums.LoanIdentifierType? loanIdentifierType;
  static const fromJsonFactory = _$LoanIdentifierFromJson;
  static const toJsonFactory = _$LoanIdentifierToJson;
  Map<String, dynamic> toJson() => _$LoanIdentifierToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LoanIdentifier &&
            (identical(other.loanIdentifier, loanIdentifier) ||
                const DeepCollectionEquality()
                    .equals(other.loanIdentifier, loanIdentifier)) &&
            (identical(other.loanIdentifierType, loanIdentifierType) ||
                const DeepCollectionEquality()
                    .equals(other.loanIdentifierType, loanIdentifierType)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(loanIdentifier) ^
      const DeepCollectionEquality().hash(loanIdentifierType) ^
      runtimeType.hashCode;
}

extension $LoanIdentifierExtension on LoanIdentifier {
  LoanIdentifier copyWith(
      {String? loanIdentifier, enums.LoanIdentifierType? loanIdentifierType}) {
    return LoanIdentifier(
        loanIdentifier: loanIdentifier ?? this.loanIdentifier,
        loanIdentifierType: loanIdentifierType ?? this.loanIdentifierType);
  }

  LoanIdentifier copyWithWrapped(
      {Wrapped<String?>? loanIdentifier,
      Wrapped<enums.LoanIdentifierType?>? loanIdentifierType}) {
    return LoanIdentifier(
        loanIdentifier: (loanIdentifier != null
            ? loanIdentifier.value
            : this.loanIdentifier),
        loanIdentifierType: (loanIdentifierType != null
            ? loanIdentifierType.value
            : this.loanIdentifierType));
  }
}

@JsonSerializable(explicitToJson: true)
class Parties {
  Parties({
    required this.party,
  });

  factory Parties.fromJson(Map<String, dynamic> json) =>
      _$PartiesFromJson(json);

  @JsonKey(name: 'PARTY', defaultValue: <Party>[])
  final List<Party> party;
  static const fromJsonFactory = _$PartiesFromJson;
  static const toJsonFactory = _$PartiesToJson;
  Map<String, dynamic> toJson() => _$PartiesToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Parties &&
            (identical(other.party, party) ||
                const DeepCollectionEquality().equals(other.party, party)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(party) ^ runtimeType.hashCode;
}

extension $PartiesExtension on Parties {
  Parties copyWith({List<Party>? party}) {
    return Parties(party: party ?? this.party);
  }

  Parties copyWithWrapped({Wrapped<List<Party>>? party}) {
    return Parties(party: (party != null ? party.value : this.party));
  }
}

@JsonSerializable(explicitToJson: true)
class Party {
  Party({
    required this.individual,
    required this.roles,
    required this.taxpayeridentifiers,
  });

  factory Party.fromJson(Map<String, dynamic> json) => _$PartyFromJson(json);

  @JsonKey(name: 'INDIVIDUAL')
  final PartyIndividual individual;
  @JsonKey(name: 'ROLES')
  final Roles roles;
  @JsonKey(name: 'TAXPAYER_IDENTIFIERS')
  final TaxpayerIdentifiers taxpayeridentifiers;
  static const fromJsonFactory = _$PartyFromJson;
  static const toJsonFactory = _$PartyToJson;
  Map<String, dynamic> toJson() => _$PartyToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Party &&
            (identical(other.individual, individual) ||
                const DeepCollectionEquality()
                    .equals(other.individual, individual)) &&
            (identical(other.roles, roles) ||
                const DeepCollectionEquality().equals(other.roles, roles)) &&
            (identical(other.taxpayeridentifiers, taxpayeridentifiers) ||
                const DeepCollectionEquality()
                    .equals(other.taxpayeridentifiers, taxpayeridentifiers)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(individual) ^
      const DeepCollectionEquality().hash(roles) ^
      const DeepCollectionEquality().hash(taxpayeridentifiers) ^
      runtimeType.hashCode;
}

extension $PartyExtension on Party {
  Party copyWith(
      {PartyIndividual? individual,
      Roles? roles,
      TaxpayerIdentifiers? taxpayeridentifiers}) {
    return Party(
        individual: individual ?? this.individual,
        roles: roles ?? this.roles,
        taxpayeridentifiers: taxpayeridentifiers ?? this.taxpayeridentifiers);
  }

  Party copyWithWrapped(
      {Wrapped<PartyIndividual>? individual,
      Wrapped<Roles>? roles,
      Wrapped<TaxpayerIdentifiers>? taxpayeridentifiers}) {
    return Party(
        individual: (individual != null ? individual.value : this.individual),
        roles: (roles != null ? roles.value : this.roles),
        taxpayeridentifiers: (taxpayeridentifiers != null
            ? taxpayeridentifiers.value
            : this.taxpayeridentifiers));
  }
}

@JsonSerializable(explicitToJson: true)
class PartyIndividual {
  PartyIndividual({
    required this.name,
  });

  factory PartyIndividual.fromJson(Map<String, dynamic> json) =>
      _$PartyIndividualFromJson(json);

  @JsonKey(name: 'NAME')
  final IndividualName name;
  static const fromJsonFactory = _$PartyIndividualFromJson;
  static const toJsonFactory = _$PartyIndividualToJson;
  Map<String, dynamic> toJson() => _$PartyIndividualToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PartyIndividual &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^ runtimeType.hashCode;
}

extension $PartyIndividualExtension on PartyIndividual {
  PartyIndividual copyWith({IndividualName? name}) {
    return PartyIndividual(name: name ?? this.name);
  }

  PartyIndividual copyWithWrapped({Wrapped<IndividualName>? name}) {
    return PartyIndividual(name: (name != null ? name.value : this.name));
  }
}

@JsonSerializable(explicitToJson: true)
class IndividualName {
  IndividualName({
    required this.firstName,
    required this.lastName,
  });

  factory IndividualName.fromJson(Map<String, dynamic> json) =>
      _$IndividualNameFromJson(json);

  @JsonKey(name: 'FirstName')
  final String firstName;
  @JsonKey(name: 'LastName')
  final String lastName;
  static const fromJsonFactory = _$IndividualNameFromJson;
  static const toJsonFactory = _$IndividualNameToJson;
  Map<String, dynamic> toJson() => _$IndividualNameToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IndividualName &&
            (identical(other.firstName, firstName) ||
                const DeepCollectionEquality()
                    .equals(other.firstName, firstName)) &&
            (identical(other.lastName, lastName) ||
                const DeepCollectionEquality()
                    .equals(other.lastName, lastName)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(firstName) ^
      const DeepCollectionEquality().hash(lastName) ^
      runtimeType.hashCode;
}

extension $IndividualNameExtension on IndividualName {
  IndividualName copyWith({String? firstName, String? lastName}) {
    return IndividualName(
        firstName: firstName ?? this.firstName,
        lastName: lastName ?? this.lastName);
  }

  IndividualName copyWithWrapped(
      {Wrapped<String>? firstName, Wrapped<String>? lastName}) {
    return IndividualName(
        firstName: (firstName != null ? firstName.value : this.firstName),
        lastName: (lastName != null ? lastName.value : this.lastName));
  }
}

@JsonSerializable(explicitToJson: true)
class Roles {
  Roles({
    required this.role,
  });

  factory Roles.fromJson(Map<String, dynamic> json) => _$RolesFromJson(json);

  @JsonKey(name: 'ROLE')
  final Role role;
  static const fromJsonFactory = _$RolesFromJson;
  static const toJsonFactory = _$RolesToJson;
  Map<String, dynamic> toJson() => _$RolesToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Roles &&
            (identical(other.role, role) ||
                const DeepCollectionEquality().equals(other.role, role)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(role) ^ runtimeType.hashCode;
}

extension $RolesExtension on Roles {
  Roles copyWith({Role? role}) {
    return Roles(role: role ?? this.role);
  }

  Roles copyWithWrapped({Wrapped<Role>? role}) {
    return Roles(role: (role != null ? role.value : this.role));
  }
}

@JsonSerializable(explicitToJson: true)
class Role {
  Role({
    required this.roledetail,
  });

  factory Role.fromJson(Map<String, dynamic> json) => _$RoleFromJson(json);

  @JsonKey(name: 'ROLE_DETAIL')
  final RoleDetail roledetail;
  static const fromJsonFactory = _$RoleFromJson;
  static const toJsonFactory = _$RoleToJson;
  Map<String, dynamic> toJson() => _$RoleToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Role &&
            (identical(other.roledetail, roledetail) ||
                const DeepCollectionEquality()
                    .equals(other.roledetail, roledetail)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(roledetail) ^ runtimeType.hashCode;
}

extension $RoleExtension on Role {
  Role copyWith({RoleDetail? roledetail}) {
    return Role(roledetail: roledetail ?? this.roledetail);
  }

  Role copyWithWrapped({Wrapped<RoleDetail>? roledetail}) {
    return Role(
        roledetail: (roledetail != null ? roledetail.value : this.roledetail));
  }
}

@JsonSerializable(explicitToJson: true)
class RoleDetail {
  RoleDetail({
    required this.partyRoleType,
  });

  factory RoleDetail.fromJson(Map<String, dynamic> json) =>
      _$RoleDetailFromJson(json);

  @JsonKey(
    name: 'PartyRoleType',
    toJson: partyRoleTypeToJson,
    fromJson: partyRoleTypeFromJson,
  )
  final enums.PartyRoleType partyRoleType;
  static const fromJsonFactory = _$RoleDetailFromJson;
  static const toJsonFactory = _$RoleDetailToJson;
  Map<String, dynamic> toJson() => _$RoleDetailToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is RoleDetail &&
            (identical(other.partyRoleType, partyRoleType) ||
                const DeepCollectionEquality()
                    .equals(other.partyRoleType, partyRoleType)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(partyRoleType) ^ runtimeType.hashCode;
}

extension $RoleDetailExtension on RoleDetail {
  RoleDetail copyWith({enums.PartyRoleType? partyRoleType}) {
    return RoleDetail(partyRoleType: partyRoleType ?? this.partyRoleType);
  }

  RoleDetail copyWithWrapped({Wrapped<enums.PartyRoleType>? partyRoleType}) {
    return RoleDetail(
        partyRoleType:
            (partyRoleType != null ? partyRoleType.value : this.partyRoleType));
  }
}

@JsonSerializable(explicitToJson: true)
class TaxpayerIdentifiers {
  TaxpayerIdentifiers({
    required this.taxpayeridentifier,
  });

  factory TaxpayerIdentifiers.fromJson(Map<String, dynamic> json) =>
      _$TaxpayerIdentifiersFromJson(json);

  @JsonKey(name: 'TAXPAYER_IDENTIFIER')
  final TaxpayerIdentifier taxpayeridentifier;
  static const fromJsonFactory = _$TaxpayerIdentifiersFromJson;
  static const toJsonFactory = _$TaxpayerIdentifiersToJson;
  Map<String, dynamic> toJson() => _$TaxpayerIdentifiersToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TaxpayerIdentifiers &&
            (identical(other.taxpayeridentifier, taxpayeridentifier) ||
                const DeepCollectionEquality()
                    .equals(other.taxpayeridentifier, taxpayeridentifier)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(taxpayeridentifier) ^
      runtimeType.hashCode;
}

extension $TaxpayerIdentifiersExtension on TaxpayerIdentifiers {
  TaxpayerIdentifiers copyWith({TaxpayerIdentifier? taxpayeridentifier}) {
    return TaxpayerIdentifiers(
        taxpayeridentifier: taxpayeridentifier ?? this.taxpayeridentifier);
  }

  TaxpayerIdentifiers copyWithWrapped(
      {Wrapped<TaxpayerIdentifier>? taxpayeridentifier}) {
    return TaxpayerIdentifiers(
        taxpayeridentifier: (taxpayeridentifier != null
            ? taxpayeridentifier.value
            : this.taxpayeridentifier));
  }
}

@JsonSerializable(explicitToJson: true)
class TaxpayerIdentifier {
  TaxpayerIdentifier({
    required this.taxpayerIdentifierType,
    required this.taxpayerIdentifierValue,
  });

  factory TaxpayerIdentifier.fromJson(Map<String, dynamic> json) =>
      _$TaxpayerIdentifierFromJson(json);

  @JsonKey(
    name: 'TaxpayerIdentifierType',
    toJson: taxpayerIdentifierTypeToJson,
    fromJson: taxpayerIdentifierTypeFromJson,
  )
  final enums.TaxpayerIdentifierType? taxpayerIdentifierType;
  @JsonKey(name: 'TaxpayerIdentifierValue')
  final String? taxpayerIdentifierValue;
  static const fromJsonFactory = _$TaxpayerIdentifierFromJson;
  static const toJsonFactory = _$TaxpayerIdentifierToJson;
  Map<String, dynamic> toJson() => _$TaxpayerIdentifierToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TaxpayerIdentifier &&
            (identical(other.taxpayerIdentifierType, taxpayerIdentifierType) ||
                const DeepCollectionEquality().equals(
                    other.taxpayerIdentifierType, taxpayerIdentifierType)) &&
            (identical(
                    other.taxpayerIdentifierValue, taxpayerIdentifierValue) ||
                const DeepCollectionEquality().equals(
                    other.taxpayerIdentifierValue, taxpayerIdentifierValue)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(taxpayerIdentifierType) ^
      const DeepCollectionEquality().hash(taxpayerIdentifierValue) ^
      runtimeType.hashCode;
}

extension $TaxpayerIdentifierExtension on TaxpayerIdentifier {
  TaxpayerIdentifier copyWith(
      {enums.TaxpayerIdentifierType? taxpayerIdentifierType,
      String? taxpayerIdentifierValue}) {
    return TaxpayerIdentifier(
        taxpayerIdentifierType:
            taxpayerIdentifierType ?? this.taxpayerIdentifierType,
        taxpayerIdentifierValue:
            taxpayerIdentifierValue ?? this.taxpayerIdentifierValue);
  }

  TaxpayerIdentifier copyWithWrapped(
      {Wrapped<enums.TaxpayerIdentifierType?>? taxpayerIdentifierType,
      Wrapped<String?>? taxpayerIdentifierValue}) {
    return TaxpayerIdentifier(
        taxpayerIdentifierType: (taxpayerIdentifierType != null
            ? taxpayerIdentifierType.value
            : this.taxpayerIdentifierType),
        taxpayerIdentifierValue: (taxpayerIdentifierValue != null
            ? taxpayerIdentifierValue.value
            : this.taxpayerIdentifierValue));
  }
}

@JsonSerializable(explicitToJson: true)
class Services {
  Services({
    required this.service,
  });

  factory Services.fromJson(Map<String, dynamic> json) =>
      _$ServicesFromJson(json);

  @JsonKey(name: 'SERVICE')
  final Service service;
  static const fromJsonFactory = _$ServicesFromJson;
  static const toJsonFactory = _$ServicesToJson;
  Map<String, dynamic> toJson() => _$ServicesToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Services &&
            (identical(other.service, service) ||
                const DeepCollectionEquality().equals(other.service, service)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(service) ^ runtimeType.hashCode;
}

extension $ServicesExtension on Services {
  Services copyWith({Service? service}) {
    return Services(service: service ?? this.service);
  }

  Services copyWithWrapped({Wrapped<Service>? service}) {
    return Services(service: (service != null ? service.value : this.service));
  }
}

@JsonSerializable(explicitToJson: true)
class Service {
  Service({
    required this.verificationofasset,
    required this.statuses,
  });

  factory Service.fromJson(Map<String, dynamic> json) =>
      _$ServiceFromJson(json);

  @JsonKey(name: 'VERIFICATION_OF_ASSET')
  final VerificationOfAsset verificationofasset;
  @JsonKey(name: 'STATUSES')
  final Statuses statuses;
  static const fromJsonFactory = _$ServiceFromJson;
  static const toJsonFactory = _$ServiceToJson;
  Map<String, dynamic> toJson() => _$ServiceToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Service &&
            (identical(other.verificationofasset, verificationofasset) ||
                const DeepCollectionEquality()
                    .equals(other.verificationofasset, verificationofasset)) &&
            (identical(other.statuses, statuses) ||
                const DeepCollectionEquality()
                    .equals(other.statuses, statuses)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(verificationofasset) ^
      const DeepCollectionEquality().hash(statuses) ^
      runtimeType.hashCode;
}

extension $ServiceExtension on Service {
  Service copyWith(
      {VerificationOfAsset? verificationofasset, Statuses? statuses}) {
    return Service(
        verificationofasset: verificationofasset ?? this.verificationofasset,
        statuses: statuses ?? this.statuses);
  }

  Service copyWithWrapped(
      {Wrapped<VerificationOfAsset>? verificationofasset,
      Wrapped<Statuses>? statuses}) {
    return Service(
        verificationofasset: (verificationofasset != null
            ? verificationofasset.value
            : this.verificationofasset),
        statuses: (statuses != null ? statuses.value : this.statuses));
  }
}

@JsonSerializable(explicitToJson: true)
class VerificationOfAsset {
  VerificationOfAsset({
    required this.reportinginformation,
    required this.serviceproductfulfillment,
    required this.verificationofassetresponse,
  });

  factory VerificationOfAsset.fromJson(Map<String, dynamic> json) =>
      _$VerificationOfAssetFromJson(json);

  @JsonKey(name: 'REPORTING_INFORMATION')
  final ReportingInformation reportinginformation;
  @JsonKey(name: 'SERVICE_PRODUCT_FULFILLMENT')
  final ServiceProductFulfillment serviceproductfulfillment;
  @JsonKey(name: 'VERIFICATION_OF_ASSET_RESPONSE')
  final VerificationOfAssetResponse verificationofassetresponse;
  static const fromJsonFactory = _$VerificationOfAssetFromJson;
  static const toJsonFactory = _$VerificationOfAssetToJson;
  Map<String, dynamic> toJson() => _$VerificationOfAssetToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is VerificationOfAsset &&
            (identical(other.reportinginformation, reportinginformation) ||
                const DeepCollectionEquality().equals(
                    other.reportinginformation, reportinginformation)) &&
            (identical(other.serviceproductfulfillment,
                    serviceproductfulfillment) ||
                const DeepCollectionEquality().equals(
                    other.serviceproductfulfillment,
                    serviceproductfulfillment)) &&
            (identical(other.verificationofassetresponse,
                    verificationofassetresponse) ||
                const DeepCollectionEquality().equals(
                    other.verificationofassetresponse,
                    verificationofassetresponse)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(reportinginformation) ^
      const DeepCollectionEquality().hash(serviceproductfulfillment) ^
      const DeepCollectionEquality().hash(verificationofassetresponse) ^
      runtimeType.hashCode;
}

extension $VerificationOfAssetExtension on VerificationOfAsset {
  VerificationOfAsset copyWith(
      {ReportingInformation? reportinginformation,
      ServiceProductFulfillment? serviceproductfulfillment,
      VerificationOfAssetResponse? verificationofassetresponse}) {
    return VerificationOfAsset(
        reportinginformation: reportinginformation ?? this.reportinginformation,
        serviceproductfulfillment:
            serviceproductfulfillment ?? this.serviceproductfulfillment,
        verificationofassetresponse:
            verificationofassetresponse ?? this.verificationofassetresponse);
  }

  VerificationOfAsset copyWithWrapped(
      {Wrapped<ReportingInformation>? reportinginformation,
      Wrapped<ServiceProductFulfillment>? serviceproductfulfillment,
      Wrapped<VerificationOfAssetResponse>? verificationofassetresponse}) {
    return VerificationOfAsset(
        reportinginformation: (reportinginformation != null
            ? reportinginformation.value
            : this.reportinginformation),
        serviceproductfulfillment: (serviceproductfulfillment != null
            ? serviceproductfulfillment.value
            : this.serviceproductfulfillment),
        verificationofassetresponse: (verificationofassetresponse != null
            ? verificationofassetresponse.value
            : this.verificationofassetresponse));
  }
}

@JsonSerializable(explicitToJson: true)
class ReportingInformation {
  ReportingInformation({
    required this.reportingInformationIdentifier,
  });

  factory ReportingInformation.fromJson(Map<String, dynamic> json) =>
      _$ReportingInformationFromJson(json);

  @JsonKey(name: 'ReportingInformationIdentifier')
  final String reportingInformationIdentifier;
  static const fromJsonFactory = _$ReportingInformationFromJson;
  static const toJsonFactory = _$ReportingInformationToJson;
  Map<String, dynamic> toJson() => _$ReportingInformationToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ReportingInformation &&
            (identical(other.reportingInformationIdentifier,
                    reportingInformationIdentifier) ||
                const DeepCollectionEquality().equals(
                    other.reportingInformationIdentifier,
                    reportingInformationIdentifier)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(reportingInformationIdentifier) ^
      runtimeType.hashCode;
}

extension $ReportingInformationExtension on ReportingInformation {
  ReportingInformation copyWith({String? reportingInformationIdentifier}) {
    return ReportingInformation(
        reportingInformationIdentifier: reportingInformationIdentifier ??
            this.reportingInformationIdentifier);
  }

  ReportingInformation copyWithWrapped(
      {Wrapped<String>? reportingInformationIdentifier}) {
    return ReportingInformation(
        reportingInformationIdentifier: (reportingInformationIdentifier != null
            ? reportingInformationIdentifier.value
            : this.reportingInformationIdentifier));
  }
}

@JsonSerializable(explicitToJson: true)
class ServiceProductFulfillment {
  ServiceProductFulfillment({
    required this.serviceproductfulfillmentdetail,
  });

  factory ServiceProductFulfillment.fromJson(Map<String, dynamic> json) =>
      _$ServiceProductFulfillmentFromJson(json);

  @JsonKey(name: 'SERVICE_PRODUCT_FULFILLMENT_DETAIL')
  final ServiceProductFulfillmentDetail serviceproductfulfillmentdetail;
  static const fromJsonFactory = _$ServiceProductFulfillmentFromJson;
  static const toJsonFactory = _$ServiceProductFulfillmentToJson;
  Map<String, dynamic> toJson() => _$ServiceProductFulfillmentToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ServiceProductFulfillment &&
            (identical(other.serviceproductfulfillmentdetail,
                    serviceproductfulfillmentdetail) ||
                const DeepCollectionEquality().equals(
                    other.serviceproductfulfillmentdetail,
                    serviceproductfulfillmentdetail)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(serviceproductfulfillmentdetail) ^
      runtimeType.hashCode;
}

extension $ServiceProductFulfillmentExtension on ServiceProductFulfillment {
  ServiceProductFulfillment copyWith(
      {ServiceProductFulfillmentDetail? serviceproductfulfillmentdetail}) {
    return ServiceProductFulfillment(
        serviceproductfulfillmentdetail: serviceproductfulfillmentdetail ??
            this.serviceproductfulfillmentdetail);
  }

  ServiceProductFulfillment copyWithWrapped(
      {Wrapped<ServiceProductFulfillmentDetail>?
          serviceproductfulfillmentdetail}) {
    return ServiceProductFulfillment(
        serviceproductfulfillmentdetail:
            (serviceproductfulfillmentdetail != null
                ? serviceproductfulfillmentdetail.value
                : this.serviceproductfulfillmentdetail));
  }
}

@JsonSerializable(explicitToJson: true)
class ServiceProductFulfillmentDetail {
  ServiceProductFulfillmentDetail({
    required this.vendorOrderIdentifier,
    required this.serviceProductFulfillmentIdentifier,
  });

  factory ServiceProductFulfillmentDetail.fromJson(Map<String, dynamic> json) =>
      _$ServiceProductFulfillmentDetailFromJson(json);

  @JsonKey(name: 'VendorOrderIdentifier')
  final String? vendorOrderIdentifier;
  @JsonKey(
    name: 'ServiceProductFulfillmentIdentifier',
    toJson: serviceProductFulfillmentIdentifierToJson,
    fromJson: serviceProductFulfillmentIdentifierFromJson,
  )
  final enums.ServiceProductFulfillmentIdentifier
      serviceProductFulfillmentIdentifier;
  static const fromJsonFactory = _$ServiceProductFulfillmentDetailFromJson;
  static const toJsonFactory = _$ServiceProductFulfillmentDetailToJson;
  Map<String, dynamic> toJson() =>
      _$ServiceProductFulfillmentDetailToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ServiceProductFulfillmentDetail &&
            (identical(other.vendorOrderIdentifier, vendorOrderIdentifier) ||
                const DeepCollectionEquality().equals(
                    other.vendorOrderIdentifier, vendorOrderIdentifier)) &&
            (identical(other.serviceProductFulfillmentIdentifier,
                    serviceProductFulfillmentIdentifier) ||
                const DeepCollectionEquality().equals(
                    other.serviceProductFulfillmentIdentifier,
                    serviceProductFulfillmentIdentifier)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(vendorOrderIdentifier) ^
      const DeepCollectionEquality().hash(serviceProductFulfillmentIdentifier) ^
      runtimeType.hashCode;
}

extension $ServiceProductFulfillmentDetailExtension
    on ServiceProductFulfillmentDetail {
  ServiceProductFulfillmentDetail copyWith(
      {String? vendorOrderIdentifier,
      enums.ServiceProductFulfillmentIdentifier?
          serviceProductFulfillmentIdentifier}) {
    return ServiceProductFulfillmentDetail(
        vendorOrderIdentifier:
            vendorOrderIdentifier ?? this.vendorOrderIdentifier,
        serviceProductFulfillmentIdentifier:
            serviceProductFulfillmentIdentifier ??
                this.serviceProductFulfillmentIdentifier);
  }

  ServiceProductFulfillmentDetail copyWithWrapped(
      {Wrapped<String?>? vendorOrderIdentifier,
      Wrapped<enums.ServiceProductFulfillmentIdentifier>?
          serviceProductFulfillmentIdentifier}) {
    return ServiceProductFulfillmentDetail(
        vendorOrderIdentifier: (vendorOrderIdentifier != null
            ? vendorOrderIdentifier.value
            : this.vendorOrderIdentifier),
        serviceProductFulfillmentIdentifier:
            (serviceProductFulfillmentIdentifier != null
                ? serviceProductFulfillmentIdentifier.value
                : this.serviceProductFulfillmentIdentifier));
  }
}

@JsonSerializable(explicitToJson: true)
class VerificationOfAssetResponse {
  VerificationOfAssetResponse({
    required this.assets,
  });

  factory VerificationOfAssetResponse.fromJson(Map<String, dynamic> json) =>
      _$VerificationOfAssetResponseFromJson(json);

  @JsonKey(name: 'ASSETS')
  final Assets assets;
  static const fromJsonFactory = _$VerificationOfAssetResponseFromJson;
  static const toJsonFactory = _$VerificationOfAssetResponseToJson;
  Map<String, dynamic> toJson() => _$VerificationOfAssetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is VerificationOfAssetResponse &&
            (identical(other.assets, assets) ||
                const DeepCollectionEquality().equals(other.assets, assets)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(assets) ^ runtimeType.hashCode;
}

extension $VerificationOfAssetResponseExtension on VerificationOfAssetResponse {
  VerificationOfAssetResponse copyWith({Assets? assets}) {
    return VerificationOfAssetResponse(assets: assets ?? this.assets);
  }

  VerificationOfAssetResponse copyWithWrapped({Wrapped<Assets>? assets}) {
    return VerificationOfAssetResponse(
        assets: (assets != null ? assets.value : this.assets));
  }
}

@JsonSerializable(explicitToJson: true)
class Assets {
  Assets({
    required this.asset,
  });

  factory Assets.fromJson(Map<String, dynamic> json) => _$AssetsFromJson(json);

  @JsonKey(name: 'ASSET', defaultValue: <Asset>[])
  final List<Asset> asset;
  static const fromJsonFactory = _$AssetsFromJson;
  static const toJsonFactory = _$AssetsToJson;
  Map<String, dynamic> toJson() => _$AssetsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Assets &&
            (identical(other.asset, asset) ||
                const DeepCollectionEquality().equals(other.asset, asset)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(asset) ^ runtimeType.hashCode;
}

extension $AssetsExtension on Assets {
  Assets copyWith({List<Asset>? asset}) {
    return Assets(asset: asset ?? this.asset);
  }

  Assets copyWithWrapped({Wrapped<List<Asset>>? asset}) {
    return Assets(asset: (asset != null ? asset.value : this.asset));
  }
}

@JsonSerializable(explicitToJson: true)
class Asset {
  Asset({
    required this.assetdetail,
    required this.assetowners,
    required this.assetholder,
    required this.assettransactions,
    required this.validationsources,
  });

  factory Asset.fromJson(Map<String, dynamic> json) => _$AssetFromJson(json);

  @JsonKey(name: 'ASSET_DETAIL')
  final AssetDetail assetdetail;
  @JsonKey(name: 'ASSET_OWNERS')
  final AssetOwners assetowners;
  @JsonKey(name: 'ASSET_HOLDER')
  final AssetHolder assetholder;
  @JsonKey(name: 'ASSET_TRANSACTIONS')
  final AssetTransactions assettransactions;
  @JsonKey(name: 'VALIDATION_SOURCES')
  final ValidationSources validationsources;
  static const fromJsonFactory = _$AssetFromJson;
  static const toJsonFactory = _$AssetToJson;
  Map<String, dynamic> toJson() => _$AssetToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Asset &&
            (identical(other.assetdetail, assetdetail) ||
                const DeepCollectionEquality()
                    .equals(other.assetdetail, assetdetail)) &&
            (identical(other.assetowners, assetowners) ||
                const DeepCollectionEquality()
                    .equals(other.assetowners, assetowners)) &&
            (identical(other.assetholder, assetholder) ||
                const DeepCollectionEquality()
                    .equals(other.assetholder, assetholder)) &&
            (identical(other.assettransactions, assettransactions) ||
                const DeepCollectionEquality()
                    .equals(other.assettransactions, assettransactions)) &&
            (identical(other.validationsources, validationsources) ||
                const DeepCollectionEquality()
                    .equals(other.validationsources, validationsources)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(assetdetail) ^
      const DeepCollectionEquality().hash(assetowners) ^
      const DeepCollectionEquality().hash(assetholder) ^
      const DeepCollectionEquality().hash(assettransactions) ^
      const DeepCollectionEquality().hash(validationsources) ^
      runtimeType.hashCode;
}

extension $AssetExtension on Asset {
  Asset copyWith(
      {AssetDetail? assetdetail,
      AssetOwners? assetowners,
      AssetHolder? assetholder,
      AssetTransactions? assettransactions,
      ValidationSources? validationsources}) {
    return Asset(
        assetdetail: assetdetail ?? this.assetdetail,
        assetowners: assetowners ?? this.assetowners,
        assetholder: assetholder ?? this.assetholder,
        assettransactions: assettransactions ?? this.assettransactions,
        validationsources: validationsources ?? this.validationsources);
  }

  Asset copyWithWrapped(
      {Wrapped<AssetDetail>? assetdetail,
      Wrapped<AssetOwners>? assetowners,
      Wrapped<AssetHolder>? assetholder,
      Wrapped<AssetTransactions>? assettransactions,
      Wrapped<ValidationSources>? validationsources}) {
    return Asset(
        assetdetail:
            (assetdetail != null ? assetdetail.value : this.assetdetail),
        assetowners:
            (assetowners != null ? assetowners.value : this.assetowners),
        assetholder:
            (assetholder != null ? assetholder.value : this.assetholder),
        assettransactions: (assettransactions != null
            ? assettransactions.value
            : this.assettransactions),
        validationsources: (validationsources != null
            ? validationsources.value
            : this.validationsources));
  }
}

@JsonSerializable(explicitToJson: true)
class AssetDetail {
  AssetDetail({
    required this.assetUniqueIdentifier,
    required this.assetAccountIdentifier,
    required this.assetAsOfDate,
    required this.assetDescription,
    required this.assetAvailableBalanceAmount,
    required this.assetCurrentBalanceAmount,
    required this.assetType,
    required this.assetTypeAdditionalDescription,
    required this.assetDaysRequestedCount,
    required this.assetOwnershipType,
  });

  factory AssetDetail.fromJson(Map<String, dynamic> json) =>
      _$AssetDetailFromJson(json);

  @JsonKey(name: 'AssetUniqueIdentifier')
  final String assetUniqueIdentifier;
  @JsonKey(name: 'AssetAccountIdentifier')
  final String assetAccountIdentifier;
  @JsonKey(name: 'AssetAsOfDate')
  final String assetAsOfDate;
  @JsonKey(name: 'AssetDescription')
  final String? assetDescription;
  @JsonKey(name: 'AssetAvailableBalanceAmount')
  final double assetAvailableBalanceAmount;
  @JsonKey(name: 'AssetCurrentBalanceAmount')
  final double assetCurrentBalanceAmount;
  @JsonKey(
    name: 'AssetType',
    toJson: assetTypeToJson,
    fromJson: assetTypeFromJson,
  )
  final enums.AssetType assetType;
  @JsonKey(name: 'AssetTypeAdditionalDescription')
  final String? assetTypeAdditionalDescription;
  @JsonKey(name: 'AssetDaysRequestedCount')
  final int assetDaysRequestedCount;
  @JsonKey(name: 'AssetOwnershipType')
  final String? assetOwnershipType;
  static const fromJsonFactory = _$AssetDetailFromJson;
  static const toJsonFactory = _$AssetDetailToJson;
  Map<String, dynamic> toJson() => _$AssetDetailToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AssetDetail &&
            (identical(other.assetUniqueIdentifier, assetUniqueIdentifier) ||
                const DeepCollectionEquality().equals(
                    other.assetUniqueIdentifier, assetUniqueIdentifier)) &&
            (identical(other.assetAccountIdentifier, assetAccountIdentifier) ||
                const DeepCollectionEquality().equals(
                    other.assetAccountIdentifier, assetAccountIdentifier)) &&
            (identical(other.assetAsOfDate, assetAsOfDate) ||
                const DeepCollectionEquality()
                    .equals(other.assetAsOfDate, assetAsOfDate)) &&
            (identical(other.assetDescription, assetDescription) ||
                const DeepCollectionEquality()
                    .equals(other.assetDescription, assetDescription)) &&
            (identical(other.assetAvailableBalanceAmount,
                    assetAvailableBalanceAmount) ||
                const DeepCollectionEquality().equals(
                    other.assetAvailableBalanceAmount,
                    assetAvailableBalanceAmount)) &&
            (identical(other.assetCurrentBalanceAmount, assetCurrentBalanceAmount) ||
                const DeepCollectionEquality().equals(
                    other.assetCurrentBalanceAmount,
                    assetCurrentBalanceAmount)) &&
            (identical(other.assetType, assetType) ||
                const DeepCollectionEquality()
                    .equals(other.assetType, assetType)) &&
            (identical(other.assetTypeAdditionalDescription,
                    assetTypeAdditionalDescription) ||
                const DeepCollectionEquality().equals(
                    other.assetTypeAdditionalDescription,
                    assetTypeAdditionalDescription)) &&
            (identical(other.assetDaysRequestedCount, assetDaysRequestedCount) ||
                const DeepCollectionEquality().equals(
                    other.assetDaysRequestedCount, assetDaysRequestedCount)) &&
            (identical(other.assetOwnershipType, assetOwnershipType) ||
                const DeepCollectionEquality()
                    .equals(other.assetOwnershipType, assetOwnershipType)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(assetUniqueIdentifier) ^
      const DeepCollectionEquality().hash(assetAccountIdentifier) ^
      const DeepCollectionEquality().hash(assetAsOfDate) ^
      const DeepCollectionEquality().hash(assetDescription) ^
      const DeepCollectionEquality().hash(assetAvailableBalanceAmount) ^
      const DeepCollectionEquality().hash(assetCurrentBalanceAmount) ^
      const DeepCollectionEquality().hash(assetType) ^
      const DeepCollectionEquality().hash(assetTypeAdditionalDescription) ^
      const DeepCollectionEquality().hash(assetDaysRequestedCount) ^
      const DeepCollectionEquality().hash(assetOwnershipType) ^
      runtimeType.hashCode;
}

extension $AssetDetailExtension on AssetDetail {
  AssetDetail copyWith(
      {String? assetUniqueIdentifier,
      String? assetAccountIdentifier,
      String? assetAsOfDate,
      String? assetDescription,
      double? assetAvailableBalanceAmount,
      double? assetCurrentBalanceAmount,
      enums.AssetType? assetType,
      String? assetTypeAdditionalDescription,
      int? assetDaysRequestedCount,
      String? assetOwnershipType}) {
    return AssetDetail(
        assetUniqueIdentifier:
            assetUniqueIdentifier ?? this.assetUniqueIdentifier,
        assetAccountIdentifier:
            assetAccountIdentifier ?? this.assetAccountIdentifier,
        assetAsOfDate: assetAsOfDate ?? this.assetAsOfDate,
        assetDescription: assetDescription ?? this.assetDescription,
        assetAvailableBalanceAmount:
            assetAvailableBalanceAmount ?? this.assetAvailableBalanceAmount,
        assetCurrentBalanceAmount:
            assetCurrentBalanceAmount ?? this.assetCurrentBalanceAmount,
        assetType: assetType ?? this.assetType,
        assetTypeAdditionalDescription: assetTypeAdditionalDescription ??
            this.assetTypeAdditionalDescription,
        assetDaysRequestedCount:
            assetDaysRequestedCount ?? this.assetDaysRequestedCount,
        assetOwnershipType: assetOwnershipType ?? this.assetOwnershipType);
  }

  AssetDetail copyWithWrapped(
      {Wrapped<String>? assetUniqueIdentifier,
      Wrapped<String>? assetAccountIdentifier,
      Wrapped<String>? assetAsOfDate,
      Wrapped<String?>? assetDescription,
      Wrapped<double>? assetAvailableBalanceAmount,
      Wrapped<double>? assetCurrentBalanceAmount,
      Wrapped<enums.AssetType>? assetType,
      Wrapped<String?>? assetTypeAdditionalDescription,
      Wrapped<int>? assetDaysRequestedCount,
      Wrapped<String?>? assetOwnershipType}) {
    return AssetDetail(
        assetUniqueIdentifier: (assetUniqueIdentifier != null
            ? assetUniqueIdentifier.value
            : this.assetUniqueIdentifier),
        assetAccountIdentifier: (assetAccountIdentifier != null
            ? assetAccountIdentifier.value
            : this.assetAccountIdentifier),
        assetAsOfDate:
            (assetAsOfDate != null ? assetAsOfDate.value : this.assetAsOfDate),
        assetDescription: (assetDescription != null
            ? assetDescription.value
            : this.assetDescription),
        assetAvailableBalanceAmount: (assetAvailableBalanceAmount != null
            ? assetAvailableBalanceAmount.value
            : this.assetAvailableBalanceAmount),
        assetCurrentBalanceAmount: (assetCurrentBalanceAmount != null
            ? assetCurrentBalanceAmount.value
            : this.assetCurrentBalanceAmount),
        assetType: (assetType != null ? assetType.value : this.assetType),
        assetTypeAdditionalDescription: (assetTypeAdditionalDescription != null
            ? assetTypeAdditionalDescription.value
            : this.assetTypeAdditionalDescription),
        assetDaysRequestedCount: (assetDaysRequestedCount != null
            ? assetDaysRequestedCount.value
            : this.assetDaysRequestedCount),
        assetOwnershipType: (assetOwnershipType != null
            ? assetOwnershipType.value
            : this.assetOwnershipType));
  }
}

@JsonSerializable(explicitToJson: true)
class AssetOwners {
  AssetOwners({
    required this.assetowner,
  });

  factory AssetOwners.fromJson(Map<String, dynamic> json) =>
      _$AssetOwnersFromJson(json);

  @JsonKey(name: 'ASSET_OWNER', defaultValue: <AssetOwner>[])
  final List<AssetOwner> assetowner;
  static const fromJsonFactory = _$AssetOwnersFromJson;
  static const toJsonFactory = _$AssetOwnersToJson;
  Map<String, dynamic> toJson() => _$AssetOwnersToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AssetOwners &&
            (identical(other.assetowner, assetowner) ||
                const DeepCollectionEquality()
                    .equals(other.assetowner, assetowner)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(assetowner) ^ runtimeType.hashCode;
}

extension $AssetOwnersExtension on AssetOwners {
  AssetOwners copyWith({List<AssetOwner>? assetowner}) {
    return AssetOwners(assetowner: assetowner ?? this.assetowner);
  }

  AssetOwners copyWithWrapped({Wrapped<List<AssetOwner>>? assetowner}) {
    return AssetOwners(
        assetowner: (assetowner != null ? assetowner.value : this.assetowner));
  }
}

@JsonSerializable(explicitToJson: true)
class AssetOwner {
  AssetOwner({
    required this.assetOwnerText,
  });

  factory AssetOwner.fromJson(Map<String, dynamic> json) =>
      _$AssetOwnerFromJson(json);

  @JsonKey(name: 'AssetOwnerText')
  final String? assetOwnerText;
  static const fromJsonFactory = _$AssetOwnerFromJson;
  static const toJsonFactory = _$AssetOwnerToJson;
  Map<String, dynamic> toJson() => _$AssetOwnerToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AssetOwner &&
            (identical(other.assetOwnerText, assetOwnerText) ||
                const DeepCollectionEquality()
                    .equals(other.assetOwnerText, assetOwnerText)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(assetOwnerText) ^
      runtimeType.hashCode;
}

extension $AssetOwnerExtension on AssetOwner {
  AssetOwner copyWith({String? assetOwnerText}) {
    return AssetOwner(assetOwnerText: assetOwnerText ?? this.assetOwnerText);
  }

  AssetOwner copyWithWrapped({Wrapped<String?>? assetOwnerText}) {
    return AssetOwner(
        assetOwnerText: (assetOwnerText != null
            ? assetOwnerText.value
            : this.assetOwnerText));
  }
}

@JsonSerializable(explicitToJson: true)
class AssetHolder {
  AssetHolder({
    required this.name,
  });

  factory AssetHolder.fromJson(Map<String, dynamic> json) =>
      _$AssetHolderFromJson(json);

  @JsonKey(name: 'NAME')
  final AssetHolderName name;
  static const fromJsonFactory = _$AssetHolderFromJson;
  static const toJsonFactory = _$AssetHolderToJson;
  Map<String, dynamic> toJson() => _$AssetHolderToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AssetHolder &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^ runtimeType.hashCode;
}

extension $AssetHolderExtension on AssetHolder {
  AssetHolder copyWith({AssetHolderName? name}) {
    return AssetHolder(name: name ?? this.name);
  }

  AssetHolder copyWithWrapped({Wrapped<AssetHolderName>? name}) {
    return AssetHolder(name: (name != null ? name.value : this.name));
  }
}

@JsonSerializable(explicitToJson: true)
class AssetHolderName {
  AssetHolderName({
    required this.fullName,
  });

  factory AssetHolderName.fromJson(Map<String, dynamic> json) =>
      _$AssetHolderNameFromJson(json);

  @JsonKey(name: 'FullName')
  final String fullName;
  static const fromJsonFactory = _$AssetHolderNameFromJson;
  static const toJsonFactory = _$AssetHolderNameToJson;
  Map<String, dynamic> toJson() => _$AssetHolderNameToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AssetHolderName &&
            (identical(other.fullName, fullName) ||
                const DeepCollectionEquality()
                    .equals(other.fullName, fullName)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(fullName) ^ runtimeType.hashCode;
}

extension $AssetHolderNameExtension on AssetHolderName {
  AssetHolderName copyWith({String? fullName}) {
    return AssetHolderName(fullName: fullName ?? this.fullName);
  }

  AssetHolderName copyWithWrapped({Wrapped<String>? fullName}) {
    return AssetHolderName(
        fullName: (fullName != null ? fullName.value : this.fullName));
  }
}

@JsonSerializable(explicitToJson: true)
class AssetTransactions {
  AssetTransactions({
    required this.assettransaction,
  });

  factory AssetTransactions.fromJson(Map<String, dynamic> json) =>
      _$AssetTransactionsFromJson(json);

  @JsonKey(name: 'ASSET_TRANSACTION', defaultValue: <AssetTransaction>[])
  final List<AssetTransaction> assettransaction;
  static const fromJsonFactory = _$AssetTransactionsFromJson;
  static const toJsonFactory = _$AssetTransactionsToJson;
  Map<String, dynamic> toJson() => _$AssetTransactionsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AssetTransactions &&
            (identical(other.assettransaction, assettransaction) ||
                const DeepCollectionEquality()
                    .equals(other.assettransaction, assettransaction)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(assettransaction) ^
      runtimeType.hashCode;
}

extension $AssetTransactionsExtension on AssetTransactions {
  AssetTransactions copyWith({List<AssetTransaction>? assettransaction}) {
    return AssetTransactions(
        assettransaction: assettransaction ?? this.assettransaction);
  }

  AssetTransactions copyWithWrapped(
      {Wrapped<List<AssetTransaction>>? assettransaction}) {
    return AssetTransactions(
        assettransaction: (assettransaction != null
            ? assettransaction.value
            : this.assettransaction));
  }
}

@JsonSerializable(explicitToJson: true)
class AssetTransaction {
  AssetTransaction({
    required this.assettransactiondetail,
    required this.assettransactiondescripton,
  });

  factory AssetTransaction.fromJson(Map<String, dynamic> json) =>
      _$AssetTransactionFromJson(json);

  @JsonKey(name: 'ASSET_TRANSACTION_DETAIL')
  final AssetTransactionDetail assettransactiondetail;
  @JsonKey(
      name: 'ASSET_TRANSACTION_DESCRIPTON',
      defaultValue: <AssetTransactionDescription>[])
  final List<AssetTransactionDescription> assettransactiondescripton;
  static const fromJsonFactory = _$AssetTransactionFromJson;
  static const toJsonFactory = _$AssetTransactionToJson;
  Map<String, dynamic> toJson() => _$AssetTransactionToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AssetTransaction &&
            (identical(other.assettransactiondetail, assettransactiondetail) ||
                const DeepCollectionEquality().equals(
                    other.assettransactiondetail, assettransactiondetail)) &&
            (identical(other.assettransactiondescripton,
                    assettransactiondescripton) ||
                const DeepCollectionEquality().equals(
                    other.assettransactiondescripton,
                    assettransactiondescripton)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(assettransactiondetail) ^
      const DeepCollectionEquality().hash(assettransactiondescripton) ^
      runtimeType.hashCode;
}

extension $AssetTransactionExtension on AssetTransaction {
  AssetTransaction copyWith(
      {AssetTransactionDetail? assettransactiondetail,
      List<AssetTransactionDescription>? assettransactiondescripton}) {
    return AssetTransaction(
        assettransactiondetail:
            assettransactiondetail ?? this.assettransactiondetail,
        assettransactiondescripton:
            assettransactiondescripton ?? this.assettransactiondescripton);
  }

  AssetTransaction copyWithWrapped(
      {Wrapped<AssetTransactionDetail>? assettransactiondetail,
      Wrapped<List<AssetTransactionDescription>>? assettransactiondescripton}) {
    return AssetTransaction(
        assettransactiondetail: (assettransactiondetail != null
            ? assettransactiondetail.value
            : this.assettransactiondetail),
        assettransactiondescripton: (assettransactiondescripton != null
            ? assettransactiondescripton.value
            : this.assettransactiondescripton));
  }
}

@JsonSerializable(explicitToJson: true)
class AssetTransactionDetail {
  AssetTransactionDetail({
    required this.assetTransactionUniqueIdentifier,
    required this.assetTransactionAmount,
    required this.assetTransactionDate,
    required this.assetTransactionPostDate,
    required this.assetTransactionType,
    required this.assetTransactionPaidByName,
    required this.assetTransactionTypeAdditionalDescription,
    required this.assetTransactionCategoryType,
    required this.financialInstitutionTransactionIdentifier,
  });

  factory AssetTransactionDetail.fromJson(Map<String, dynamic> json) =>
      _$AssetTransactionDetailFromJson(json);

  @JsonKey(name: 'AssetTransactionUniqueIdentifier')
  final String assetTransactionUniqueIdentifier;
  @JsonKey(name: 'AssetTransactionAmount')
  final double assetTransactionAmount;
  @JsonKey(name: 'AssetTransactionDate', toJson: _dateToJson)
  final DateTime assetTransactionDate;
  @JsonKey(name: 'AssetTransactionPostDate', toJson: _dateToJson)
  final DateTime assetTransactionPostDate;
  @JsonKey(
    name: 'AssetTransactionType',
    toJson: assetTransactionTypeToJson,
    fromJson: assetTransactionTypeFromJson,
  )
  final enums.AssetTransactionType assetTransactionType;
  @JsonKey(name: 'AssetTransactionPaidByName')
  final String? assetTransactionPaidByName;
  @JsonKey(name: 'AssetTransactionTypeAdditionalDescription')
  final String? assetTransactionTypeAdditionalDescription;
  @JsonKey(
    name: 'AssetTransactionCategoryType',
    toJson: assetTransactionCategoryTypeToJson,
    fromJson: assetTransactionCategoryTypeFromJson,
  )
  final enums.AssetTransactionCategoryType? assetTransactionCategoryType;
  @JsonKey(name: 'FinancialInstitutionTransactionIdentifier')
  final String? financialInstitutionTransactionIdentifier;
  static const fromJsonFactory = _$AssetTransactionDetailFromJson;
  static const toJsonFactory = _$AssetTransactionDetailToJson;
  Map<String, dynamic> toJson() => _$AssetTransactionDetailToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AssetTransactionDetail &&
            (identical(other.assetTransactionUniqueIdentifier, assetTransactionUniqueIdentifier) ||
                const DeepCollectionEquality().equals(
                    other.assetTransactionUniqueIdentifier,
                    assetTransactionUniqueIdentifier)) &&
            (identical(other.assetTransactionAmount, assetTransactionAmount) ||
                const DeepCollectionEquality().equals(
                    other.assetTransactionAmount, assetTransactionAmount)) &&
            (identical(other.assetTransactionDate, assetTransactionDate) ||
                const DeepCollectionEquality().equals(
                    other.assetTransactionDate, assetTransactionDate)) &&
            (identical(other.assetTransactionPostDate, assetTransactionPostDate) ||
                const DeepCollectionEquality().equals(
                    other.assetTransactionPostDate,
                    assetTransactionPostDate)) &&
            (identical(other.assetTransactionType, assetTransactionType) ||
                const DeepCollectionEquality().equals(
                    other.assetTransactionType, assetTransactionType)) &&
            (identical(other.assetTransactionPaidByName, assetTransactionPaidByName) ||
                const DeepCollectionEquality().equals(
                    other.assetTransactionPaidByName,
                    assetTransactionPaidByName)) &&
            (identical(other.assetTransactionTypeAdditionalDescription, assetTransactionTypeAdditionalDescription) ||
                const DeepCollectionEquality().equals(
                    other.assetTransactionTypeAdditionalDescription,
                    assetTransactionTypeAdditionalDescription)) &&
            (identical(other.assetTransactionCategoryType, assetTransactionCategoryType) ||
                const DeepCollectionEquality().equals(
                    other.assetTransactionCategoryType,
                    assetTransactionCategoryType)) &&
            (identical(other.financialInstitutionTransactionIdentifier, financialInstitutionTransactionIdentifier) ||
                const DeepCollectionEquality().equals(
                    other.financialInstitutionTransactionIdentifier,
                    financialInstitutionTransactionIdentifier)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(assetTransactionUniqueIdentifier) ^
      const DeepCollectionEquality().hash(assetTransactionAmount) ^
      const DeepCollectionEquality().hash(assetTransactionDate) ^
      const DeepCollectionEquality().hash(assetTransactionPostDate) ^
      const DeepCollectionEquality().hash(assetTransactionType) ^
      const DeepCollectionEquality().hash(assetTransactionPaidByName) ^
      const DeepCollectionEquality()
          .hash(assetTransactionTypeAdditionalDescription) ^
      const DeepCollectionEquality().hash(assetTransactionCategoryType) ^
      const DeepCollectionEquality()
          .hash(financialInstitutionTransactionIdentifier) ^
      runtimeType.hashCode;
}

extension $AssetTransactionDetailExtension on AssetTransactionDetail {
  AssetTransactionDetail copyWith(
      {String? assetTransactionUniqueIdentifier,
      double? assetTransactionAmount,
      DateTime? assetTransactionDate,
      DateTime? assetTransactionPostDate,
      enums.AssetTransactionType? assetTransactionType,
      String? assetTransactionPaidByName,
      String? assetTransactionTypeAdditionalDescription,
      enums.AssetTransactionCategoryType? assetTransactionCategoryType,
      String? financialInstitutionTransactionIdentifier}) {
    return AssetTransactionDetail(
        assetTransactionUniqueIdentifier: assetTransactionUniqueIdentifier ??
            this.assetTransactionUniqueIdentifier,
        assetTransactionAmount:
            assetTransactionAmount ?? this.assetTransactionAmount,
        assetTransactionDate: assetTransactionDate ?? this.assetTransactionDate,
        assetTransactionPostDate:
            assetTransactionPostDate ?? this.assetTransactionPostDate,
        assetTransactionType: assetTransactionType ?? this.assetTransactionType,
        assetTransactionPaidByName:
            assetTransactionPaidByName ?? this.assetTransactionPaidByName,
        assetTransactionTypeAdditionalDescription:
            assetTransactionTypeAdditionalDescription ??
                this.assetTransactionTypeAdditionalDescription,
        assetTransactionCategoryType:
            assetTransactionCategoryType ?? this.assetTransactionCategoryType,
        financialInstitutionTransactionIdentifier:
            financialInstitutionTransactionIdentifier ??
                this.financialInstitutionTransactionIdentifier);
  }

  AssetTransactionDetail copyWithWrapped(
      {Wrapped<String>? assetTransactionUniqueIdentifier,
      Wrapped<double>? assetTransactionAmount,
      Wrapped<DateTime>? assetTransactionDate,
      Wrapped<DateTime>? assetTransactionPostDate,
      Wrapped<enums.AssetTransactionType>? assetTransactionType,
      Wrapped<String?>? assetTransactionPaidByName,
      Wrapped<String?>? assetTransactionTypeAdditionalDescription,
      Wrapped<enums.AssetTransactionCategoryType?>?
          assetTransactionCategoryType,
      Wrapped<String?>? financialInstitutionTransactionIdentifier}) {
    return AssetTransactionDetail(
        assetTransactionUniqueIdentifier:
            (assetTransactionUniqueIdentifier != null
                ? assetTransactionUniqueIdentifier.value
                : this.assetTransactionUniqueIdentifier),
        assetTransactionAmount: (assetTransactionAmount != null
            ? assetTransactionAmount.value
            : this.assetTransactionAmount),
        assetTransactionDate: (assetTransactionDate != null
            ? assetTransactionDate.value
            : this.assetTransactionDate),
        assetTransactionPostDate: (assetTransactionPostDate != null
            ? assetTransactionPostDate.value
            : this.assetTransactionPostDate),
        assetTransactionType: (assetTransactionType != null
            ? assetTransactionType.value
            : this.assetTransactionType),
        assetTransactionPaidByName: (assetTransactionPaidByName != null
            ? assetTransactionPaidByName.value
            : this.assetTransactionPaidByName),
        assetTransactionTypeAdditionalDescription:
            (assetTransactionTypeAdditionalDescription != null
                ? assetTransactionTypeAdditionalDescription.value
                : this.assetTransactionTypeAdditionalDescription),
        assetTransactionCategoryType: (assetTransactionCategoryType != null
            ? assetTransactionCategoryType.value
            : this.assetTransactionCategoryType),
        financialInstitutionTransactionIdentifier:
            (financialInstitutionTransactionIdentifier != null
                ? financialInstitutionTransactionIdentifier.value
                : this.financialInstitutionTransactionIdentifier));
  }
}

@JsonSerializable(explicitToJson: true)
class AssetTransactionDescription {
  AssetTransactionDescription({
    required this.assetTransactionDescription,
  });

  factory AssetTransactionDescription.fromJson(Map<String, dynamic> json) =>
      _$AssetTransactionDescriptionFromJson(json);

  @JsonKey(name: 'AssetTransactionDescription')
  final String assetTransactionDescription;
  static const fromJsonFactory = _$AssetTransactionDescriptionFromJson;
  static const toJsonFactory = _$AssetTransactionDescriptionToJson;
  Map<String, dynamic> toJson() => _$AssetTransactionDescriptionToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AssetTransactionDescription &&
            (identical(other.assetTransactionDescription,
                    assetTransactionDescription) ||
                const DeepCollectionEquality().equals(
                    other.assetTransactionDescription,
                    assetTransactionDescription)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(assetTransactionDescription) ^
      runtimeType.hashCode;
}

extension $AssetTransactionDescriptionExtension on AssetTransactionDescription {
  AssetTransactionDescription copyWith({String? assetTransactionDescription}) {
    return AssetTransactionDescription(
        assetTransactionDescription:
            assetTransactionDescription ?? this.assetTransactionDescription);
  }

  AssetTransactionDescription copyWithWrapped(
      {Wrapped<String>? assetTransactionDescription}) {
    return AssetTransactionDescription(
        assetTransactionDescription: (assetTransactionDescription != null
            ? assetTransactionDescription.value
            : this.assetTransactionDescription));
  }
}

@JsonSerializable(explicitToJson: true)
class ValidationSources {
  ValidationSources({
    required this.validationsource,
  });

  factory ValidationSources.fromJson(Map<String, dynamic> json) =>
      _$ValidationSourcesFromJson(json);

  @JsonKey(name: 'VALIDATION_SOURCE', defaultValue: <ValidationSource>[])
  final List<ValidationSource> validationsource;
  static const fromJsonFactory = _$ValidationSourcesFromJson;
  static const toJsonFactory = _$ValidationSourcesToJson;
  Map<String, dynamic> toJson() => _$ValidationSourcesToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ValidationSources &&
            (identical(other.validationsource, validationsource) ||
                const DeepCollectionEquality()
                    .equals(other.validationsource, validationsource)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(validationsource) ^
      runtimeType.hashCode;
}

extension $ValidationSourcesExtension on ValidationSources {
  ValidationSources copyWith({List<ValidationSource>? validationsource}) {
    return ValidationSources(
        validationsource: validationsource ?? this.validationsource);
  }

  ValidationSources copyWithWrapped(
      {Wrapped<List<ValidationSource>>? validationsource}) {
    return ValidationSources(
        validationsource: (validationsource != null
            ? validationsource.value
            : this.validationsource));
  }
}

@JsonSerializable(explicitToJson: true)
class ValidationSource {
  ValidationSource({
    required this.validationSourceName,
    required this.validationSourceReferenceIdentifier,
  });

  factory ValidationSource.fromJson(Map<String, dynamic> json) =>
      _$ValidationSourceFromJson(json);

  @JsonKey(name: 'ValidationSourceName')
  final String? validationSourceName;
  @JsonKey(name: 'ValidationSourceReferenceIdentifier')
  final String? validationSourceReferenceIdentifier;
  static const fromJsonFactory = _$ValidationSourceFromJson;
  static const toJsonFactory = _$ValidationSourceToJson;
  Map<String, dynamic> toJson() => _$ValidationSourceToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ValidationSource &&
            (identical(other.validationSourceName, validationSourceName) ||
                const DeepCollectionEquality().equals(
                    other.validationSourceName, validationSourceName)) &&
            (identical(other.validationSourceReferenceIdentifier,
                    validationSourceReferenceIdentifier) ||
                const DeepCollectionEquality().equals(
                    other.validationSourceReferenceIdentifier,
                    validationSourceReferenceIdentifier)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(validationSourceName) ^
      const DeepCollectionEquality().hash(validationSourceReferenceIdentifier) ^
      runtimeType.hashCode;
}

extension $ValidationSourceExtension on ValidationSource {
  ValidationSource copyWith(
      {String? validationSourceName,
      String? validationSourceReferenceIdentifier}) {
    return ValidationSource(
        validationSourceName: validationSourceName ?? this.validationSourceName,
        validationSourceReferenceIdentifier:
            validationSourceReferenceIdentifier ??
                this.validationSourceReferenceIdentifier);
  }

  ValidationSource copyWithWrapped(
      {Wrapped<String?>? validationSourceName,
      Wrapped<String?>? validationSourceReferenceIdentifier}) {
    return ValidationSource(
        validationSourceName: (validationSourceName != null
            ? validationSourceName.value
            : this.validationSourceName),
        validationSourceReferenceIdentifier:
            (validationSourceReferenceIdentifier != null
                ? validationSourceReferenceIdentifier.value
                : this.validationSourceReferenceIdentifier));
  }
}

@JsonSerializable(explicitToJson: true)
class Statuses {
  Statuses({
    required this.status,
  });

  factory Statuses.fromJson(Map<String, dynamic> json) =>
      _$StatusesFromJson(json);

  @JsonKey(name: 'STATUS')
  final Status status;
  static const fromJsonFactory = _$StatusesFromJson;
  static const toJsonFactory = _$StatusesToJson;
  Map<String, dynamic> toJson() => _$StatusesToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Statuses &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^ runtimeType.hashCode;
}

extension $StatusesExtension on Statuses {
  Statuses copyWith({Status? status}) {
    return Statuses(status: status ?? this.status);
  }

  Statuses copyWithWrapped({Wrapped<Status>? status}) {
    return Statuses(status: (status != null ? status.value : this.status));
  }
}

@JsonSerializable(explicitToJson: true)
class Status {
  Status({
    required this.statusCode,
    required this.statusDescription,
  });

  factory Status.fromJson(Map<String, dynamic> json) => _$StatusFromJson(json);

  @JsonKey(name: 'StatusCode')
  final String? statusCode;
  @JsonKey(name: 'StatusDescription')
  final String? statusDescription;
  static const fromJsonFactory = _$StatusFromJson;
  static const toJsonFactory = _$StatusToJson;
  Map<String, dynamic> toJson() => _$StatusToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Status &&
            (identical(other.statusCode, statusCode) ||
                const DeepCollectionEquality()
                    .equals(other.statusCode, statusCode)) &&
            (identical(other.statusDescription, statusDescription) ||
                const DeepCollectionEquality()
                    .equals(other.statusDescription, statusDescription)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(statusCode) ^
      const DeepCollectionEquality().hash(statusDescription) ^
      runtimeType.hashCode;
}

extension $StatusExtension on Status {
  Status copyWith({String? statusCode, String? statusDescription}) {
    return Status(
        statusCode: statusCode ?? this.statusCode,
        statusDescription: statusDescription ?? this.statusDescription);
  }

  Status copyWithWrapped(
      {Wrapped<String?>? statusCode, Wrapped<String?>? statusDescription}) {
    return Status(
        statusCode: (statusCode != null ? statusCode.value : this.statusCode),
        statusDescription: (statusDescription != null
            ? statusDescription.value
            : this.statusDescription));
  }
}

@JsonSerializable(explicitToJson: true)
class ItemGetRequest {
  ItemGetRequest({
    this.clientId,
    this.secret,
    required this.accessToken,
  });

  factory ItemGetRequest.fromJson(Map<String, dynamic> json) =>
      _$ItemGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'access_token')
  final String accessToken;
  static const fromJsonFactory = _$ItemGetRequestFromJson;
  static const toJsonFactory = _$ItemGetRequestToJson;
  Map<String, dynamic> toJson() => _$ItemGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ItemGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(accessToken) ^
      runtimeType.hashCode;
}

extension $ItemGetRequestExtension on ItemGetRequest {
  ItemGetRequest copyWith(
      {String? clientId, String? secret, String? accessToken}) {
    return ItemGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        accessToken: accessToken ?? this.accessToken);
  }

  ItemGetRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? accessToken}) {
    return ItemGetRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        accessToken:
            (accessToken != null ? accessToken.value : this.accessToken));
  }
}

@JsonSerializable(explicitToJson: true)
class ItemGetResponse {
  ItemGetResponse({
    required this.item,
    this.status,
    required this.requestId,
  });

  factory ItemGetResponse.fromJson(Map<String, dynamic> json) =>
      _$ItemGetResponseFromJson(json);

  @JsonKey(name: 'item')
  final Item item;
  @JsonKey(name: 'status')
  final ItemStatusNullable? status;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$ItemGetResponseFromJson;
  static const toJsonFactory = _$ItemGetResponseToJson;
  Map<String, dynamic> toJson() => _$ItemGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ItemGetResponse &&
            (identical(other.item, item) ||
                const DeepCollectionEquality().equals(other.item, item)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(item) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $ItemGetResponseExtension on ItemGetResponse {
  ItemGetResponse copyWith(
      {Item? item, ItemStatusNullable? status, String? requestId}) {
    return ItemGetResponse(
        item: item ?? this.item,
        status: status ?? this.status,
        requestId: requestId ?? this.requestId);
  }

  ItemGetResponse copyWithWrapped(
      {Wrapped<Item>? item,
      Wrapped<ItemStatusNullable?>? status,
      Wrapped<String>? requestId}) {
    return ItemGetResponse(
        item: (item != null ? item.value : this.item),
        status: (status != null ? status.value : this.status),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class ItemRemoveRequest {
  ItemRemoveRequest({
    this.clientId,
    this.secret,
    required this.accessToken,
  });

  factory ItemRemoveRequest.fromJson(Map<String, dynamic> json) =>
      _$ItemRemoveRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'access_token')
  final String accessToken;
  static const fromJsonFactory = _$ItemRemoveRequestFromJson;
  static const toJsonFactory = _$ItemRemoveRequestToJson;
  Map<String, dynamic> toJson() => _$ItemRemoveRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ItemRemoveRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(accessToken) ^
      runtimeType.hashCode;
}

extension $ItemRemoveRequestExtension on ItemRemoveRequest {
  ItemRemoveRequest copyWith(
      {String? clientId, String? secret, String? accessToken}) {
    return ItemRemoveRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        accessToken: accessToken ?? this.accessToken);
  }

  ItemRemoveRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? accessToken}) {
    return ItemRemoveRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        accessToken:
            (accessToken != null ? accessToken.value : this.accessToken));
  }
}

@JsonSerializable(explicitToJson: true)
class ItemRemoveResponse {
  ItemRemoveResponse({
    required this.requestId,
  });

  factory ItemRemoveResponse.fromJson(Map<String, dynamic> json) =>
      _$ItemRemoveResponseFromJson(json);

  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$ItemRemoveResponseFromJson;
  static const toJsonFactory = _$ItemRemoveResponseToJson;
  Map<String, dynamic> toJson() => _$ItemRemoveResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ItemRemoveResponse &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(requestId) ^ runtimeType.hashCode;
}

extension $ItemRemoveResponseExtension on ItemRemoveResponse {
  ItemRemoveResponse copyWith({String? requestId}) {
    return ItemRemoveResponse(requestId: requestId ?? this.requestId);
  }

  ItemRemoveResponse copyWithWrapped({Wrapped<String>? requestId}) {
    return ItemRemoveResponse(
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class ItemWebhookUpdateRequest {
  ItemWebhookUpdateRequest({
    this.clientId,
    this.secret,
    required this.accessToken,
    this.webhook,
  });

  factory ItemWebhookUpdateRequest.fromJson(Map<String, dynamic> json) =>
      _$ItemWebhookUpdateRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'access_token')
  final String accessToken;
  @JsonKey(name: 'webhook')
  final String? webhook;
  static const fromJsonFactory = _$ItemWebhookUpdateRequestFromJson;
  static const toJsonFactory = _$ItemWebhookUpdateRequestToJson;
  Map<String, dynamic> toJson() => _$ItemWebhookUpdateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ItemWebhookUpdateRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)) &&
            (identical(other.webhook, webhook) ||
                const DeepCollectionEquality().equals(other.webhook, webhook)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(accessToken) ^
      const DeepCollectionEquality().hash(webhook) ^
      runtimeType.hashCode;
}

extension $ItemWebhookUpdateRequestExtension on ItemWebhookUpdateRequest {
  ItemWebhookUpdateRequest copyWith(
      {String? clientId,
      String? secret,
      String? accessToken,
      String? webhook}) {
    return ItemWebhookUpdateRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        accessToken: accessToken ?? this.accessToken,
        webhook: webhook ?? this.webhook);
  }

  ItemWebhookUpdateRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? accessToken,
      Wrapped<String?>? webhook}) {
    return ItemWebhookUpdateRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        accessToken:
            (accessToken != null ? accessToken.value : this.accessToken),
        webhook: (webhook != null ? webhook.value : this.webhook));
  }
}

@JsonSerializable(explicitToJson: true)
class ItemWebhookUpdateResponse {
  ItemWebhookUpdateResponse({
    required this.item,
    required this.requestId,
  });

  factory ItemWebhookUpdateResponse.fromJson(Map<String, dynamic> json) =>
      _$ItemWebhookUpdateResponseFromJson(json);

  @JsonKey(name: 'item')
  final Item item;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$ItemWebhookUpdateResponseFromJson;
  static const toJsonFactory = _$ItemWebhookUpdateResponseToJson;
  Map<String, dynamic> toJson() => _$ItemWebhookUpdateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ItemWebhookUpdateResponse &&
            (identical(other.item, item) ||
                const DeepCollectionEquality().equals(other.item, item)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(item) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $ItemWebhookUpdateResponseExtension on ItemWebhookUpdateResponse {
  ItemWebhookUpdateResponse copyWith({Item? item, String? requestId}) {
    return ItemWebhookUpdateResponse(
        item: item ?? this.item, requestId: requestId ?? this.requestId);
  }

  ItemWebhookUpdateResponse copyWithWrapped(
      {Wrapped<Item>? item, Wrapped<String>? requestId}) {
    return ItemWebhookUpdateResponse(
        item: (item != null ? item.value : this.item),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class ItemAccessTokenInvalidateRequest {
  ItemAccessTokenInvalidateRequest({
    this.clientId,
    this.secret,
    required this.accessToken,
  });

  factory ItemAccessTokenInvalidateRequest.fromJson(
          Map<String, dynamic> json) =>
      _$ItemAccessTokenInvalidateRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'access_token')
  final String accessToken;
  static const fromJsonFactory = _$ItemAccessTokenInvalidateRequestFromJson;
  static const toJsonFactory = _$ItemAccessTokenInvalidateRequestToJson;
  Map<String, dynamic> toJson() =>
      _$ItemAccessTokenInvalidateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ItemAccessTokenInvalidateRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(accessToken) ^
      runtimeType.hashCode;
}

extension $ItemAccessTokenInvalidateRequestExtension
    on ItemAccessTokenInvalidateRequest {
  ItemAccessTokenInvalidateRequest copyWith(
      {String? clientId, String? secret, String? accessToken}) {
    return ItemAccessTokenInvalidateRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        accessToken: accessToken ?? this.accessToken);
  }

  ItemAccessTokenInvalidateRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? accessToken}) {
    return ItemAccessTokenInvalidateRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        accessToken:
            (accessToken != null ? accessToken.value : this.accessToken));
  }
}

@JsonSerializable(explicitToJson: true)
class ItemAccessTokenInvalidateResponse {
  ItemAccessTokenInvalidateResponse({
    required this.newAccessToken,
    required this.requestId,
  });

  factory ItemAccessTokenInvalidateResponse.fromJson(
          Map<String, dynamic> json) =>
      _$ItemAccessTokenInvalidateResponseFromJson(json);

  @JsonKey(name: 'new_access_token')
  final String newAccessToken;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$ItemAccessTokenInvalidateResponseFromJson;
  static const toJsonFactory = _$ItemAccessTokenInvalidateResponseToJson;
  Map<String, dynamic> toJson() =>
      _$ItemAccessTokenInvalidateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ItemAccessTokenInvalidateResponse &&
            (identical(other.newAccessToken, newAccessToken) ||
                const DeepCollectionEquality()
                    .equals(other.newAccessToken, newAccessToken)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(newAccessToken) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $ItemAccessTokenInvalidateResponseExtension
    on ItemAccessTokenInvalidateResponse {
  ItemAccessTokenInvalidateResponse copyWith(
      {String? newAccessToken, String? requestId}) {
    return ItemAccessTokenInvalidateResponse(
        newAccessToken: newAccessToken ?? this.newAccessToken,
        requestId: requestId ?? this.requestId);
  }

  ItemAccessTokenInvalidateResponse copyWithWrapped(
      {Wrapped<String>? newAccessToken, Wrapped<String>? requestId}) {
    return ItemAccessTokenInvalidateResponse(
        newAccessToken: (newAccessToken != null
            ? newAccessToken.value
            : this.newAccessToken),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class ItemPublicTokenExchangeRequest {
  ItemPublicTokenExchangeRequest({
    this.clientId,
    this.secret,
    required this.publicToken,
  });

  factory ItemPublicTokenExchangeRequest.fromJson(Map<String, dynamic> json) =>
      _$ItemPublicTokenExchangeRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'public_token')
  final String publicToken;
  static const fromJsonFactory = _$ItemPublicTokenExchangeRequestFromJson;
  static const toJsonFactory = _$ItemPublicTokenExchangeRequestToJson;
  Map<String, dynamic> toJson() => _$ItemPublicTokenExchangeRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ItemPublicTokenExchangeRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.publicToken, publicToken) ||
                const DeepCollectionEquality()
                    .equals(other.publicToken, publicToken)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(publicToken) ^
      runtimeType.hashCode;
}

extension $ItemPublicTokenExchangeRequestExtension
    on ItemPublicTokenExchangeRequest {
  ItemPublicTokenExchangeRequest copyWith(
      {String? clientId, String? secret, String? publicToken}) {
    return ItemPublicTokenExchangeRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        publicToken: publicToken ?? this.publicToken);
  }

  ItemPublicTokenExchangeRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? publicToken}) {
    return ItemPublicTokenExchangeRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        publicToken:
            (publicToken != null ? publicToken.value : this.publicToken));
  }
}

@JsonSerializable(explicitToJson: true)
class ItemPublicTokenExchangeResponse {
  ItemPublicTokenExchangeResponse({
    required this.accessToken,
    required this.itemId,
    required this.requestId,
  });

  factory ItemPublicTokenExchangeResponse.fromJson(Map<String, dynamic> json) =>
      _$ItemPublicTokenExchangeResponseFromJson(json);

  @JsonKey(name: 'access_token')
  final String accessToken;
  @JsonKey(name: 'item_id')
  final String itemId;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$ItemPublicTokenExchangeResponseFromJson;
  static const toJsonFactory = _$ItemPublicTokenExchangeResponseToJson;
  Map<String, dynamic> toJson() =>
      _$ItemPublicTokenExchangeResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ItemPublicTokenExchangeResponse &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)) &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accessToken) ^
      const DeepCollectionEquality().hash(itemId) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $ItemPublicTokenExchangeResponseExtension
    on ItemPublicTokenExchangeResponse {
  ItemPublicTokenExchangeResponse copyWith(
      {String? accessToken, String? itemId, String? requestId}) {
    return ItemPublicTokenExchangeResponse(
        accessToken: accessToken ?? this.accessToken,
        itemId: itemId ?? this.itemId,
        requestId: requestId ?? this.requestId);
  }

  ItemPublicTokenExchangeResponse copyWithWrapped(
      {Wrapped<String>? accessToken,
      Wrapped<String>? itemId,
      Wrapped<String>? requestId}) {
    return ItemPublicTokenExchangeResponse(
        accessToken:
            (accessToken != null ? accessToken.value : this.accessToken),
        itemId: (itemId != null ? itemId.value : this.itemId),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class ItemPublicTokenCreateRequest {
  ItemPublicTokenCreateRequest({
    this.clientId,
    this.secret,
    required this.accessToken,
  });

  factory ItemPublicTokenCreateRequest.fromJson(Map<String, dynamic> json) =>
      _$ItemPublicTokenCreateRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'access_token')
  final String accessToken;
  static const fromJsonFactory = _$ItemPublicTokenCreateRequestFromJson;
  static const toJsonFactory = _$ItemPublicTokenCreateRequestToJson;
  Map<String, dynamic> toJson() => _$ItemPublicTokenCreateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ItemPublicTokenCreateRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(accessToken) ^
      runtimeType.hashCode;
}

extension $ItemPublicTokenCreateRequestExtension
    on ItemPublicTokenCreateRequest {
  ItemPublicTokenCreateRequest copyWith(
      {String? clientId, String? secret, String? accessToken}) {
    return ItemPublicTokenCreateRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        accessToken: accessToken ?? this.accessToken);
  }

  ItemPublicTokenCreateRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<String>? accessToken}) {
    return ItemPublicTokenCreateRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        accessToken:
            (accessToken != null ? accessToken.value : this.accessToken));
  }
}

@JsonSerializable(explicitToJson: true)
class ItemPublicTokenCreateResponse {
  ItemPublicTokenCreateResponse({
    required this.publicToken,
    this.expiration,
    required this.requestId,
  });

  factory ItemPublicTokenCreateResponse.fromJson(Map<String, dynamic> json) =>
      _$ItemPublicTokenCreateResponseFromJson(json);

  @JsonKey(name: 'public_token')
  final String publicToken;
  @JsonKey(name: 'expiration')
  final DateTime? expiration;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$ItemPublicTokenCreateResponseFromJson;
  static const toJsonFactory = _$ItemPublicTokenCreateResponseToJson;
  Map<String, dynamic> toJson() => _$ItemPublicTokenCreateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ItemPublicTokenCreateResponse &&
            (identical(other.publicToken, publicToken) ||
                const DeepCollectionEquality()
                    .equals(other.publicToken, publicToken)) &&
            (identical(other.expiration, expiration) ||
                const DeepCollectionEquality()
                    .equals(other.expiration, expiration)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(publicToken) ^
      const DeepCollectionEquality().hash(expiration) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $ItemPublicTokenCreateResponseExtension
    on ItemPublicTokenCreateResponse {
  ItemPublicTokenCreateResponse copyWith(
      {String? publicToken, DateTime? expiration, String? requestId}) {
    return ItemPublicTokenCreateResponse(
        publicToken: publicToken ?? this.publicToken,
        expiration: expiration ?? this.expiration,
        requestId: requestId ?? this.requestId);
  }

  ItemPublicTokenCreateResponse copyWithWrapped(
      {Wrapped<String>? publicToken,
      Wrapped<DateTime?>? expiration,
      Wrapped<String>? requestId}) {
    return ItemPublicTokenCreateResponse(
        publicToken:
            (publicToken != null ? publicToken.value : this.publicToken),
        expiration: (expiration != null ? expiration.value : this.expiration),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class ItemImportRequest {
  ItemImportRequest({
    this.clientId,
    this.secret,
    required this.products,
    required this.userAuth,
    this.options,
  });

  factory ItemImportRequest.fromJson(Map<String, dynamic> json) =>
      _$ItemImportRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(
    name: 'products',
    toJson: productsListToJson,
    fromJson: productsListFromJson,
  )
  final List<enums.Products> products;
  @JsonKey(name: 'user_auth')
  final ItemImportRequestUserAuth userAuth;
  @JsonKey(name: 'options')
  final ItemImportRequestOptions? options;
  static const fromJsonFactory = _$ItemImportRequestFromJson;
  static const toJsonFactory = _$ItemImportRequestToJson;
  Map<String, dynamic> toJson() => _$ItemImportRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ItemImportRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.products, products) ||
                const DeepCollectionEquality()
                    .equals(other.products, products)) &&
            (identical(other.userAuth, userAuth) ||
                const DeepCollectionEquality()
                    .equals(other.userAuth, userAuth)) &&
            (identical(other.options, options) ||
                const DeepCollectionEquality().equals(other.options, options)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(products) ^
      const DeepCollectionEquality().hash(userAuth) ^
      const DeepCollectionEquality().hash(options) ^
      runtimeType.hashCode;
}

extension $ItemImportRequestExtension on ItemImportRequest {
  ItemImportRequest copyWith(
      {String? clientId,
      String? secret,
      List<enums.Products>? products,
      ItemImportRequestUserAuth? userAuth,
      ItemImportRequestOptions? options}) {
    return ItemImportRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        products: products ?? this.products,
        userAuth: userAuth ?? this.userAuth,
        options: options ?? this.options);
  }

  ItemImportRequest copyWithWrapped(
      {Wrapped<String?>? clientId,
      Wrapped<String?>? secret,
      Wrapped<List<enums.Products>>? products,
      Wrapped<ItemImportRequestUserAuth>? userAuth,
      Wrapped<ItemImportRequestOptions?>? options}) {
    return ItemImportRequest(
        clientId: (clientId != null ? clientId.value : this.clientId),
        secret: (secret != null ? secret.value : this.secret),
        products: (products != null ? products.value : this.products),
        userAuth: (userAuth != null ? userAuth.value : this.userAuth),
        options: (options != null ? options.value : this.options));
  }
}

@JsonSerializable(explicitToJson: true)
class ItemImportRequestOptions {
  ItemImportRequestOptions({
    this.webhook,
  });

  factory ItemImportRequestOptions.fromJson(Map<String, dynamic> json) =>
      _$ItemImportRequestOptionsFromJson(json);

  @JsonKey(name: 'webhook')
  final String? webhook;
  static const fromJsonFactory = _$ItemImportRequestOptionsFromJson;
  static const toJsonFactory = _$ItemImportRequestOptionsToJson;
  Map<String, dynamic> toJson() => _$ItemImportRequestOptionsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ItemImportRequestOptions &&
            (identical(other.webhook, webhook) ||
                const DeepCollectionEquality().equals(other.webhook, webhook)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(webhook) ^ runtimeType.hashCode;
}

extension $ItemImportRequestOptionsExtension on ItemImportRequestOptions {
  ItemImportRequestOptions copyWith({String? webhook}) {
    return ItemImportRequestOptions(webhook: webhook ?? this.webhook);
  }

  ItemImportRequestOptions copyWithWrapped({Wrapped<String?>? webhook}) {
    return ItemImportRequestOptions(
        webhook: (webhook != null ? webhook.value : this.webhook));
  }
}

@JsonSerializable(explicitToJson: true)
class ItemImportRequestUserAuth {
  ItemImportRequestUserAuth({
    required this.userId,
    required this.authToken,
  });

  factory ItemImportRequestUserAuth.fromJson(Map<String, dynamic> json) =>
      _$ItemImportRequestUserAuthFromJson(json);

  @JsonKey(name: 'user_id')
  final String userId;
  @JsonKey(name: 'auth_token')
  final String authToken;
  static const fromJsonFactory = _$ItemImportRequestUserAuthFromJson;
  static const toJsonFactory = _$ItemImportRequestUserAuthToJson;
  Map<String, dynamic> toJson() => _$ItemImportRequestUserAuthToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ItemImportRequestUserAuth &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)) &&
            (identical(other.authToken, authToken) ||
                const DeepCollectionEquality()
                    .equals(other.authToken, authToken)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(userId) ^
      const DeepCollectionEquality().hash(authToken) ^
      runtimeType.hashCode;
}

extension $ItemImportRequestUserAuthExtension on ItemImportRequestUserAuth {
  ItemImportRequestUserAuth copyWith({String? userId, String? authToken}) {
    return ItemImportRequestUserAuth(
        userId: userId ?? this.userId, authToken: authToken ?? this.authToken);
  }

  ItemImportRequestUserAuth copyWithWrapped(
      {Wrapped<String>? userId, Wrapped<String>? authToken}) {
    return ItemImportRequestUserAuth(
        userId: (userId != null ? userId.value : this.userId),
        authToken: (authToken != null ? authToken.value : this.authToken));
  }
}

@JsonSerializable(explicitToJson: true)
class ItemImportResponse {
  ItemImportResponse({
    required this.accessToken,
    required this.requestId,
  });

  factory ItemImportResponse.fromJson(Map<String, dynamic> json) =>
      _$ItemImportResponseFromJson(json);

  @JsonKey(name: 'access_token')
  final String accessToken;
  @JsonKey(name: 'request_id')
  final String requestId;
  static const fromJsonFactory = _$ItemImportResponseFromJson;
  static const toJsonFactory = _$ItemImportResponseToJson;
  Map<String, dynamic> toJson() => _$ItemImportResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ItemImportResponse &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accessToken) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $ItemImportResponseExtension on ItemImportResponse {
  ItemImportResponse copyWith({String? accessToken, String? requestId}) {
    return ItemImportResponse(
        accessToken: accessToken ?? this.accessToken,
        requestId: requestId ?? this.requestId);
  }

  ItemImportResponse copyWithWrapped(
      {Wrapped<String>? accessToken, Wrapped<String>? requestId}) {
    return ItemImportResponse(
        accessToken:
            (accessToken != null ? accessToken.value : this.accessToken),
        requestId: (requestId != null ? requestId.value : this.requestId));
  }
}

@JsonSerializable(explicitToJson: true)
class Item {
  Item({
    required this.itemId,
    this.institutionId,
    required this.webhook,
    required this.error,
    required this.availableProducts,
    required this.billedProducts,
    this.products,
    this.consentedProducts,
    required this.consentExpirationTime,
    required this.updateType,
  });

  factory Item.fromJson(Map<String, dynamic> json) => _$ItemFromJson(json);

  @JsonKey(name: 'item_id')
  final String itemId;
  @JsonKey(name: 'institution_id')
  final String? institutionId;
  @JsonKey(name: 'webhook')
  final String? webhook;
  @JsonKey(name: 'error')
  final PlaidError? error;
  @JsonKey(
    name: 'available_products',
    toJson: productsListToJson,
    fromJson: productsListFromJson,
  )
  final List<enums.Products> availableProducts;
  @JsonKey(
    name: 'billed_products',
    toJson: productsListToJson,
    fromJson: productsListFromJson,
  )
  final List<enums.Products> billedProducts;
  @JsonKey(
    name: 'products',
    toJson: productsListToJson,
    fromJson: productsListFromJson,
  )
  final List<enums.Products>? products;
  @JsonKey(
    name: 'consented_products',
    toJson: productsListToJson,
    fromJson: productsListFromJson,
  )
  final List<enums.Products>? consentedProducts;
  @JsonKey(name: 'consent_expiration_time')
  final DateTime? consentExpirationTime;
  @JsonKey(
    name: 'update_type',
    toJson: itemUpdateTypeToJson,
    fromJson: itemUpdateTypeFromJson,
  )
  final enums.ItemUpdateType updateType;
  static const fromJsonFactory = _$ItemFromJson;
  static const toJsonFactory = _$ItemToJson;
  Map<String, dynamic> toJson() => _$ItemToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Item &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)) &&
            (identical(other.institutionId, institutionId) ||
                const DeepCollectionEquality()
                    .equals(other.institutionId, institutionId)) &&
            (identical(other.webhook, webhook) ||
                const DeepCollectionEquality()
                    .equals(other.webhook, webhook)) &&
            (identical(other.error, error) ||
                const DeepCollectionEquality().equals(other.error, error)) &&
            (identical(other.availableProducts, availableProducts) ||
                const DeepCollectionEquality()
                    .equals(other.availableProducts, availableProducts)) &&
            (identical(other.billedProducts, billedProducts) ||
                const DeepCollectionEquality()
                    .equals(other.billedProducts, billedProducts)) &&
            (identical(other.products, products) ||
                const DeepCollectionEquality()
                    .equals(other.products, products)) &&
            (identical(other.consentedProducts, consentedProducts) ||
                const DeepCollectionEquality()
                    .equals(other.consentedProducts, consentedProducts)) &&
            (identical(other.consentExpirationTime, consentExpirationTime) ||
                const DeepCollectionEquality().equals(
                    other.consentExpirationTime, consentExpirationTime)) &&
            (identical(other.updateType, updateType) ||
                const DeepCollectionEquality()
                    .equals(other.updateType, updateType)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(itemId) ^
      const DeepCollectionEquality().hash(institutionId) ^
      const DeepCollectionEquality().hash(webhook) ^
      const DeepCollectionEquality().hash(error) ^
      const DeepCollectionEquality().hash(availableProducts) ^
      const DeepCollectionEquality().hash(billedProducts) ^
      const DeepCollectionEquality().hash(products) ^
      const DeepCollectionEquality().hash(consentedProducts) ^
      const DeepCollectionEquality().hash(consentExpirationTime) ^
      const DeepCollectionEquality().hash(updateType) ^
      runtimeType.hashCode;
}

extension $ItemExtension on Item {
  Item copyWith(
      {String? itemId,
      String? institutionId,
      String? webhook,
      PlaidError? error,
      List<enums.Products>? availableProducts,
      List<enums.Products>? billedProducts,
      List<enums.Products>? products,
      List<enums.Products>? consentedProducts,
      DateTime? consentExpirationTime,
      enums.ItemUpdateType? updateType}) {
    return Item(
        itemId: itemId ?? this.itemId,
        institutionId: institutionId ?? this.institutionId,
        webhook: webhook ?? this.webhook,
        error: error ?? this.error,
        availableProducts: availableProducts ?? this.availableProducts,
        billedProducts: billedProducts ?? this.billedProducts,
        products: products ?? this.products,
        consentedProducts: consentedProducts ?? this.consentedProducts,
        consentExpirationTime:
            consentExpirationTime ?? this.consentExpirationTime,
        updateType: updateType ?? this.updateType);
  }

  Item copyWithWrapped(
      {Wrapped<String>? itemId,
      Wrapped<String?>? institutionId,
      Wrapped<String?>? webhook,
      Wrapped<PlaidError?>? error,
      Wrapped<List<enums.Products>>? availableProducts,
      Wrapped<List<enums.Products>>? billedProducts,
      Wrapped<List<enums.Products>?>? products,
      Wrapped<List<enums.Products>?>? consentedProducts,
      Wrapped<DateTime?>? consentExpirationTime,
      Wrapped<enums.ItemUpdateType>? updateType}) {
    return Item(
        itemId: (itemId != null ? itemId.value : this.itemId),
        institutionId:
            (institutionId != null ? institutionId.value : this.institutionId),
        webhook: (webhook != null ? webhook.value : this.webhook),
        error: (error != null ? error.value : this.error),
        availableProducts: (availableProducts != null
            ? availableProducts.value
            : this.availableProducts),
        billedProducts: (billedProducts != null
            ? billedProducts.value
            : this.billedProducts),
        products: (products != null ? products.value : this.products),
        consentedProducts: (consentedProducts != null
            ? consentedProducts.value
            : this.consentedProducts),
        consentExpirationTime: (consentExpirationTime != null
            ? consentExpirationTime.value
            : this.consentExpirationTime),
        updateType: (updateType != null ? updateType.value : this.updateType));
  }
}

@JsonSerializable(explicitToJson: true)
class ItemStatus {
  ItemStatus({
    this.investments,
    this.transactions,
    this.lastWebhook,
  });

  factory ItemStatus.fromJson(Map<String, dynamic> json) =>
      _$ItemStatusFromJson(json);

  @JsonKey(name: 'investments')
  final ItemStatusInvestments? investments;
  @JsonKey(name: 'transactions')
  final ItemStatusTransactions? transactions;
  @JsonKey(name: 'last_webhook')
  final ItemStatusLastWebhook? lastWebhook;
  static const fromJsonFactory = _$ItemStatusFromJson;
  static const toJsonFactory = _$ItemStatusToJson;
  Map<String, dynamic> toJson() => _$ItemStatusToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ItemStatus &&
            (identical(other.investments, investments) ||
                const DeepCollectionEquality()
                    .equals(other.investments, investments)) &&
            (identical(other.transactions, transactions) ||
                const DeepCollectionEquality()
                    .equals(other.transactions, transactions)) &&
            (identical(other.lastWebhook, lastWebhook) ||
                const DeepCollectionEquality()
                    .equals(other.lastWebhook, lastWebhook)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(investments) ^
      const DeepCollectionEquality().hash(transactions) ^
      const DeepCollectionEquality().hash(lastWebhook) ^
      runtimeType.hashCode;
}

extension $ItemStatusExtension on ItemStatus {
  ItemStatus copyWith(
      {ItemStatusInvestments? investments,
      ItemStatusTransactions? transactions,
      ItemStatusLastWebhook? lastWebhook}) {
    return ItemStatus(
        investments: investments ?? this.investments,
        transactions: transactions ?? this.transactions,
        lastWebhook: lastWebhook ?? this.lastWebhook);
  }

  ItemStatus copyWithWrapped(
      {Wrapped<ItemStatusInvestments?>? investments,
      Wrapped<ItemStatusTransactions?>? transactions,
      Wrapped<ItemStatusLastWebhook?>? lastWebhook}) {
    return ItemStatus(
        investments:
            (investments != null ? investments.value : this.investments),
        transactions:
            (transactions != null ? transactions.value : this.transactions),
        lastWebhook:
            (lastWebhook != null ? lastWebhook.value : this.lastWebhook));
  }
}

@JsonSerializable(explicitToJson: true)
class ItemStatusNullable {
  ItemStatusNullable({
    this.investments,
    this.transactions,
    this.lastWebhook,
  });

  factory ItemStatusNullable.fromJson(Map<String, dynamic> json) =>
      _$ItemStatusNullableFromJson(json);

  @JsonKey(name: 'investments')
  final ItemStatusInvestments? investments;
  @JsonKey(name: 'transactions')
  final ItemStatusTransactions? transactions;
  @JsonKey(name: 'last_webhook')
  final ItemStatusLastWebhook? lastWebhook;
  static const fromJsonFactory = _$ItemStatusNullableFromJson;
  static const toJsonFactory = _$ItemStatusNullableToJson;
  Map<String, dynamic> toJson() => _$ItemStatusNullableToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ItemStatusNullable &&
            (identical(other.investments, investments) ||
                const DeepCollectionEquality()
                    .equals(other.investments, investments)) &&
            (identical(other.transactions, transactions) ||
                const DeepCollectionEquality()
                    .equals(other.transactions, transactions)) &&
            (identical(other.lastWebhook, lastWebhook) ||
                const DeepCollectionEquality()
                    .equals(other.lastWebhook, lastWebhook)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(investments) ^
      const DeepCollectionEquality().hash(transactions) ^
      const DeepCollectionEquality().hash(lastWebhook) ^
      runtimeType.hashCode;
}

extension $ItemStatusNullableExtension on ItemStatusNullable {
  ItemStatusNullable copyWith(
      {ItemStatusInvestments? investments,
      ItemStatusTransactions? transactions,
      ItemStatusLastWebhook? lastWebhook}) {
    return ItemStatusNullable(
        investments: investments ?? this.investments,
        transactions: transactions ?? this.transactions,
        lastWebhook: lastWebhook ?? this.lastWebhook);
  }

  ItemStatusNullable copyWithWrapped(
      {Wrapped<ItemStatusInvestments?>? investments,
      Wrapped<ItemStatusTransactions?>? transactions,
      Wrapped<ItemStatusLastWebhook?>? lastWebhook}) {
    return ItemStatusNullable(
        investments:
            (investments != null ? investments.value : this.investments),
        transactions:
            (transactions != null ? transactions.value : this.transactions),
        lastWebhook:
            (lastWebhook != null ? lastWebhook.value : this.lastWebhook));
  }
}

@JsonSerializable(explicitToJson: true)
class ItemStatusTransactions {
  ItemStatusTransactions({
    this.lastSuccessfulUpdate,
    this.lastFailedUpdate,
  });

  factory ItemStatusTransactions.fromJson(Map<String, dynamic> json) =>
      _$ItemStatusTransactionsFromJson(json);

  @JsonKey(name: 'last_successful_update')
  final DateTime? lastSuccessfulUpdate;
  @JsonKey(name: 'last_failed_update')
  final DateTime? lastFailedUpdate;
  static const fromJsonFactory = _$ItemStatusTransactionsFromJson;
  static const toJsonFactory = _$ItemStatusTransactionsToJson;
  Map<String, dynamic> toJson() => _$ItemStatusTransactionsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ItemStatusTransactions &&
            (identical(other.lastSuccessfulUpdate, lastSuccessfulUpdate) ||
                const DeepCollectionEquality().equals(
                    other.lastSuccessfulUpdate, lastSuccessfulUpdate)) &&
            (identical(other.lastFailedUpdate, lastFailedUpdate) ||
                const DeepCollectionEquality()
                    .equals(other.lastFailedUpdate, lastFailedUpdate)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(lastSuccessfulUpdate) ^
      const DeepCollectionEquality().hash(lastFailedUpdate) ^
      runtimeType.hashCode;
}

extension $ItemStatusTransactionsExtension on ItemStatusTransactions {
  ItemStatusTransactions copyWith(
      {DateTime? lastSuccessfulUpdate, DateTime? lastFailedUpdate}) {
    return ItemStatusTransactions(
        lastSuccessfulUpdate: lastSuccessfulUpdate ?? this.lastSuccessfulUpdate,
        lastFailedUpdate: lastFailedUpdate ?? this.lastFailedUpdate);
  }

  ItemStatusTransactions copyWithWrapped(
      {Wrapped<DateTime?>? lastSuccessfulUpdate,
      Wrapped<DateTime?>? lastFailedUpdate}) {
    return ItemStatusTransactions(
        lastSuccessfulUpdate: (lastSuccessfulUpdate != null
            ? lastSuccessfulUpdate.value
            : this.lastSuccessfulUpdate),
        lastFailedUpdate: (lastFailedUpdate != null
            ? lastFailedUpdate.value
            : this.lastFailedUpdate));
  }
}

@JsonSerializable(explicitToJson: true)
class ItemStatusInvestments {
  ItemStatusInvestments({
    this.lastSuccessfulUpdate,
    this.lastFailedUpdate,
  });

  factory ItemStatusInvestments.fromJson(Map<String, dynamic> json) =>
      _$ItemStatusInvestmentsFromJson(json);

  @JsonKey(name: 'last_successful_update')
  final DateTime? lastSuccessfulUpdate;
  @JsonKey(name: 'last_failed_update')
  final DateTime? lastFailedUpdate;
  static const fromJsonFactory = _$ItemStatusInvestmentsFromJson;
  static const toJsonFactory = _$ItemStatusInvestmentsToJson;
  Map<String, dynamic> toJson() => _$ItemStatusInvestmentsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ItemStatusInvestments &&
            (identical(other.lastSuccessfulUpdate, lastSuccessfulUpdate) ||
                const DeepCollectionEquality().equals(
                    other.lastSuccessfulUpdate, lastSuccessfulUpdate)) &&
            (identical(other.lastFailedUpdate, lastFailedUpdate) ||
                const DeepCollectionEquality()
                    .equals(other.lastFailedUpdate, lastFailedUpdate)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(lastSuccessfulUpdate) ^
      const DeepCollectionEquality().hash(lastFailedUpdate) ^
      runtimeType.hashCode;
}

extension $ItemStatusInvestmentsExtension on ItemStatusInvestments {
  ItemStatusInvestments copyWith(
      {DateTime? lastSuccessfulUpdate, DateTime? lastFailedUpdate}) {
    return ItemStatusInvestments(
        lastSuccessfulUpdate: lastSuccessfulUpdate ?? this.lastSuccessfulUpdate,
        lastFailedUpdate: lastFailedUpdate ?? this.lastFailedUpdate);
  }

  ItemStatusInvestments copyWithWrapped(
      {Wrapped<DateTime?>? lastSuccessfulUpdate,
      Wrapped<DateTime?>? lastFailedUpdate}) {
    return ItemStatusInvestments(
        lastSuccessfulUpdate: (lastSuccessfulUpdate != null
            ? lastSuccessfulUpdate.value
            : this.lastSuccessfulUpdate),
        lastFailedUpdate: (lastFailedUpdate != null
            ? lastFailedUpdate.value
            : this.lastFailedUpdate));
  }
}

@JsonSerializable(explicitToJson: true)
class ItemStatusLastWebhook {
  ItemStatusLastWebhook({
    this.sentAt,
    this.codeSent,
  });

  factory ItemStatusLastWebhook.fromJson(Map<String, dynamic> json) =>
      _$ItemStatusLastWebhookFromJson(json);

  @JsonKey(name: 'sent_at')
  final DateTime? sentAt;
  @JsonKey(name: 'code_sent')
  final String? codeSent;
  static const fromJsonFactory = _$ItemStatusLastWebhookFromJson;
  static const toJsonFactory = _$ItemStatusLastWebhookToJson;
  Map<String, dynamic> toJson() => _$ItemStatusLastWebhookToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ItemStatusLastWebhook &&
            (identical(other.sentAt, sentAt) ||
                const DeepCollectionEquality().equals(other.sentAt, sentAt)) &&
            (identical(other.codeSent, codeSent) ||
                const DeepCollectionEquality()
                    .equals(other.codeSent, codeSent)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(sentAt) ^
      const DeepCollectionEquality().hash(codeSent) ^
      runtimeType.hashCode;
}

extension $ItemStatusLastWebhookExtension on ItemStatusLastWebhook {
  ItemStatusLastWebhook copyWith({DateTime? sentAt, String? codeSent}) {
    return ItemStatusLastWebhook(
        sentAt: sentAt ?? this.sentAt, codeSent: codeSent ?? this.codeSent);
  }

  ItemStatusLastWebhook copyWithWrapped(
      {Wrapped<DateTime?>? sentAt, Wrapped<String?>? codeSent}) {
    return ItemStatusLastWebhook(
        sentAt: (sentAt != null ? sentAt.value : this.sentAt),
        codeSent: (codeSent != null ? codeSent.value : this.codeSent));
  }
}

@JsonSerializable(explicitToJson: true)
class FDXParty {
  FDXParty({
    required this.name,
    required this.type,
    this.homeUri,
    this.logoUri,
    this.registry,
    this.registeredEntityName,
    this.registeredEntityId,
  });

  factory FDXParty.fromJson(Map<String, dynamic> json) =>
      _$FDXPartyFromJson(json);

  @JsonKey(name: 'name')
  final String name;
  @JsonKey(
    name: 'type',
    toJson: fDXPartyTypeToJson,
    fromJson: fDXPartyTypeFromJson,
  )
  final enums.FDXPartyType type;
  @JsonKey(name: 'homeUri')
  final String? homeUri;
  @JsonKey(name: 'logoUri')
  final String? logoUri;
  @JsonKey(
    name: 'registry',
    toJson: fDXPartyRegistryToJson,
    fromJson: fDXPartyRegistryFromJson,
  )
  final enums.FDXPartyRegistry? registry;
  @JsonKey(name: 'registeredEntityName')
  final String? registeredEntityName;
  @JsonKey(name: 'registeredEntityId')
  final String? registeredEntityId;
  static const fromJsonFactory = _$FDXPartyFromJson;
  static const toJsonFactory = _$FDXPartyToJson;
  Map<String, dynamic> toJson() => _$FDXPartyToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is FDXParty &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.homeUri, homeUri) ||
                const DeepCollectionEquality()
                    .equals(other.homeUri, homeUri)) &&
            (identical(other.logoUri, logoUri) ||
                const DeepCollectionEquality()
                    .equals(other.logoUri, logoUri)) &&
            (identical(other.registry, registry) ||
                const DeepCollectionEquality()
                    .equals(other.registry, registry)) &&
            (identical(other.registeredEntityName, registeredEntityName) ||
                const DeepCollectionEquality().equals(
                    other.registeredEntityName, registeredEntityName)) &&
            (identical(other.registeredEntityId, registeredEntityId) ||
                const DeepCollectionEquality()
                    .equals(other.registeredEntityId, registeredEntityId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(homeUri) ^
      const DeepCollectionEquality().hash(logoUri) ^
      const DeepCollectionEquality().hash(registry) ^
      const DeepCollectionEquality().hash(registeredEntityName) ^
      const DeepCollectionEquality().hash(registeredEntityId) ^
      runtimeType.hashCode;
}

extension $FDXPartyExtension on FDXParty {
  FDXParty copyWith(
      {String? name,
      enums.FDXPartyType? type,
      String? homeUri,
      String? logoUri,
      enums.FDXPartyRegistry? registry,
      String? registeredEntityName,
      String? registeredEntityId}) {
    return FDXParty(
        name: name ?? this.name,
        type: type ?? this.type,
        homeUri: homeUri ?? this.homeUri,
        logoUri: logoUri ?? this.logoUri,
        registry: registry ?? this.registry,
        registeredEntityName: registeredEntityName ?? this.registeredEntityName,
        registeredEntityId: registeredEntityId ?? this.registeredEntityId);
  }

  FDXParty copyWithWrapped(
      {Wrapped<String>? name,
      Wrapped<enums.FDXPartyType>? type,
      Wrapped<String?>? homeUri,
      Wrapped<String?>? logoUri,
      Wrapped<enums.FDXPartyRegistry?>? registry,
      Wrapped<String?>? registeredEntityName,
      Wrapped<String?>? registeredEntityId}) {
    return FDXParty(
        name: (name != null ? name.value : this.name),
        type: (type != null ? type.value : this.type),
        homeUri: (homeUri != null ? homeUri.value : this.homeUri),
        logoUri: (logoUri != null ? logoUri.value : this.logoUri),
        registry: (registry != null ? registry.value : this.registry),
        registeredEntityName: (registeredEntityName != null
            ? registeredEntityName.value
            : this.registeredEntityName),
        registeredEntityId: (registeredEntityId != null
            ? registeredEntityId.value
            : this.registeredEntityId));
  }
}

@JsonSerializable(explicitToJson: true)
class FDXFiAttribute {
  FDXFiAttribute({
    this.name,
    this.value,
  });

  factory FDXFiAttribute.fromJson(Map<String, dynamic> json) =>
      _$FDXFiAttributeFromJson(json);

  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'value')
  final String? value;
  static const fromJsonFactory = _$FDXFiAttributeFromJson;
  static const toJsonFactory = _$FDXFiAttributeToJson;
  Map<String, dynamic> toJson() => _$FDXFiAttributeToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is FDXFiAttribute &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.value, value) ||
                const DeepCollectionEquality().equals(other.value, value)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(value) ^
      runtimeType.hashCode;
}

extension $FDXFiAttributeExtension on FDXFiAttribute {
  FDXFiAttribute copyWith({String? name, String? value}) {
    return FDXFiAttribute(name: name ?? this.name, value: value ?? this.value);
  }

  FDXFiAttribute copyWithWrapped(
      {Wrapped<String?>? name, Wrapped<String?>? value}) {
    return FDXFiAttribute(
        name: (name != null ? name.value : this.name),
        value: (value != null ? value.value : this.value));
  }
}

@JsonSerializable(explicitToJson: true)
class FDXNotificationPayload {
  FDXNotificationPayload({
    this.id,
    this.idType,
    this.customFields,
  });

  factory FDXNotificationPayload.fromJson(Map<String, dynamic> json) =>
      _$FDXNotificationPayloadFromJson(json);

  @JsonKey(name: 'id')
  final String? id;
  @JsonKey(
    name: 'idType',
    toJson: fDXNotificationPayloadIdTypeToJson,
    fromJson: fDXNotificationPayloadIdTypeFromJson,
  )
  final enums.FDXNotificationPayloadIdType? idType;
  @JsonKey(name: 'customFields')
  final FDXFiAttribute? customFields;
  static const fromJsonFactory = _$FDXNotificationPayloadFromJson;
  static const toJsonFactory = _$FDXNotificationPayloadToJson;
  Map<String, dynamic> toJson() => _$FDXNotificationPayloadToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is FDXNotificationPayload &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.idType, idType) ||
                const DeepCollectionEquality().equals(other.idType, idType)) &&
            (identical(other.customFields, customFields) ||
                const DeepCollectionEquality()
                    .equals(other.customFields, customFields)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(idType) ^
      const DeepCollectionEquality().hash(customFields) ^
      runtimeType.hashCode;
}

extension $FDXNotificationPayloadExtension on FDXNotificationPayload {
  FDXNotificationPayload copyWith(
      {String? id,
      enums.FDXNotificationPayloadIdType? idType,
      FDXFiAttribute? customFields}) {
    return FDXNotificationPayload(
        id: id ?? this.id,
        idType: idType ?? this.idType,
        customFields: customFields ?? this.customFields);
  }

  FDXNotificationPayload copyWithWrapped(
      {Wrapped<String?>? id,
      Wrapped<enums.FDXNotificationPayloadIdType?>? idType,
      Wrapped<FDXFiAttribute?>? customFields}) {
    return FDXNotificationPayload(
        id: (id != null ? id.value : this.id),
        idType: (idType != null ? idType.value : this.idType),
        customFields:
            (customFields != null ? customFields.value : this.customFields));
  }
}

@JsonSerializable(explicitToJson: true)
class FDXHateoasLink {
  FDXHateoasLink({
    required this.href,
    this.action,
    this.rel,
    this.types,
  });

  factory FDXHateoasLink.fromJson(Map<String, dynamic> json) =>
      _$FDXHateoasLinkFromJson(json);

  @JsonKey(name: 'href')
  final String href;
  @JsonKey(
    name: 'action',
    toJson: fDXHateoasLinkActionToJson,
    fromJson: fDXHateoasLinkActionFromJson,
  )
  final enums.FDXHateoasLinkAction? action;
  @JsonKey(name: 'rel')
  final String? rel;
  @JsonKey(
    name: 'types',
    toJson: fDXContentTypesListToJson,
    fromJson: fDXContentTypesListFromJson,
  )
  final List<enums.FDXContentTypes>? types;
  static const fromJsonFactory = _$FDXHateoasLinkFromJson;
  static const toJsonFactory = _$FDXHateoasLinkToJson;
  Map<String, dynamic> toJson() => _$FDXHateoasLinkToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is FDXHateoasLink &&
            (identical(other.href, href) ||
                const DeepCollectionEquality().equals(other.href, href)) &&
            (identical(other.action, action) ||
                const DeepCollectionEquality().equals(other.action, action)) &&
            (identical(other.rel, rel) ||
                const DeepCollectionEquality().equals(other.rel, rel)) &&
            (identical(other.types, types) ||
                const DeepCollectionEquality().equals(other.types, types)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(href) ^
      const DeepCollectionEquality().hash(action) ^
      const DeepCollectionEquality().hash(rel) ^
      const DeepCollectionEquality().hash(types) ^
      runtimeType.hashCode;
}

extension $FDXHateoasLinkExtension on FDXHateoasLink {
  FDXHateoasLink copyWith(
      {String? href,
      enums.FDXHateoasLinkAction? action,
      String? rel,
      List<enums.FDXContentTypes>? types}) {
    return FDXHateoasLink(
        href: href ?? this.href,
        action: action ?? this.action,
        rel: rel ?? this.rel,
        types: types ?? this.types);
  }

  FDXHateoasLink copyWithWrapped(
      {Wrapped<String>? href,
      Wrapped<enums.FDXHateoasLinkAction?>? action,
      Wrapped<String?>? rel,
      Wrapped<List<enums.FDXContentTypes>?>? types}) {
    return FDXHateoasLink(
        href: (href != null ? href.value : this.href),
        action: (action != null ? action.value : this.action),
        rel: (rel != null ? rel.value : this.rel),
        types: (types != null ? types.value : this.types));
  }
}

@JsonSerializable(explicitToJson: true)
class FDXNotification {
  FDXNotification({
    required this.notificationId,
    required this.type,
    required this.sentOn,
    required this.category,
    this.severity,
    this.priority,
    required this.publisher,
    this.subscriber,
    required this.notificationPayload,
    this.url,
  });

  factory FDXNotification.fromJson(Map<String, dynamic> json) =>
      _$FDXNotificationFromJson(json);

  @JsonKey(name: 'notificationId')
  final String notificationId;
  @JsonKey(
    name: 'type',
    toJson: fDXNotificationTypeToJson,
    fromJson: fDXNotificationTypeFromJson,
  )
  final enums.FDXNotificationType type;
  @JsonKey(name: 'sentOn')
  final String sentOn;
  @JsonKey(
    name: 'category',
    toJson: fDXNotificationCategoryToJson,
    fromJson: fDXNotificationCategoryFromJson,
  )
  final enums.FDXNotificationCategory category;
  @JsonKey(
    name: 'severity',
    toJson: fDXNotificationSeverityToJson,
    fromJson: fDXNotificationSeverityFromJson,
  )
  final enums.FDXNotificationSeverity? severity;
  @JsonKey(
    name: 'priority',
    toJson: fDXNotificationPriorityToJson,
    fromJson: fDXNotificationPriorityFromJson,
  )
  final enums.FDXNotificationPriority? priority;
  @JsonKey(name: 'publisher')
  final FDXParty publisher;
  @JsonKey(name: 'subscriber')
  final FDXParty? subscriber;
  @JsonKey(name: 'notificationPayload')
  final FDXNotificationPayload notificationPayload;
  @JsonKey(name: 'url')
  final FDXHateoasLink? url;
  static const fromJsonFactory = _$FDXNotificationFromJson;
  static const toJsonFactory = _$FDXNotificationToJson;
  Map<String, dynamic> toJson() => _$FDXNotificationToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is FDXNotification &&
            (identical(other.notificationId, notificationId) ||
                const DeepCollectionEquality()
                    .equals(other.notificationId, notificationId)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.sentOn, sentOn) ||
                const DeepCollectionEquality().equals(other.sentOn, sentOn)) &&
            (identical(other.category, category) ||
                const DeepCollectionEquality()
                    .equals(other.category, category)) &&
            (identical(other.severity, severity) ||
                const DeepCollectionEquality()
                    .equals(other.severity, severity)) &&
            (identical(other.priority, priority) ||
                const DeepCollectionEquality()
                    .equals(other.priority, priority)) &&
            (identical(other.publisher, publisher) ||
                const DeepCollectionEquality()
                    .equals(other.publisher, publisher)) &&
            (identical(other.subscriber, subscriber) ||
                const DeepCollectionEquality()
                    .equals(other.subscriber, subscriber)) &&
            (identical(other.notificationPayload, notificationPayload) ||
                const DeepCollectionEquality()
                    .equals(other.notificationPayload, notificationPayload)) &&
            (identical(other.url, url) ||
                const DeepCollectionEquality().equals(other.url, url)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(notificationId) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(sentOn) ^
      const DeepCollectionEquality().hash(category) ^
      const DeepCollectionEquality().hash(severity) ^
      const DeepCollectionEquality().hash(priority) ^
      const DeepCollectionEquality().hash(publisher) ^
      const DeepCollectionEquality().hash(subscriber) ^
      const DeepCollectionEquality().hash(notificationPayload) ^
      const DeepCollectionEquality().hash(url) ^
      runtimeType.hashCode;
}

extension $FDXNotificationExtension on FDXNotification {
  FDXNotification copyWith(
      {String? notificationId,
      enums.FDXNotificationType? type,
      String? sentOn,
      enums.FDXNotificationCategory? category,
      enums.FDXNotificationSeverity? severity,
      enums.FDXNotificationPriority? priority,
      FDXParty? publisher,
      FDXParty? subscriber,
      FDXNotificationPayload? notificationPayload,
      FDXHateoasLink? url}) {
    return FDXNotification(
        notificationId: notificationId ?? this.notificationId,
        type: type ?? this.type,
        sentOn: sentOn ?? this.sentOn,
        category: category ?? this.category,
        severity: severity ?? this.severity,
        priority: priority ?? this.priority,
        publisher: publisher ?? this.publisher,
        subscriber: subscriber ?? this.subscriber,
        notificationPayload: notificationPayload ?? this.notificationPayload,
        url: url ?? this.url);
  }

  FDXNotification copyWithWrapped(
      {Wrapped<String>? notificationId,
      Wrapped<enums.FDXNotificationType>? type,
      Wrapped<String>? sentOn,
      Wrapped<enums.FDXNotificationCategory>? category,
      Wrapped<enums.FDXNotificationSeverity?>? severity,
      Wrapped<enums.FDXNotificationPriority?>? priority,
      Wrapped<FDXParty>? publisher,
      Wrapped<FDXParty?>? subscriber,
      Wrapped<FDXNotificationPayload>? notificationPayload,
      Wrapped<FDXHateoasLink?>? url}) {
    return FDXNotification(
        notificationId: (notificationId != null
            ? notificationId.value
            : this.notificationId),
        type: (type != null ? type.value : this.type),
        sentOn: (sentOn != null ? sentOn.value : this.sentOn),
        category: (category != null ? category.value : this.category),
        severity: (severity != null ? severity.value : this.severity),
        priority: (priority != null ? priority.value : this.priority),
        publisher: (publisher != null ? publisher.value : this.publisher),
        subscriber: (subscriber != null ? subscriber.value : this.subscriber),
        notificationPayload: (notificationPayload != null
            ? notificationPayload.value
            : this.notificationPayload),
        url: (url != null ? url.value : this.url));
  }
}

String? webhookEnvironmentValuesToJson(
    enums.WebhookEnvironmentValues? webhookEnvironmentValues) {
  return enums.$WebhookEnvironmentValuesMap[webhookEnvironmentValues];
}

enums.WebhookEnvironmentValues webhookEnvironmentValuesFromJson(
  Object? webhookEnvironmentValues, [
  enums.WebhookEnvironmentValues? defaultValue,
]) {
  if (webhookEnvironmentValues is String) {
    return enums.$WebhookEnvironmentValuesMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                webhookEnvironmentValues.toLowerCase(),
            orElse: () => const MapEntry(
                enums.WebhookEnvironmentValues.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$WebhookEnvironmentValuesMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.WebhookEnvironmentValues.swaggerGeneratedUnknown;
}

List<String> webhookEnvironmentValuesListToJson(
    List<enums.WebhookEnvironmentValues>? webhookEnvironmentValues) {
  if (webhookEnvironmentValues == null) {
    return [];
  }

  return webhookEnvironmentValues
      .map((e) => enums.$WebhookEnvironmentValuesMap[e]!)
      .toList();
}

List<enums.WebhookEnvironmentValues> webhookEnvironmentValuesListFromJson(
  List? webhookEnvironmentValues, [
  List<enums.WebhookEnvironmentValues>? defaultValue,
]) {
  if (webhookEnvironmentValues == null) {
    return defaultValue ?? [];
  }

  return webhookEnvironmentValues
      .map((e) => webhookEnvironmentValuesFromJson(e.toString()))
      .toList();
}

List<enums.WebhookEnvironmentValues>?
    webhookEnvironmentValuesNullableListFromJson(
  List? webhookEnvironmentValues, [
  List<enums.WebhookEnvironmentValues>? defaultValue,
]) {
  if (webhookEnvironmentValues == null) {
    return defaultValue;
  }

  return webhookEnvironmentValues
      .map((e) => webhookEnvironmentValuesFromJson(e.toString()))
      .toList();
}

String? sandboxItemFireWebhookRequestWebhookCodeToJson(
    enums.SandboxItemFireWebhookRequestWebhookCode?
        sandboxItemFireWebhookRequestWebhookCode) {
  return enums.$SandboxItemFireWebhookRequestWebhookCodeMap[
      sandboxItemFireWebhookRequestWebhookCode];
}

enums.SandboxItemFireWebhookRequestWebhookCode
    sandboxItemFireWebhookRequestWebhookCodeFromJson(
  Object? sandboxItemFireWebhookRequestWebhookCode, [
  enums.SandboxItemFireWebhookRequestWebhookCode? defaultValue,
]) {
  if (sandboxItemFireWebhookRequestWebhookCode is String) {
    return enums.$SandboxItemFireWebhookRequestWebhookCodeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                sandboxItemFireWebhookRequestWebhookCode.toLowerCase(),
            orElse: () => const MapEntry(
                enums.SandboxItemFireWebhookRequestWebhookCode
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$SandboxItemFireWebhookRequestWebhookCodeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.SandboxItemFireWebhookRequestWebhookCode.swaggerGeneratedUnknown;
}

List<String> sandboxItemFireWebhookRequestWebhookCodeListToJson(
    List<enums.SandboxItemFireWebhookRequestWebhookCode>?
        sandboxItemFireWebhookRequestWebhookCode) {
  if (sandboxItemFireWebhookRequestWebhookCode == null) {
    return [];
  }

  return sandboxItemFireWebhookRequestWebhookCode
      .map((e) => enums.$SandboxItemFireWebhookRequestWebhookCodeMap[e]!)
      .toList();
}

List<enums.SandboxItemFireWebhookRequestWebhookCode>
    sandboxItemFireWebhookRequestWebhookCodeListFromJson(
  List? sandboxItemFireWebhookRequestWebhookCode, [
  List<enums.SandboxItemFireWebhookRequestWebhookCode>? defaultValue,
]) {
  if (sandboxItemFireWebhookRequestWebhookCode == null) {
    return defaultValue ?? [];
  }

  return sandboxItemFireWebhookRequestWebhookCode
      .map(
          (e) => sandboxItemFireWebhookRequestWebhookCodeFromJson(e.toString()))
      .toList();
}

List<enums.SandboxItemFireWebhookRequestWebhookCode>?
    sandboxItemFireWebhookRequestWebhookCodeNullableListFromJson(
  List? sandboxItemFireWebhookRequestWebhookCode, [
  List<enums.SandboxItemFireWebhookRequestWebhookCode>? defaultValue,
]) {
  if (sandboxItemFireWebhookRequestWebhookCode == null) {
    return defaultValue;
  }

  return sandboxItemFireWebhookRequestWebhookCode
      .map(
          (e) => sandboxItemFireWebhookRequestWebhookCodeFromJson(e.toString()))
      .toList();
}

String? webhookTypeToJson(enums.WebhookType? webhookType) {
  return enums.$WebhookTypeMap[webhookType];
}

enums.WebhookType webhookTypeFromJson(
  Object? webhookType, [
  enums.WebhookType? defaultValue,
]) {
  if (webhookType is String) {
    return enums.$WebhookTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == webhookType.toLowerCase(),
            orElse: () =>
                const MapEntry(enums.WebhookType.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$WebhookTypeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.WebhookType.swaggerGeneratedUnknown;
}

List<String> webhookTypeListToJson(List<enums.WebhookType>? webhookType) {
  if (webhookType == null) {
    return [];
  }

  return webhookType.map((e) => enums.$WebhookTypeMap[e]!).toList();
}

List<enums.WebhookType> webhookTypeListFromJson(
  List? webhookType, [
  List<enums.WebhookType>? defaultValue,
]) {
  if (webhookType == null) {
    return defaultValue ?? [];
  }

  return webhookType.map((e) => webhookTypeFromJson(e.toString())).toList();
}

List<enums.WebhookType>? webhookTypeNullableListFromJson(
  List? webhookType, [
  List<enums.WebhookType>? defaultValue,
]) {
  if (webhookType == null) {
    return defaultValue;
  }

  return webhookType.map((e) => webhookTypeFromJson(e.toString())).toList();
}

String? paymentInitiationPaymentCreateStatusToJson(
    enums.PaymentInitiationPaymentCreateStatus?
        paymentInitiationPaymentCreateStatus) {
  return enums.$PaymentInitiationPaymentCreateStatusMap[
      paymentInitiationPaymentCreateStatus];
}

enums.PaymentInitiationPaymentCreateStatus
    paymentInitiationPaymentCreateStatusFromJson(
  Object? paymentInitiationPaymentCreateStatus, [
  enums.PaymentInitiationPaymentCreateStatus? defaultValue,
]) {
  if (paymentInitiationPaymentCreateStatus is String) {
    return enums.$PaymentInitiationPaymentCreateStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                paymentInitiationPaymentCreateStatus.toLowerCase(),
            orElse: () => const MapEntry(
                enums.PaymentInitiationPaymentCreateStatus
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$PaymentInitiationPaymentCreateStatusMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.PaymentInitiationPaymentCreateStatus.swaggerGeneratedUnknown;
}

List<String> paymentInitiationPaymentCreateStatusListToJson(
    List<enums.PaymentInitiationPaymentCreateStatus>?
        paymentInitiationPaymentCreateStatus) {
  if (paymentInitiationPaymentCreateStatus == null) {
    return [];
  }

  return paymentInitiationPaymentCreateStatus
      .map((e) => enums.$PaymentInitiationPaymentCreateStatusMap[e]!)
      .toList();
}

List<enums.PaymentInitiationPaymentCreateStatus>
    paymentInitiationPaymentCreateStatusListFromJson(
  List? paymentInitiationPaymentCreateStatus, [
  List<enums.PaymentInitiationPaymentCreateStatus>? defaultValue,
]) {
  if (paymentInitiationPaymentCreateStatus == null) {
    return defaultValue ?? [];
  }

  return paymentInitiationPaymentCreateStatus
      .map((e) => paymentInitiationPaymentCreateStatusFromJson(e.toString()))
      .toList();
}

List<enums.PaymentInitiationPaymentCreateStatus>?
    paymentInitiationPaymentCreateStatusNullableListFromJson(
  List? paymentInitiationPaymentCreateStatus, [
  List<enums.PaymentInitiationPaymentCreateStatus>? defaultValue,
]) {
  if (paymentInitiationPaymentCreateStatus == null) {
    return defaultValue;
  }

  return paymentInitiationPaymentCreateStatus
      .map((e) => paymentInitiationPaymentCreateStatusFromJson(e.toString()))
      .toList();
}

String? sandboxItemSetVerificationStatusRequestVerificationStatusToJson(
    enums.SandboxItemSetVerificationStatusRequestVerificationStatus?
        sandboxItemSetVerificationStatusRequestVerificationStatus) {
  return enums.$SandboxItemSetVerificationStatusRequestVerificationStatusMap[
      sandboxItemSetVerificationStatusRequestVerificationStatus];
}

enums.SandboxItemSetVerificationStatusRequestVerificationStatus
    sandboxItemSetVerificationStatusRequestVerificationStatusFromJson(
  Object? sandboxItemSetVerificationStatusRequestVerificationStatus, [
  enums.SandboxItemSetVerificationStatusRequestVerificationStatus? defaultValue,
]) {
  if (sandboxItemSetVerificationStatusRequestVerificationStatus is String) {
    return enums
        .$SandboxItemSetVerificationStatusRequestVerificationStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                sandboxItemSetVerificationStatusRequestVerificationStatus
                    .toLowerCase(),
            orElse: () => const MapEntry(
                enums.SandboxItemSetVerificationStatusRequestVerificationStatus
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums
          .$SandboxItemSetVerificationStatusRequestVerificationStatusMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.SandboxItemSetVerificationStatusRequestVerificationStatus
          .swaggerGeneratedUnknown;
}

List<String>
    sandboxItemSetVerificationStatusRequestVerificationStatusListToJson(
        List<enums.SandboxItemSetVerificationStatusRequestVerificationStatus>?
            sandboxItemSetVerificationStatusRequestVerificationStatus) {
  if (sandboxItemSetVerificationStatusRequestVerificationStatus == null) {
    return [];
  }

  return sandboxItemSetVerificationStatusRequestVerificationStatus
      .map((e) => enums
          .$SandboxItemSetVerificationStatusRequestVerificationStatusMap[e]!)
      .toList();
}

List<enums.SandboxItemSetVerificationStatusRequestVerificationStatus>
    sandboxItemSetVerificationStatusRequestVerificationStatusListFromJson(
  List? sandboxItemSetVerificationStatusRequestVerificationStatus, [
  List<enums.SandboxItemSetVerificationStatusRequestVerificationStatus>?
      defaultValue,
]) {
  if (sandboxItemSetVerificationStatusRequestVerificationStatus == null) {
    return defaultValue ?? [];
  }

  return sandboxItemSetVerificationStatusRequestVerificationStatus
      .map((e) =>
          sandboxItemSetVerificationStatusRequestVerificationStatusFromJson(
              e.toString()))
      .toList();
}

List<enums.SandboxItemSetVerificationStatusRequestVerificationStatus>?
    sandboxItemSetVerificationStatusRequestVerificationStatusNullableListFromJson(
  List? sandboxItemSetVerificationStatusRequestVerificationStatus, [
  List<enums.SandboxItemSetVerificationStatusRequestVerificationStatus>?
      defaultValue,
]) {
  if (sandboxItemSetVerificationStatusRequestVerificationStatus == null) {
    return defaultValue;
  }

  return sandboxItemSetVerificationStatusRequestVerificationStatus
      .map((e) =>
          sandboxItemSetVerificationStatusRequestVerificationStatusFromJson(
              e.toString()))
      .toList();
}

String? creditSessionBankIncomeStatusToJson(
    enums.CreditSessionBankIncomeStatus? creditSessionBankIncomeStatus) {
  return enums.$CreditSessionBankIncomeStatusMap[creditSessionBankIncomeStatus];
}

enums.CreditSessionBankIncomeStatus creditSessionBankIncomeStatusFromJson(
  Object? creditSessionBankIncomeStatus, [
  enums.CreditSessionBankIncomeStatus? defaultValue,
]) {
  if (creditSessionBankIncomeStatus is String) {
    return enums.$CreditSessionBankIncomeStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                creditSessionBankIncomeStatus.toLowerCase(),
            orElse: () => const MapEntry(
                enums.CreditSessionBankIncomeStatus.swaggerGeneratedUnknown,
                ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$CreditSessionBankIncomeStatusMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.CreditSessionBankIncomeStatus.swaggerGeneratedUnknown;
}

List<String> creditSessionBankIncomeStatusListToJson(
    List<enums.CreditSessionBankIncomeStatus>? creditSessionBankIncomeStatus) {
  if (creditSessionBankIncomeStatus == null) {
    return [];
  }

  return creditSessionBankIncomeStatus
      .map((e) => enums.$CreditSessionBankIncomeStatusMap[e]!)
      .toList();
}

List<enums.CreditSessionBankIncomeStatus>
    creditSessionBankIncomeStatusListFromJson(
  List? creditSessionBankIncomeStatus, [
  List<enums.CreditSessionBankIncomeStatus>? defaultValue,
]) {
  if (creditSessionBankIncomeStatus == null) {
    return defaultValue ?? [];
  }

  return creditSessionBankIncomeStatus
      .map((e) => creditSessionBankIncomeStatusFromJson(e.toString()))
      .toList();
}

List<enums.CreditSessionBankIncomeStatus>?
    creditSessionBankIncomeStatusNullableListFromJson(
  List? creditSessionBankIncomeStatus, [
  List<enums.CreditSessionBankIncomeStatus>? defaultValue,
]) {
  if (creditSessionBankIncomeStatus == null) {
    return defaultValue;
  }

  return creditSessionBankIncomeStatus
      .map((e) => creditSessionBankIncomeStatusFromJson(e.toString()))
      .toList();
}

String? paymentInitiationPaymentStatusToJson(
    enums.PaymentInitiationPaymentStatus? paymentInitiationPaymentStatus) {
  return enums
      .$PaymentInitiationPaymentStatusMap[paymentInitiationPaymentStatus];
}

enums.PaymentInitiationPaymentStatus paymentInitiationPaymentStatusFromJson(
  Object? paymentInitiationPaymentStatus, [
  enums.PaymentInitiationPaymentStatus? defaultValue,
]) {
  if (paymentInitiationPaymentStatus is String) {
    return enums.$PaymentInitiationPaymentStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                paymentInitiationPaymentStatus.toLowerCase(),
            orElse: () => const MapEntry(
                enums.PaymentInitiationPaymentStatus.swaggerGeneratedUnknown,
                ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$PaymentInitiationPaymentStatusMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.PaymentInitiationPaymentStatus.swaggerGeneratedUnknown;
}

List<String> paymentInitiationPaymentStatusListToJson(
    List<enums.PaymentInitiationPaymentStatus>?
        paymentInitiationPaymentStatus) {
  if (paymentInitiationPaymentStatus == null) {
    return [];
  }

  return paymentInitiationPaymentStatus
      .map((e) => enums.$PaymentInitiationPaymentStatusMap[e]!)
      .toList();
}

List<enums.PaymentInitiationPaymentStatus>
    paymentInitiationPaymentStatusListFromJson(
  List? paymentInitiationPaymentStatus, [
  List<enums.PaymentInitiationPaymentStatus>? defaultValue,
]) {
  if (paymentInitiationPaymentStatus == null) {
    return defaultValue ?? [];
  }

  return paymentInitiationPaymentStatus
      .map((e) => paymentInitiationPaymentStatusFromJson(e.toString()))
      .toList();
}

List<enums.PaymentInitiationPaymentStatus>?
    paymentInitiationPaymentStatusNullableListFromJson(
  List? paymentInitiationPaymentStatus, [
  List<enums.PaymentInitiationPaymentStatus>? defaultValue,
]) {
  if (paymentInitiationPaymentStatus == null) {
    return defaultValue;
  }

  return paymentInitiationPaymentStatus
      .map((e) => paymentInitiationPaymentStatusFromJson(e.toString()))
      .toList();
}

String? paymentInitiationConsentStatusToJson(
    enums.PaymentInitiationConsentStatus? paymentInitiationConsentStatus) {
  return enums
      .$PaymentInitiationConsentStatusMap[paymentInitiationConsentStatus];
}

enums.PaymentInitiationConsentStatus paymentInitiationConsentStatusFromJson(
  Object? paymentInitiationConsentStatus, [
  enums.PaymentInitiationConsentStatus? defaultValue,
]) {
  if (paymentInitiationConsentStatus is String) {
    return enums.$PaymentInitiationConsentStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                paymentInitiationConsentStatus.toLowerCase(),
            orElse: () => const MapEntry(
                enums.PaymentInitiationConsentStatus.swaggerGeneratedUnknown,
                ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$PaymentInitiationConsentStatusMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.PaymentInitiationConsentStatus.swaggerGeneratedUnknown;
}

List<String> paymentInitiationConsentStatusListToJson(
    List<enums.PaymentInitiationConsentStatus>?
        paymentInitiationConsentStatus) {
  if (paymentInitiationConsentStatus == null) {
    return [];
  }

  return paymentInitiationConsentStatus
      .map((e) => enums.$PaymentInitiationConsentStatusMap[e]!)
      .toList();
}

List<enums.PaymentInitiationConsentStatus>
    paymentInitiationConsentStatusListFromJson(
  List? paymentInitiationConsentStatus, [
  List<enums.PaymentInitiationConsentStatus>? defaultValue,
]) {
  if (paymentInitiationConsentStatus == null) {
    return defaultValue ?? [];
  }

  return paymentInitiationConsentStatus
      .map((e) => paymentInitiationConsentStatusFromJson(e.toString()))
      .toList();
}

List<enums.PaymentInitiationConsentStatus>?
    paymentInitiationConsentStatusNullableListFromJson(
  List? paymentInitiationConsentStatus, [
  List<enums.PaymentInitiationConsentStatus>? defaultValue,
]) {
  if (paymentInitiationConsentStatus == null) {
    return defaultValue;
  }

  return paymentInitiationConsentStatus
      .map((e) => paymentInitiationConsentStatusFromJson(e.toString()))
      .toList();
}

String? processorTokenCreateRequestProcessorToJson(
    enums.ProcessorTokenCreateRequestProcessor?
        processorTokenCreateRequestProcessor) {
  return enums.$ProcessorTokenCreateRequestProcessorMap[
      processorTokenCreateRequestProcessor];
}

enums.ProcessorTokenCreateRequestProcessor
    processorTokenCreateRequestProcessorFromJson(
  Object? processorTokenCreateRequestProcessor, [
  enums.ProcessorTokenCreateRequestProcessor? defaultValue,
]) {
  if (processorTokenCreateRequestProcessor is String) {
    return enums.$ProcessorTokenCreateRequestProcessorMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                processorTokenCreateRequestProcessor.toLowerCase(),
            orElse: () => const MapEntry(
                enums.ProcessorTokenCreateRequestProcessor
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$ProcessorTokenCreateRequestProcessorMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.ProcessorTokenCreateRequestProcessor.swaggerGeneratedUnknown;
}

List<String> processorTokenCreateRequestProcessorListToJson(
    List<enums.ProcessorTokenCreateRequestProcessor>?
        processorTokenCreateRequestProcessor) {
  if (processorTokenCreateRequestProcessor == null) {
    return [];
  }

  return processorTokenCreateRequestProcessor
      .map((e) => enums.$ProcessorTokenCreateRequestProcessorMap[e]!)
      .toList();
}

List<enums.ProcessorTokenCreateRequestProcessor>
    processorTokenCreateRequestProcessorListFromJson(
  List? processorTokenCreateRequestProcessor, [
  List<enums.ProcessorTokenCreateRequestProcessor>? defaultValue,
]) {
  if (processorTokenCreateRequestProcessor == null) {
    return defaultValue ?? [];
  }

  return processorTokenCreateRequestProcessor
      .map((e) => processorTokenCreateRequestProcessorFromJson(e.toString()))
      .toList();
}

List<enums.ProcessorTokenCreateRequestProcessor>?
    processorTokenCreateRequestProcessorNullableListFromJson(
  List? processorTokenCreateRequestProcessor, [
  List<enums.ProcessorTokenCreateRequestProcessor>? defaultValue,
]) {
  if (processorTokenCreateRequestProcessor == null) {
    return defaultValue;
  }

  return processorTokenCreateRequestProcessor
      .map((e) => processorTokenCreateRequestProcessorFromJson(e.toString()))
      .toList();
}

String? depositSwitchCreateRequestCountryCodeToJson(
    enums.DepositSwitchCreateRequestCountryCode?
        depositSwitchCreateRequestCountryCode) {
  return enums.$DepositSwitchCreateRequestCountryCodeMap[
      depositSwitchCreateRequestCountryCode];
}

enums.DepositSwitchCreateRequestCountryCode
    depositSwitchCreateRequestCountryCodeFromJson(
  Object? depositSwitchCreateRequestCountryCode, [
  enums.DepositSwitchCreateRequestCountryCode? defaultValue,
]) {
  if (depositSwitchCreateRequestCountryCode is String) {
    return enums.$DepositSwitchCreateRequestCountryCodeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                depositSwitchCreateRequestCountryCode.toLowerCase(),
            orElse: () => const MapEntry(
                enums.DepositSwitchCreateRequestCountryCode
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$DepositSwitchCreateRequestCountryCodeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.DepositSwitchCreateRequestCountryCode.swaggerGeneratedUnknown;
}

List<String> depositSwitchCreateRequestCountryCodeListToJson(
    List<enums.DepositSwitchCreateRequestCountryCode>?
        depositSwitchCreateRequestCountryCode) {
  if (depositSwitchCreateRequestCountryCode == null) {
    return [];
  }

  return depositSwitchCreateRequestCountryCode
      .map((e) => enums.$DepositSwitchCreateRequestCountryCodeMap[e]!)
      .toList();
}

List<enums.DepositSwitchCreateRequestCountryCode>
    depositSwitchCreateRequestCountryCodeListFromJson(
  List? depositSwitchCreateRequestCountryCode, [
  List<enums.DepositSwitchCreateRequestCountryCode>? defaultValue,
]) {
  if (depositSwitchCreateRequestCountryCode == null) {
    return defaultValue ?? [];
  }

  return depositSwitchCreateRequestCountryCode
      .map((e) => depositSwitchCreateRequestCountryCodeFromJson(e.toString()))
      .toList();
}

List<enums.DepositSwitchCreateRequestCountryCode>?
    depositSwitchCreateRequestCountryCodeNullableListFromJson(
  List? depositSwitchCreateRequestCountryCode, [
  List<enums.DepositSwitchCreateRequestCountryCode>? defaultValue,
]) {
  if (depositSwitchCreateRequestCountryCode == null) {
    return defaultValue;
  }

  return depositSwitchCreateRequestCountryCode
      .map((e) => depositSwitchCreateRequestCountryCodeFromJson(e.toString()))
      .toList();
}

String? userStatedIncomeSourceCategoryToJson(
    enums.UserStatedIncomeSourceCategory? userStatedIncomeSourceCategory) {
  return enums
      .$UserStatedIncomeSourceCategoryMap[userStatedIncomeSourceCategory];
}

enums.UserStatedIncomeSourceCategory userStatedIncomeSourceCategoryFromJson(
  Object? userStatedIncomeSourceCategory, [
  enums.UserStatedIncomeSourceCategory? defaultValue,
]) {
  if (userStatedIncomeSourceCategory is String) {
    return enums.$UserStatedIncomeSourceCategoryMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                userStatedIncomeSourceCategory.toLowerCase(),
            orElse: () => const MapEntry(
                enums.UserStatedIncomeSourceCategory.swaggerGeneratedUnknown,
                ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$UserStatedIncomeSourceCategoryMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.UserStatedIncomeSourceCategory.swaggerGeneratedUnknown;
}

List<String> userStatedIncomeSourceCategoryListToJson(
    List<enums.UserStatedIncomeSourceCategory>?
        userStatedIncomeSourceCategory) {
  if (userStatedIncomeSourceCategory == null) {
    return [];
  }

  return userStatedIncomeSourceCategory
      .map((e) => enums.$UserStatedIncomeSourceCategoryMap[e]!)
      .toList();
}

List<enums.UserStatedIncomeSourceCategory>
    userStatedIncomeSourceCategoryListFromJson(
  List? userStatedIncomeSourceCategory, [
  List<enums.UserStatedIncomeSourceCategory>? defaultValue,
]) {
  if (userStatedIncomeSourceCategory == null) {
    return defaultValue ?? [];
  }

  return userStatedIncomeSourceCategory
      .map((e) => userStatedIncomeSourceCategoryFromJson(e.toString()))
      .toList();
}

List<enums.UserStatedIncomeSourceCategory>?
    userStatedIncomeSourceCategoryNullableListFromJson(
  List? userStatedIncomeSourceCategory, [
  List<enums.UserStatedIncomeSourceCategory>? defaultValue,
]) {
  if (userStatedIncomeSourceCategory == null) {
    return defaultValue;
  }

  return userStatedIncomeSourceCategory
      .map((e) => userStatedIncomeSourceCategoryFromJson(e.toString()))
      .toList();
}

String? userStatedIncomeSourceFrequencyToJson(
    enums.UserStatedIncomeSourceFrequency? userStatedIncomeSourceFrequency) {
  return enums
      .$UserStatedIncomeSourceFrequencyMap[userStatedIncomeSourceFrequency];
}

enums.UserStatedIncomeSourceFrequency userStatedIncomeSourceFrequencyFromJson(
  Object? userStatedIncomeSourceFrequency, [
  enums.UserStatedIncomeSourceFrequency? defaultValue,
]) {
  if (userStatedIncomeSourceFrequency is String) {
    return enums.$UserStatedIncomeSourceFrequencyMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                userStatedIncomeSourceFrequency.toLowerCase(),
            orElse: () => const MapEntry(
                enums.UserStatedIncomeSourceFrequency.swaggerGeneratedUnknown,
                ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$UserStatedIncomeSourceFrequencyMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.UserStatedIncomeSourceFrequency.swaggerGeneratedUnknown;
}

List<String> userStatedIncomeSourceFrequencyListToJson(
    List<enums.UserStatedIncomeSourceFrequency>?
        userStatedIncomeSourceFrequency) {
  if (userStatedIncomeSourceFrequency == null) {
    return [];
  }

  return userStatedIncomeSourceFrequency
      .map((e) => enums.$UserStatedIncomeSourceFrequencyMap[e]!)
      .toList();
}

List<enums.UserStatedIncomeSourceFrequency>
    userStatedIncomeSourceFrequencyListFromJson(
  List? userStatedIncomeSourceFrequency, [
  List<enums.UserStatedIncomeSourceFrequency>? defaultValue,
]) {
  if (userStatedIncomeSourceFrequency == null) {
    return defaultValue ?? [];
  }

  return userStatedIncomeSourceFrequency
      .map((e) => userStatedIncomeSourceFrequencyFromJson(e.toString()))
      .toList();
}

List<enums.UserStatedIncomeSourceFrequency>?
    userStatedIncomeSourceFrequencyNullableListFromJson(
  List? userStatedIncomeSourceFrequency, [
  List<enums.UserStatedIncomeSourceFrequency>? defaultValue,
]) {
  if (userStatedIncomeSourceFrequency == null) {
    return defaultValue;
  }

  return userStatedIncomeSourceFrequency
      .map((e) => userStatedIncomeSourceFrequencyFromJson(e.toString()))
      .toList();
}

String? userStatedIncomeSourcePayTypeToJson(
    enums.UserStatedIncomeSourcePayType? userStatedIncomeSourcePayType) {
  return enums.$UserStatedIncomeSourcePayTypeMap[userStatedIncomeSourcePayType];
}

enums.UserStatedIncomeSourcePayType userStatedIncomeSourcePayTypeFromJson(
  Object? userStatedIncomeSourcePayType, [
  enums.UserStatedIncomeSourcePayType? defaultValue,
]) {
  if (userStatedIncomeSourcePayType is String) {
    return enums.$UserStatedIncomeSourcePayTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                userStatedIncomeSourcePayType.toLowerCase(),
            orElse: () => const MapEntry(
                enums.UserStatedIncomeSourcePayType.swaggerGeneratedUnknown,
                ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$UserStatedIncomeSourcePayTypeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.UserStatedIncomeSourcePayType.swaggerGeneratedUnknown;
}

List<String> userStatedIncomeSourcePayTypeListToJson(
    List<enums.UserStatedIncomeSourcePayType>? userStatedIncomeSourcePayType) {
  if (userStatedIncomeSourcePayType == null) {
    return [];
  }

  return userStatedIncomeSourcePayType
      .map((e) => enums.$UserStatedIncomeSourcePayTypeMap[e]!)
      .toList();
}

List<enums.UserStatedIncomeSourcePayType>
    userStatedIncomeSourcePayTypeListFromJson(
  List? userStatedIncomeSourcePayType, [
  List<enums.UserStatedIncomeSourcePayType>? defaultValue,
]) {
  if (userStatedIncomeSourcePayType == null) {
    return defaultValue ?? [];
  }

  return userStatedIncomeSourcePayType
      .map((e) => userStatedIncomeSourcePayTypeFromJson(e.toString()))
      .toList();
}

List<enums.UserStatedIncomeSourcePayType>?
    userStatedIncomeSourcePayTypeNullableListFromJson(
  List? userStatedIncomeSourcePayType, [
  List<enums.UserStatedIncomeSourcePayType>? defaultValue,
]) {
  if (userStatedIncomeSourcePayType == null) {
    return defaultValue;
  }

  return userStatedIncomeSourcePayType
      .map((e) => userStatedIncomeSourcePayTypeFromJson(e.toString()))
      .toList();
}

String? linkTokenCreateRequestAuthFlowTypeToJson(
    enums.LinkTokenCreateRequestAuthFlowType?
        linkTokenCreateRequestAuthFlowType) {
  return enums.$LinkTokenCreateRequestAuthFlowTypeMap[
      linkTokenCreateRequestAuthFlowType];
}

enums.LinkTokenCreateRequestAuthFlowType
    linkTokenCreateRequestAuthFlowTypeFromJson(
  Object? linkTokenCreateRequestAuthFlowType, [
  enums.LinkTokenCreateRequestAuthFlowType? defaultValue,
]) {
  if (linkTokenCreateRequestAuthFlowType is String) {
    return enums.$LinkTokenCreateRequestAuthFlowTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                linkTokenCreateRequestAuthFlowType.toLowerCase(),
            orElse: () => const MapEntry(
                enums
                    .LinkTokenCreateRequestAuthFlowType.swaggerGeneratedUnknown,
                ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$LinkTokenCreateRequestAuthFlowTypeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.LinkTokenCreateRequestAuthFlowType.swaggerGeneratedUnknown;
}

List<String> linkTokenCreateRequestAuthFlowTypeListToJson(
    List<enums.LinkTokenCreateRequestAuthFlowType>?
        linkTokenCreateRequestAuthFlowType) {
  if (linkTokenCreateRequestAuthFlowType == null) {
    return [];
  }

  return linkTokenCreateRequestAuthFlowType
      .map((e) => enums.$LinkTokenCreateRequestAuthFlowTypeMap[e]!)
      .toList();
}

List<enums.LinkTokenCreateRequestAuthFlowType>
    linkTokenCreateRequestAuthFlowTypeListFromJson(
  List? linkTokenCreateRequestAuthFlowType, [
  List<enums.LinkTokenCreateRequestAuthFlowType>? defaultValue,
]) {
  if (linkTokenCreateRequestAuthFlowType == null) {
    return defaultValue ?? [];
  }

  return linkTokenCreateRequestAuthFlowType
      .map((e) => linkTokenCreateRequestAuthFlowTypeFromJson(e.toString()))
      .toList();
}

List<enums.LinkTokenCreateRequestAuthFlowType>?
    linkTokenCreateRequestAuthFlowTypeNullableListFromJson(
  List? linkTokenCreateRequestAuthFlowType, [
  List<enums.LinkTokenCreateRequestAuthFlowType>? defaultValue,
]) {
  if (linkTokenCreateRequestAuthFlowType == null) {
    return defaultValue;
  }

  return linkTokenCreateRequestAuthFlowType
      .map((e) => linkTokenCreateRequestAuthFlowTypeFromJson(e.toString()))
      .toList();
}

String? plaidErrorTypeToJson(enums.PlaidErrorType? plaidErrorType) {
  return enums.$PlaidErrorTypeMap[plaidErrorType];
}

enums.PlaidErrorType plaidErrorTypeFromJson(
  Object? plaidErrorType, [
  enums.PlaidErrorType? defaultValue,
]) {
  if (plaidErrorType is String) {
    return enums.$PlaidErrorTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == plaidErrorType.toLowerCase(),
            orElse: () => const MapEntry(
                enums.PlaidErrorType.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$PlaidErrorTypeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.PlaidErrorType.swaggerGeneratedUnknown;
}

List<String> plaidErrorTypeListToJson(
    List<enums.PlaidErrorType>? plaidErrorType) {
  if (plaidErrorType == null) {
    return [];
  }

  return plaidErrorType.map((e) => enums.$PlaidErrorTypeMap[e]!).toList();
}

List<enums.PlaidErrorType> plaidErrorTypeListFromJson(
  List? plaidErrorType, [
  List<enums.PlaidErrorType>? defaultValue,
]) {
  if (plaidErrorType == null) {
    return defaultValue ?? [];
  }

  return plaidErrorType
      .map((e) => plaidErrorTypeFromJson(e.toString()))
      .toList();
}

List<enums.PlaidErrorType>? plaidErrorTypeNullableListFromJson(
  List? plaidErrorType, [
  List<enums.PlaidErrorType>? defaultValue,
]) {
  if (plaidErrorType == null) {
    return defaultValue;
  }

  return plaidErrorType
      .map((e) => plaidErrorTypeFromJson(e.toString()))
      .toList();
}

String? accountTypeToJson(enums.AccountType? accountType) {
  return enums.$AccountTypeMap[accountType];
}

enums.AccountType accountTypeFromJson(
  Object? accountType, [
  enums.AccountType? defaultValue,
]) {
  if (accountType is String) {
    return enums.$AccountTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == accountType.toLowerCase(),
            orElse: () =>
                const MapEntry(enums.AccountType.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$AccountTypeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.AccountType.swaggerGeneratedUnknown;
}

List<String> accountTypeListToJson(List<enums.AccountType>? accountType) {
  if (accountType == null) {
    return [];
  }

  return accountType.map((e) => enums.$AccountTypeMap[e]!).toList();
}

List<enums.AccountType> accountTypeListFromJson(
  List? accountType, [
  List<enums.AccountType>? defaultValue,
]) {
  if (accountType == null) {
    return defaultValue ?? [];
  }

  return accountType.map((e) => accountTypeFromJson(e.toString())).toList();
}

List<enums.AccountType>? accountTypeNullableListFromJson(
  List? accountType, [
  List<enums.AccountType>? defaultValue,
]) {
  if (accountType == null) {
    return defaultValue;
  }

  return accountType.map((e) => accountTypeFromJson(e.toString())).toList();
}

String? overrideAccountTypeToJson(
    enums.OverrideAccountType? overrideAccountType) {
  return enums.$OverrideAccountTypeMap[overrideAccountType];
}

enums.OverrideAccountType overrideAccountTypeFromJson(
  Object? overrideAccountType, [
  enums.OverrideAccountType? defaultValue,
]) {
  if (overrideAccountType is String) {
    return enums.$OverrideAccountTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                overrideAccountType.toLowerCase(),
            orElse: () => const MapEntry(
                enums.OverrideAccountType.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$OverrideAccountTypeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.OverrideAccountType.swaggerGeneratedUnknown;
}

List<String> overrideAccountTypeListToJson(
    List<enums.OverrideAccountType>? overrideAccountType) {
  if (overrideAccountType == null) {
    return [];
  }

  return overrideAccountType
      .map((e) => enums.$OverrideAccountTypeMap[e]!)
      .toList();
}

List<enums.OverrideAccountType> overrideAccountTypeListFromJson(
  List? overrideAccountType, [
  List<enums.OverrideAccountType>? defaultValue,
]) {
  if (overrideAccountType == null) {
    return defaultValue ?? [];
  }

  return overrideAccountType
      .map((e) => overrideAccountTypeFromJson(e.toString()))
      .toList();
}

List<enums.OverrideAccountType>? overrideAccountTypeNullableListFromJson(
  List? overrideAccountType, [
  List<enums.OverrideAccountType>? defaultValue,
]) {
  if (overrideAccountType == null) {
    return defaultValue;
  }

  return overrideAccountType
      .map((e) => overrideAccountTypeFromJson(e.toString()))
      .toList();
}

String? accountBaseVerificationStatusToJson(
    enums.AccountBaseVerificationStatus? accountBaseVerificationStatus) {
  return enums.$AccountBaseVerificationStatusMap[accountBaseVerificationStatus];
}

enums.AccountBaseVerificationStatus accountBaseVerificationStatusFromJson(
  Object? accountBaseVerificationStatus, [
  enums.AccountBaseVerificationStatus? defaultValue,
]) {
  if (accountBaseVerificationStatus is String) {
    return enums.$AccountBaseVerificationStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                accountBaseVerificationStatus.toLowerCase(),
            orElse: () => const MapEntry(
                enums.AccountBaseVerificationStatus.swaggerGeneratedUnknown,
                ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$AccountBaseVerificationStatusMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.AccountBaseVerificationStatus.swaggerGeneratedUnknown;
}

List<String> accountBaseVerificationStatusListToJson(
    List<enums.AccountBaseVerificationStatus>? accountBaseVerificationStatus) {
  if (accountBaseVerificationStatus == null) {
    return [];
  }

  return accountBaseVerificationStatus
      .map((e) => enums.$AccountBaseVerificationStatusMap[e]!)
      .toList();
}

List<enums.AccountBaseVerificationStatus>
    accountBaseVerificationStatusListFromJson(
  List? accountBaseVerificationStatus, [
  List<enums.AccountBaseVerificationStatus>? defaultValue,
]) {
  if (accountBaseVerificationStatus == null) {
    return defaultValue ?? [];
  }

  return accountBaseVerificationStatus
      .map((e) => accountBaseVerificationStatusFromJson(e.toString()))
      .toList();
}

List<enums.AccountBaseVerificationStatus>?
    accountBaseVerificationStatusNullableListFromJson(
  List? accountBaseVerificationStatus, [
  List<enums.AccountBaseVerificationStatus>? defaultValue,
]) {
  if (accountBaseVerificationStatus == null) {
    return defaultValue;
  }

  return accountBaseVerificationStatus
      .map((e) => accountBaseVerificationStatusFromJson(e.toString()))
      .toList();
}

String? accountSubtypeToJson(enums.AccountSubtype? accountSubtype) {
  return enums.$AccountSubtypeMap[accountSubtype];
}

enums.AccountSubtype accountSubtypeFromJson(
  Object? accountSubtype, [
  enums.AccountSubtype? defaultValue,
]) {
  if (accountSubtype is String) {
    return enums.$AccountSubtypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == accountSubtype.toLowerCase(),
            orElse: () => const MapEntry(
                enums.AccountSubtype.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$AccountSubtypeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.AccountSubtype.swaggerGeneratedUnknown;
}

List<String> accountSubtypeListToJson(
    List<enums.AccountSubtype>? accountSubtype) {
  if (accountSubtype == null) {
    return [];
  }

  return accountSubtype.map((e) => enums.$AccountSubtypeMap[e]!).toList();
}

List<enums.AccountSubtype> accountSubtypeListFromJson(
  List? accountSubtype, [
  List<enums.AccountSubtype>? defaultValue,
]) {
  if (accountSubtype == null) {
    return defaultValue ?? [];
  }

  return accountSubtype
      .map((e) => accountSubtypeFromJson(e.toString()))
      .toList();
}

List<enums.AccountSubtype>? accountSubtypeNullableListFromJson(
  List? accountSubtype, [
  List<enums.AccountSubtype>? defaultValue,
]) {
  if (accountSubtype == null) {
    return defaultValue;
  }

  return accountSubtype
      .map((e) => accountSubtypeFromJson(e.toString()))
      .toList();
}

String? transactionsRuleFieldToJson(
    enums.TransactionsRuleField? transactionsRuleField) {
  return enums.$TransactionsRuleFieldMap[transactionsRuleField];
}

enums.TransactionsRuleField transactionsRuleFieldFromJson(
  Object? transactionsRuleField, [
  enums.TransactionsRuleField? defaultValue,
]) {
  if (transactionsRuleField is String) {
    return enums.$TransactionsRuleFieldMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                transactionsRuleField.toLowerCase(),
            orElse: () => const MapEntry(
                enums.TransactionsRuleField.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$TransactionsRuleFieldMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.TransactionsRuleField.swaggerGeneratedUnknown;
}

List<String> transactionsRuleFieldListToJson(
    List<enums.TransactionsRuleField>? transactionsRuleField) {
  if (transactionsRuleField == null) {
    return [];
  }

  return transactionsRuleField
      .map((e) => enums.$TransactionsRuleFieldMap[e]!)
      .toList();
}

List<enums.TransactionsRuleField> transactionsRuleFieldListFromJson(
  List? transactionsRuleField, [
  List<enums.TransactionsRuleField>? defaultValue,
]) {
  if (transactionsRuleField == null) {
    return defaultValue ?? [];
  }

  return transactionsRuleField
      .map((e) => transactionsRuleFieldFromJson(e.toString()))
      .toList();
}

List<enums.TransactionsRuleField>? transactionsRuleFieldNullableListFromJson(
  List? transactionsRuleField, [
  List<enums.TransactionsRuleField>? defaultValue,
]) {
  if (transactionsRuleField == null) {
    return defaultValue;
  }

  return transactionsRuleField
      .map((e) => transactionsRuleFieldFromJson(e.toString()))
      .toList();
}

String? transactionsRuleTypeToJson(
    enums.TransactionsRuleType? transactionsRuleType) {
  return enums.$TransactionsRuleTypeMap[transactionsRuleType];
}

enums.TransactionsRuleType transactionsRuleTypeFromJson(
  Object? transactionsRuleType, [
  enums.TransactionsRuleType? defaultValue,
]) {
  if (transactionsRuleType is String) {
    return enums.$TransactionsRuleTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                transactionsRuleType.toLowerCase(),
            orElse: () => const MapEntry(
                enums.TransactionsRuleType.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$TransactionsRuleTypeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.TransactionsRuleType.swaggerGeneratedUnknown;
}

List<String> transactionsRuleTypeListToJson(
    List<enums.TransactionsRuleType>? transactionsRuleType) {
  if (transactionsRuleType == null) {
    return [];
  }

  return transactionsRuleType
      .map((e) => enums.$TransactionsRuleTypeMap[e]!)
      .toList();
}

List<enums.TransactionsRuleType> transactionsRuleTypeListFromJson(
  List? transactionsRuleType, [
  List<enums.TransactionsRuleType>? defaultValue,
]) {
  if (transactionsRuleType == null) {
    return defaultValue ?? [];
  }

  return transactionsRuleType
      .map((e) => transactionsRuleTypeFromJson(e.toString()))
      .toList();
}

List<enums.TransactionsRuleType>? transactionsRuleTypeNullableListFromJson(
  List? transactionsRuleType, [
  List<enums.TransactionsRuleType>? defaultValue,
]) {
  if (transactionsRuleType == null) {
    return defaultValue;
  }

  return transactionsRuleType
      .map((e) => transactionsRuleTypeFromJson(e.toString()))
      .toList();
}

String? transactionBaseTransactionTypeToJson(
    enums.TransactionBaseTransactionType? transactionBaseTransactionType) {
  return enums
      .$TransactionBaseTransactionTypeMap[transactionBaseTransactionType];
}

enums.TransactionBaseTransactionType transactionBaseTransactionTypeFromJson(
  Object? transactionBaseTransactionType, [
  enums.TransactionBaseTransactionType? defaultValue,
]) {
  if (transactionBaseTransactionType is String) {
    return enums.$TransactionBaseTransactionTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                transactionBaseTransactionType.toLowerCase(),
            orElse: () => const MapEntry(
                enums.TransactionBaseTransactionType.swaggerGeneratedUnknown,
                ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$TransactionBaseTransactionTypeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.TransactionBaseTransactionType.swaggerGeneratedUnknown;
}

List<String> transactionBaseTransactionTypeListToJson(
    List<enums.TransactionBaseTransactionType>?
        transactionBaseTransactionType) {
  if (transactionBaseTransactionType == null) {
    return [];
  }

  return transactionBaseTransactionType
      .map((e) => enums.$TransactionBaseTransactionTypeMap[e]!)
      .toList();
}

List<enums.TransactionBaseTransactionType>
    transactionBaseTransactionTypeListFromJson(
  List? transactionBaseTransactionType, [
  List<enums.TransactionBaseTransactionType>? defaultValue,
]) {
  if (transactionBaseTransactionType == null) {
    return defaultValue ?? [];
  }

  return transactionBaseTransactionType
      .map((e) => transactionBaseTransactionTypeFromJson(e.toString()))
      .toList();
}

List<enums.TransactionBaseTransactionType>?
    transactionBaseTransactionTypeNullableListFromJson(
  List? transactionBaseTransactionType, [
  List<enums.TransactionBaseTransactionType>? defaultValue,
]) {
  if (transactionBaseTransactionType == null) {
    return defaultValue;
  }

  return transactionBaseTransactionType
      .map((e) => transactionBaseTransactionTypeFromJson(e.toString()))
      .toList();
}

String? transactionPaymentChannelToJson(
    enums.TransactionPaymentChannel? transactionPaymentChannel) {
  return enums.$TransactionPaymentChannelMap[transactionPaymentChannel];
}

enums.TransactionPaymentChannel transactionPaymentChannelFromJson(
  Object? transactionPaymentChannel, [
  enums.TransactionPaymentChannel? defaultValue,
]) {
  if (transactionPaymentChannel is String) {
    return enums.$TransactionPaymentChannelMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                transactionPaymentChannel.toLowerCase(),
            orElse: () => const MapEntry(
                enums.TransactionPaymentChannel.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$TransactionPaymentChannelMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.TransactionPaymentChannel.swaggerGeneratedUnknown;
}

List<String> transactionPaymentChannelListToJson(
    List<enums.TransactionPaymentChannel>? transactionPaymentChannel) {
  if (transactionPaymentChannel == null) {
    return [];
  }

  return transactionPaymentChannel
      .map((e) => enums.$TransactionPaymentChannelMap[e]!)
      .toList();
}

List<enums.TransactionPaymentChannel> transactionPaymentChannelListFromJson(
  List? transactionPaymentChannel, [
  List<enums.TransactionPaymentChannel>? defaultValue,
]) {
  if (transactionPaymentChannel == null) {
    return defaultValue ?? [];
  }

  return transactionPaymentChannel
      .map((e) => transactionPaymentChannelFromJson(e.toString()))
      .toList();
}

List<enums.TransactionPaymentChannel>?
    transactionPaymentChannelNullableListFromJson(
  List? transactionPaymentChannel, [
  List<enums.TransactionPaymentChannel>? defaultValue,
]) {
  if (transactionPaymentChannel == null) {
    return defaultValue;
  }

  return transactionPaymentChannel
      .map((e) => transactionPaymentChannelFromJson(e.toString()))
      .toList();
}

String? transactionTransactionTypeToJson(
    enums.TransactionTransactionType? transactionTransactionType) {
  return enums.$TransactionTransactionTypeMap[transactionTransactionType];
}

enums.TransactionTransactionType transactionTransactionTypeFromJson(
  Object? transactionTransactionType, [
  enums.TransactionTransactionType? defaultValue,
]) {
  if (transactionTransactionType is String) {
    return enums.$TransactionTransactionTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                transactionTransactionType.toLowerCase(),
            orElse: () => const MapEntry(
                enums.TransactionTransactionType.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$TransactionTransactionTypeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.TransactionTransactionType.swaggerGeneratedUnknown;
}

List<String> transactionTransactionTypeListToJson(
    List<enums.TransactionTransactionType>? transactionTransactionType) {
  if (transactionTransactionType == null) {
    return [];
  }

  return transactionTransactionType
      .map((e) => enums.$TransactionTransactionTypeMap[e]!)
      .toList();
}

List<enums.TransactionTransactionType> transactionTransactionTypeListFromJson(
  List? transactionTransactionType, [
  List<enums.TransactionTransactionType>? defaultValue,
]) {
  if (transactionTransactionType == null) {
    return defaultValue ?? [];
  }

  return transactionTransactionType
      .map((e) => transactionTransactionTypeFromJson(e.toString()))
      .toList();
}

List<enums.TransactionTransactionType>?
    transactionTransactionTypeNullableListFromJson(
  List? transactionTransactionType, [
  List<enums.TransactionTransactionType>? defaultValue,
]) {
  if (transactionTransactionType == null) {
    return defaultValue;
  }

  return transactionTransactionType
      .map((e) => transactionTransactionTypeFromJson(e.toString()))
      .toList();
}

String? recurringTransactionFrequencyToJson(
    enums.RecurringTransactionFrequency? recurringTransactionFrequency) {
  return enums.$RecurringTransactionFrequencyMap[recurringTransactionFrequency];
}

enums.RecurringTransactionFrequency recurringTransactionFrequencyFromJson(
  Object? recurringTransactionFrequency, [
  enums.RecurringTransactionFrequency? defaultValue,
]) {
  if (recurringTransactionFrequency is String) {
    return enums.$RecurringTransactionFrequencyMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                recurringTransactionFrequency.toLowerCase(),
            orElse: () => const MapEntry(
                enums.RecurringTransactionFrequency.swaggerGeneratedUnknown,
                ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$RecurringTransactionFrequencyMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.RecurringTransactionFrequency.swaggerGeneratedUnknown;
}

List<String> recurringTransactionFrequencyListToJson(
    List<enums.RecurringTransactionFrequency>? recurringTransactionFrequency) {
  if (recurringTransactionFrequency == null) {
    return [];
  }

  return recurringTransactionFrequency
      .map((e) => enums.$RecurringTransactionFrequencyMap[e]!)
      .toList();
}

List<enums.RecurringTransactionFrequency>
    recurringTransactionFrequencyListFromJson(
  List? recurringTransactionFrequency, [
  List<enums.RecurringTransactionFrequency>? defaultValue,
]) {
  if (recurringTransactionFrequency == null) {
    return defaultValue ?? [];
  }

  return recurringTransactionFrequency
      .map((e) => recurringTransactionFrequencyFromJson(e.toString()))
      .toList();
}

List<enums.RecurringTransactionFrequency>?
    recurringTransactionFrequencyNullableListFromJson(
  List? recurringTransactionFrequency, [
  List<enums.RecurringTransactionFrequency>? defaultValue,
]) {
  if (recurringTransactionFrequency == null) {
    return defaultValue;
  }

  return recurringTransactionFrequency
      .map((e) => recurringTransactionFrequencyFromJson(e.toString()))
      .toList();
}

String? transactionStreamStatusToJson(
    enums.TransactionStreamStatus? transactionStreamStatus) {
  return enums.$TransactionStreamStatusMap[transactionStreamStatus];
}

enums.TransactionStreamStatus transactionStreamStatusFromJson(
  Object? transactionStreamStatus, [
  enums.TransactionStreamStatus? defaultValue,
]) {
  if (transactionStreamStatus is String) {
    return enums.$TransactionStreamStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                transactionStreamStatus.toLowerCase(),
            orElse: () => const MapEntry(
                enums.TransactionStreamStatus.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$TransactionStreamStatusMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.TransactionStreamStatus.swaggerGeneratedUnknown;
}

List<String> transactionStreamStatusListToJson(
    List<enums.TransactionStreamStatus>? transactionStreamStatus) {
  if (transactionStreamStatus == null) {
    return [];
  }

  return transactionStreamStatus
      .map((e) => enums.$TransactionStreamStatusMap[e]!)
      .toList();
}

List<enums.TransactionStreamStatus> transactionStreamStatusListFromJson(
  List? transactionStreamStatus, [
  List<enums.TransactionStreamStatus>? defaultValue,
]) {
  if (transactionStreamStatus == null) {
    return defaultValue ?? [];
  }

  return transactionStreamStatus
      .map((e) => transactionStreamStatusFromJson(e.toString()))
      .toList();
}

List<enums.TransactionStreamStatus>?
    transactionStreamStatusNullableListFromJson(
  List? transactionStreamStatus, [
  List<enums.TransactionStreamStatus>? defaultValue,
]) {
  if (transactionStreamStatus == null) {
    return defaultValue;
  }

  return transactionStreamStatus
      .map((e) => transactionStreamStatusFromJson(e.toString()))
      .toList();
}

String? countryCodeToJson(enums.CountryCode? countryCode) {
  return enums.$CountryCodeMap[countryCode];
}

enums.CountryCode countryCodeFromJson(
  Object? countryCode, [
  enums.CountryCode? defaultValue,
]) {
  if (countryCode is String) {
    return enums.$CountryCodeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == countryCode.toLowerCase(),
            orElse: () =>
                const MapEntry(enums.CountryCode.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$CountryCodeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.CountryCode.swaggerGeneratedUnknown;
}

List<String> countryCodeListToJson(List<enums.CountryCode>? countryCode) {
  if (countryCode == null) {
    return [];
  }

  return countryCode.map((e) => enums.$CountryCodeMap[e]!).toList();
}

List<enums.CountryCode> countryCodeListFromJson(
  List? countryCode, [
  List<enums.CountryCode>? defaultValue,
]) {
  if (countryCode == null) {
    return defaultValue ?? [];
  }

  return countryCode.map((e) => countryCodeFromJson(e.toString())).toList();
}

List<enums.CountryCode>? countryCodeNullableListFromJson(
  List? countryCode, [
  List<enums.CountryCode>? defaultValue,
]) {
  if (countryCode == null) {
    return defaultValue;
  }

  return countryCode.map((e) => countryCodeFromJson(e.toString())).toList();
}

String? transactionCodeToJson(enums.TransactionCode? transactionCode) {
  return enums.$TransactionCodeMap[transactionCode];
}

enums.TransactionCode transactionCodeFromJson(
  Object? transactionCode, [
  enums.TransactionCode? defaultValue,
]) {
  if (transactionCode is String) {
    return enums.$TransactionCodeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == transactionCode.toLowerCase(),
            orElse: () => const MapEntry(
                enums.TransactionCode.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$TransactionCodeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.TransactionCode.swaggerGeneratedUnknown;
}

List<String> transactionCodeListToJson(
    List<enums.TransactionCode>? transactionCode) {
  if (transactionCode == null) {
    return [];
  }

  return transactionCode.map((e) => enums.$TransactionCodeMap[e]!).toList();
}

List<enums.TransactionCode> transactionCodeListFromJson(
  List? transactionCode, [
  List<enums.TransactionCode>? defaultValue,
]) {
  if (transactionCode == null) {
    return defaultValue ?? [];
  }

  return transactionCode
      .map((e) => transactionCodeFromJson(e.toString()))
      .toList();
}

List<enums.TransactionCode>? transactionCodeNullableListFromJson(
  List? transactionCode, [
  List<enums.TransactionCode>? defaultValue,
]) {
  if (transactionCode == null) {
    return defaultValue;
  }

  return transactionCode
      .map((e) => transactionCodeFromJson(e.toString()))
      .toList();
}

String? counterpartyTypeToJson(enums.CounterpartyType? counterpartyType) {
  return enums.$CounterpartyTypeMap[counterpartyType];
}

enums.CounterpartyType counterpartyTypeFromJson(
  Object? counterpartyType, [
  enums.CounterpartyType? defaultValue,
]) {
  if (counterpartyType is String) {
    return enums.$CounterpartyTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == counterpartyType.toLowerCase(),
            orElse: () => const MapEntry(
                enums.CounterpartyType.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$CounterpartyTypeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.CounterpartyType.swaggerGeneratedUnknown;
}

List<String> counterpartyTypeListToJson(
    List<enums.CounterpartyType>? counterpartyType) {
  if (counterpartyType == null) {
    return [];
  }

  return counterpartyType.map((e) => enums.$CounterpartyTypeMap[e]!).toList();
}

List<enums.CounterpartyType> counterpartyTypeListFromJson(
  List? counterpartyType, [
  List<enums.CounterpartyType>? defaultValue,
]) {
  if (counterpartyType == null) {
    return defaultValue ?? [];
  }

  return counterpartyType
      .map((e) => counterpartyTypeFromJson(e.toString()))
      .toList();
}

List<enums.CounterpartyType>? counterpartyTypeNullableListFromJson(
  List? counterpartyType, [
  List<enums.CounterpartyType>? defaultValue,
]) {
  if (counterpartyType == null) {
    return defaultValue;
  }

  return counterpartyType
      .map((e) => counterpartyTypeFromJson(e.toString()))
      .toList();
}

String? identityUpdateTypesToJson(
    enums.IdentityUpdateTypes? identityUpdateTypes) {
  return enums.$IdentityUpdateTypesMap[identityUpdateTypes];
}

enums.IdentityUpdateTypes identityUpdateTypesFromJson(
  Object? identityUpdateTypes, [
  enums.IdentityUpdateTypes? defaultValue,
]) {
  if (identityUpdateTypes is String) {
    return enums.$IdentityUpdateTypesMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                identityUpdateTypes.toLowerCase(),
            orElse: () => const MapEntry(
                enums.IdentityUpdateTypes.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$IdentityUpdateTypesMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.IdentityUpdateTypes.swaggerGeneratedUnknown;
}

List<String> identityUpdateTypesListToJson(
    List<enums.IdentityUpdateTypes>? identityUpdateTypes) {
  if (identityUpdateTypes == null) {
    return [];
  }

  return identityUpdateTypes
      .map((e) => enums.$IdentityUpdateTypesMap[e]!)
      .toList();
}

List<enums.IdentityUpdateTypes> identityUpdateTypesListFromJson(
  List? identityUpdateTypes, [
  List<enums.IdentityUpdateTypes>? defaultValue,
]) {
  if (identityUpdateTypes == null) {
    return defaultValue ?? [];
  }

  return identityUpdateTypes
      .map((e) => identityUpdateTypesFromJson(e.toString()))
      .toList();
}

List<enums.IdentityUpdateTypes>? identityUpdateTypesNullableListFromJson(
  List? identityUpdateTypes, [
  List<enums.IdentityUpdateTypes>? defaultValue,
]) {
  if (identityUpdateTypes == null) {
    return defaultValue;
  }

  return identityUpdateTypes
      .map((e) => identityUpdateTypesFromJson(e.toString()))
      .toList();
}

String? phoneNumberTypeToJson(enums.PhoneNumberType? phoneNumberType) {
  return enums.$PhoneNumberTypeMap[phoneNumberType];
}

enums.PhoneNumberType phoneNumberTypeFromJson(
  Object? phoneNumberType, [
  enums.PhoneNumberType? defaultValue,
]) {
  if (phoneNumberType is String) {
    return enums.$PhoneNumberTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == phoneNumberType.toLowerCase(),
            orElse: () => const MapEntry(
                enums.PhoneNumberType.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$PhoneNumberTypeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.PhoneNumberType.swaggerGeneratedUnknown;
}

List<String> phoneNumberTypeListToJson(
    List<enums.PhoneNumberType>? phoneNumberType) {
  if (phoneNumberType == null) {
    return [];
  }

  return phoneNumberType.map((e) => enums.$PhoneNumberTypeMap[e]!).toList();
}

List<enums.PhoneNumberType> phoneNumberTypeListFromJson(
  List? phoneNumberType, [
  List<enums.PhoneNumberType>? defaultValue,
]) {
  if (phoneNumberType == null) {
    return defaultValue ?? [];
  }

  return phoneNumberType
      .map((e) => phoneNumberTypeFromJson(e.toString()))
      .toList();
}

List<enums.PhoneNumberType>? phoneNumberTypeNullableListFromJson(
  List? phoneNumberType, [
  List<enums.PhoneNumberType>? defaultValue,
]) {
  if (phoneNumberType == null) {
    return defaultValue;
  }

  return phoneNumberType
      .map((e) => phoneNumberTypeFromJson(e.toString()))
      .toList();
}

String? emailTypeToJson(enums.EmailType? emailType) {
  return enums.$EmailTypeMap[emailType];
}

enums.EmailType emailTypeFromJson(
  Object? emailType, [
  enums.EmailType? defaultValue,
]) {
  if (emailType is String) {
    return enums.$EmailTypeMap.entries
        .firstWhere(
            (element) => element.value.toLowerCase() == emailType.toLowerCase(),
            orElse: () =>
                const MapEntry(enums.EmailType.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$EmailTypeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.EmailType.swaggerGeneratedUnknown;
}

List<String> emailTypeListToJson(List<enums.EmailType>? emailType) {
  if (emailType == null) {
    return [];
  }

  return emailType.map((e) => enums.$EmailTypeMap[e]!).toList();
}

List<enums.EmailType> emailTypeListFromJson(
  List? emailType, [
  List<enums.EmailType>? defaultValue,
]) {
  if (emailType == null) {
    return defaultValue ?? [];
  }

  return emailType.map((e) => emailTypeFromJson(e.toString())).toList();
}

List<enums.EmailType>? emailTypeNullableListFromJson(
  List? emailType, [
  List<enums.EmailType>? defaultValue,
]) {
  if (emailType == null) {
    return defaultValue;
  }

  return emailType.map((e) => emailTypeFromJson(e.toString())).toList();
}

String? studentLoanStatusTypeToJson(
    enums.StudentLoanStatusType? studentLoanStatusType) {
  return enums.$StudentLoanStatusTypeMap[studentLoanStatusType];
}

enums.StudentLoanStatusType studentLoanStatusTypeFromJson(
  Object? studentLoanStatusType, [
  enums.StudentLoanStatusType? defaultValue,
]) {
  if (studentLoanStatusType is String) {
    return enums.$StudentLoanStatusTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                studentLoanStatusType.toLowerCase(),
            orElse: () => const MapEntry(
                enums.StudentLoanStatusType.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$StudentLoanStatusTypeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.StudentLoanStatusType.swaggerGeneratedUnknown;
}

List<String> studentLoanStatusTypeListToJson(
    List<enums.StudentLoanStatusType>? studentLoanStatusType) {
  if (studentLoanStatusType == null) {
    return [];
  }

  return studentLoanStatusType
      .map((e) => enums.$StudentLoanStatusTypeMap[e]!)
      .toList();
}

List<enums.StudentLoanStatusType> studentLoanStatusTypeListFromJson(
  List? studentLoanStatusType, [
  List<enums.StudentLoanStatusType>? defaultValue,
]) {
  if (studentLoanStatusType == null) {
    return defaultValue ?? [];
  }

  return studentLoanStatusType
      .map((e) => studentLoanStatusTypeFromJson(e.toString()))
      .toList();
}

List<enums.StudentLoanStatusType>? studentLoanStatusTypeNullableListFromJson(
  List? studentLoanStatusType, [
  List<enums.StudentLoanStatusType>? defaultValue,
]) {
  if (studentLoanStatusType == null) {
    return defaultValue;
  }

  return studentLoanStatusType
      .map((e) => studentLoanStatusTypeFromJson(e.toString()))
      .toList();
}

String? studentRepaymentPlanTypeToJson(
    enums.StudentRepaymentPlanType? studentRepaymentPlanType) {
  return enums.$StudentRepaymentPlanTypeMap[studentRepaymentPlanType];
}

enums.StudentRepaymentPlanType studentRepaymentPlanTypeFromJson(
  Object? studentRepaymentPlanType, [
  enums.StudentRepaymentPlanType? defaultValue,
]) {
  if (studentRepaymentPlanType is String) {
    return enums.$StudentRepaymentPlanTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                studentRepaymentPlanType.toLowerCase(),
            orElse: () => const MapEntry(
                enums.StudentRepaymentPlanType.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$StudentRepaymentPlanTypeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.StudentRepaymentPlanType.swaggerGeneratedUnknown;
}

List<String> studentRepaymentPlanTypeListToJson(
    List<enums.StudentRepaymentPlanType>? studentRepaymentPlanType) {
  if (studentRepaymentPlanType == null) {
    return [];
  }

  return studentRepaymentPlanType
      .map((e) => enums.$StudentRepaymentPlanTypeMap[e]!)
      .toList();
}

List<enums.StudentRepaymentPlanType> studentRepaymentPlanTypeListFromJson(
  List? studentRepaymentPlanType, [
  List<enums.StudentRepaymentPlanType>? defaultValue,
]) {
  if (studentRepaymentPlanType == null) {
    return defaultValue ?? [];
  }

  return studentRepaymentPlanType
      .map((e) => studentRepaymentPlanTypeFromJson(e.toString()))
      .toList();
}

List<enums.StudentRepaymentPlanType>?
    studentRepaymentPlanTypeNullableListFromJson(
  List? studentRepaymentPlanType, [
  List<enums.StudentRepaymentPlanType>? defaultValue,
]) {
  if (studentRepaymentPlanType == null) {
    return defaultValue;
  }

  return studentRepaymentPlanType
      .map((e) => studentRepaymentPlanTypeFromJson(e.toString()))
      .toList();
}

String? aprAprTypeToJson(enums.AprAprType? aprAprType) {
  return enums.$AprAprTypeMap[aprAprType];
}

enums.AprAprType aprAprTypeFromJson(
  Object? aprAprType, [
  enums.AprAprType? defaultValue,
]) {
  if (aprAprType is String) {
    return enums.$AprAprTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == aprAprType.toLowerCase(),
            orElse: () =>
                const MapEntry(enums.AprAprType.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$AprAprTypeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.AprAprType.swaggerGeneratedUnknown;
}

List<String> aprAprTypeListToJson(List<enums.AprAprType>? aprAprType) {
  if (aprAprType == null) {
    return [];
  }

  return aprAprType.map((e) => enums.$AprAprTypeMap[e]!).toList();
}

List<enums.AprAprType> aprAprTypeListFromJson(
  List? aprAprType, [
  List<enums.AprAprType>? defaultValue,
]) {
  if (aprAprType == null) {
    return defaultValue ?? [];
  }

  return aprAprType.map((e) => aprAprTypeFromJson(e.toString())).toList();
}

List<enums.AprAprType>? aprAprTypeNullableListFromJson(
  List? aprAprType, [
  List<enums.AprAprType>? defaultValue,
]) {
  if (aprAprType == null) {
    return defaultValue;
  }

  return aprAprType.map((e) => aprAprTypeFromJson(e.toString())).toList();
}

String? paymentScheduleIntervalToJson(
    enums.PaymentScheduleInterval? paymentScheduleInterval) {
  return enums.$PaymentScheduleIntervalMap[paymentScheduleInterval];
}

enums.PaymentScheduleInterval paymentScheduleIntervalFromJson(
  Object? paymentScheduleInterval, [
  enums.PaymentScheduleInterval? defaultValue,
]) {
  if (paymentScheduleInterval is String) {
    return enums.$PaymentScheduleIntervalMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                paymentScheduleInterval.toLowerCase(),
            orElse: () => const MapEntry(
                enums.PaymentScheduleInterval.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$PaymentScheduleIntervalMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.PaymentScheduleInterval.swaggerGeneratedUnknown;
}

List<String> paymentScheduleIntervalListToJson(
    List<enums.PaymentScheduleInterval>? paymentScheduleInterval) {
  if (paymentScheduleInterval == null) {
    return [];
  }

  return paymentScheduleInterval
      .map((e) => enums.$PaymentScheduleIntervalMap[e]!)
      .toList();
}

List<enums.PaymentScheduleInterval> paymentScheduleIntervalListFromJson(
  List? paymentScheduleInterval, [
  List<enums.PaymentScheduleInterval>? defaultValue,
]) {
  if (paymentScheduleInterval == null) {
    return defaultValue ?? [];
  }

  return paymentScheduleInterval
      .map((e) => paymentScheduleIntervalFromJson(e.toString()))
      .toList();
}

List<enums.PaymentScheduleInterval>?
    paymentScheduleIntervalNullableListFromJson(
  List? paymentScheduleInterval, [
  List<enums.PaymentScheduleInterval>? defaultValue,
]) {
  if (paymentScheduleInterval == null) {
    return defaultValue;
  }

  return paymentScheduleInterval
      .map((e) => paymentScheduleIntervalFromJson(e.toString()))
      .toList();
}

String? paymentSchemeToJson(enums.PaymentScheme? paymentScheme) {
  return enums.$PaymentSchemeMap[paymentScheme];
}

enums.PaymentScheme paymentSchemeFromJson(
  Object? paymentScheme, [
  enums.PaymentScheme? defaultValue,
]) {
  if (paymentScheme is String) {
    return enums.$PaymentSchemeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == paymentScheme.toLowerCase(),
            orElse: () =>
                const MapEntry(enums.PaymentScheme.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$PaymentSchemeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.PaymentScheme.swaggerGeneratedUnknown;
}

List<String> paymentSchemeListToJson(List<enums.PaymentScheme>? paymentScheme) {
  if (paymentScheme == null) {
    return [];
  }

  return paymentScheme.map((e) => enums.$PaymentSchemeMap[e]!).toList();
}

List<enums.PaymentScheme> paymentSchemeListFromJson(
  List? paymentScheme, [
  List<enums.PaymentScheme>? defaultValue,
]) {
  if (paymentScheme == null) {
    return defaultValue ?? [];
  }

  return paymentScheme.map((e) => paymentSchemeFromJson(e.toString())).toList();
}

List<enums.PaymentScheme>? paymentSchemeNullableListFromJson(
  List? paymentScheme, [
  List<enums.PaymentScheme>? defaultValue,
]) {
  if (paymentScheme == null) {
    return defaultValue;
  }

  return paymentScheme.map((e) => paymentSchemeFromJson(e.toString())).toList();
}

String? paymentInitiationConsentScopeToJson(
    enums.PaymentInitiationConsentScope? paymentInitiationConsentScope) {
  return enums.$PaymentInitiationConsentScopeMap[paymentInitiationConsentScope];
}

enums.PaymentInitiationConsentScope paymentInitiationConsentScopeFromJson(
  Object? paymentInitiationConsentScope, [
  enums.PaymentInitiationConsentScope? defaultValue,
]) {
  if (paymentInitiationConsentScope is String) {
    return enums.$PaymentInitiationConsentScopeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                paymentInitiationConsentScope.toLowerCase(),
            orElse: () => const MapEntry(
                enums.PaymentInitiationConsentScope.swaggerGeneratedUnknown,
                ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$PaymentInitiationConsentScopeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.PaymentInitiationConsentScope.swaggerGeneratedUnknown;
}

List<String> paymentInitiationConsentScopeListToJson(
    List<enums.PaymentInitiationConsentScope>? paymentInitiationConsentScope) {
  if (paymentInitiationConsentScope == null) {
    return [];
  }

  return paymentInitiationConsentScope
      .map((e) => enums.$PaymentInitiationConsentScopeMap[e]!)
      .toList();
}

List<enums.PaymentInitiationConsentScope>
    paymentInitiationConsentScopeListFromJson(
  List? paymentInitiationConsentScope, [
  List<enums.PaymentInitiationConsentScope>? defaultValue,
]) {
  if (paymentInitiationConsentScope == null) {
    return defaultValue ?? [];
  }

  return paymentInitiationConsentScope
      .map((e) => paymentInitiationConsentScopeFromJson(e.toString()))
      .toList();
}

List<enums.PaymentInitiationConsentScope>?
    paymentInitiationConsentScopeNullableListFromJson(
  List? paymentInitiationConsentScope, [
  List<enums.PaymentInitiationConsentScope>? defaultValue,
]) {
  if (paymentInitiationConsentScope == null) {
    return defaultValue;
  }

  return paymentInitiationConsentScope
      .map((e) => paymentInitiationConsentScopeFromJson(e.toString()))
      .toList();
}

String? productsToJson(enums.Products? products) {
  return enums.$ProductsMap[products];
}

enums.Products productsFromJson(
  Object? products, [
  enums.Products? defaultValue,
]) {
  if (products is String) {
    return enums.$ProductsMap.entries
        .firstWhere(
            (element) => element.value.toLowerCase() == products.toLowerCase(),
            orElse: () =>
                const MapEntry(enums.Products.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$ProductsMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ?? defaultValue ?? enums.Products.swaggerGeneratedUnknown;
}

List<String> productsListToJson(List<enums.Products>? products) {
  if (products == null) {
    return [];
  }

  return products.map((e) => enums.$ProductsMap[e]!).toList();
}

List<enums.Products> productsListFromJson(
  List? products, [
  List<enums.Products>? defaultValue,
]) {
  if (products == null) {
    return defaultValue ?? [];
  }

  return products.map((e) => productsFromJson(e.toString())).toList();
}

List<enums.Products>? productsNullableListFromJson(
  List? products, [
  List<enums.Products>? defaultValue,
]) {
  if (products == null) {
    return defaultValue;
  }

  return products.map((e) => productsFromJson(e.toString())).toList();
}

String? productStatusStatusToJson(
    enums.ProductStatusStatus? productStatusStatus) {
  return enums.$ProductStatusStatusMap[productStatusStatus];
}

enums.ProductStatusStatus productStatusStatusFromJson(
  Object? productStatusStatus, [
  enums.ProductStatusStatus? defaultValue,
]) {
  if (productStatusStatus is String) {
    return enums.$ProductStatusStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                productStatusStatus.toLowerCase(),
            orElse: () => const MapEntry(
                enums.ProductStatusStatus.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$ProductStatusStatusMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.ProductStatusStatus.swaggerGeneratedUnknown;
}

List<String> productStatusStatusListToJson(
    List<enums.ProductStatusStatus>? productStatusStatus) {
  if (productStatusStatus == null) {
    return [];
  }

  return productStatusStatus
      .map((e) => enums.$ProductStatusStatusMap[e]!)
      .toList();
}

List<enums.ProductStatusStatus> productStatusStatusListFromJson(
  List? productStatusStatus, [
  List<enums.ProductStatusStatus>? defaultValue,
]) {
  if (productStatusStatus == null) {
    return defaultValue ?? [];
  }

  return productStatusStatus
      .map((e) => productStatusStatusFromJson(e.toString()))
      .toList();
}

List<enums.ProductStatusStatus>? productStatusStatusNullableListFromJson(
  List? productStatusStatus, [
  List<enums.ProductStatusStatus>? defaultValue,
]) {
  if (productStatusStatus == null) {
    return defaultValue;
  }

  return productStatusStatus
      .map((e) => productStatusStatusFromJson(e.toString()))
      .toList();
}

String? productStatusBreakdownRefreshIntervalToJson(
    enums.ProductStatusBreakdownRefreshInterval?
        productStatusBreakdownRefreshInterval) {
  return enums.$ProductStatusBreakdownRefreshIntervalMap[
      productStatusBreakdownRefreshInterval];
}

enums.ProductStatusBreakdownRefreshInterval
    productStatusBreakdownRefreshIntervalFromJson(
  Object? productStatusBreakdownRefreshInterval, [
  enums.ProductStatusBreakdownRefreshInterval? defaultValue,
]) {
  if (productStatusBreakdownRefreshInterval is String) {
    return enums.$ProductStatusBreakdownRefreshIntervalMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                productStatusBreakdownRefreshInterval.toLowerCase(),
            orElse: () => const MapEntry(
                enums.ProductStatusBreakdownRefreshInterval
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$ProductStatusBreakdownRefreshIntervalMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.ProductStatusBreakdownRefreshInterval.swaggerGeneratedUnknown;
}

List<String> productStatusBreakdownRefreshIntervalListToJson(
    List<enums.ProductStatusBreakdownRefreshInterval>?
        productStatusBreakdownRefreshInterval) {
  if (productStatusBreakdownRefreshInterval == null) {
    return [];
  }

  return productStatusBreakdownRefreshInterval
      .map((e) => enums.$ProductStatusBreakdownRefreshIntervalMap[e]!)
      .toList();
}

List<enums.ProductStatusBreakdownRefreshInterval>
    productStatusBreakdownRefreshIntervalListFromJson(
  List? productStatusBreakdownRefreshInterval, [
  List<enums.ProductStatusBreakdownRefreshInterval>? defaultValue,
]) {
  if (productStatusBreakdownRefreshInterval == null) {
    return defaultValue ?? [];
  }

  return productStatusBreakdownRefreshInterval
      .map((e) => productStatusBreakdownRefreshIntervalFromJson(e.toString()))
      .toList();
}

List<enums.ProductStatusBreakdownRefreshInterval>?
    productStatusBreakdownRefreshIntervalNullableListFromJson(
  List? productStatusBreakdownRefreshInterval, [
  List<enums.ProductStatusBreakdownRefreshInterval>? defaultValue,
]) {
  if (productStatusBreakdownRefreshInterval == null) {
    return defaultValue;
  }

  return productStatusBreakdownRefreshInterval
      .map((e) => productStatusBreakdownRefreshIntervalFromJson(e.toString()))
      .toList();
}

String? paymentAmountCurrencyToJson(
    enums.PaymentAmountCurrency? paymentAmountCurrency) {
  return enums.$PaymentAmountCurrencyMap[paymentAmountCurrency];
}

enums.PaymentAmountCurrency paymentAmountCurrencyFromJson(
  Object? paymentAmountCurrency, [
  enums.PaymentAmountCurrency? defaultValue,
]) {
  if (paymentAmountCurrency is String) {
    return enums.$PaymentAmountCurrencyMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                paymentAmountCurrency.toLowerCase(),
            orElse: () => const MapEntry(
                enums.PaymentAmountCurrency.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$PaymentAmountCurrencyMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.PaymentAmountCurrency.swaggerGeneratedUnknown;
}

List<String> paymentAmountCurrencyListToJson(
    List<enums.PaymentAmountCurrency>? paymentAmountCurrency) {
  if (paymentAmountCurrency == null) {
    return [];
  }

  return paymentAmountCurrency
      .map((e) => enums.$PaymentAmountCurrencyMap[e]!)
      .toList();
}

List<enums.PaymentAmountCurrency> paymentAmountCurrencyListFromJson(
  List? paymentAmountCurrency, [
  List<enums.PaymentAmountCurrency>? defaultValue,
]) {
  if (paymentAmountCurrency == null) {
    return defaultValue ?? [];
  }

  return paymentAmountCurrency
      .map((e) => paymentAmountCurrencyFromJson(e.toString()))
      .toList();
}

List<enums.PaymentAmountCurrency>? paymentAmountCurrencyNullableListFromJson(
  List? paymentAmountCurrency, [
  List<enums.PaymentAmountCurrency>? defaultValue,
]) {
  if (paymentAmountCurrency == null) {
    return defaultValue;
  }

  return paymentAmountCurrency
      .map((e) => paymentAmountCurrencyFromJson(e.toString()))
      .toList();
}

String? paymentConsentPeriodicIntervalToJson(
    enums.PaymentConsentPeriodicInterval? paymentConsentPeriodicInterval) {
  return enums
      .$PaymentConsentPeriodicIntervalMap[paymentConsentPeriodicInterval];
}

enums.PaymentConsentPeriodicInterval paymentConsentPeriodicIntervalFromJson(
  Object? paymentConsentPeriodicInterval, [
  enums.PaymentConsentPeriodicInterval? defaultValue,
]) {
  if (paymentConsentPeriodicInterval is String) {
    return enums.$PaymentConsentPeriodicIntervalMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                paymentConsentPeriodicInterval.toLowerCase(),
            orElse: () => const MapEntry(
                enums.PaymentConsentPeriodicInterval.swaggerGeneratedUnknown,
                ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$PaymentConsentPeriodicIntervalMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.PaymentConsentPeriodicInterval.swaggerGeneratedUnknown;
}

List<String> paymentConsentPeriodicIntervalListToJson(
    List<enums.PaymentConsentPeriodicInterval>?
        paymentConsentPeriodicInterval) {
  if (paymentConsentPeriodicInterval == null) {
    return [];
  }

  return paymentConsentPeriodicInterval
      .map((e) => enums.$PaymentConsentPeriodicIntervalMap[e]!)
      .toList();
}

List<enums.PaymentConsentPeriodicInterval>
    paymentConsentPeriodicIntervalListFromJson(
  List? paymentConsentPeriodicInterval, [
  List<enums.PaymentConsentPeriodicInterval>? defaultValue,
]) {
  if (paymentConsentPeriodicInterval == null) {
    return defaultValue ?? [];
  }

  return paymentConsentPeriodicInterval
      .map((e) => paymentConsentPeriodicIntervalFromJson(e.toString()))
      .toList();
}

List<enums.PaymentConsentPeriodicInterval>?
    paymentConsentPeriodicIntervalNullableListFromJson(
  List? paymentConsentPeriodicInterval, [
  List<enums.PaymentConsentPeriodicInterval>? defaultValue,
]) {
  if (paymentConsentPeriodicInterval == null) {
    return defaultValue;
  }

  return paymentConsentPeriodicInterval
      .map((e) => paymentConsentPeriodicIntervalFromJson(e.toString()))
      .toList();
}

String? paymentConsentPeriodicAlignmentToJson(
    enums.PaymentConsentPeriodicAlignment? paymentConsentPeriodicAlignment) {
  return enums
      .$PaymentConsentPeriodicAlignmentMap[paymentConsentPeriodicAlignment];
}

enums.PaymentConsentPeriodicAlignment paymentConsentPeriodicAlignmentFromJson(
  Object? paymentConsentPeriodicAlignment, [
  enums.PaymentConsentPeriodicAlignment? defaultValue,
]) {
  if (paymentConsentPeriodicAlignment is String) {
    return enums.$PaymentConsentPeriodicAlignmentMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                paymentConsentPeriodicAlignment.toLowerCase(),
            orElse: () => const MapEntry(
                enums.PaymentConsentPeriodicAlignment.swaggerGeneratedUnknown,
                ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$PaymentConsentPeriodicAlignmentMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.PaymentConsentPeriodicAlignment.swaggerGeneratedUnknown;
}

List<String> paymentConsentPeriodicAlignmentListToJson(
    List<enums.PaymentConsentPeriodicAlignment>?
        paymentConsentPeriodicAlignment) {
  if (paymentConsentPeriodicAlignment == null) {
    return [];
  }

  return paymentConsentPeriodicAlignment
      .map((e) => enums.$PaymentConsentPeriodicAlignmentMap[e]!)
      .toList();
}

List<enums.PaymentConsentPeriodicAlignment>
    paymentConsentPeriodicAlignmentListFromJson(
  List? paymentConsentPeriodicAlignment, [
  List<enums.PaymentConsentPeriodicAlignment>? defaultValue,
]) {
  if (paymentConsentPeriodicAlignment == null) {
    return defaultValue ?? [];
  }

  return paymentConsentPeriodicAlignment
      .map((e) => paymentConsentPeriodicAlignmentFromJson(e.toString()))
      .toList();
}

List<enums.PaymentConsentPeriodicAlignment>?
    paymentConsentPeriodicAlignmentNullableListFromJson(
  List? paymentConsentPeriodicAlignment, [
  List<enums.PaymentConsentPeriodicAlignment>? defaultValue,
]) {
  if (paymentConsentPeriodicAlignment == null) {
    return defaultValue;
  }

  return paymentConsentPeriodicAlignment
      .map((e) => paymentConsentPeriodicAlignmentFromJson(e.toString()))
      .toList();
}

String? investmentTransactionTypeToJson(
    enums.InvestmentTransactionType? investmentTransactionType) {
  return enums.$InvestmentTransactionTypeMap[investmentTransactionType];
}

enums.InvestmentTransactionType investmentTransactionTypeFromJson(
  Object? investmentTransactionType, [
  enums.InvestmentTransactionType? defaultValue,
]) {
  if (investmentTransactionType is String) {
    return enums.$InvestmentTransactionTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                investmentTransactionType.toLowerCase(),
            orElse: () => const MapEntry(
                enums.InvestmentTransactionType.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$InvestmentTransactionTypeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.InvestmentTransactionType.swaggerGeneratedUnknown;
}

List<String> investmentTransactionTypeListToJson(
    List<enums.InvestmentTransactionType>? investmentTransactionType) {
  if (investmentTransactionType == null) {
    return [];
  }

  return investmentTransactionType
      .map((e) => enums.$InvestmentTransactionTypeMap[e]!)
      .toList();
}

List<enums.InvestmentTransactionType> investmentTransactionTypeListFromJson(
  List? investmentTransactionType, [
  List<enums.InvestmentTransactionType>? defaultValue,
]) {
  if (investmentTransactionType == null) {
    return defaultValue ?? [];
  }

  return investmentTransactionType
      .map((e) => investmentTransactionTypeFromJson(e.toString()))
      .toList();
}

List<enums.InvestmentTransactionType>?
    investmentTransactionTypeNullableListFromJson(
  List? investmentTransactionType, [
  List<enums.InvestmentTransactionType>? defaultValue,
]) {
  if (investmentTransactionType == null) {
    return defaultValue;
  }

  return investmentTransactionType
      .map((e) => investmentTransactionTypeFromJson(e.toString()))
      .toList();
}

String? investmentTransactionSubtypeToJson(
    enums.InvestmentTransactionSubtype? investmentTransactionSubtype) {
  return enums.$InvestmentTransactionSubtypeMap[investmentTransactionSubtype];
}

enums.InvestmentTransactionSubtype investmentTransactionSubtypeFromJson(
  Object? investmentTransactionSubtype, [
  enums.InvestmentTransactionSubtype? defaultValue,
]) {
  if (investmentTransactionSubtype is String) {
    return enums.$InvestmentTransactionSubtypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                investmentTransactionSubtype.toLowerCase(),
            orElse: () => const MapEntry(
                enums.InvestmentTransactionSubtype.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$InvestmentTransactionSubtypeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.InvestmentTransactionSubtype.swaggerGeneratedUnknown;
}

List<String> investmentTransactionSubtypeListToJson(
    List<enums.InvestmentTransactionSubtype>? investmentTransactionSubtype) {
  if (investmentTransactionSubtype == null) {
    return [];
  }

  return investmentTransactionSubtype
      .map((e) => enums.$InvestmentTransactionSubtypeMap[e]!)
      .toList();
}

List<enums.InvestmentTransactionSubtype>
    investmentTransactionSubtypeListFromJson(
  List? investmentTransactionSubtype, [
  List<enums.InvestmentTransactionSubtype>? defaultValue,
]) {
  if (investmentTransactionSubtype == null) {
    return defaultValue ?? [];
  }

  return investmentTransactionSubtype
      .map((e) => investmentTransactionSubtypeFromJson(e.toString()))
      .toList();
}

List<enums.InvestmentTransactionSubtype>?
    investmentTransactionSubtypeNullableListFromJson(
  List? investmentTransactionSubtype, [
  List<enums.InvestmentTransactionSubtype>? defaultValue,
]) {
  if (investmentTransactionSubtype == null) {
    return defaultValue;
  }

  return investmentTransactionSubtype
      .map((e) => investmentTransactionSubtypeFromJson(e.toString()))
      .toList();
}

String? depositSwitchGetResponseStateToJson(
    enums.DepositSwitchGetResponseState? depositSwitchGetResponseState) {
  return enums.$DepositSwitchGetResponseStateMap[depositSwitchGetResponseState];
}

enums.DepositSwitchGetResponseState depositSwitchGetResponseStateFromJson(
  Object? depositSwitchGetResponseState, [
  enums.DepositSwitchGetResponseState? defaultValue,
]) {
  if (depositSwitchGetResponseState is String) {
    return enums.$DepositSwitchGetResponseStateMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                depositSwitchGetResponseState.toLowerCase(),
            orElse: () => const MapEntry(
                enums.DepositSwitchGetResponseState.swaggerGeneratedUnknown,
                ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$DepositSwitchGetResponseStateMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.DepositSwitchGetResponseState.swaggerGeneratedUnknown;
}

List<String> depositSwitchGetResponseStateListToJson(
    List<enums.DepositSwitchGetResponseState>? depositSwitchGetResponseState) {
  if (depositSwitchGetResponseState == null) {
    return [];
  }

  return depositSwitchGetResponseState
      .map((e) => enums.$DepositSwitchGetResponseStateMap[e]!)
      .toList();
}

List<enums.DepositSwitchGetResponseState>
    depositSwitchGetResponseStateListFromJson(
  List? depositSwitchGetResponseState, [
  List<enums.DepositSwitchGetResponseState>? defaultValue,
]) {
  if (depositSwitchGetResponseState == null) {
    return defaultValue ?? [];
  }

  return depositSwitchGetResponseState
      .map((e) => depositSwitchGetResponseStateFromJson(e.toString()))
      .toList();
}

List<enums.DepositSwitchGetResponseState>?
    depositSwitchGetResponseStateNullableListFromJson(
  List? depositSwitchGetResponseState, [
  List<enums.DepositSwitchGetResponseState>? defaultValue,
]) {
  if (depositSwitchGetResponseState == null) {
    return defaultValue;
  }

  return depositSwitchGetResponseState
      .map((e) => depositSwitchGetResponseStateFromJson(e.toString()))
      .toList();
}

String? depositSwitchGetResponseSwitchMethodToJson(
    enums.DepositSwitchGetResponseSwitchMethod?
        depositSwitchGetResponseSwitchMethod) {
  return enums.$DepositSwitchGetResponseSwitchMethodMap[
      depositSwitchGetResponseSwitchMethod];
}

enums.DepositSwitchGetResponseSwitchMethod
    depositSwitchGetResponseSwitchMethodFromJson(
  Object? depositSwitchGetResponseSwitchMethod, [
  enums.DepositSwitchGetResponseSwitchMethod? defaultValue,
]) {
  if (depositSwitchGetResponseSwitchMethod is String) {
    return enums.$DepositSwitchGetResponseSwitchMethodMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                depositSwitchGetResponseSwitchMethod.toLowerCase(),
            orElse: () => const MapEntry(
                enums.DepositSwitchGetResponseSwitchMethod
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$DepositSwitchGetResponseSwitchMethodMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.DepositSwitchGetResponseSwitchMethod.swaggerGeneratedUnknown;
}

List<String> depositSwitchGetResponseSwitchMethodListToJson(
    List<enums.DepositSwitchGetResponseSwitchMethod>?
        depositSwitchGetResponseSwitchMethod) {
  if (depositSwitchGetResponseSwitchMethod == null) {
    return [];
  }

  return depositSwitchGetResponseSwitchMethod
      .map((e) => enums.$DepositSwitchGetResponseSwitchMethodMap[e]!)
      .toList();
}

List<enums.DepositSwitchGetResponseSwitchMethod>
    depositSwitchGetResponseSwitchMethodListFromJson(
  List? depositSwitchGetResponseSwitchMethod, [
  List<enums.DepositSwitchGetResponseSwitchMethod>? defaultValue,
]) {
  if (depositSwitchGetResponseSwitchMethod == null) {
    return defaultValue ?? [];
  }

  return depositSwitchGetResponseSwitchMethod
      .map((e) => depositSwitchGetResponseSwitchMethodFromJson(e.toString()))
      .toList();
}

List<enums.DepositSwitchGetResponseSwitchMethod>?
    depositSwitchGetResponseSwitchMethodNullableListFromJson(
  List? depositSwitchGetResponseSwitchMethod, [
  List<enums.DepositSwitchGetResponseSwitchMethod>? defaultValue,
]) {
  if (depositSwitchGetResponseSwitchMethod == null) {
    return defaultValue;
  }

  return depositSwitchGetResponseSwitchMethod
      .map((e) => depositSwitchGetResponseSwitchMethodFromJson(e.toString()))
      .toList();
}

String? aCHClassToJson(enums.ACHClass? aCHClass) {
  return enums.$ACHClassMap[aCHClass];
}

enums.ACHClass aCHClassFromJson(
  Object? aCHClass, [
  enums.ACHClass? defaultValue,
]) {
  if (aCHClass is String) {
    return enums.$ACHClassMap.entries
        .firstWhere(
            (element) => element.value.toLowerCase() == aCHClass.toLowerCase(),
            orElse: () =>
                const MapEntry(enums.ACHClass.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$ACHClassMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ?? defaultValue ?? enums.ACHClass.swaggerGeneratedUnknown;
}

List<String> aCHClassListToJson(List<enums.ACHClass>? aCHClass) {
  if (aCHClass == null) {
    return [];
  }

  return aCHClass.map((e) => enums.$ACHClassMap[e]!).toList();
}

List<enums.ACHClass> aCHClassListFromJson(
  List? aCHClass, [
  List<enums.ACHClass>? defaultValue,
]) {
  if (aCHClass == null) {
    return defaultValue ?? [];
  }

  return aCHClass.map((e) => aCHClassFromJson(e.toString())).toList();
}

List<enums.ACHClass>? aCHClassNullableListFromJson(
  List? aCHClass, [
  List<enums.ACHClass>? defaultValue,
]) {
  if (aCHClass == null) {
    return defaultValue;
  }

  return aCHClass.map((e) => aCHClassFromJson(e.toString())).toList();
}

String? transferIntentCreateModeToJson(
    enums.TransferIntentCreateMode? transferIntentCreateMode) {
  return enums.$TransferIntentCreateModeMap[transferIntentCreateMode];
}

enums.TransferIntentCreateMode transferIntentCreateModeFromJson(
  Object? transferIntentCreateMode, [
  enums.TransferIntentCreateMode? defaultValue,
]) {
  if (transferIntentCreateMode is String) {
    return enums.$TransferIntentCreateModeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                transferIntentCreateMode.toLowerCase(),
            orElse: () => const MapEntry(
                enums.TransferIntentCreateMode.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$TransferIntentCreateModeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.TransferIntentCreateMode.swaggerGeneratedUnknown;
}

List<String> transferIntentCreateModeListToJson(
    List<enums.TransferIntentCreateMode>? transferIntentCreateMode) {
  if (transferIntentCreateMode == null) {
    return [];
  }

  return transferIntentCreateMode
      .map((e) => enums.$TransferIntentCreateModeMap[e]!)
      .toList();
}

List<enums.TransferIntentCreateMode> transferIntentCreateModeListFromJson(
  List? transferIntentCreateMode, [
  List<enums.TransferIntentCreateMode>? defaultValue,
]) {
  if (transferIntentCreateMode == null) {
    return defaultValue ?? [];
  }

  return transferIntentCreateMode
      .map((e) => transferIntentCreateModeFromJson(e.toString()))
      .toList();
}

List<enums.TransferIntentCreateMode>?
    transferIntentCreateModeNullableListFromJson(
  List? transferIntentCreateMode, [
  List<enums.TransferIntentCreateMode>? defaultValue,
]) {
  if (transferIntentCreateMode == null) {
    return defaultValue;
  }

  return transferIntentCreateMode
      .map((e) => transferIntentCreateModeFromJson(e.toString()))
      .toList();
}

String? transferAuthorizationDecisionRationaleCodeToJson(
    enums.TransferAuthorizationDecisionRationaleCode?
        transferAuthorizationDecisionRationaleCode) {
  return enums.$TransferAuthorizationDecisionRationaleCodeMap[
      transferAuthorizationDecisionRationaleCode];
}

enums.TransferAuthorizationDecisionRationaleCode
    transferAuthorizationDecisionRationaleCodeFromJson(
  Object? transferAuthorizationDecisionRationaleCode, [
  enums.TransferAuthorizationDecisionRationaleCode? defaultValue,
]) {
  if (transferAuthorizationDecisionRationaleCode is String) {
    return enums.$TransferAuthorizationDecisionRationaleCodeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                transferAuthorizationDecisionRationaleCode.toLowerCase(),
            orElse: () => const MapEntry(
                enums.TransferAuthorizationDecisionRationaleCode
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$TransferAuthorizationDecisionRationaleCodeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.TransferAuthorizationDecisionRationaleCode.swaggerGeneratedUnknown;
}

List<String> transferAuthorizationDecisionRationaleCodeListToJson(
    List<enums.TransferAuthorizationDecisionRationaleCode>?
        transferAuthorizationDecisionRationaleCode) {
  if (transferAuthorizationDecisionRationaleCode == null) {
    return [];
  }

  return transferAuthorizationDecisionRationaleCode
      .map((e) => enums.$TransferAuthorizationDecisionRationaleCodeMap[e]!)
      .toList();
}

List<enums.TransferAuthorizationDecisionRationaleCode>
    transferAuthorizationDecisionRationaleCodeListFromJson(
  List? transferAuthorizationDecisionRationaleCode, [
  List<enums.TransferAuthorizationDecisionRationaleCode>? defaultValue,
]) {
  if (transferAuthorizationDecisionRationaleCode == null) {
    return defaultValue ?? [];
  }

  return transferAuthorizationDecisionRationaleCode
      .map((e) =>
          transferAuthorizationDecisionRationaleCodeFromJson(e.toString()))
      .toList();
}

List<enums.TransferAuthorizationDecisionRationaleCode>?
    transferAuthorizationDecisionRationaleCodeNullableListFromJson(
  List? transferAuthorizationDecisionRationaleCode, [
  List<enums.TransferAuthorizationDecisionRationaleCode>? defaultValue,
]) {
  if (transferAuthorizationDecisionRationaleCode == null) {
    return defaultValue;
  }

  return transferAuthorizationDecisionRationaleCode
      .map((e) =>
          transferAuthorizationDecisionRationaleCodeFromJson(e.toString()))
      .toList();
}

String? signalPaymentMethodToJson(
    enums.SignalPaymentMethod? signalPaymentMethod) {
  return enums.$SignalPaymentMethodMap[signalPaymentMethod];
}

enums.SignalPaymentMethod signalPaymentMethodFromJson(
  Object? signalPaymentMethod, [
  enums.SignalPaymentMethod? defaultValue,
]) {
  if (signalPaymentMethod is String) {
    return enums.$SignalPaymentMethodMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                signalPaymentMethod.toLowerCase(),
            orElse: () => const MapEntry(
                enums.SignalPaymentMethod.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$SignalPaymentMethodMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.SignalPaymentMethod.swaggerGeneratedUnknown;
}

List<String> signalPaymentMethodListToJson(
    List<enums.SignalPaymentMethod>? signalPaymentMethod) {
  if (signalPaymentMethod == null) {
    return [];
  }

  return signalPaymentMethod
      .map((e) => enums.$SignalPaymentMethodMap[e]!)
      .toList();
}

List<enums.SignalPaymentMethod> signalPaymentMethodListFromJson(
  List? signalPaymentMethod, [
  List<enums.SignalPaymentMethod>? defaultValue,
]) {
  if (signalPaymentMethod == null) {
    return defaultValue ?? [];
  }

  return signalPaymentMethod
      .map((e) => signalPaymentMethodFromJson(e.toString()))
      .toList();
}

List<enums.SignalPaymentMethod>? signalPaymentMethodNullableListFromJson(
  List? signalPaymentMethod, [
  List<enums.SignalPaymentMethod>? defaultValue,
]) {
  if (signalPaymentMethod == null) {
    return defaultValue;
  }

  return signalPaymentMethod
      .map((e) => signalPaymentMethodFromJson(e.toString()))
      .toList();
}

String? signalDecisionOutcomeToJson(
    enums.SignalDecisionOutcome? signalDecisionOutcome) {
  return enums.$SignalDecisionOutcomeMap[signalDecisionOutcome];
}

enums.SignalDecisionOutcome signalDecisionOutcomeFromJson(
  Object? signalDecisionOutcome, [
  enums.SignalDecisionOutcome? defaultValue,
]) {
  if (signalDecisionOutcome is String) {
    return enums.$SignalDecisionOutcomeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                signalDecisionOutcome.toLowerCase(),
            orElse: () => const MapEntry(
                enums.SignalDecisionOutcome.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$SignalDecisionOutcomeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.SignalDecisionOutcome.swaggerGeneratedUnknown;
}

List<String> signalDecisionOutcomeListToJson(
    List<enums.SignalDecisionOutcome>? signalDecisionOutcome) {
  if (signalDecisionOutcome == null) {
    return [];
  }

  return signalDecisionOutcome
      .map((e) => enums.$SignalDecisionOutcomeMap[e]!)
      .toList();
}

List<enums.SignalDecisionOutcome> signalDecisionOutcomeListFromJson(
  List? signalDecisionOutcome, [
  List<enums.SignalDecisionOutcome>? defaultValue,
]) {
  if (signalDecisionOutcome == null) {
    return defaultValue ?? [];
  }

  return signalDecisionOutcome
      .map((e) => signalDecisionOutcomeFromJson(e.toString()))
      .toList();
}

List<enums.SignalDecisionOutcome>? signalDecisionOutcomeNullableListFromJson(
  List? signalDecisionOutcome, [
  List<enums.SignalDecisionOutcome>? defaultValue,
]) {
  if (signalDecisionOutcome == null) {
    return defaultValue;
  }

  return signalDecisionOutcome
      .map((e) => signalDecisionOutcomeFromJson(e.toString()))
      .toList();
}

String? transferAuthorizationGuaranteeDecisionToJson(
    enums.TransferAuthorizationGuaranteeDecision?
        transferAuthorizationGuaranteeDecision) {
  return enums.$TransferAuthorizationGuaranteeDecisionMap[
      transferAuthorizationGuaranteeDecision];
}

enums.TransferAuthorizationGuaranteeDecision
    transferAuthorizationGuaranteeDecisionFromJson(
  Object? transferAuthorizationGuaranteeDecision, [
  enums.TransferAuthorizationGuaranteeDecision? defaultValue,
]) {
  if (transferAuthorizationGuaranteeDecision is String) {
    return enums.$TransferAuthorizationGuaranteeDecisionMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                transferAuthorizationGuaranteeDecision.toLowerCase(),
            orElse: () => const MapEntry(
                enums.TransferAuthorizationGuaranteeDecision
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$TransferAuthorizationGuaranteeDecisionMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.TransferAuthorizationGuaranteeDecision.swaggerGeneratedUnknown;
}

List<String> transferAuthorizationGuaranteeDecisionListToJson(
    List<enums.TransferAuthorizationGuaranteeDecision>?
        transferAuthorizationGuaranteeDecision) {
  if (transferAuthorizationGuaranteeDecision == null) {
    return [];
  }

  return transferAuthorizationGuaranteeDecision
      .map((e) => enums.$TransferAuthorizationGuaranteeDecisionMap[e]!)
      .toList();
}

List<enums.TransferAuthorizationGuaranteeDecision>
    transferAuthorizationGuaranteeDecisionListFromJson(
  List? transferAuthorizationGuaranteeDecision, [
  List<enums.TransferAuthorizationGuaranteeDecision>? defaultValue,
]) {
  if (transferAuthorizationGuaranteeDecision == null) {
    return defaultValue ?? [];
  }

  return transferAuthorizationGuaranteeDecision
      .map((e) => transferAuthorizationGuaranteeDecisionFromJson(e.toString()))
      .toList();
}

List<enums.TransferAuthorizationGuaranteeDecision>?
    transferAuthorizationGuaranteeDecisionNullableListFromJson(
  List? transferAuthorizationGuaranteeDecision, [
  List<enums.TransferAuthorizationGuaranteeDecision>? defaultValue,
]) {
  if (transferAuthorizationGuaranteeDecision == null) {
    return defaultValue;
  }

  return transferAuthorizationGuaranteeDecision
      .map((e) => transferAuthorizationGuaranteeDecisionFromJson(e.toString()))
      .toList();
}

String? transferAuthorizationGuaranteeDecisionRationaleCodeToJson(
    enums.TransferAuthorizationGuaranteeDecisionRationaleCode?
        transferAuthorizationGuaranteeDecisionRationaleCode) {
  return enums.$TransferAuthorizationGuaranteeDecisionRationaleCodeMap[
      transferAuthorizationGuaranteeDecisionRationaleCode];
}

enums.TransferAuthorizationGuaranteeDecisionRationaleCode
    transferAuthorizationGuaranteeDecisionRationaleCodeFromJson(
  Object? transferAuthorizationGuaranteeDecisionRationaleCode, [
  enums.TransferAuthorizationGuaranteeDecisionRationaleCode? defaultValue,
]) {
  if (transferAuthorizationGuaranteeDecisionRationaleCode is String) {
    return enums.$TransferAuthorizationGuaranteeDecisionRationaleCodeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                transferAuthorizationGuaranteeDecisionRationaleCode
                    .toLowerCase(),
            orElse: () => const MapEntry(
                enums.TransferAuthorizationGuaranteeDecisionRationaleCode
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$TransferAuthorizationGuaranteeDecisionRationaleCodeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.TransferAuthorizationGuaranteeDecisionRationaleCode
          .swaggerGeneratedUnknown;
}

List<String> transferAuthorizationGuaranteeDecisionRationaleCodeListToJson(
    List<enums.TransferAuthorizationGuaranteeDecisionRationaleCode>?
        transferAuthorizationGuaranteeDecisionRationaleCode) {
  if (transferAuthorizationGuaranteeDecisionRationaleCode == null) {
    return [];
  }

  return transferAuthorizationGuaranteeDecisionRationaleCode
      .map((e) =>
          enums.$TransferAuthorizationGuaranteeDecisionRationaleCodeMap[e]!)
      .toList();
}

List<enums.TransferAuthorizationGuaranteeDecisionRationaleCode>
    transferAuthorizationGuaranteeDecisionRationaleCodeListFromJson(
  List? transferAuthorizationGuaranteeDecisionRationaleCode, [
  List<enums.TransferAuthorizationGuaranteeDecisionRationaleCode>? defaultValue,
]) {
  if (transferAuthorizationGuaranteeDecisionRationaleCode == null) {
    return defaultValue ?? [];
  }

  return transferAuthorizationGuaranteeDecisionRationaleCode
      .map((e) => transferAuthorizationGuaranteeDecisionRationaleCodeFromJson(
          e.toString()))
      .toList();
}

List<enums.TransferAuthorizationGuaranteeDecisionRationaleCode>?
    transferAuthorizationGuaranteeDecisionRationaleCodeNullableListFromJson(
  List? transferAuthorizationGuaranteeDecisionRationaleCode, [
  List<enums.TransferAuthorizationGuaranteeDecisionRationaleCode>? defaultValue,
]) {
  if (transferAuthorizationGuaranteeDecisionRationaleCode == null) {
    return defaultValue;
  }

  return transferAuthorizationGuaranteeDecisionRationaleCode
      .map((e) => transferAuthorizationGuaranteeDecisionRationaleCodeFromJson(
          e.toString()))
      .toList();
}

String? transferScheduleIntervalUnitToJson(
    enums.TransferScheduleIntervalUnit? transferScheduleIntervalUnit) {
  return enums.$TransferScheduleIntervalUnitMap[transferScheduleIntervalUnit];
}

enums.TransferScheduleIntervalUnit transferScheduleIntervalUnitFromJson(
  Object? transferScheduleIntervalUnit, [
  enums.TransferScheduleIntervalUnit? defaultValue,
]) {
  if (transferScheduleIntervalUnit is String) {
    return enums.$TransferScheduleIntervalUnitMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                transferScheduleIntervalUnit.toLowerCase(),
            orElse: () => const MapEntry(
                enums.TransferScheduleIntervalUnit.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$TransferScheduleIntervalUnitMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.TransferScheduleIntervalUnit.swaggerGeneratedUnknown;
}

List<String> transferScheduleIntervalUnitListToJson(
    List<enums.TransferScheduleIntervalUnit>? transferScheduleIntervalUnit) {
  if (transferScheduleIntervalUnit == null) {
    return [];
  }

  return transferScheduleIntervalUnit
      .map((e) => enums.$TransferScheduleIntervalUnitMap[e]!)
      .toList();
}

List<enums.TransferScheduleIntervalUnit>
    transferScheduleIntervalUnitListFromJson(
  List? transferScheduleIntervalUnit, [
  List<enums.TransferScheduleIntervalUnit>? defaultValue,
]) {
  if (transferScheduleIntervalUnit == null) {
    return defaultValue ?? [];
  }

  return transferScheduleIntervalUnit
      .map((e) => transferScheduleIntervalUnitFromJson(e.toString()))
      .toList();
}

List<enums.TransferScheduleIntervalUnit>?
    transferScheduleIntervalUnitNullableListFromJson(
  List? transferScheduleIntervalUnit, [
  List<enums.TransferScheduleIntervalUnit>? defaultValue,
]) {
  if (transferScheduleIntervalUnit == null) {
    return defaultValue;
  }

  return transferScheduleIntervalUnit
      .map((e) => transferScheduleIntervalUnitFromJson(e.toString()))
      .toList();
}

String? transferTypeToJson(enums.TransferType? transferType) {
  return enums.$TransferTypeMap[transferType];
}

enums.TransferType transferTypeFromJson(
  Object? transferType, [
  enums.TransferType? defaultValue,
]) {
  if (transferType is String) {
    return enums.$TransferTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == transferType.toLowerCase(),
            orElse: () =>
                const MapEntry(enums.TransferType.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$TransferTypeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.TransferType.swaggerGeneratedUnknown;
}

List<String> transferTypeListToJson(List<enums.TransferType>? transferType) {
  if (transferType == null) {
    return [];
  }

  return transferType.map((e) => enums.$TransferTypeMap[e]!).toList();
}

List<enums.TransferType> transferTypeListFromJson(
  List? transferType, [
  List<enums.TransferType>? defaultValue,
]) {
  if (transferType == null) {
    return defaultValue ?? [];
  }

  return transferType.map((e) => transferTypeFromJson(e.toString())).toList();
}

List<enums.TransferType>? transferTypeNullableListFromJson(
  List? transferType, [
  List<enums.TransferType>? defaultValue,
]) {
  if (transferType == null) {
    return defaultValue;
  }

  return transferType.map((e) => transferTypeFromJson(e.toString())).toList();
}

String? bankTransferTypeToJson(enums.BankTransferType? bankTransferType) {
  return enums.$BankTransferTypeMap[bankTransferType];
}

enums.BankTransferType bankTransferTypeFromJson(
  Object? bankTransferType, [
  enums.BankTransferType? defaultValue,
]) {
  if (bankTransferType is String) {
    return enums.$BankTransferTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == bankTransferType.toLowerCase(),
            orElse: () => const MapEntry(
                enums.BankTransferType.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$BankTransferTypeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.BankTransferType.swaggerGeneratedUnknown;
}

List<String> bankTransferTypeListToJson(
    List<enums.BankTransferType>? bankTransferType) {
  if (bankTransferType == null) {
    return [];
  }

  return bankTransferType.map((e) => enums.$BankTransferTypeMap[e]!).toList();
}

List<enums.BankTransferType> bankTransferTypeListFromJson(
  List? bankTransferType, [
  List<enums.BankTransferType>? defaultValue,
]) {
  if (bankTransferType == null) {
    return defaultValue ?? [];
  }

  return bankTransferType
      .map((e) => bankTransferTypeFromJson(e.toString()))
      .toList();
}

List<enums.BankTransferType>? bankTransferTypeNullableListFromJson(
  List? bankTransferType, [
  List<enums.BankTransferType>? defaultValue,
]) {
  if (bankTransferType == null) {
    return defaultValue;
  }

  return bankTransferType
      .map((e) => bankTransferTypeFromJson(e.toString()))
      .toList();
}

String? transactionFrequencyToJson(
    enums.TransactionFrequency? transactionFrequency) {
  return enums.$TransactionFrequencyMap[transactionFrequency];
}

enums.TransactionFrequency transactionFrequencyFromJson(
  Object? transactionFrequency, [
  enums.TransactionFrequency? defaultValue,
]) {
  if (transactionFrequency is String) {
    return enums.$TransactionFrequencyMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                transactionFrequency.toLowerCase(),
            orElse: () => const MapEntry(
                enums.TransactionFrequency.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$TransactionFrequencyMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.TransactionFrequency.swaggerGeneratedUnknown;
}

List<String> transactionFrequencyListToJson(
    List<enums.TransactionFrequency>? transactionFrequency) {
  if (transactionFrequency == null) {
    return [];
  }

  return transactionFrequency
      .map((e) => enums.$TransactionFrequencyMap[e]!)
      .toList();
}

List<enums.TransactionFrequency> transactionFrequencyListFromJson(
  List? transactionFrequency, [
  List<enums.TransactionFrequency>? defaultValue,
]) {
  if (transactionFrequency == null) {
    return defaultValue ?? [];
  }

  return transactionFrequency
      .map((e) => transactionFrequencyFromJson(e.toString()))
      .toList();
}

List<enums.TransactionFrequency>? transactionFrequencyNullableListFromJson(
  List? transactionFrequency, [
  List<enums.TransactionFrequency>? defaultValue,
]) {
  if (transactionFrequency == null) {
    return defaultValue;
  }

  return transactionFrequency
      .map((e) => transactionFrequencyFromJson(e.toString()))
      .toList();
}

String? transferDiligenceStatusToJson(
    enums.TransferDiligenceStatus? transferDiligenceStatus) {
  return enums.$TransferDiligenceStatusMap[transferDiligenceStatus];
}

enums.TransferDiligenceStatus transferDiligenceStatusFromJson(
  Object? transferDiligenceStatus, [
  enums.TransferDiligenceStatus? defaultValue,
]) {
  if (transferDiligenceStatus is String) {
    return enums.$TransferDiligenceStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                transferDiligenceStatus.toLowerCase(),
            orElse: () => const MapEntry(
                enums.TransferDiligenceStatus.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$TransferDiligenceStatusMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.TransferDiligenceStatus.swaggerGeneratedUnknown;
}

List<String> transferDiligenceStatusListToJson(
    List<enums.TransferDiligenceStatus>? transferDiligenceStatus) {
  if (transferDiligenceStatus == null) {
    return [];
  }

  return transferDiligenceStatus
      .map((e) => enums.$TransferDiligenceStatusMap[e]!)
      .toList();
}

List<enums.TransferDiligenceStatus> transferDiligenceStatusListFromJson(
  List? transferDiligenceStatus, [
  List<enums.TransferDiligenceStatus>? defaultValue,
]) {
  if (transferDiligenceStatus == null) {
    return defaultValue ?? [];
  }

  return transferDiligenceStatus
      .map((e) => transferDiligenceStatusFromJson(e.toString()))
      .toList();
}

List<enums.TransferDiligenceStatus>?
    transferDiligenceStatusNullableListFromJson(
  List? transferDiligenceStatus, [
  List<enums.TransferDiligenceStatus>? defaultValue,
]) {
  if (transferDiligenceStatus == null) {
    return defaultValue;
  }

  return transferDiligenceStatus
      .map((e) => transferDiligenceStatusFromJson(e.toString()))
      .toList();
}

String? transferStatusToJson(enums.TransferStatus? transferStatus) {
  return enums.$TransferStatusMap[transferStatus];
}

enums.TransferStatus transferStatusFromJson(
  Object? transferStatus, [
  enums.TransferStatus? defaultValue,
]) {
  if (transferStatus is String) {
    return enums.$TransferStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == transferStatus.toLowerCase(),
            orElse: () => const MapEntry(
                enums.TransferStatus.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$TransferStatusMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.TransferStatus.swaggerGeneratedUnknown;
}

List<String> transferStatusListToJson(
    List<enums.TransferStatus>? transferStatus) {
  if (transferStatus == null) {
    return [];
  }

  return transferStatus.map((e) => enums.$TransferStatusMap[e]!).toList();
}

List<enums.TransferStatus> transferStatusListFromJson(
  List? transferStatus, [
  List<enums.TransferStatus>? defaultValue,
]) {
  if (transferStatus == null) {
    return defaultValue ?? [];
  }

  return transferStatus
      .map((e) => transferStatusFromJson(e.toString()))
      .toList();
}

List<enums.TransferStatus>? transferStatusNullableListFromJson(
  List? transferStatus, [
  List<enums.TransferStatus>? defaultValue,
]) {
  if (transferStatus == null) {
    return defaultValue;
  }

  return transferStatus
      .map((e) => transferStatusFromJson(e.toString()))
      .toList();
}

String? transferRecurringStatusToJson(
    enums.TransferRecurringStatus? transferRecurringStatus) {
  return enums.$TransferRecurringStatusMap[transferRecurringStatus];
}

enums.TransferRecurringStatus transferRecurringStatusFromJson(
  Object? transferRecurringStatus, [
  enums.TransferRecurringStatus? defaultValue,
]) {
  if (transferRecurringStatus is String) {
    return enums.$TransferRecurringStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                transferRecurringStatus.toLowerCase(),
            orElse: () => const MapEntry(
                enums.TransferRecurringStatus.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$TransferRecurringStatusMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.TransferRecurringStatus.swaggerGeneratedUnknown;
}

List<String> transferRecurringStatusListToJson(
    List<enums.TransferRecurringStatus>? transferRecurringStatus) {
  if (transferRecurringStatus == null) {
    return [];
  }

  return transferRecurringStatus
      .map((e) => enums.$TransferRecurringStatusMap[e]!)
      .toList();
}

List<enums.TransferRecurringStatus> transferRecurringStatusListFromJson(
  List? transferRecurringStatus, [
  List<enums.TransferRecurringStatus>? defaultValue,
]) {
  if (transferRecurringStatus == null) {
    return defaultValue ?? [];
  }

  return transferRecurringStatus
      .map((e) => transferRecurringStatusFromJson(e.toString()))
      .toList();
}

List<enums.TransferRecurringStatus>?
    transferRecurringStatusNullableListFromJson(
  List? transferRecurringStatus, [
  List<enums.TransferRecurringStatus>? defaultValue,
]) {
  if (transferRecurringStatus == null) {
    return defaultValue;
  }

  return transferRecurringStatus
      .map((e) => transferRecurringStatusFromJson(e.toString()))
      .toList();
}

String? transferSweepStatusToJson(
    enums.TransferSweepStatus? transferSweepStatus) {
  return enums.$TransferSweepStatusMap[transferSweepStatus];
}

enums.TransferSweepStatus transferSweepStatusFromJson(
  Object? transferSweepStatus, [
  enums.TransferSweepStatus? defaultValue,
]) {
  if (transferSweepStatus is String) {
    return enums.$TransferSweepStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                transferSweepStatus.toLowerCase(),
            orElse: () => const MapEntry(
                enums.TransferSweepStatus.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$TransferSweepStatusMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.TransferSweepStatus.swaggerGeneratedUnknown;
}

List<String> transferSweepStatusListToJson(
    List<enums.TransferSweepStatus>? transferSweepStatus) {
  if (transferSweepStatus == null) {
    return [];
  }

  return transferSweepStatus
      .map((e) => enums.$TransferSweepStatusMap[e]!)
      .toList();
}

List<enums.TransferSweepStatus> transferSweepStatusListFromJson(
  List? transferSweepStatus, [
  List<enums.TransferSweepStatus>? defaultValue,
]) {
  if (transferSweepStatus == null) {
    return defaultValue ?? [];
  }

  return transferSweepStatus
      .map((e) => transferSweepStatusFromJson(e.toString()))
      .toList();
}

List<enums.TransferSweepStatus>? transferSweepStatusNullableListFromJson(
  List? transferSweepStatus, [
  List<enums.TransferSweepStatus>? defaultValue,
]) {
  if (transferSweepStatus == null) {
    return defaultValue;
  }

  return transferSweepStatus
      .map((e) => transferSweepStatusFromJson(e.toString()))
      .toList();
}

String? transferRefundStatusToJson(
    enums.TransferRefundStatus? transferRefundStatus) {
  return enums.$TransferRefundStatusMap[transferRefundStatus];
}

enums.TransferRefundStatus transferRefundStatusFromJson(
  Object? transferRefundStatus, [
  enums.TransferRefundStatus? defaultValue,
]) {
  if (transferRefundStatus is String) {
    return enums.$TransferRefundStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                transferRefundStatus.toLowerCase(),
            orElse: () => const MapEntry(
                enums.TransferRefundStatus.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$TransferRefundStatusMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.TransferRefundStatus.swaggerGeneratedUnknown;
}

List<String> transferRefundStatusListToJson(
    List<enums.TransferRefundStatus>? transferRefundStatus) {
  if (transferRefundStatus == null) {
    return [];
  }

  return transferRefundStatus
      .map((e) => enums.$TransferRefundStatusMap[e]!)
      .toList();
}

List<enums.TransferRefundStatus> transferRefundStatusListFromJson(
  List? transferRefundStatus, [
  List<enums.TransferRefundStatus>? defaultValue,
]) {
  if (transferRefundStatus == null) {
    return defaultValue ?? [];
  }

  return transferRefundStatus
      .map((e) => transferRefundStatusFromJson(e.toString()))
      .toList();
}

List<enums.TransferRefundStatus>? transferRefundStatusNullableListFromJson(
  List? transferRefundStatus, [
  List<enums.TransferRefundStatus>? defaultValue,
]) {
  if (transferRefundStatus == null) {
    return defaultValue;
  }

  return transferRefundStatus
      .map((e) => transferRefundStatusFromJson(e.toString()))
      .toList();
}

String? bankTransferStatusToJson(enums.BankTransferStatus? bankTransferStatus) {
  return enums.$BankTransferStatusMap[bankTransferStatus];
}

enums.BankTransferStatus bankTransferStatusFromJson(
  Object? bankTransferStatus, [
  enums.BankTransferStatus? defaultValue,
]) {
  if (bankTransferStatus is String) {
    return enums.$BankTransferStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == bankTransferStatus.toLowerCase(),
            orElse: () => const MapEntry(
                enums.BankTransferStatus.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$BankTransferStatusMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.BankTransferStatus.swaggerGeneratedUnknown;
}

List<String> bankTransferStatusListToJson(
    List<enums.BankTransferStatus>? bankTransferStatus) {
  if (bankTransferStatus == null) {
    return [];
  }

  return bankTransferStatus
      .map((e) => enums.$BankTransferStatusMap[e]!)
      .toList();
}

List<enums.BankTransferStatus> bankTransferStatusListFromJson(
  List? bankTransferStatus, [
  List<enums.BankTransferStatus>? defaultValue,
]) {
  if (bankTransferStatus == null) {
    return defaultValue ?? [];
  }

  return bankTransferStatus
      .map((e) => bankTransferStatusFromJson(e.toString()))
      .toList();
}

List<enums.BankTransferStatus>? bankTransferStatusNullableListFromJson(
  List? bankTransferStatus, [
  List<enums.BankTransferStatus>? defaultValue,
]) {
  if (bankTransferStatus == null) {
    return defaultValue;
  }

  return bankTransferStatus
      .map((e) => bankTransferStatusFromJson(e.toString()))
      .toList();
}

String? transferNetworkToJson(enums.TransferNetwork? transferNetwork) {
  return enums.$TransferNetworkMap[transferNetwork];
}

enums.TransferNetwork transferNetworkFromJson(
  Object? transferNetwork, [
  enums.TransferNetwork? defaultValue,
]) {
  if (transferNetwork is String) {
    return enums.$TransferNetworkMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == transferNetwork.toLowerCase(),
            orElse: () => const MapEntry(
                enums.TransferNetwork.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$TransferNetworkMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.TransferNetwork.swaggerGeneratedUnknown;
}

List<String> transferNetworkListToJson(
    List<enums.TransferNetwork>? transferNetwork) {
  if (transferNetwork == null) {
    return [];
  }

  return transferNetwork.map((e) => enums.$TransferNetworkMap[e]!).toList();
}

List<enums.TransferNetwork> transferNetworkListFromJson(
  List? transferNetwork, [
  List<enums.TransferNetwork>? defaultValue,
]) {
  if (transferNetwork == null) {
    return defaultValue ?? [];
  }

  return transferNetwork
      .map((e) => transferNetworkFromJson(e.toString()))
      .toList();
}

List<enums.TransferNetwork>? transferNetworkNullableListFromJson(
  List? transferNetwork, [
  List<enums.TransferNetwork>? defaultValue,
]) {
  if (transferNetwork == null) {
    return defaultValue;
  }

  return transferNetwork
      .map((e) => transferNetworkFromJson(e.toString()))
      .toList();
}

String? bankTransferNetworkToJson(
    enums.BankTransferNetwork? bankTransferNetwork) {
  return enums.$BankTransferNetworkMap[bankTransferNetwork];
}

enums.BankTransferNetwork bankTransferNetworkFromJson(
  Object? bankTransferNetwork, [
  enums.BankTransferNetwork? defaultValue,
]) {
  if (bankTransferNetwork is String) {
    return enums.$BankTransferNetworkMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                bankTransferNetwork.toLowerCase(),
            orElse: () => const MapEntry(
                enums.BankTransferNetwork.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$BankTransferNetworkMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.BankTransferNetwork.swaggerGeneratedUnknown;
}

List<String> bankTransferNetworkListToJson(
    List<enums.BankTransferNetwork>? bankTransferNetwork) {
  if (bankTransferNetwork == null) {
    return [];
  }

  return bankTransferNetwork
      .map((e) => enums.$BankTransferNetworkMap[e]!)
      .toList();
}

List<enums.BankTransferNetwork> bankTransferNetworkListFromJson(
  List? bankTransferNetwork, [
  List<enums.BankTransferNetwork>? defaultValue,
]) {
  if (bankTransferNetwork == null) {
    return defaultValue ?? [];
  }

  return bankTransferNetwork
      .map((e) => bankTransferNetworkFromJson(e.toString()))
      .toList();
}

List<enums.BankTransferNetwork>? bankTransferNetworkNullableListFromJson(
  List? bankTransferNetwork, [
  List<enums.BankTransferNetwork>? defaultValue,
]) {
  if (bankTransferNetwork == null) {
    return defaultValue;
  }

  return bankTransferNetwork
      .map((e) => bankTransferNetworkFromJson(e.toString()))
      .toList();
}

String? transferAuthorizationDecisionToJson(
    enums.TransferAuthorizationDecision? transferAuthorizationDecision) {
  return enums.$TransferAuthorizationDecisionMap[transferAuthorizationDecision];
}

enums.TransferAuthorizationDecision transferAuthorizationDecisionFromJson(
  Object? transferAuthorizationDecision, [
  enums.TransferAuthorizationDecision? defaultValue,
]) {
  if (transferAuthorizationDecision is String) {
    return enums.$TransferAuthorizationDecisionMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                transferAuthorizationDecision.toLowerCase(),
            orElse: () => const MapEntry(
                enums.TransferAuthorizationDecision.swaggerGeneratedUnknown,
                ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$TransferAuthorizationDecisionMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.TransferAuthorizationDecision.swaggerGeneratedUnknown;
}

List<String> transferAuthorizationDecisionListToJson(
    List<enums.TransferAuthorizationDecision>? transferAuthorizationDecision) {
  if (transferAuthorizationDecision == null) {
    return [];
  }

  return transferAuthorizationDecision
      .map((e) => enums.$TransferAuthorizationDecisionMap[e]!)
      .toList();
}

List<enums.TransferAuthorizationDecision>
    transferAuthorizationDecisionListFromJson(
  List? transferAuthorizationDecision, [
  List<enums.TransferAuthorizationDecision>? defaultValue,
]) {
  if (transferAuthorizationDecision == null) {
    return defaultValue ?? [];
  }

  return transferAuthorizationDecision
      .map((e) => transferAuthorizationDecisionFromJson(e.toString()))
      .toList();
}

List<enums.TransferAuthorizationDecision>?
    transferAuthorizationDecisionNullableListFromJson(
  List? transferAuthorizationDecision, [
  List<enums.TransferAuthorizationDecision>? defaultValue,
]) {
  if (transferAuthorizationDecision == null) {
    return defaultValue;
  }

  return transferAuthorizationDecision
      .map((e) => transferAuthorizationDecisionFromJson(e.toString()))
      .toList();
}

String? bankTransferDirectionToJson(
    enums.BankTransferDirection? bankTransferDirection) {
  return enums.$BankTransferDirectionMap[bankTransferDirection];
}

enums.BankTransferDirection bankTransferDirectionFromJson(
  Object? bankTransferDirection, [
  enums.BankTransferDirection? defaultValue,
]) {
  if (bankTransferDirection is String) {
    return enums.$BankTransferDirectionMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                bankTransferDirection.toLowerCase(),
            orElse: () => const MapEntry(
                enums.BankTransferDirection.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$BankTransferDirectionMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.BankTransferDirection.swaggerGeneratedUnknown;
}

List<String> bankTransferDirectionListToJson(
    List<enums.BankTransferDirection>? bankTransferDirection) {
  if (bankTransferDirection == null) {
    return [];
  }

  return bankTransferDirection
      .map((e) => enums.$BankTransferDirectionMap[e]!)
      .toList();
}

List<enums.BankTransferDirection> bankTransferDirectionListFromJson(
  List? bankTransferDirection, [
  List<enums.BankTransferDirection>? defaultValue,
]) {
  if (bankTransferDirection == null) {
    return defaultValue ?? [];
  }

  return bankTransferDirection
      .map((e) => bankTransferDirectionFromJson(e.toString()))
      .toList();
}

List<enums.BankTransferDirection>? bankTransferDirectionNullableListFromJson(
  List? bankTransferDirection, [
  List<enums.BankTransferDirection>? defaultValue,
]) {
  if (bankTransferDirection == null) {
    return defaultValue;
  }

  return bankTransferDirection
      .map((e) => bankTransferDirectionFromJson(e.toString()))
      .toList();
}

String? transferEventListTransferTypeToJson(
    enums.TransferEventListTransferType? transferEventListTransferType) {
  return enums.$TransferEventListTransferTypeMap[transferEventListTransferType];
}

enums.TransferEventListTransferType transferEventListTransferTypeFromJson(
  Object? transferEventListTransferType, [
  enums.TransferEventListTransferType? defaultValue,
]) {
  if (transferEventListTransferType is String) {
    return enums.$TransferEventListTransferTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                transferEventListTransferType.toLowerCase(),
            orElse: () => const MapEntry(
                enums.TransferEventListTransferType.swaggerGeneratedUnknown,
                ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$TransferEventListTransferTypeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.TransferEventListTransferType.swaggerGeneratedUnknown;
}

List<String> transferEventListTransferTypeListToJson(
    List<enums.TransferEventListTransferType>? transferEventListTransferType) {
  if (transferEventListTransferType == null) {
    return [];
  }

  return transferEventListTransferType
      .map((e) => enums.$TransferEventListTransferTypeMap[e]!)
      .toList();
}

List<enums.TransferEventListTransferType>
    transferEventListTransferTypeListFromJson(
  List? transferEventListTransferType, [
  List<enums.TransferEventListTransferType>? defaultValue,
]) {
  if (transferEventListTransferType == null) {
    return defaultValue ?? [];
  }

  return transferEventListTransferType
      .map((e) => transferEventListTransferTypeFromJson(e.toString()))
      .toList();
}

List<enums.TransferEventListTransferType>?
    transferEventListTransferTypeNullableListFromJson(
  List? transferEventListTransferType, [
  List<enums.TransferEventListTransferType>? defaultValue,
]) {
  if (transferEventListTransferType == null) {
    return defaultValue;
  }

  return transferEventListTransferType
      .map((e) => transferEventListTransferTypeFromJson(e.toString()))
      .toList();
}

String? bankTransferEventListBankTransferTypeToJson(
    enums.BankTransferEventListBankTransferType?
        bankTransferEventListBankTransferType) {
  return enums.$BankTransferEventListBankTransferTypeMap[
      bankTransferEventListBankTransferType];
}

enums.BankTransferEventListBankTransferType
    bankTransferEventListBankTransferTypeFromJson(
  Object? bankTransferEventListBankTransferType, [
  enums.BankTransferEventListBankTransferType? defaultValue,
]) {
  if (bankTransferEventListBankTransferType is String) {
    return enums.$BankTransferEventListBankTransferTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                bankTransferEventListBankTransferType.toLowerCase(),
            orElse: () => const MapEntry(
                enums.BankTransferEventListBankTransferType
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$BankTransferEventListBankTransferTypeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.BankTransferEventListBankTransferType.swaggerGeneratedUnknown;
}

List<String> bankTransferEventListBankTransferTypeListToJson(
    List<enums.BankTransferEventListBankTransferType>?
        bankTransferEventListBankTransferType) {
  if (bankTransferEventListBankTransferType == null) {
    return [];
  }

  return bankTransferEventListBankTransferType
      .map((e) => enums.$BankTransferEventListBankTransferTypeMap[e]!)
      .toList();
}

List<enums.BankTransferEventListBankTransferType>
    bankTransferEventListBankTransferTypeListFromJson(
  List? bankTransferEventListBankTransferType, [
  List<enums.BankTransferEventListBankTransferType>? defaultValue,
]) {
  if (bankTransferEventListBankTransferType == null) {
    return defaultValue ?? [];
  }

  return bankTransferEventListBankTransferType
      .map((e) => bankTransferEventListBankTransferTypeFromJson(e.toString()))
      .toList();
}

List<enums.BankTransferEventListBankTransferType>?
    bankTransferEventListBankTransferTypeNullableListFromJson(
  List? bankTransferEventListBankTransferType, [
  List<enums.BankTransferEventListBankTransferType>? defaultValue,
]) {
  if (bankTransferEventListBankTransferType == null) {
    return defaultValue;
  }

  return bankTransferEventListBankTransferType
      .map((e) => bankTransferEventListBankTransferTypeFromJson(e.toString()))
      .toList();
}

String? bankTransferEventListDirectionToJson(
    enums.BankTransferEventListDirection? bankTransferEventListDirection) {
  return enums
      .$BankTransferEventListDirectionMap[bankTransferEventListDirection];
}

enums.BankTransferEventListDirection bankTransferEventListDirectionFromJson(
  Object? bankTransferEventListDirection, [
  enums.BankTransferEventListDirection? defaultValue,
]) {
  if (bankTransferEventListDirection is String) {
    return enums.$BankTransferEventListDirectionMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                bankTransferEventListDirection.toLowerCase(),
            orElse: () => const MapEntry(
                enums.BankTransferEventListDirection.swaggerGeneratedUnknown,
                ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$BankTransferEventListDirectionMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.BankTransferEventListDirection.swaggerGeneratedUnknown;
}

List<String> bankTransferEventListDirectionListToJson(
    List<enums.BankTransferEventListDirection>?
        bankTransferEventListDirection) {
  if (bankTransferEventListDirection == null) {
    return [];
  }

  return bankTransferEventListDirection
      .map((e) => enums.$BankTransferEventListDirectionMap[e]!)
      .toList();
}

List<enums.BankTransferEventListDirection>
    bankTransferEventListDirectionListFromJson(
  List? bankTransferEventListDirection, [
  List<enums.BankTransferEventListDirection>? defaultValue,
]) {
  if (bankTransferEventListDirection == null) {
    return defaultValue ?? [];
  }

  return bankTransferEventListDirection
      .map((e) => bankTransferEventListDirectionFromJson(e.toString()))
      .toList();
}

List<enums.BankTransferEventListDirection>?
    bankTransferEventListDirectionNullableListFromJson(
  List? bankTransferEventListDirection, [
  List<enums.BankTransferEventListDirection>? defaultValue,
]) {
  if (bankTransferEventListDirection == null) {
    return defaultValue;
  }

  return bankTransferEventListDirection
      .map((e) => bankTransferEventListDirectionFromJson(e.toString()))
      .toList();
}

String? transferEventTypeToJson(enums.TransferEventType? transferEventType) {
  return enums.$TransferEventTypeMap[transferEventType];
}

enums.TransferEventType transferEventTypeFromJson(
  Object? transferEventType, [
  enums.TransferEventType? defaultValue,
]) {
  if (transferEventType is String) {
    return enums.$TransferEventTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == transferEventType.toLowerCase(),
            orElse: () => const MapEntry(
                enums.TransferEventType.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$TransferEventTypeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.TransferEventType.swaggerGeneratedUnknown;
}

List<String> transferEventTypeListToJson(
    List<enums.TransferEventType>? transferEventType) {
  if (transferEventType == null) {
    return [];
  }

  return transferEventType.map((e) => enums.$TransferEventTypeMap[e]!).toList();
}

List<enums.TransferEventType> transferEventTypeListFromJson(
  List? transferEventType, [
  List<enums.TransferEventType>? defaultValue,
]) {
  if (transferEventType == null) {
    return defaultValue ?? [];
  }

  return transferEventType
      .map((e) => transferEventTypeFromJson(e.toString()))
      .toList();
}

List<enums.TransferEventType>? transferEventTypeNullableListFromJson(
  List? transferEventType, [
  List<enums.TransferEventType>? defaultValue,
]) {
  if (transferEventType == null) {
    return defaultValue;
  }

  return transferEventType
      .map((e) => transferEventTypeFromJson(e.toString()))
      .toList();
}

String? bankTransferEventTypeToJson(
    enums.BankTransferEventType? bankTransferEventType) {
  return enums.$BankTransferEventTypeMap[bankTransferEventType];
}

enums.BankTransferEventType bankTransferEventTypeFromJson(
  Object? bankTransferEventType, [
  enums.BankTransferEventType? defaultValue,
]) {
  if (bankTransferEventType is String) {
    return enums.$BankTransferEventTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                bankTransferEventType.toLowerCase(),
            orElse: () => const MapEntry(
                enums.BankTransferEventType.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$BankTransferEventTypeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.BankTransferEventType.swaggerGeneratedUnknown;
}

List<String> bankTransferEventTypeListToJson(
    List<enums.BankTransferEventType>? bankTransferEventType) {
  if (bankTransferEventType == null) {
    return [];
  }

  return bankTransferEventType
      .map((e) => enums.$BankTransferEventTypeMap[e]!)
      .toList();
}

List<enums.BankTransferEventType> bankTransferEventTypeListFromJson(
  List? bankTransferEventType, [
  List<enums.BankTransferEventType>? defaultValue,
]) {
  if (bankTransferEventType == null) {
    return defaultValue ?? [];
  }

  return bankTransferEventType
      .map((e) => bankTransferEventTypeFromJson(e.toString()))
      .toList();
}

List<enums.BankTransferEventType>? bankTransferEventTypeNullableListFromJson(
  List? bankTransferEventType, [
  List<enums.BankTransferEventType>? defaultValue,
]) {
  if (bankTransferEventType == null) {
    return defaultValue;
  }

  return bankTransferEventType
      .map((e) => bankTransferEventTypeFromJson(e.toString()))
      .toList();
}

String? transferIntentStatusToJson(
    enums.TransferIntentStatus? transferIntentStatus) {
  return enums.$TransferIntentStatusMap[transferIntentStatus];
}

enums.TransferIntentStatus transferIntentStatusFromJson(
  Object? transferIntentStatus, [
  enums.TransferIntentStatus? defaultValue,
]) {
  if (transferIntentStatus is String) {
    return enums.$TransferIntentStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                transferIntentStatus.toLowerCase(),
            orElse: () => const MapEntry(
                enums.TransferIntentStatus.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$TransferIntentStatusMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.TransferIntentStatus.swaggerGeneratedUnknown;
}

List<String> transferIntentStatusListToJson(
    List<enums.TransferIntentStatus>? transferIntentStatus) {
  if (transferIntentStatus == null) {
    return [];
  }

  return transferIntentStatus
      .map((e) => enums.$TransferIntentStatusMap[e]!)
      .toList();
}

List<enums.TransferIntentStatus> transferIntentStatusListFromJson(
  List? transferIntentStatus, [
  List<enums.TransferIntentStatus>? defaultValue,
]) {
  if (transferIntentStatus == null) {
    return defaultValue ?? [];
  }

  return transferIntentStatus
      .map((e) => transferIntentStatusFromJson(e.toString()))
      .toList();
}

List<enums.TransferIntentStatus>? transferIntentStatusNullableListFromJson(
  List? transferIntentStatus, [
  List<enums.TransferIntentStatus>? defaultValue,
]) {
  if (transferIntentStatus == null) {
    return defaultValue;
  }

  return transferIntentStatus
      .map((e) => transferIntentStatusFromJson(e.toString()))
      .toList();
}

String? transferIntentAuthorizationDecisionToJson(
    enums.TransferIntentAuthorizationDecision?
        transferIntentAuthorizationDecision) {
  return enums.$TransferIntentAuthorizationDecisionMap[
      transferIntentAuthorizationDecision];
}

enums.TransferIntentAuthorizationDecision
    transferIntentAuthorizationDecisionFromJson(
  Object? transferIntentAuthorizationDecision, [
  enums.TransferIntentAuthorizationDecision? defaultValue,
]) {
  if (transferIntentAuthorizationDecision is String) {
    return enums.$TransferIntentAuthorizationDecisionMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                transferIntentAuthorizationDecision.toLowerCase(),
            orElse: () => const MapEntry(
                enums.TransferIntentAuthorizationDecision
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$TransferIntentAuthorizationDecisionMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.TransferIntentAuthorizationDecision.swaggerGeneratedUnknown;
}

List<String> transferIntentAuthorizationDecisionListToJson(
    List<enums.TransferIntentAuthorizationDecision>?
        transferIntentAuthorizationDecision) {
  if (transferIntentAuthorizationDecision == null) {
    return [];
  }

  return transferIntentAuthorizationDecision
      .map((e) => enums.$TransferIntentAuthorizationDecisionMap[e]!)
      .toList();
}

List<enums.TransferIntentAuthorizationDecision>
    transferIntentAuthorizationDecisionListFromJson(
  List? transferIntentAuthorizationDecision, [
  List<enums.TransferIntentAuthorizationDecision>? defaultValue,
]) {
  if (transferIntentAuthorizationDecision == null) {
    return defaultValue ?? [];
  }

  return transferIntentAuthorizationDecision
      .map((e) => transferIntentAuthorizationDecisionFromJson(e.toString()))
      .toList();
}

List<enums.TransferIntentAuthorizationDecision>?
    transferIntentAuthorizationDecisionNullableListFromJson(
  List? transferIntentAuthorizationDecision, [
  List<enums.TransferIntentAuthorizationDecision>? defaultValue,
]) {
  if (transferIntentAuthorizationDecision == null) {
    return defaultValue;
  }

  return transferIntentAuthorizationDecision
      .map((e) => transferIntentAuthorizationDecisionFromJson(e.toString()))
      .toList();
}

String? accountIdentityVerificationStatusToJson(
    enums.AccountIdentityVerificationStatus?
        accountIdentityVerificationStatus) {
  return enums
      .$AccountIdentityVerificationStatusMap[accountIdentityVerificationStatus];
}

enums.AccountIdentityVerificationStatus
    accountIdentityVerificationStatusFromJson(
  Object? accountIdentityVerificationStatus, [
  enums.AccountIdentityVerificationStatus? defaultValue,
]) {
  if (accountIdentityVerificationStatus is String) {
    return enums.$AccountIdentityVerificationStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                accountIdentityVerificationStatus.toLowerCase(),
            orElse: () => const MapEntry(
                enums.AccountIdentityVerificationStatus.swaggerGeneratedUnknown,
                ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$AccountIdentityVerificationStatusMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.AccountIdentityVerificationStatus.swaggerGeneratedUnknown;
}

List<String> accountIdentityVerificationStatusListToJson(
    List<enums.AccountIdentityVerificationStatus>?
        accountIdentityVerificationStatus) {
  if (accountIdentityVerificationStatus == null) {
    return [];
  }

  return accountIdentityVerificationStatus
      .map((e) => enums.$AccountIdentityVerificationStatusMap[e]!)
      .toList();
}

List<enums.AccountIdentityVerificationStatus>
    accountIdentityVerificationStatusListFromJson(
  List? accountIdentityVerificationStatus, [
  List<enums.AccountIdentityVerificationStatus>? defaultValue,
]) {
  if (accountIdentityVerificationStatus == null) {
    return defaultValue ?? [];
  }

  return accountIdentityVerificationStatus
      .map((e) => accountIdentityVerificationStatusFromJson(e.toString()))
      .toList();
}

List<enums.AccountIdentityVerificationStatus>?
    accountIdentityVerificationStatusNullableListFromJson(
  List? accountIdentityVerificationStatus, [
  List<enums.AccountIdentityVerificationStatus>? defaultValue,
]) {
  if (accountIdentityVerificationStatus == null) {
    return defaultValue;
  }

  return accountIdentityVerificationStatus
      .map((e) => accountIdentityVerificationStatusFromJson(e.toString()))
      .toList();
}

String? accountIdentityMatchScoreVerificationStatusToJson(
    enums.AccountIdentityMatchScoreVerificationStatus?
        accountIdentityMatchScoreVerificationStatus) {
  return enums.$AccountIdentityMatchScoreVerificationStatusMap[
      accountIdentityMatchScoreVerificationStatus];
}

enums.AccountIdentityMatchScoreVerificationStatus
    accountIdentityMatchScoreVerificationStatusFromJson(
  Object? accountIdentityMatchScoreVerificationStatus, [
  enums.AccountIdentityMatchScoreVerificationStatus? defaultValue,
]) {
  if (accountIdentityMatchScoreVerificationStatus is String) {
    return enums.$AccountIdentityMatchScoreVerificationStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                accountIdentityMatchScoreVerificationStatus.toLowerCase(),
            orElse: () => const MapEntry(
                enums.AccountIdentityMatchScoreVerificationStatus
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$AccountIdentityMatchScoreVerificationStatusMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.AccountIdentityMatchScoreVerificationStatus.swaggerGeneratedUnknown;
}

List<String> accountIdentityMatchScoreVerificationStatusListToJson(
    List<enums.AccountIdentityMatchScoreVerificationStatus>?
        accountIdentityMatchScoreVerificationStatus) {
  if (accountIdentityMatchScoreVerificationStatus == null) {
    return [];
  }

  return accountIdentityMatchScoreVerificationStatus
      .map((e) => enums.$AccountIdentityMatchScoreVerificationStatusMap[e]!)
      .toList();
}

List<enums.AccountIdentityMatchScoreVerificationStatus>
    accountIdentityMatchScoreVerificationStatusListFromJson(
  List? accountIdentityMatchScoreVerificationStatus, [
  List<enums.AccountIdentityMatchScoreVerificationStatus>? defaultValue,
]) {
  if (accountIdentityMatchScoreVerificationStatus == null) {
    return defaultValue ?? [];
  }

  return accountIdentityMatchScoreVerificationStatus
      .map((e) =>
          accountIdentityMatchScoreVerificationStatusFromJson(e.toString()))
      .toList();
}

List<enums.AccountIdentityMatchScoreVerificationStatus>?
    accountIdentityMatchScoreVerificationStatusNullableListFromJson(
  List? accountIdentityMatchScoreVerificationStatus, [
  List<enums.AccountIdentityMatchScoreVerificationStatus>? defaultValue,
]) {
  if (accountIdentityMatchScoreVerificationStatus == null) {
    return defaultValue;
  }

  return accountIdentityMatchScoreVerificationStatus
      .map((e) =>
          accountIdentityMatchScoreVerificationStatusFromJson(e.toString()))
      .toList();
}

String? depositoryAccountSubtypeToJson(
    enums.DepositoryAccountSubtype? depositoryAccountSubtype) {
  return enums.$DepositoryAccountSubtypeMap[depositoryAccountSubtype];
}

enums.DepositoryAccountSubtype depositoryAccountSubtypeFromJson(
  Object? depositoryAccountSubtype, [
  enums.DepositoryAccountSubtype? defaultValue,
]) {
  if (depositoryAccountSubtype is String) {
    return enums.$DepositoryAccountSubtypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                depositoryAccountSubtype.toLowerCase(),
            orElse: () => const MapEntry(
                enums.DepositoryAccountSubtype.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$DepositoryAccountSubtypeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.DepositoryAccountSubtype.swaggerGeneratedUnknown;
}

List<String> depositoryAccountSubtypeListToJson(
    List<enums.DepositoryAccountSubtype>? depositoryAccountSubtype) {
  if (depositoryAccountSubtype == null) {
    return [];
  }

  return depositoryAccountSubtype
      .map((e) => enums.$DepositoryAccountSubtypeMap[e]!)
      .toList();
}

List<enums.DepositoryAccountSubtype> depositoryAccountSubtypeListFromJson(
  List? depositoryAccountSubtype, [
  List<enums.DepositoryAccountSubtype>? defaultValue,
]) {
  if (depositoryAccountSubtype == null) {
    return defaultValue ?? [];
  }

  return depositoryAccountSubtype
      .map((e) => depositoryAccountSubtypeFromJson(e.toString()))
      .toList();
}

List<enums.DepositoryAccountSubtype>?
    depositoryAccountSubtypeNullableListFromJson(
  List? depositoryAccountSubtype, [
  List<enums.DepositoryAccountSubtype>? defaultValue,
]) {
  if (depositoryAccountSubtype == null) {
    return defaultValue;
  }

  return depositoryAccountSubtype
      .map((e) => depositoryAccountSubtypeFromJson(e.toString()))
      .toList();
}

String? creditAccountSubtypeToJson(
    enums.CreditAccountSubtype? creditAccountSubtype) {
  return enums.$CreditAccountSubtypeMap[creditAccountSubtype];
}

enums.CreditAccountSubtype creditAccountSubtypeFromJson(
  Object? creditAccountSubtype, [
  enums.CreditAccountSubtype? defaultValue,
]) {
  if (creditAccountSubtype is String) {
    return enums.$CreditAccountSubtypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                creditAccountSubtype.toLowerCase(),
            orElse: () => const MapEntry(
                enums.CreditAccountSubtype.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$CreditAccountSubtypeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.CreditAccountSubtype.swaggerGeneratedUnknown;
}

List<String> creditAccountSubtypeListToJson(
    List<enums.CreditAccountSubtype>? creditAccountSubtype) {
  if (creditAccountSubtype == null) {
    return [];
  }

  return creditAccountSubtype
      .map((e) => enums.$CreditAccountSubtypeMap[e]!)
      .toList();
}

List<enums.CreditAccountSubtype> creditAccountSubtypeListFromJson(
  List? creditAccountSubtype, [
  List<enums.CreditAccountSubtype>? defaultValue,
]) {
  if (creditAccountSubtype == null) {
    return defaultValue ?? [];
  }

  return creditAccountSubtype
      .map((e) => creditAccountSubtypeFromJson(e.toString()))
      .toList();
}

List<enums.CreditAccountSubtype>? creditAccountSubtypeNullableListFromJson(
  List? creditAccountSubtype, [
  List<enums.CreditAccountSubtype>? defaultValue,
]) {
  if (creditAccountSubtype == null) {
    return defaultValue;
  }

  return creditAccountSubtype
      .map((e) => creditAccountSubtypeFromJson(e.toString()))
      .toList();
}

String? loanAccountSubtypeToJson(enums.LoanAccountSubtype? loanAccountSubtype) {
  return enums.$LoanAccountSubtypeMap[loanAccountSubtype];
}

enums.LoanAccountSubtype loanAccountSubtypeFromJson(
  Object? loanAccountSubtype, [
  enums.LoanAccountSubtype? defaultValue,
]) {
  if (loanAccountSubtype is String) {
    return enums.$LoanAccountSubtypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == loanAccountSubtype.toLowerCase(),
            orElse: () => const MapEntry(
                enums.LoanAccountSubtype.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$LoanAccountSubtypeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.LoanAccountSubtype.swaggerGeneratedUnknown;
}

List<String> loanAccountSubtypeListToJson(
    List<enums.LoanAccountSubtype>? loanAccountSubtype) {
  if (loanAccountSubtype == null) {
    return [];
  }

  return loanAccountSubtype
      .map((e) => enums.$LoanAccountSubtypeMap[e]!)
      .toList();
}

List<enums.LoanAccountSubtype> loanAccountSubtypeListFromJson(
  List? loanAccountSubtype, [
  List<enums.LoanAccountSubtype>? defaultValue,
]) {
  if (loanAccountSubtype == null) {
    return defaultValue ?? [];
  }

  return loanAccountSubtype
      .map((e) => loanAccountSubtypeFromJson(e.toString()))
      .toList();
}

List<enums.LoanAccountSubtype>? loanAccountSubtypeNullableListFromJson(
  List? loanAccountSubtype, [
  List<enums.LoanAccountSubtype>? defaultValue,
]) {
  if (loanAccountSubtype == null) {
    return defaultValue;
  }

  return loanAccountSubtype
      .map((e) => loanAccountSubtypeFromJson(e.toString()))
      .toList();
}

String? investmentAccountSubtypeToJson(
    enums.InvestmentAccountSubtype? investmentAccountSubtype) {
  return enums.$InvestmentAccountSubtypeMap[investmentAccountSubtype];
}

enums.InvestmentAccountSubtype investmentAccountSubtypeFromJson(
  Object? investmentAccountSubtype, [
  enums.InvestmentAccountSubtype? defaultValue,
]) {
  if (investmentAccountSubtype is String) {
    return enums.$InvestmentAccountSubtypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                investmentAccountSubtype.toLowerCase(),
            orElse: () => const MapEntry(
                enums.InvestmentAccountSubtype.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$InvestmentAccountSubtypeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.InvestmentAccountSubtype.swaggerGeneratedUnknown;
}

List<String> investmentAccountSubtypeListToJson(
    List<enums.InvestmentAccountSubtype>? investmentAccountSubtype) {
  if (investmentAccountSubtype == null) {
    return [];
  }

  return investmentAccountSubtype
      .map((e) => enums.$InvestmentAccountSubtypeMap[e]!)
      .toList();
}

List<enums.InvestmentAccountSubtype> investmentAccountSubtypeListFromJson(
  List? investmentAccountSubtype, [
  List<enums.InvestmentAccountSubtype>? defaultValue,
]) {
  if (investmentAccountSubtype == null) {
    return defaultValue ?? [];
  }

  return investmentAccountSubtype
      .map((e) => investmentAccountSubtypeFromJson(e.toString()))
      .toList();
}

List<enums.InvestmentAccountSubtype>?
    investmentAccountSubtypeNullableListFromJson(
  List? investmentAccountSubtype, [
  List<enums.InvestmentAccountSubtype>? defaultValue,
]) {
  if (investmentAccountSubtype == null) {
    return defaultValue;
  }

  return investmentAccountSubtype
      .map((e) => investmentAccountSubtypeFromJson(e.toString()))
      .toList();
}

String? incomeVerificationPrecheckConfidenceToJson(
    enums.IncomeVerificationPrecheckConfidence?
        incomeVerificationPrecheckConfidence) {
  return enums.$IncomeVerificationPrecheckConfidenceMap[
      incomeVerificationPrecheckConfidence];
}

enums.IncomeVerificationPrecheckConfidence
    incomeVerificationPrecheckConfidenceFromJson(
  Object? incomeVerificationPrecheckConfidence, [
  enums.IncomeVerificationPrecheckConfidence? defaultValue,
]) {
  if (incomeVerificationPrecheckConfidence is String) {
    return enums.$IncomeVerificationPrecheckConfidenceMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                incomeVerificationPrecheckConfidence.toLowerCase(),
            orElse: () => const MapEntry(
                enums.IncomeVerificationPrecheckConfidence
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$IncomeVerificationPrecheckConfidenceMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.IncomeVerificationPrecheckConfidence.swaggerGeneratedUnknown;
}

List<String> incomeVerificationPrecheckConfidenceListToJson(
    List<enums.IncomeVerificationPrecheckConfidence>?
        incomeVerificationPrecheckConfidence) {
  if (incomeVerificationPrecheckConfidence == null) {
    return [];
  }

  return incomeVerificationPrecheckConfidence
      .map((e) => enums.$IncomeVerificationPrecheckConfidenceMap[e]!)
      .toList();
}

List<enums.IncomeVerificationPrecheckConfidence>
    incomeVerificationPrecheckConfidenceListFromJson(
  List? incomeVerificationPrecheckConfidence, [
  List<enums.IncomeVerificationPrecheckConfidence>? defaultValue,
]) {
  if (incomeVerificationPrecheckConfidence == null) {
    return defaultValue ?? [];
  }

  return incomeVerificationPrecheckConfidence
      .map((e) => incomeVerificationPrecheckConfidenceFromJson(e.toString()))
      .toList();
}

List<enums.IncomeVerificationPrecheckConfidence>?
    incomeVerificationPrecheckConfidenceNullableListFromJson(
  List? incomeVerificationPrecheckConfidence, [
  List<enums.IncomeVerificationPrecheckConfidence>? defaultValue,
]) {
  if (incomeVerificationPrecheckConfidence == null) {
    return defaultValue;
  }

  return incomeVerificationPrecheckConfidence
      .map((e) => incomeVerificationPrecheckConfidenceFromJson(e.toString()))
      .toList();
}

String? incomeVerificationSourceTypeToJson(
    enums.IncomeVerificationSourceType? incomeVerificationSourceType) {
  return enums.$IncomeVerificationSourceTypeMap[incomeVerificationSourceType];
}

enums.IncomeVerificationSourceType incomeVerificationSourceTypeFromJson(
  Object? incomeVerificationSourceType, [
  enums.IncomeVerificationSourceType? defaultValue,
]) {
  if (incomeVerificationSourceType is String) {
    return enums.$IncomeVerificationSourceTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                incomeVerificationSourceType.toLowerCase(),
            orElse: () => const MapEntry(
                enums.IncomeVerificationSourceType.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$IncomeVerificationSourceTypeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.IncomeVerificationSourceType.swaggerGeneratedUnknown;
}

List<String> incomeVerificationSourceTypeListToJson(
    List<enums.IncomeVerificationSourceType>? incomeVerificationSourceType) {
  if (incomeVerificationSourceType == null) {
    return [];
  }

  return incomeVerificationSourceType
      .map((e) => enums.$IncomeVerificationSourceTypeMap[e]!)
      .toList();
}

List<enums.IncomeVerificationSourceType>
    incomeVerificationSourceTypeListFromJson(
  List? incomeVerificationSourceType, [
  List<enums.IncomeVerificationSourceType>? defaultValue,
]) {
  if (incomeVerificationSourceType == null) {
    return defaultValue ?? [];
  }

  return incomeVerificationSourceType
      .map((e) => incomeVerificationSourceTypeFromJson(e.toString()))
      .toList();
}

List<enums.IncomeVerificationSourceType>?
    incomeVerificationSourceTypeNullableListFromJson(
  List? incomeVerificationSourceType, [
  List<enums.IncomeVerificationSourceType>? defaultValue,
]) {
  if (incomeVerificationSourceType == null) {
    return defaultValue;
  }

  return incomeVerificationSourceType
      .map((e) => incomeVerificationSourceTypeFromJson(e.toString()))
      .toList();
}

String? incomeVerificationPayrollFlowTypeToJson(
    enums.IncomeVerificationPayrollFlowType?
        incomeVerificationPayrollFlowType) {
  return enums
      .$IncomeVerificationPayrollFlowTypeMap[incomeVerificationPayrollFlowType];
}

enums.IncomeVerificationPayrollFlowType
    incomeVerificationPayrollFlowTypeFromJson(
  Object? incomeVerificationPayrollFlowType, [
  enums.IncomeVerificationPayrollFlowType? defaultValue,
]) {
  if (incomeVerificationPayrollFlowType is String) {
    return enums.$IncomeVerificationPayrollFlowTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                incomeVerificationPayrollFlowType.toLowerCase(),
            orElse: () => const MapEntry(
                enums.IncomeVerificationPayrollFlowType.swaggerGeneratedUnknown,
                ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$IncomeVerificationPayrollFlowTypeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.IncomeVerificationPayrollFlowType.swaggerGeneratedUnknown;
}

List<String> incomeVerificationPayrollFlowTypeListToJson(
    List<enums.IncomeVerificationPayrollFlowType>?
        incomeVerificationPayrollFlowType) {
  if (incomeVerificationPayrollFlowType == null) {
    return [];
  }

  return incomeVerificationPayrollFlowType
      .map((e) => enums.$IncomeVerificationPayrollFlowTypeMap[e]!)
      .toList();
}

List<enums.IncomeVerificationPayrollFlowType>
    incomeVerificationPayrollFlowTypeListFromJson(
  List? incomeVerificationPayrollFlowType, [
  List<enums.IncomeVerificationPayrollFlowType>? defaultValue,
]) {
  if (incomeVerificationPayrollFlowType == null) {
    return defaultValue ?? [];
  }

  return incomeVerificationPayrollFlowType
      .map((e) => incomeVerificationPayrollFlowTypeFromJson(e.toString()))
      .toList();
}

List<enums.IncomeVerificationPayrollFlowType>?
    incomeVerificationPayrollFlowTypeNullableListFromJson(
  List? incomeVerificationPayrollFlowType, [
  List<enums.IncomeVerificationPayrollFlowType>? defaultValue,
]) {
  if (incomeVerificationPayrollFlowType == null) {
    return defaultValue;
  }

  return incomeVerificationPayrollFlowType
      .map((e) => incomeVerificationPayrollFlowTypeFromJson(e.toString()))
      .toList();
}

String? payFrequencyValueToJson(enums.PayFrequencyValue? payFrequencyValue) {
  return enums.$PayFrequencyValueMap[payFrequencyValue];
}

enums.PayFrequencyValue payFrequencyValueFromJson(
  Object? payFrequencyValue, [
  enums.PayFrequencyValue? defaultValue,
]) {
  if (payFrequencyValue is String) {
    return enums.$PayFrequencyValueMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == payFrequencyValue.toLowerCase(),
            orElse: () => const MapEntry(
                enums.PayFrequencyValue.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$PayFrequencyValueMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.PayFrequencyValue.swaggerGeneratedUnknown;
}

List<String> payFrequencyValueListToJson(
    List<enums.PayFrequencyValue>? payFrequencyValue) {
  if (payFrequencyValue == null) {
    return [];
  }

  return payFrequencyValue.map((e) => enums.$PayFrequencyValueMap[e]!).toList();
}

List<enums.PayFrequencyValue> payFrequencyValueListFromJson(
  List? payFrequencyValue, [
  List<enums.PayFrequencyValue>? defaultValue,
]) {
  if (payFrequencyValue == null) {
    return defaultValue ?? [];
  }

  return payFrequencyValue
      .map((e) => payFrequencyValueFromJson(e.toString()))
      .toList();
}

List<enums.PayFrequencyValue>? payFrequencyValueNullableListFromJson(
  List? payFrequencyValue, [
  List<enums.PayFrequencyValue>? defaultValue,
]) {
  if (payFrequencyValue == null) {
    return defaultValue;
  }

  return payFrequencyValue
      .map((e) => payFrequencyValueFromJson(e.toString()))
      .toList();
}

String? verificationStatusToJson(enums.VerificationStatus? verificationStatus) {
  return enums.$VerificationStatusMap[verificationStatus];
}

enums.VerificationStatus verificationStatusFromJson(
  Object? verificationStatus, [
  enums.VerificationStatus? defaultValue,
]) {
  if (verificationStatus is String) {
    return enums.$VerificationStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == verificationStatus.toLowerCase(),
            orElse: () => const MapEntry(
                enums.VerificationStatus.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$VerificationStatusMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.VerificationStatus.swaggerGeneratedUnknown;
}

List<String> verificationStatusListToJson(
    List<enums.VerificationStatus>? verificationStatus) {
  if (verificationStatus == null) {
    return [];
  }

  return verificationStatus
      .map((e) => enums.$VerificationStatusMap[e]!)
      .toList();
}

List<enums.VerificationStatus> verificationStatusListFromJson(
  List? verificationStatus, [
  List<enums.VerificationStatus>? defaultValue,
]) {
  if (verificationStatus == null) {
    return defaultValue ?? [];
  }

  return verificationStatus
      .map((e) => verificationStatusFromJson(e.toString()))
      .toList();
}

List<enums.VerificationStatus>? verificationStatusNullableListFromJson(
  List? verificationStatus, [
  List<enums.VerificationStatus>? defaultValue,
]) {
  if (verificationStatus == null) {
    return defaultValue;
  }

  return verificationStatus
      .map((e) => verificationStatusFromJson(e.toString()))
      .toList();
}

String? verificationRefreshStatusToJson(
    enums.VerificationRefreshStatus? verificationRefreshStatus) {
  return enums.$VerificationRefreshStatusMap[verificationRefreshStatus];
}

enums.VerificationRefreshStatus verificationRefreshStatusFromJson(
  Object? verificationRefreshStatus, [
  enums.VerificationRefreshStatus? defaultValue,
]) {
  if (verificationRefreshStatus is String) {
    return enums.$VerificationRefreshStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                verificationRefreshStatus.toLowerCase(),
            orElse: () => const MapEntry(
                enums.VerificationRefreshStatus.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$VerificationRefreshStatusMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.VerificationRefreshStatus.swaggerGeneratedUnknown;
}

List<String> verificationRefreshStatusListToJson(
    List<enums.VerificationRefreshStatus>? verificationRefreshStatus) {
  if (verificationRefreshStatus == null) {
    return [];
  }

  return verificationRefreshStatus
      .map((e) => enums.$VerificationRefreshStatusMap[e]!)
      .toList();
}

List<enums.VerificationRefreshStatus> verificationRefreshStatusListFromJson(
  List? verificationRefreshStatus, [
  List<enums.VerificationRefreshStatus>? defaultValue,
]) {
  if (verificationRefreshStatus == null) {
    return defaultValue ?? [];
  }

  return verificationRefreshStatus
      .map((e) => verificationRefreshStatusFromJson(e.toString()))
      .toList();
}

List<enums.VerificationRefreshStatus>?
    verificationRefreshStatusNullableListFromJson(
  List? verificationRefreshStatus, [
  List<enums.VerificationRefreshStatus>? defaultValue,
]) {
  if (verificationRefreshStatus == null) {
    return defaultValue;
  }

  return verificationRefreshStatus
      .map((e) => verificationRefreshStatusFromJson(e.toString()))
      .toList();
}

String? docTypeToJson(enums.DocType? docType) {
  return enums.$DocTypeMap[docType];
}

enums.DocType docTypeFromJson(
  Object? docType, [
  enums.DocType? defaultValue,
]) {
  if (docType is String) {
    return enums.$DocTypeMap.entries
        .firstWhere(
            (element) => element.value.toLowerCase() == docType.toLowerCase(),
            orElse: () =>
                const MapEntry(enums.DocType.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$DocTypeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ?? defaultValue ?? enums.DocType.swaggerGeneratedUnknown;
}

List<String> docTypeListToJson(List<enums.DocType>? docType) {
  if (docType == null) {
    return [];
  }

  return docType.map((e) => enums.$DocTypeMap[e]!).toList();
}

List<enums.DocType> docTypeListFromJson(
  List? docType, [
  List<enums.DocType>? defaultValue,
]) {
  if (docType == null) {
    return defaultValue ?? [];
  }

  return docType.map((e) => docTypeFromJson(e.toString())).toList();
}

List<enums.DocType>? docTypeNullableListFromJson(
  List? docType, [
  List<enums.DocType>? defaultValue,
]) {
  if (docType == null) {
    return defaultValue;
  }

  return docType.map((e) => docTypeFromJson(e.toString())).toList();
}

String? totalCanonicalDescriptionToJson(
    enums.TotalCanonicalDescription? totalCanonicalDescription) {
  return enums.$TotalCanonicalDescriptionMap[totalCanonicalDescription];
}

enums.TotalCanonicalDescription totalCanonicalDescriptionFromJson(
  Object? totalCanonicalDescription, [
  enums.TotalCanonicalDescription? defaultValue,
]) {
  if (totalCanonicalDescription is String) {
    return enums.$TotalCanonicalDescriptionMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                totalCanonicalDescription.toLowerCase(),
            orElse: () => const MapEntry(
                enums.TotalCanonicalDescription.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$TotalCanonicalDescriptionMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.TotalCanonicalDescription.swaggerGeneratedUnknown;
}

List<String> totalCanonicalDescriptionListToJson(
    List<enums.TotalCanonicalDescription>? totalCanonicalDescription) {
  if (totalCanonicalDescription == null) {
    return [];
  }

  return totalCanonicalDescription
      .map((e) => enums.$TotalCanonicalDescriptionMap[e]!)
      .toList();
}

List<enums.TotalCanonicalDescription> totalCanonicalDescriptionListFromJson(
  List? totalCanonicalDescription, [
  List<enums.TotalCanonicalDescription>? defaultValue,
]) {
  if (totalCanonicalDescription == null) {
    return defaultValue ?? [];
  }

  return totalCanonicalDescription
      .map((e) => totalCanonicalDescriptionFromJson(e.toString()))
      .toList();
}

List<enums.TotalCanonicalDescription>?
    totalCanonicalDescriptionNullableListFromJson(
  List? totalCanonicalDescription, [
  List<enums.TotalCanonicalDescription>? defaultValue,
]) {
  if (totalCanonicalDescription == null) {
    return defaultValue;
  }

  return totalCanonicalDescription
      .map((e) => totalCanonicalDescriptionFromJson(e.toString()))
      .toList();
}

String? earningsBreakdownCanonicalDescriptionToJson(
    enums.EarningsBreakdownCanonicalDescription?
        earningsBreakdownCanonicalDescription) {
  return enums.$EarningsBreakdownCanonicalDescriptionMap[
      earningsBreakdownCanonicalDescription];
}

enums.EarningsBreakdownCanonicalDescription
    earningsBreakdownCanonicalDescriptionFromJson(
  Object? earningsBreakdownCanonicalDescription, [
  enums.EarningsBreakdownCanonicalDescription? defaultValue,
]) {
  if (earningsBreakdownCanonicalDescription is String) {
    return enums.$EarningsBreakdownCanonicalDescriptionMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                earningsBreakdownCanonicalDescription.toLowerCase(),
            orElse: () => const MapEntry(
                enums.EarningsBreakdownCanonicalDescription
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$EarningsBreakdownCanonicalDescriptionMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.EarningsBreakdownCanonicalDescription.swaggerGeneratedUnknown;
}

List<String> earningsBreakdownCanonicalDescriptionListToJson(
    List<enums.EarningsBreakdownCanonicalDescription>?
        earningsBreakdownCanonicalDescription) {
  if (earningsBreakdownCanonicalDescription == null) {
    return [];
  }

  return earningsBreakdownCanonicalDescription
      .map((e) => enums.$EarningsBreakdownCanonicalDescriptionMap[e]!)
      .toList();
}

List<enums.EarningsBreakdownCanonicalDescription>
    earningsBreakdownCanonicalDescriptionListFromJson(
  List? earningsBreakdownCanonicalDescription, [
  List<enums.EarningsBreakdownCanonicalDescription>? defaultValue,
]) {
  if (earningsBreakdownCanonicalDescription == null) {
    return defaultValue ?? [];
  }

  return earningsBreakdownCanonicalDescription
      .map((e) => earningsBreakdownCanonicalDescriptionFromJson(e.toString()))
      .toList();
}

List<enums.EarningsBreakdownCanonicalDescription>?
    earningsBreakdownCanonicalDescriptionNullableListFromJson(
  List? earningsBreakdownCanonicalDescription, [
  List<enums.EarningsBreakdownCanonicalDescription>? defaultValue,
]) {
  if (earningsBreakdownCanonicalDescription == null) {
    return defaultValue;
  }

  return earningsBreakdownCanonicalDescription
      .map((e) => earningsBreakdownCanonicalDescriptionFromJson(e.toString()))
      .toList();
}

String? paystubPayFrequencyToJson(
    enums.PaystubPayFrequency? paystubPayFrequency) {
  return enums.$PaystubPayFrequencyMap[paystubPayFrequency];
}

enums.PaystubPayFrequency paystubPayFrequencyFromJson(
  Object? paystubPayFrequency, [
  enums.PaystubPayFrequency? defaultValue,
]) {
  if (paystubPayFrequency is String) {
    return enums.$PaystubPayFrequencyMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                paystubPayFrequency.toLowerCase(),
            orElse: () => const MapEntry(
                enums.PaystubPayFrequency.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$PaystubPayFrequencyMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.PaystubPayFrequency.swaggerGeneratedUnknown;
}

List<String> paystubPayFrequencyListToJson(
    List<enums.PaystubPayFrequency>? paystubPayFrequency) {
  if (paystubPayFrequency == null) {
    return [];
  }

  return paystubPayFrequency
      .map((e) => enums.$PaystubPayFrequencyMap[e]!)
      .toList();
}

List<enums.PaystubPayFrequency> paystubPayFrequencyListFromJson(
  List? paystubPayFrequency, [
  List<enums.PaystubPayFrequency>? defaultValue,
]) {
  if (paystubPayFrequency == null) {
    return defaultValue ?? [];
  }

  return paystubPayFrequency
      .map((e) => paystubPayFrequencyFromJson(e.toString()))
      .toList();
}

List<enums.PaystubPayFrequency>? paystubPayFrequencyNullableListFromJson(
  List? paystubPayFrequency, [
  List<enums.PaystubPayFrequency>? defaultValue,
]) {
  if (paystubPayFrequency == null) {
    return defaultValue;
  }

  return paystubPayFrequency
      .map((e) => paystubPayFrequencyFromJson(e.toString()))
      .toList();
}

String? incomeBreakdownTypeToJson(
    enums.IncomeBreakdownType? incomeBreakdownType) {
  return enums.$IncomeBreakdownTypeMap[incomeBreakdownType];
}

enums.IncomeBreakdownType incomeBreakdownTypeFromJson(
  Object? incomeBreakdownType, [
  enums.IncomeBreakdownType? defaultValue,
]) {
  if (incomeBreakdownType is String) {
    return enums.$IncomeBreakdownTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                incomeBreakdownType.toLowerCase(),
            orElse: () => const MapEntry(
                enums.IncomeBreakdownType.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$IncomeBreakdownTypeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.IncomeBreakdownType.swaggerGeneratedUnknown;
}

List<String> incomeBreakdownTypeListToJson(
    List<enums.IncomeBreakdownType>? incomeBreakdownType) {
  if (incomeBreakdownType == null) {
    return [];
  }

  return incomeBreakdownType
      .map((e) => enums.$IncomeBreakdownTypeMap[e]!)
      .toList();
}

List<enums.IncomeBreakdownType> incomeBreakdownTypeListFromJson(
  List? incomeBreakdownType, [
  List<enums.IncomeBreakdownType>? defaultValue,
]) {
  if (incomeBreakdownType == null) {
    return defaultValue ?? [];
  }

  return incomeBreakdownType
      .map((e) => incomeBreakdownTypeFromJson(e.toString()))
      .toList();
}

List<enums.IncomeBreakdownType>? incomeBreakdownTypeNullableListFromJson(
  List? incomeBreakdownType, [
  List<enums.IncomeBreakdownType>? defaultValue,
]) {
  if (incomeBreakdownType == null) {
    return defaultValue;
  }

  return incomeBreakdownType
      .map((e) => incomeBreakdownTypeFromJson(e.toString()))
      .toList();
}

String? payPeriodDetailsPayFrequencyToJson(
    enums.PayPeriodDetailsPayFrequency? payPeriodDetailsPayFrequency) {
  return enums.$PayPeriodDetailsPayFrequencyMap[payPeriodDetailsPayFrequency];
}

enums.PayPeriodDetailsPayFrequency payPeriodDetailsPayFrequencyFromJson(
  Object? payPeriodDetailsPayFrequency, [
  enums.PayPeriodDetailsPayFrequency? defaultValue,
]) {
  if (payPeriodDetailsPayFrequency is String) {
    return enums.$PayPeriodDetailsPayFrequencyMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                payPeriodDetailsPayFrequency.toLowerCase(),
            orElse: () => const MapEntry(
                enums.PayPeriodDetailsPayFrequency.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$PayPeriodDetailsPayFrequencyMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.PayPeriodDetailsPayFrequency.swaggerGeneratedUnknown;
}

List<String> payPeriodDetailsPayFrequencyListToJson(
    List<enums.PayPeriodDetailsPayFrequency>? payPeriodDetailsPayFrequency) {
  if (payPeriodDetailsPayFrequency == null) {
    return [];
  }

  return payPeriodDetailsPayFrequency
      .map((e) => enums.$PayPeriodDetailsPayFrequencyMap[e]!)
      .toList();
}

List<enums.PayPeriodDetailsPayFrequency>
    payPeriodDetailsPayFrequencyListFromJson(
  List? payPeriodDetailsPayFrequency, [
  List<enums.PayPeriodDetailsPayFrequency>? defaultValue,
]) {
  if (payPeriodDetailsPayFrequency == null) {
    return defaultValue ?? [];
  }

  return payPeriodDetailsPayFrequency
      .map((e) => payPeriodDetailsPayFrequencyFromJson(e.toString()))
      .toList();
}

List<enums.PayPeriodDetailsPayFrequency>?
    payPeriodDetailsPayFrequencyNullableListFromJson(
  List? payPeriodDetailsPayFrequency, [
  List<enums.PayPeriodDetailsPayFrequency>? defaultValue,
]) {
  if (payPeriodDetailsPayFrequency == null) {
    return defaultValue;
  }

  return payPeriodDetailsPayFrequency
      .map((e) => payPeriodDetailsPayFrequencyFromJson(e.toString()))
      .toList();
}

String? employmentVerificationStatusToJson(
    enums.EmploymentVerificationStatus? employmentVerificationStatus) {
  return enums.$EmploymentVerificationStatusMap[employmentVerificationStatus];
}

enums.EmploymentVerificationStatus employmentVerificationStatusFromJson(
  Object? employmentVerificationStatus, [
  enums.EmploymentVerificationStatus? defaultValue,
]) {
  if (employmentVerificationStatus is String) {
    return enums.$EmploymentVerificationStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                employmentVerificationStatus.toLowerCase(),
            orElse: () => const MapEntry(
                enums.EmploymentVerificationStatus.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$EmploymentVerificationStatusMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.EmploymentVerificationStatus.swaggerGeneratedUnknown;
}

List<String> employmentVerificationStatusListToJson(
    List<enums.EmploymentVerificationStatus>? employmentVerificationStatus) {
  if (employmentVerificationStatus == null) {
    return [];
  }

  return employmentVerificationStatus
      .map((e) => enums.$EmploymentVerificationStatusMap[e]!)
      .toList();
}

List<enums.EmploymentVerificationStatus>
    employmentVerificationStatusListFromJson(
  List? employmentVerificationStatus, [
  List<enums.EmploymentVerificationStatus>? defaultValue,
]) {
  if (employmentVerificationStatus == null) {
    return defaultValue ?? [];
  }

  return employmentVerificationStatus
      .map((e) => employmentVerificationStatusFromJson(e.toString()))
      .toList();
}

List<enums.EmploymentVerificationStatus>?
    employmentVerificationStatusNullableListFromJson(
  List? employmentVerificationStatus, [
  List<enums.EmploymentVerificationStatus>? defaultValue,
]) {
  if (employmentVerificationStatus == null) {
    return defaultValue;
  }

  return employmentVerificationStatus
      .map((e) => employmentVerificationStatusFromJson(e.toString()))
      .toList();
}

String? incidentUpdateStatusToJson(
    enums.IncidentUpdateStatus? incidentUpdateStatus) {
  return enums.$IncidentUpdateStatusMap[incidentUpdateStatus];
}

enums.IncidentUpdateStatus incidentUpdateStatusFromJson(
  Object? incidentUpdateStatus, [
  enums.IncidentUpdateStatus? defaultValue,
]) {
  if (incidentUpdateStatus is String) {
    return enums.$IncidentUpdateStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                incidentUpdateStatus.toLowerCase(),
            orElse: () => const MapEntry(
                enums.IncidentUpdateStatus.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$IncidentUpdateStatusMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.IncidentUpdateStatus.swaggerGeneratedUnknown;
}

List<String> incidentUpdateStatusListToJson(
    List<enums.IncidentUpdateStatus>? incidentUpdateStatus) {
  if (incidentUpdateStatus == null) {
    return [];
  }

  return incidentUpdateStatus
      .map((e) => enums.$IncidentUpdateStatusMap[e]!)
      .toList();
}

List<enums.IncidentUpdateStatus> incidentUpdateStatusListFromJson(
  List? incidentUpdateStatus, [
  List<enums.IncidentUpdateStatus>? defaultValue,
]) {
  if (incidentUpdateStatus == null) {
    return defaultValue ?? [];
  }

  return incidentUpdateStatus
      .map((e) => incidentUpdateStatusFromJson(e.toString()))
      .toList();
}

List<enums.IncidentUpdateStatus>? incidentUpdateStatusNullableListFromJson(
  List? incidentUpdateStatus, [
  List<enums.IncidentUpdateStatus>? defaultValue,
]) {
  if (incidentUpdateStatus == null) {
    return defaultValue;
  }

  return incidentUpdateStatus
      .map((e) => incidentUpdateStatusFromJson(e.toString()))
      .toList();
}

String? depositSwitchAltCreateRequestCountryCodeToJson(
    enums.DepositSwitchAltCreateRequestCountryCode?
        depositSwitchAltCreateRequestCountryCode) {
  return enums.$DepositSwitchAltCreateRequestCountryCodeMap[
      depositSwitchAltCreateRequestCountryCode];
}

enums.DepositSwitchAltCreateRequestCountryCode
    depositSwitchAltCreateRequestCountryCodeFromJson(
  Object? depositSwitchAltCreateRequestCountryCode, [
  enums.DepositSwitchAltCreateRequestCountryCode? defaultValue,
]) {
  if (depositSwitchAltCreateRequestCountryCode is String) {
    return enums.$DepositSwitchAltCreateRequestCountryCodeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                depositSwitchAltCreateRequestCountryCode.toLowerCase(),
            orElse: () => const MapEntry(
                enums.DepositSwitchAltCreateRequestCountryCode
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$DepositSwitchAltCreateRequestCountryCodeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.DepositSwitchAltCreateRequestCountryCode.swaggerGeneratedUnknown;
}

List<String> depositSwitchAltCreateRequestCountryCodeListToJson(
    List<enums.DepositSwitchAltCreateRequestCountryCode>?
        depositSwitchAltCreateRequestCountryCode) {
  if (depositSwitchAltCreateRequestCountryCode == null) {
    return [];
  }

  return depositSwitchAltCreateRequestCountryCode
      .map((e) => enums.$DepositSwitchAltCreateRequestCountryCodeMap[e]!)
      .toList();
}

List<enums.DepositSwitchAltCreateRequestCountryCode>
    depositSwitchAltCreateRequestCountryCodeListFromJson(
  List? depositSwitchAltCreateRequestCountryCode, [
  List<enums.DepositSwitchAltCreateRequestCountryCode>? defaultValue,
]) {
  if (depositSwitchAltCreateRequestCountryCode == null) {
    return defaultValue ?? [];
  }

  return depositSwitchAltCreateRequestCountryCode
      .map(
          (e) => depositSwitchAltCreateRequestCountryCodeFromJson(e.toString()))
      .toList();
}

List<enums.DepositSwitchAltCreateRequestCountryCode>?
    depositSwitchAltCreateRequestCountryCodeNullableListFromJson(
  List? depositSwitchAltCreateRequestCountryCode, [
  List<enums.DepositSwitchAltCreateRequestCountryCode>? defaultValue,
]) {
  if (depositSwitchAltCreateRequestCountryCode == null) {
    return defaultValue;
  }

  return depositSwitchAltCreateRequestCountryCode
      .map(
          (e) => depositSwitchAltCreateRequestCountryCodeFromJson(e.toString()))
      .toList();
}

String? depositSwitchTargetAccountAccountSubtypeToJson(
    enums.DepositSwitchTargetAccountAccountSubtype?
        depositSwitchTargetAccountAccountSubtype) {
  return enums.$DepositSwitchTargetAccountAccountSubtypeMap[
      depositSwitchTargetAccountAccountSubtype];
}

enums.DepositSwitchTargetAccountAccountSubtype
    depositSwitchTargetAccountAccountSubtypeFromJson(
  Object? depositSwitchTargetAccountAccountSubtype, [
  enums.DepositSwitchTargetAccountAccountSubtype? defaultValue,
]) {
  if (depositSwitchTargetAccountAccountSubtype is String) {
    return enums.$DepositSwitchTargetAccountAccountSubtypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                depositSwitchTargetAccountAccountSubtype.toLowerCase(),
            orElse: () => const MapEntry(
                enums.DepositSwitchTargetAccountAccountSubtype
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$DepositSwitchTargetAccountAccountSubtypeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.DepositSwitchTargetAccountAccountSubtype.swaggerGeneratedUnknown;
}

List<String> depositSwitchTargetAccountAccountSubtypeListToJson(
    List<enums.DepositSwitchTargetAccountAccountSubtype>?
        depositSwitchTargetAccountAccountSubtype) {
  if (depositSwitchTargetAccountAccountSubtype == null) {
    return [];
  }

  return depositSwitchTargetAccountAccountSubtype
      .map((e) => enums.$DepositSwitchTargetAccountAccountSubtypeMap[e]!)
      .toList();
}

List<enums.DepositSwitchTargetAccountAccountSubtype>
    depositSwitchTargetAccountAccountSubtypeListFromJson(
  List? depositSwitchTargetAccountAccountSubtype, [
  List<enums.DepositSwitchTargetAccountAccountSubtype>? defaultValue,
]) {
  if (depositSwitchTargetAccountAccountSubtype == null) {
    return defaultValue ?? [];
  }

  return depositSwitchTargetAccountAccountSubtype
      .map(
          (e) => depositSwitchTargetAccountAccountSubtypeFromJson(e.toString()))
      .toList();
}

List<enums.DepositSwitchTargetAccountAccountSubtype>?
    depositSwitchTargetAccountAccountSubtypeNullableListFromJson(
  List? depositSwitchTargetAccountAccountSubtype, [
  List<enums.DepositSwitchTargetAccountAccountSubtype>? defaultValue,
]) {
  if (depositSwitchTargetAccountAccountSubtype == null) {
    return defaultValue;
  }

  return depositSwitchTargetAccountAccountSubtype
      .map(
          (e) => depositSwitchTargetAccountAccountSubtypeFromJson(e.toString()))
      .toList();
}

String? creditBankIncomeAccountTypeToJson(
    enums.CreditBankIncomeAccountType? creditBankIncomeAccountType) {
  return enums.$CreditBankIncomeAccountTypeMap[creditBankIncomeAccountType];
}

enums.CreditBankIncomeAccountType creditBankIncomeAccountTypeFromJson(
  Object? creditBankIncomeAccountType, [
  enums.CreditBankIncomeAccountType? defaultValue,
]) {
  if (creditBankIncomeAccountType is String) {
    return enums.$CreditBankIncomeAccountTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                creditBankIncomeAccountType.toLowerCase(),
            orElse: () => const MapEntry(
                enums.CreditBankIncomeAccountType.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$CreditBankIncomeAccountTypeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.CreditBankIncomeAccountType.swaggerGeneratedUnknown;
}

List<String> creditBankIncomeAccountTypeListToJson(
    List<enums.CreditBankIncomeAccountType>? creditBankIncomeAccountType) {
  if (creditBankIncomeAccountType == null) {
    return [];
  }

  return creditBankIncomeAccountType
      .map((e) => enums.$CreditBankIncomeAccountTypeMap[e]!)
      .toList();
}

List<enums.CreditBankIncomeAccountType> creditBankIncomeAccountTypeListFromJson(
  List? creditBankIncomeAccountType, [
  List<enums.CreditBankIncomeAccountType>? defaultValue,
]) {
  if (creditBankIncomeAccountType == null) {
    return defaultValue ?? [];
  }

  return creditBankIncomeAccountType
      .map((e) => creditBankIncomeAccountTypeFromJson(e.toString()))
      .toList();
}

List<enums.CreditBankIncomeAccountType>?
    creditBankIncomeAccountTypeNullableListFromJson(
  List? creditBankIncomeAccountType, [
  List<enums.CreditBankIncomeAccountType>? defaultValue,
]) {
  if (creditBankIncomeAccountType == null) {
    return defaultValue;
  }

  return creditBankIncomeAccountType
      .map((e) => creditBankIncomeAccountTypeFromJson(e.toString()))
      .toList();
}

String? creditBankIncomeCategoryToJson(
    enums.CreditBankIncomeCategory? creditBankIncomeCategory) {
  return enums.$CreditBankIncomeCategoryMap[creditBankIncomeCategory];
}

enums.CreditBankIncomeCategory creditBankIncomeCategoryFromJson(
  Object? creditBankIncomeCategory, [
  enums.CreditBankIncomeCategory? defaultValue,
]) {
  if (creditBankIncomeCategory is String) {
    return enums.$CreditBankIncomeCategoryMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                creditBankIncomeCategory.toLowerCase(),
            orElse: () => const MapEntry(
                enums.CreditBankIncomeCategory.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$CreditBankIncomeCategoryMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.CreditBankIncomeCategory.swaggerGeneratedUnknown;
}

List<String> creditBankIncomeCategoryListToJson(
    List<enums.CreditBankIncomeCategory>? creditBankIncomeCategory) {
  if (creditBankIncomeCategory == null) {
    return [];
  }

  return creditBankIncomeCategory
      .map((e) => enums.$CreditBankIncomeCategoryMap[e]!)
      .toList();
}

List<enums.CreditBankIncomeCategory> creditBankIncomeCategoryListFromJson(
  List? creditBankIncomeCategory, [
  List<enums.CreditBankIncomeCategory>? defaultValue,
]) {
  if (creditBankIncomeCategory == null) {
    return defaultValue ?? [];
  }

  return creditBankIncomeCategory
      .map((e) => creditBankIncomeCategoryFromJson(e.toString()))
      .toList();
}

List<enums.CreditBankIncomeCategory>?
    creditBankIncomeCategoryNullableListFromJson(
  List? creditBankIncomeCategory, [
  List<enums.CreditBankIncomeCategory>? defaultValue,
]) {
  if (creditBankIncomeCategory == null) {
    return defaultValue;
  }

  return creditBankIncomeCategory
      .map((e) => creditBankIncomeCategoryFromJson(e.toString()))
      .toList();
}

String? creditBankIncomePayFrequencyToJson(
    enums.CreditBankIncomePayFrequency? creditBankIncomePayFrequency) {
  return enums.$CreditBankIncomePayFrequencyMap[creditBankIncomePayFrequency];
}

enums.CreditBankIncomePayFrequency creditBankIncomePayFrequencyFromJson(
  Object? creditBankIncomePayFrequency, [
  enums.CreditBankIncomePayFrequency? defaultValue,
]) {
  if (creditBankIncomePayFrequency is String) {
    return enums.$CreditBankIncomePayFrequencyMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                creditBankIncomePayFrequency.toLowerCase(),
            orElse: () => const MapEntry(
                enums.CreditBankIncomePayFrequency.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$CreditBankIncomePayFrequencyMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.CreditBankIncomePayFrequency.swaggerGeneratedUnknown;
}

List<String> creditBankIncomePayFrequencyListToJson(
    List<enums.CreditBankIncomePayFrequency>? creditBankIncomePayFrequency) {
  if (creditBankIncomePayFrequency == null) {
    return [];
  }

  return creditBankIncomePayFrequency
      .map((e) => enums.$CreditBankIncomePayFrequencyMap[e]!)
      .toList();
}

List<enums.CreditBankIncomePayFrequency>
    creditBankIncomePayFrequencyListFromJson(
  List? creditBankIncomePayFrequency, [
  List<enums.CreditBankIncomePayFrequency>? defaultValue,
]) {
  if (creditBankIncomePayFrequency == null) {
    return defaultValue ?? [];
  }

  return creditBankIncomePayFrequency
      .map((e) => creditBankIncomePayFrequencyFromJson(e.toString()))
      .toList();
}

List<enums.CreditBankIncomePayFrequency>?
    creditBankIncomePayFrequencyNullableListFromJson(
  List? creditBankIncomePayFrequency, [
  List<enums.CreditBankIncomePayFrequency>? defaultValue,
]) {
  if (creditBankIncomePayFrequency == null) {
    return defaultValue;
  }

  return creditBankIncomePayFrequency
      .map((e) => creditBankIncomePayFrequencyFromJson(e.toString()))
      .toList();
}

String? form1099TypeToJson(enums.Form1099Type? form1099Type) {
  return enums.$Form1099TypeMap[form1099Type];
}

enums.Form1099Type form1099TypeFromJson(
  Object? form1099Type, [
  enums.Form1099Type? defaultValue,
]) {
  if (form1099Type is String) {
    return enums.$Form1099TypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == form1099Type.toLowerCase(),
            orElse: () =>
                const MapEntry(enums.Form1099Type.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$Form1099TypeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.Form1099Type.swaggerGeneratedUnknown;
}

List<String> form1099TypeListToJson(List<enums.Form1099Type>? form1099Type) {
  if (form1099Type == null) {
    return [];
  }

  return form1099Type.map((e) => enums.$Form1099TypeMap[e]!).toList();
}

List<enums.Form1099Type> form1099TypeListFromJson(
  List? form1099Type, [
  List<enums.Form1099Type>? defaultValue,
]) {
  if (form1099Type == null) {
    return defaultValue ?? [];
  }

  return form1099Type.map((e) => form1099TypeFromJson(e.toString())).toList();
}

List<enums.Form1099Type>? form1099TypeNullableListFromJson(
  List? form1099Type, [
  List<enums.Form1099Type>? defaultValue,
]) {
  if (form1099Type == null) {
    return defaultValue;
  }

  return form1099Type.map((e) => form1099TypeFromJson(e.toString())).toList();
}

String? reportTypeToJson(enums.ReportType? reportType) {
  return enums.$ReportTypeMap[reportType];
}

enums.ReportType reportTypeFromJson(
  Object? reportType, [
  enums.ReportType? defaultValue,
]) {
  if (reportType is String) {
    return enums.$ReportTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == reportType.toLowerCase(),
            orElse: () =>
                const MapEntry(enums.ReportType.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$ReportTypeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.ReportType.swaggerGeneratedUnknown;
}

List<String> reportTypeListToJson(List<enums.ReportType>? reportType) {
  if (reportType == null) {
    return [];
  }

  return reportType.map((e) => enums.$ReportTypeMap[e]!).toList();
}

List<enums.ReportType> reportTypeListFromJson(
  List? reportType, [
  List<enums.ReportType>? defaultValue,
]) {
  if (reportType == null) {
    return defaultValue ?? [];
  }

  return reportType.map((e) => reportTypeFromJson(e.toString())).toList();
}

List<enums.ReportType>? reportTypeNullableListFromJson(
  List? reportType, [
  List<enums.ReportType>? defaultValue,
]) {
  if (reportType == null) {
    return defaultValue;
  }

  return reportType.map((e) => reportTypeFromJson(e.toString())).toList();
}

String? creditBankIncomeWarningTypeToJson(
    enums.CreditBankIncomeWarningType? creditBankIncomeWarningType) {
  return enums.$CreditBankIncomeWarningTypeMap[creditBankIncomeWarningType];
}

enums.CreditBankIncomeWarningType creditBankIncomeWarningTypeFromJson(
  Object? creditBankIncomeWarningType, [
  enums.CreditBankIncomeWarningType? defaultValue,
]) {
  if (creditBankIncomeWarningType is String) {
    return enums.$CreditBankIncomeWarningTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                creditBankIncomeWarningType.toLowerCase(),
            orElse: () => const MapEntry(
                enums.CreditBankIncomeWarningType.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$CreditBankIncomeWarningTypeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.CreditBankIncomeWarningType.swaggerGeneratedUnknown;
}

List<String> creditBankIncomeWarningTypeListToJson(
    List<enums.CreditBankIncomeWarningType>? creditBankIncomeWarningType) {
  if (creditBankIncomeWarningType == null) {
    return [];
  }

  return creditBankIncomeWarningType
      .map((e) => enums.$CreditBankIncomeWarningTypeMap[e]!)
      .toList();
}

List<enums.CreditBankIncomeWarningType> creditBankIncomeWarningTypeListFromJson(
  List? creditBankIncomeWarningType, [
  List<enums.CreditBankIncomeWarningType>? defaultValue,
]) {
  if (creditBankIncomeWarningType == null) {
    return defaultValue ?? [];
  }

  return creditBankIncomeWarningType
      .map((e) => creditBankIncomeWarningTypeFromJson(e.toString()))
      .toList();
}

List<enums.CreditBankIncomeWarningType>?
    creditBankIncomeWarningTypeNullableListFromJson(
  List? creditBankIncomeWarningType, [
  List<enums.CreditBankIncomeWarningType>? defaultValue,
]) {
  if (creditBankIncomeWarningType == null) {
    return defaultValue;
  }

  return creditBankIncomeWarningType
      .map((e) => creditBankIncomeWarningTypeFromJson(e.toString()))
      .toList();
}

String? creditBankIncomeWarningCodeToJson(
    enums.CreditBankIncomeWarningCode? creditBankIncomeWarningCode) {
  return enums.$CreditBankIncomeWarningCodeMap[creditBankIncomeWarningCode];
}

enums.CreditBankIncomeWarningCode creditBankIncomeWarningCodeFromJson(
  Object? creditBankIncomeWarningCode, [
  enums.CreditBankIncomeWarningCode? defaultValue,
]) {
  if (creditBankIncomeWarningCode is String) {
    return enums.$CreditBankIncomeWarningCodeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                creditBankIncomeWarningCode.toLowerCase(),
            orElse: () => const MapEntry(
                enums.CreditBankIncomeWarningCode.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$CreditBankIncomeWarningCodeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.CreditBankIncomeWarningCode.swaggerGeneratedUnknown;
}

List<String> creditBankIncomeWarningCodeListToJson(
    List<enums.CreditBankIncomeWarningCode>? creditBankIncomeWarningCode) {
  if (creditBankIncomeWarningCode == null) {
    return [];
  }

  return creditBankIncomeWarningCode
      .map((e) => enums.$CreditBankIncomeWarningCodeMap[e]!)
      .toList();
}

List<enums.CreditBankIncomeWarningCode> creditBankIncomeWarningCodeListFromJson(
  List? creditBankIncomeWarningCode, [
  List<enums.CreditBankIncomeWarningCode>? defaultValue,
]) {
  if (creditBankIncomeWarningCode == null) {
    return defaultValue ?? [];
  }

  return creditBankIncomeWarningCode
      .map((e) => creditBankIncomeWarningCodeFromJson(e.toString()))
      .toList();
}

List<enums.CreditBankIncomeWarningCode>?
    creditBankIncomeWarningCodeNullableListFromJson(
  List? creditBankIncomeWarningCode, [
  List<enums.CreditBankIncomeWarningCode>? defaultValue,
]) {
  if (creditBankIncomeWarningCode == null) {
    return defaultValue;
  }

  return creditBankIncomeWarningCode
      .map((e) => creditBankIncomeWarningCodeFromJson(e.toString()))
      .toList();
}

String? creditBankIncomeErrorTypeToJson(
    enums.CreditBankIncomeErrorType? creditBankIncomeErrorType) {
  return enums.$CreditBankIncomeErrorTypeMap[creditBankIncomeErrorType];
}

enums.CreditBankIncomeErrorType creditBankIncomeErrorTypeFromJson(
  Object? creditBankIncomeErrorType, [
  enums.CreditBankIncomeErrorType? defaultValue,
]) {
  if (creditBankIncomeErrorType is String) {
    return enums.$CreditBankIncomeErrorTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                creditBankIncomeErrorType.toLowerCase(),
            orElse: () => const MapEntry(
                enums.CreditBankIncomeErrorType.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$CreditBankIncomeErrorTypeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.CreditBankIncomeErrorType.swaggerGeneratedUnknown;
}

List<String> creditBankIncomeErrorTypeListToJson(
    List<enums.CreditBankIncomeErrorType>? creditBankIncomeErrorType) {
  if (creditBankIncomeErrorType == null) {
    return [];
  }

  return creditBankIncomeErrorType
      .map((e) => enums.$CreditBankIncomeErrorTypeMap[e]!)
      .toList();
}

List<enums.CreditBankIncomeErrorType> creditBankIncomeErrorTypeListFromJson(
  List? creditBankIncomeErrorType, [
  List<enums.CreditBankIncomeErrorType>? defaultValue,
]) {
  if (creditBankIncomeErrorType == null) {
    return defaultValue ?? [];
  }

  return creditBankIncomeErrorType
      .map((e) => creditBankIncomeErrorTypeFromJson(e.toString()))
      .toList();
}

List<enums.CreditBankIncomeErrorType>?
    creditBankIncomeErrorTypeNullableListFromJson(
  List? creditBankIncomeErrorType, [
  List<enums.CreditBankIncomeErrorType>? defaultValue,
]) {
  if (creditBankIncomeErrorType == null) {
    return defaultValue;
  }

  return creditBankIncomeErrorType
      .map((e) => creditBankIncomeErrorTypeFromJson(e.toString()))
      .toList();
}

String? scopesContextToJson(enums.ScopesContext? scopesContext) {
  return enums.$ScopesContextMap[scopesContext];
}

enums.ScopesContext scopesContextFromJson(
  Object? scopesContext, [
  enums.ScopesContext? defaultValue,
]) {
  if (scopesContext is String) {
    return enums.$ScopesContextMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == scopesContext.toLowerCase(),
            orElse: () =>
                const MapEntry(enums.ScopesContext.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$ScopesContextMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.ScopesContext.swaggerGeneratedUnknown;
}

List<String> scopesContextListToJson(List<enums.ScopesContext>? scopesContext) {
  if (scopesContext == null) {
    return [];
  }

  return scopesContext.map((e) => enums.$ScopesContextMap[e]!).toList();
}

List<enums.ScopesContext> scopesContextListFromJson(
  List? scopesContext, [
  List<enums.ScopesContext>? defaultValue,
]) {
  if (scopesContext == null) {
    return defaultValue ?? [];
  }

  return scopesContext.map((e) => scopesContextFromJson(e.toString())).toList();
}

List<enums.ScopesContext>? scopesContextNullableListFromJson(
  List? scopesContext, [
  List<enums.ScopesContext>? defaultValue,
]) {
  if (scopesContext == null) {
    return defaultValue;
  }

  return scopesContext.map((e) => scopesContextFromJson(e.toString())).toList();
}

String? accountSelectionCardinalityToJson(
    enums.AccountSelectionCardinality? accountSelectionCardinality) {
  return enums.$AccountSelectionCardinalityMap[accountSelectionCardinality];
}

enums.AccountSelectionCardinality accountSelectionCardinalityFromJson(
  Object? accountSelectionCardinality, [
  enums.AccountSelectionCardinality? defaultValue,
]) {
  if (accountSelectionCardinality is String) {
    return enums.$AccountSelectionCardinalityMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                accountSelectionCardinality.toLowerCase(),
            orElse: () => const MapEntry(
                enums.AccountSelectionCardinality.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$AccountSelectionCardinalityMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.AccountSelectionCardinality.swaggerGeneratedUnknown;
}

List<String> accountSelectionCardinalityListToJson(
    List<enums.AccountSelectionCardinality>? accountSelectionCardinality) {
  if (accountSelectionCardinality == null) {
    return [];
  }

  return accountSelectionCardinality
      .map((e) => enums.$AccountSelectionCardinalityMap[e]!)
      .toList();
}

List<enums.AccountSelectionCardinality> accountSelectionCardinalityListFromJson(
  List? accountSelectionCardinality, [
  List<enums.AccountSelectionCardinality>? defaultValue,
]) {
  if (accountSelectionCardinality == null) {
    return defaultValue ?? [];
  }

  return accountSelectionCardinality
      .map((e) => accountSelectionCardinalityFromJson(e.toString()))
      .toList();
}

List<enums.AccountSelectionCardinality>?
    accountSelectionCardinalityNullableListFromJson(
  List? accountSelectionCardinality, [
  List<enums.AccountSelectionCardinality>? defaultValue,
]) {
  if (accountSelectionCardinality == null) {
    return defaultValue;
  }

  return accountSelectionCardinality
      .map((e) => accountSelectionCardinalityFromJson(e.toString()))
      .toList();
}

String? sandboxIncomeFireWebhookRequestVerificationStatusToJson(
    enums.SandboxIncomeFireWebhookRequestVerificationStatus?
        sandboxIncomeFireWebhookRequestVerificationStatus) {
  return enums.$SandboxIncomeFireWebhookRequestVerificationStatusMap[
      sandboxIncomeFireWebhookRequestVerificationStatus];
}

enums.SandboxIncomeFireWebhookRequestVerificationStatus
    sandboxIncomeFireWebhookRequestVerificationStatusFromJson(
  Object? sandboxIncomeFireWebhookRequestVerificationStatus, [
  enums.SandboxIncomeFireWebhookRequestVerificationStatus? defaultValue,
]) {
  if (sandboxIncomeFireWebhookRequestVerificationStatus is String) {
    return enums.$SandboxIncomeFireWebhookRequestVerificationStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                sandboxIncomeFireWebhookRequestVerificationStatus.toLowerCase(),
            orElse: () => const MapEntry(
                enums.SandboxIncomeFireWebhookRequestVerificationStatus
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$SandboxIncomeFireWebhookRequestVerificationStatusMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.SandboxIncomeFireWebhookRequestVerificationStatus
          .swaggerGeneratedUnknown;
}

List<String> sandboxIncomeFireWebhookRequestVerificationStatusListToJson(
    List<enums.SandboxIncomeFireWebhookRequestVerificationStatus>?
        sandboxIncomeFireWebhookRequestVerificationStatus) {
  if (sandboxIncomeFireWebhookRequestVerificationStatus == null) {
    return [];
  }

  return sandboxIncomeFireWebhookRequestVerificationStatus
      .map((e) =>
          enums.$SandboxIncomeFireWebhookRequestVerificationStatusMap[e]!)
      .toList();
}

List<enums.SandboxIncomeFireWebhookRequestVerificationStatus>
    sandboxIncomeFireWebhookRequestVerificationStatusListFromJson(
  List? sandboxIncomeFireWebhookRequestVerificationStatus, [
  List<enums.SandboxIncomeFireWebhookRequestVerificationStatus>? defaultValue,
]) {
  if (sandboxIncomeFireWebhookRequestVerificationStatus == null) {
    return defaultValue ?? [];
  }

  return sandboxIncomeFireWebhookRequestVerificationStatus
      .map((e) => sandboxIncomeFireWebhookRequestVerificationStatusFromJson(
          e.toString()))
      .toList();
}

List<enums.SandboxIncomeFireWebhookRequestVerificationStatus>?
    sandboxIncomeFireWebhookRequestVerificationStatusNullableListFromJson(
  List? sandboxIncomeFireWebhookRequestVerificationStatus, [
  List<enums.SandboxIncomeFireWebhookRequestVerificationStatus>? defaultValue,
]) {
  if (sandboxIncomeFireWebhookRequestVerificationStatus == null) {
    return defaultValue;
  }

  return sandboxIncomeFireWebhookRequestVerificationStatus
      .map((e) => sandboxIncomeFireWebhookRequestVerificationStatusFromJson(
          e.toString()))
      .toList();
}

String? walletISOCurrencyCodeToJson(
    enums.WalletISOCurrencyCode? walletISOCurrencyCode) {
  return enums.$WalletISOCurrencyCodeMap[walletISOCurrencyCode];
}

enums.WalletISOCurrencyCode walletISOCurrencyCodeFromJson(
  Object? walletISOCurrencyCode, [
  enums.WalletISOCurrencyCode? defaultValue,
]) {
  if (walletISOCurrencyCode is String) {
    return enums.$WalletISOCurrencyCodeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                walletISOCurrencyCode.toLowerCase(),
            orElse: () => const MapEntry(
                enums.WalletISOCurrencyCode.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$WalletISOCurrencyCodeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.WalletISOCurrencyCode.swaggerGeneratedUnknown;
}

List<String> walletISOCurrencyCodeListToJson(
    List<enums.WalletISOCurrencyCode>? walletISOCurrencyCode) {
  if (walletISOCurrencyCode == null) {
    return [];
  }

  return walletISOCurrencyCode
      .map((e) => enums.$WalletISOCurrencyCodeMap[e]!)
      .toList();
}

List<enums.WalletISOCurrencyCode> walletISOCurrencyCodeListFromJson(
  List? walletISOCurrencyCode, [
  List<enums.WalletISOCurrencyCode>? defaultValue,
]) {
  if (walletISOCurrencyCode == null) {
    return defaultValue ?? [];
  }

  return walletISOCurrencyCode
      .map((e) => walletISOCurrencyCodeFromJson(e.toString()))
      .toList();
}

List<enums.WalletISOCurrencyCode>? walletISOCurrencyCodeNullableListFromJson(
  List? walletISOCurrencyCode, [
  List<enums.WalletISOCurrencyCode>? defaultValue,
]) {
  if (walletISOCurrencyCode == null) {
    return defaultValue;
  }

  return walletISOCurrencyCode
      .map((e) => walletISOCurrencyCodeFromJson(e.toString()))
      .toList();
}

String? walletTransactionStatusToJson(
    enums.WalletTransactionStatus? walletTransactionStatus) {
  return enums.$WalletTransactionStatusMap[walletTransactionStatus];
}

enums.WalletTransactionStatus walletTransactionStatusFromJson(
  Object? walletTransactionStatus, [
  enums.WalletTransactionStatus? defaultValue,
]) {
  if (walletTransactionStatus is String) {
    return enums.$WalletTransactionStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                walletTransactionStatus.toLowerCase(),
            orElse: () => const MapEntry(
                enums.WalletTransactionStatus.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$WalletTransactionStatusMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.WalletTransactionStatus.swaggerGeneratedUnknown;
}

List<String> walletTransactionStatusListToJson(
    List<enums.WalletTransactionStatus>? walletTransactionStatus) {
  if (walletTransactionStatus == null) {
    return [];
  }

  return walletTransactionStatus
      .map((e) => enums.$WalletTransactionStatusMap[e]!)
      .toList();
}

List<enums.WalletTransactionStatus> walletTransactionStatusListFromJson(
  List? walletTransactionStatus, [
  List<enums.WalletTransactionStatus>? defaultValue,
]) {
  if (walletTransactionStatus == null) {
    return defaultValue ?? [];
  }

  return walletTransactionStatus
      .map((e) => walletTransactionStatusFromJson(e.toString()))
      .toList();
}

List<enums.WalletTransactionStatus>?
    walletTransactionStatusNullableListFromJson(
  List? walletTransactionStatus, [
  List<enums.WalletTransactionStatus>? defaultValue,
]) {
  if (walletTransactionStatus == null) {
    return defaultValue;
  }

  return walletTransactionStatus
      .map((e) => walletTransactionStatusFromJson(e.toString()))
      .toList();
}

String? walletTransactionGetResponseTypeToJson(
    enums.WalletTransactionGetResponseType? walletTransactionGetResponseType) {
  return enums
      .$WalletTransactionGetResponseTypeMap[walletTransactionGetResponseType];
}

enums.WalletTransactionGetResponseType walletTransactionGetResponseTypeFromJson(
  Object? walletTransactionGetResponseType, [
  enums.WalletTransactionGetResponseType? defaultValue,
]) {
  if (walletTransactionGetResponseType is String) {
    return enums.$WalletTransactionGetResponseTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                walletTransactionGetResponseType.toLowerCase(),
            orElse: () => const MapEntry(
                enums.WalletTransactionGetResponseType.swaggerGeneratedUnknown,
                ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$WalletTransactionGetResponseTypeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.WalletTransactionGetResponseType.swaggerGeneratedUnknown;
}

List<String> walletTransactionGetResponseTypeListToJson(
    List<enums.WalletTransactionGetResponseType>?
        walletTransactionGetResponseType) {
  if (walletTransactionGetResponseType == null) {
    return [];
  }

  return walletTransactionGetResponseType
      .map((e) => enums.$WalletTransactionGetResponseTypeMap[e]!)
      .toList();
}

List<enums.WalletTransactionGetResponseType>
    walletTransactionGetResponseTypeListFromJson(
  List? walletTransactionGetResponseType, [
  List<enums.WalletTransactionGetResponseType>? defaultValue,
]) {
  if (walletTransactionGetResponseType == null) {
    return defaultValue ?? [];
  }

  return walletTransactionGetResponseType
      .map((e) => walletTransactionGetResponseTypeFromJson(e.toString()))
      .toList();
}

List<enums.WalletTransactionGetResponseType>?
    walletTransactionGetResponseTypeNullableListFromJson(
  List? walletTransactionGetResponseType, [
  List<enums.WalletTransactionGetResponseType>? defaultValue,
]) {
  if (walletTransactionGetResponseType == null) {
    return defaultValue;
  }

  return walletTransactionGetResponseType
      .map((e) => walletTransactionGetResponseTypeFromJson(e.toString()))
      .toList();
}

String? walletTransactionTypeToJson(
    enums.WalletTransactionType? walletTransactionType) {
  return enums.$WalletTransactionTypeMap[walletTransactionType];
}

enums.WalletTransactionType walletTransactionTypeFromJson(
  Object? walletTransactionType, [
  enums.WalletTransactionType? defaultValue,
]) {
  if (walletTransactionType is String) {
    return enums.$WalletTransactionTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                walletTransactionType.toLowerCase(),
            orElse: () => const MapEntry(
                enums.WalletTransactionType.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$WalletTransactionTypeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.WalletTransactionType.swaggerGeneratedUnknown;
}

List<String> walletTransactionTypeListToJson(
    List<enums.WalletTransactionType>? walletTransactionType) {
  if (walletTransactionType == null) {
    return [];
  }

  return walletTransactionType
      .map((e) => enums.$WalletTransactionTypeMap[e]!)
      .toList();
}

List<enums.WalletTransactionType> walletTransactionTypeListFromJson(
  List? walletTransactionType, [
  List<enums.WalletTransactionType>? defaultValue,
]) {
  if (walletTransactionType == null) {
    return defaultValue ?? [];
  }

  return walletTransactionType
      .map((e) => walletTransactionTypeFromJson(e.toString()))
      .toList();
}

List<enums.WalletTransactionType>? walletTransactionTypeNullableListFromJson(
  List? walletTransactionType, [
  List<enums.WalletTransactionType>? defaultValue,
]) {
  if (walletTransactionType == null) {
    return defaultValue;
  }

  return walletTransactionType
      .map((e) => walletTransactionTypeFromJson(e.toString()))
      .toList();
}

String? enrichTransactionDirectionToJson(
    enums.EnrichTransactionDirection? enrichTransactionDirection) {
  return enums.$EnrichTransactionDirectionMap[enrichTransactionDirection];
}

enums.EnrichTransactionDirection enrichTransactionDirectionFromJson(
  Object? enrichTransactionDirection, [
  enums.EnrichTransactionDirection? defaultValue,
]) {
  if (enrichTransactionDirection is String) {
    return enums.$EnrichTransactionDirectionMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                enrichTransactionDirection.toLowerCase(),
            orElse: () => const MapEntry(
                enums.EnrichTransactionDirection.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$EnrichTransactionDirectionMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.EnrichTransactionDirection.swaggerGeneratedUnknown;
}

List<String> enrichTransactionDirectionListToJson(
    List<enums.EnrichTransactionDirection>? enrichTransactionDirection) {
  if (enrichTransactionDirection == null) {
    return [];
  }

  return enrichTransactionDirection
      .map((e) => enums.$EnrichTransactionDirectionMap[e]!)
      .toList();
}

List<enums.EnrichTransactionDirection> enrichTransactionDirectionListFromJson(
  List? enrichTransactionDirection, [
  List<enums.EnrichTransactionDirection>? defaultValue,
]) {
  if (enrichTransactionDirection == null) {
    return defaultValue ?? [];
  }

  return enrichTransactionDirection
      .map((e) => enrichTransactionDirectionFromJson(e.toString()))
      .toList();
}

List<enums.EnrichTransactionDirection>?
    enrichTransactionDirectionNullableListFromJson(
  List? enrichTransactionDirection, [
  List<enums.EnrichTransactionDirection>? defaultValue,
]) {
  if (enrichTransactionDirection == null) {
    return defaultValue;
  }

  return enrichTransactionDirection
      .map((e) => enrichTransactionDirectionFromJson(e.toString()))
      .toList();
}

String? paymentChannelToJson(enums.PaymentChannel? paymentChannel) {
  return enums.$PaymentChannelMap[paymentChannel];
}

enums.PaymentChannel paymentChannelFromJson(
  Object? paymentChannel, [
  enums.PaymentChannel? defaultValue,
]) {
  if (paymentChannel is String) {
    return enums.$PaymentChannelMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == paymentChannel.toLowerCase(),
            orElse: () => const MapEntry(
                enums.PaymentChannel.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$PaymentChannelMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.PaymentChannel.swaggerGeneratedUnknown;
}

List<String> paymentChannelListToJson(
    List<enums.PaymentChannel>? paymentChannel) {
  if (paymentChannel == null) {
    return [];
  }

  return paymentChannel.map((e) => enums.$PaymentChannelMap[e]!).toList();
}

List<enums.PaymentChannel> paymentChannelListFromJson(
  List? paymentChannel, [
  List<enums.PaymentChannel>? defaultValue,
]) {
  if (paymentChannel == null) {
    return defaultValue ?? [];
  }

  return paymentChannel
      .map((e) => paymentChannelFromJson(e.toString()))
      .toList();
}

List<enums.PaymentChannel>? paymentChannelNullableListFromJson(
  List? paymentChannel, [
  List<enums.PaymentChannel>? defaultValue,
]) {
  if (paymentChannel == null) {
    return defaultValue;
  }

  return paymentChannel
      .map((e) => paymentChannelFromJson(e.toString()))
      .toList();
}

String? paymentProfileStatusToJson(
    enums.PaymentProfileStatus? paymentProfileStatus) {
  return enums.$PaymentProfileStatusMap[paymentProfileStatus];
}

enums.PaymentProfileStatus paymentProfileStatusFromJson(
  Object? paymentProfileStatus, [
  enums.PaymentProfileStatus? defaultValue,
]) {
  if (paymentProfileStatus is String) {
    return enums.$PaymentProfileStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                paymentProfileStatus.toLowerCase(),
            orElse: () => const MapEntry(
                enums.PaymentProfileStatus.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$PaymentProfileStatusMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.PaymentProfileStatus.swaggerGeneratedUnknown;
}

List<String> paymentProfileStatusListToJson(
    List<enums.PaymentProfileStatus>? paymentProfileStatus) {
  if (paymentProfileStatus == null) {
    return [];
  }

  return paymentProfileStatus
      .map((e) => enums.$PaymentProfileStatusMap[e]!)
      .toList();
}

List<enums.PaymentProfileStatus> paymentProfileStatusListFromJson(
  List? paymentProfileStatus, [
  List<enums.PaymentProfileStatus>? defaultValue,
]) {
  if (paymentProfileStatus == null) {
    return defaultValue ?? [];
  }

  return paymentProfileStatus
      .map((e) => paymentProfileStatusFromJson(e.toString()))
      .toList();
}

List<enums.PaymentProfileStatus>? paymentProfileStatusNullableListFromJson(
  List? paymentProfileStatus, [
  List<enums.PaymentProfileStatus>? defaultValue,
]) {
  if (paymentProfileStatus == null) {
    return defaultValue;
  }

  return paymentProfileStatus
      .map((e) => paymentProfileStatusFromJson(e.toString()))
      .toList();
}

String? partnerEndCustomerStatusToJson(
    enums.PartnerEndCustomerStatus? partnerEndCustomerStatus) {
  return enums.$PartnerEndCustomerStatusMap[partnerEndCustomerStatus];
}

enums.PartnerEndCustomerStatus partnerEndCustomerStatusFromJson(
  Object? partnerEndCustomerStatus, [
  enums.PartnerEndCustomerStatus? defaultValue,
]) {
  if (partnerEndCustomerStatus is String) {
    return enums.$PartnerEndCustomerStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                partnerEndCustomerStatus.toLowerCase(),
            orElse: () => const MapEntry(
                enums.PartnerEndCustomerStatus.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$PartnerEndCustomerStatusMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.PartnerEndCustomerStatus.swaggerGeneratedUnknown;
}

List<String> partnerEndCustomerStatusListToJson(
    List<enums.PartnerEndCustomerStatus>? partnerEndCustomerStatus) {
  if (partnerEndCustomerStatus == null) {
    return [];
  }

  return partnerEndCustomerStatus
      .map((e) => enums.$PartnerEndCustomerStatusMap[e]!)
      .toList();
}

List<enums.PartnerEndCustomerStatus> partnerEndCustomerStatusListFromJson(
  List? partnerEndCustomerStatus, [
  List<enums.PartnerEndCustomerStatus>? defaultValue,
]) {
  if (partnerEndCustomerStatus == null) {
    return defaultValue ?? [];
  }

  return partnerEndCustomerStatus
      .map((e) => partnerEndCustomerStatusFromJson(e.toString()))
      .toList();
}

List<enums.PartnerEndCustomerStatus>?
    partnerEndCustomerStatusNullableListFromJson(
  List? partnerEndCustomerStatus, [
  List<enums.PartnerEndCustomerStatus>? defaultValue,
]) {
  if (partnerEndCustomerStatus == null) {
    return defaultValue;
  }

  return partnerEndCustomerStatus
      .map((e) => partnerEndCustomerStatusFromJson(e.toString()))
      .toList();
}

String? linkDeliverySessionStatusToJson(
    enums.LinkDeliverySessionStatus? linkDeliverySessionStatus) {
  return enums.$LinkDeliverySessionStatusMap[linkDeliverySessionStatus];
}

enums.LinkDeliverySessionStatus linkDeliverySessionStatusFromJson(
  Object? linkDeliverySessionStatus, [
  enums.LinkDeliverySessionStatus? defaultValue,
]) {
  if (linkDeliverySessionStatus is String) {
    return enums.$LinkDeliverySessionStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                linkDeliverySessionStatus.toLowerCase(),
            orElse: () => const MapEntry(
                enums.LinkDeliverySessionStatus.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$LinkDeliverySessionStatusMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.LinkDeliverySessionStatus.swaggerGeneratedUnknown;
}

List<String> linkDeliverySessionStatusListToJson(
    List<enums.LinkDeliverySessionStatus>? linkDeliverySessionStatus) {
  if (linkDeliverySessionStatus == null) {
    return [];
  }

  return linkDeliverySessionStatus
      .map((e) => enums.$LinkDeliverySessionStatusMap[e]!)
      .toList();
}

List<enums.LinkDeliverySessionStatus> linkDeliverySessionStatusListFromJson(
  List? linkDeliverySessionStatus, [
  List<enums.LinkDeliverySessionStatus>? defaultValue,
]) {
  if (linkDeliverySessionStatus == null) {
    return defaultValue ?? [];
  }

  return linkDeliverySessionStatus
      .map((e) => linkDeliverySessionStatusFromJson(e.toString()))
      .toList();
}

List<enums.LinkDeliverySessionStatus>?
    linkDeliverySessionStatusNullableListFromJson(
  List? linkDeliverySessionStatus, [
  List<enums.LinkDeliverySessionStatus>? defaultValue,
]) {
  if (linkDeliverySessionStatus == null) {
    return defaultValue;
  }

  return linkDeliverySessionStatus
      .map((e) => linkDeliverySessionStatusFromJson(e.toString()))
      .toList();
}

String? linkDeliveryDeliveryMethodToJson(
    enums.LinkDeliveryDeliveryMethod? linkDeliveryDeliveryMethod) {
  return enums.$LinkDeliveryDeliveryMethodMap[linkDeliveryDeliveryMethod];
}

enums.LinkDeliveryDeliveryMethod linkDeliveryDeliveryMethodFromJson(
  Object? linkDeliveryDeliveryMethod, [
  enums.LinkDeliveryDeliveryMethod? defaultValue,
]) {
  if (linkDeliveryDeliveryMethod is String) {
    return enums.$LinkDeliveryDeliveryMethodMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                linkDeliveryDeliveryMethod.toLowerCase(),
            orElse: () => const MapEntry(
                enums.LinkDeliveryDeliveryMethod.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$LinkDeliveryDeliveryMethodMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.LinkDeliveryDeliveryMethod.swaggerGeneratedUnknown;
}

List<String> linkDeliveryDeliveryMethodListToJson(
    List<enums.LinkDeliveryDeliveryMethod>? linkDeliveryDeliveryMethod) {
  if (linkDeliveryDeliveryMethod == null) {
    return [];
  }

  return linkDeliveryDeliveryMethod
      .map((e) => enums.$LinkDeliveryDeliveryMethodMap[e]!)
      .toList();
}

List<enums.LinkDeliveryDeliveryMethod> linkDeliveryDeliveryMethodListFromJson(
  List? linkDeliveryDeliveryMethod, [
  List<enums.LinkDeliveryDeliveryMethod>? defaultValue,
]) {
  if (linkDeliveryDeliveryMethod == null) {
    return defaultValue ?? [];
  }

  return linkDeliveryDeliveryMethod
      .map((e) => linkDeliveryDeliveryMethodFromJson(e.toString()))
      .toList();
}

List<enums.LinkDeliveryDeliveryMethod>?
    linkDeliveryDeliveryMethodNullableListFromJson(
  List? linkDeliveryDeliveryMethod, [
  List<enums.LinkDeliveryDeliveryMethod>? defaultValue,
]) {
  if (linkDeliveryDeliveryMethod == null) {
    return defaultValue;
  }

  return linkDeliveryDeliveryMethod
      .map((e) => linkDeliveryDeliveryMethodFromJson(e.toString()))
      .toList();
}

String? warningWarningCodeToJson(enums.WarningWarningCode? warningWarningCode) {
  return enums.$WarningWarningCodeMap[warningWarningCode];
}

enums.WarningWarningCode warningWarningCodeFromJson(
  Object? warningWarningCode, [
  enums.WarningWarningCode? defaultValue,
]) {
  if (warningWarningCode is String) {
    return enums.$WarningWarningCodeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == warningWarningCode.toLowerCase(),
            orElse: () => const MapEntry(
                enums.WarningWarningCode.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$WarningWarningCodeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.WarningWarningCode.swaggerGeneratedUnknown;
}

List<String> warningWarningCodeListToJson(
    List<enums.WarningWarningCode>? warningWarningCode) {
  if (warningWarningCode == null) {
    return [];
  }

  return warningWarningCode
      .map((e) => enums.$WarningWarningCodeMap[e]!)
      .toList();
}

List<enums.WarningWarningCode> warningWarningCodeListFromJson(
  List? warningWarningCode, [
  List<enums.WarningWarningCode>? defaultValue,
]) {
  if (warningWarningCode == null) {
    return defaultValue ?? [];
  }

  return warningWarningCode
      .map((e) => warningWarningCodeFromJson(e.toString()))
      .toList();
}

List<enums.WarningWarningCode>? warningWarningCodeNullableListFromJson(
  List? warningWarningCode, [
  List<enums.WarningWarningCode>? defaultValue,
]) {
  if (warningWarningCode == null) {
    return defaultValue;
  }

  return warningWarningCode
      .map((e) => warningWarningCodeFromJson(e.toString()))
      .toList();
}

String? accountAssetsVerificationStatusToJson(
    enums.AccountAssetsVerificationStatus? accountAssetsVerificationStatus) {
  return enums
      .$AccountAssetsVerificationStatusMap[accountAssetsVerificationStatus];
}

enums.AccountAssetsVerificationStatus accountAssetsVerificationStatusFromJson(
  Object? accountAssetsVerificationStatus, [
  enums.AccountAssetsVerificationStatus? defaultValue,
]) {
  if (accountAssetsVerificationStatus is String) {
    return enums.$AccountAssetsVerificationStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                accountAssetsVerificationStatus.toLowerCase(),
            orElse: () => const MapEntry(
                enums.AccountAssetsVerificationStatus.swaggerGeneratedUnknown,
                ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$AccountAssetsVerificationStatusMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.AccountAssetsVerificationStatus.swaggerGeneratedUnknown;
}

List<String> accountAssetsVerificationStatusListToJson(
    List<enums.AccountAssetsVerificationStatus>?
        accountAssetsVerificationStatus) {
  if (accountAssetsVerificationStatus == null) {
    return [];
  }

  return accountAssetsVerificationStatus
      .map((e) => enums.$AccountAssetsVerificationStatusMap[e]!)
      .toList();
}

List<enums.AccountAssetsVerificationStatus>
    accountAssetsVerificationStatusListFromJson(
  List? accountAssetsVerificationStatus, [
  List<enums.AccountAssetsVerificationStatus>? defaultValue,
]) {
  if (accountAssetsVerificationStatus == null) {
    return defaultValue ?? [];
  }

  return accountAssetsVerificationStatus
      .map((e) => accountAssetsVerificationStatusFromJson(e.toString()))
      .toList();
}

List<enums.AccountAssetsVerificationStatus>?
    accountAssetsVerificationStatusNullableListFromJson(
  List? accountAssetsVerificationStatus, [
  List<enums.AccountAssetsVerificationStatus>? defaultValue,
]) {
  if (accountAssetsVerificationStatus == null) {
    return defaultValue;
  }

  return accountAssetsVerificationStatus
      .map((e) => accountAssetsVerificationStatusFromJson(e.toString()))
      .toList();
}

String? ownershipTypeToJson(enums.OwnershipType? ownershipType) {
  return enums.$OwnershipTypeMap[ownershipType];
}

enums.OwnershipType ownershipTypeFromJson(
  Object? ownershipType, [
  enums.OwnershipType? defaultValue,
]) {
  if (ownershipType is String) {
    return enums.$OwnershipTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == ownershipType.toLowerCase(),
            orElse: () =>
                const MapEntry(enums.OwnershipType.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$OwnershipTypeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.OwnershipType.swaggerGeneratedUnknown;
}

List<String> ownershipTypeListToJson(List<enums.OwnershipType>? ownershipType) {
  if (ownershipType == null) {
    return [];
  }

  return ownershipType.map((e) => enums.$OwnershipTypeMap[e]!).toList();
}

List<enums.OwnershipType> ownershipTypeListFromJson(
  List? ownershipType, [
  List<enums.OwnershipType>? defaultValue,
]) {
  if (ownershipType == null) {
    return defaultValue ?? [];
  }

  return ownershipType.map((e) => ownershipTypeFromJson(e.toString())).toList();
}

List<enums.OwnershipType>? ownershipTypeNullableListFromJson(
  List? ownershipType, [
  List<enums.OwnershipType>? defaultValue,
]) {
  if (ownershipType == null) {
    return defaultValue;
  }

  return ownershipType.map((e) => ownershipTypeFromJson(e.toString())).toList();
}

String? assetReportTransactionTransactionTypeToJson(
    enums.AssetReportTransactionTransactionType?
        assetReportTransactionTransactionType) {
  return enums.$AssetReportTransactionTransactionTypeMap[
      assetReportTransactionTransactionType];
}

enums.AssetReportTransactionTransactionType
    assetReportTransactionTransactionTypeFromJson(
  Object? assetReportTransactionTransactionType, [
  enums.AssetReportTransactionTransactionType? defaultValue,
]) {
  if (assetReportTransactionTransactionType is String) {
    return enums.$AssetReportTransactionTransactionTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                assetReportTransactionTransactionType.toLowerCase(),
            orElse: () => const MapEntry(
                enums.AssetReportTransactionTransactionType
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$AssetReportTransactionTransactionTypeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.AssetReportTransactionTransactionType.swaggerGeneratedUnknown;
}

List<String> assetReportTransactionTransactionTypeListToJson(
    List<enums.AssetReportTransactionTransactionType>?
        assetReportTransactionTransactionType) {
  if (assetReportTransactionTransactionType == null) {
    return [];
  }

  return assetReportTransactionTransactionType
      .map((e) => enums.$AssetReportTransactionTransactionTypeMap[e]!)
      .toList();
}

List<enums.AssetReportTransactionTransactionType>
    assetReportTransactionTransactionTypeListFromJson(
  List? assetReportTransactionTransactionType, [
  List<enums.AssetReportTransactionTransactionType>? defaultValue,
]) {
  if (assetReportTransactionTransactionType == null) {
    return defaultValue ?? [];
  }

  return assetReportTransactionTransactionType
      .map((e) => assetReportTransactionTransactionTypeFromJson(e.toString()))
      .toList();
}

List<enums.AssetReportTransactionTransactionType>?
    assetReportTransactionTransactionTypeNullableListFromJson(
  List? assetReportTransactionTransactionType, [
  List<enums.AssetReportTransactionTransactionType>? defaultValue,
]) {
  if (assetReportTransactionTransactionType == null) {
    return defaultValue;
  }

  return assetReportTransactionTransactionType
      .map((e) => assetReportTransactionTransactionTypeFromJson(e.toString()))
      .toList();
}

String? addressPurposeLabelToJson(
    enums.AddressPurposeLabel? addressPurposeLabel) {
  return enums.$AddressPurposeLabelMap[addressPurposeLabel];
}

enums.AddressPurposeLabel addressPurposeLabelFromJson(
  Object? addressPurposeLabel, [
  enums.AddressPurposeLabel? defaultValue,
]) {
  if (addressPurposeLabel is String) {
    return enums.$AddressPurposeLabelMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                addressPurposeLabel.toLowerCase(),
            orElse: () => const MapEntry(
                enums.AddressPurposeLabel.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$AddressPurposeLabelMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.AddressPurposeLabel.swaggerGeneratedUnknown;
}

List<String> addressPurposeLabelListToJson(
    List<enums.AddressPurposeLabel>? addressPurposeLabel) {
  if (addressPurposeLabel == null) {
    return [];
  }

  return addressPurposeLabel
      .map((e) => enums.$AddressPurposeLabelMap[e]!)
      .toList();
}

List<enums.AddressPurposeLabel> addressPurposeLabelListFromJson(
  List? addressPurposeLabel, [
  List<enums.AddressPurposeLabel>? defaultValue,
]) {
  if (addressPurposeLabel == null) {
    return defaultValue ?? [];
  }

  return addressPurposeLabel
      .map((e) => addressPurposeLabelFromJson(e.toString()))
      .toList();
}

List<enums.AddressPurposeLabel>? addressPurposeLabelNullableListFromJson(
  List? addressPurposeLabel, [
  List<enums.AddressPurposeLabel>? defaultValue,
]) {
  if (addressPurposeLabel == null) {
    return defaultValue;
  }

  return addressPurposeLabel
      .map((e) => addressPurposeLabelFromJson(e.toString()))
      .toList();
}

String? dashboardUserStatusToJson(
    enums.DashboardUserStatus? dashboardUserStatus) {
  return enums.$DashboardUserStatusMap[dashboardUserStatus];
}

enums.DashboardUserStatus dashboardUserStatusFromJson(
  Object? dashboardUserStatus, [
  enums.DashboardUserStatus? defaultValue,
]) {
  if (dashboardUserStatus is String) {
    return enums.$DashboardUserStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                dashboardUserStatus.toLowerCase(),
            orElse: () => const MapEntry(
                enums.DashboardUserStatus.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$DashboardUserStatusMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.DashboardUserStatus.swaggerGeneratedUnknown;
}

List<String> dashboardUserStatusListToJson(
    List<enums.DashboardUserStatus>? dashboardUserStatus) {
  if (dashboardUserStatus == null) {
    return [];
  }

  return dashboardUserStatus
      .map((e) => enums.$DashboardUserStatusMap[e]!)
      .toList();
}

List<enums.DashboardUserStatus> dashboardUserStatusListFromJson(
  List? dashboardUserStatus, [
  List<enums.DashboardUserStatus>? defaultValue,
]) {
  if (dashboardUserStatus == null) {
    return defaultValue ?? [];
  }

  return dashboardUserStatus
      .map((e) => dashboardUserStatusFromJson(e.toString()))
      .toList();
}

List<enums.DashboardUserStatus>? dashboardUserStatusNullableListFromJson(
  List? dashboardUserStatus, [
  List<enums.DashboardUserStatus>? defaultValue,
]) {
  if (dashboardUserStatus == null) {
    return defaultValue;
  }

  return dashboardUserStatus
      .map((e) => dashboardUserStatusFromJson(e.toString()))
      .toList();
}

String? documentAuthenticityMatchCodeToJson(
    enums.DocumentAuthenticityMatchCode? documentAuthenticityMatchCode) {
  return enums.$DocumentAuthenticityMatchCodeMap[documentAuthenticityMatchCode];
}

enums.DocumentAuthenticityMatchCode documentAuthenticityMatchCodeFromJson(
  Object? documentAuthenticityMatchCode, [
  enums.DocumentAuthenticityMatchCode? defaultValue,
]) {
  if (documentAuthenticityMatchCode is String) {
    return enums.$DocumentAuthenticityMatchCodeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                documentAuthenticityMatchCode.toLowerCase(),
            orElse: () => const MapEntry(
                enums.DocumentAuthenticityMatchCode.swaggerGeneratedUnknown,
                ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$DocumentAuthenticityMatchCodeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.DocumentAuthenticityMatchCode.swaggerGeneratedUnknown;
}

List<String> documentAuthenticityMatchCodeListToJson(
    List<enums.DocumentAuthenticityMatchCode>? documentAuthenticityMatchCode) {
  if (documentAuthenticityMatchCode == null) {
    return [];
  }

  return documentAuthenticityMatchCode
      .map((e) => enums.$DocumentAuthenticityMatchCodeMap[e]!)
      .toList();
}

List<enums.DocumentAuthenticityMatchCode>
    documentAuthenticityMatchCodeListFromJson(
  List? documentAuthenticityMatchCode, [
  List<enums.DocumentAuthenticityMatchCode>? defaultValue,
]) {
  if (documentAuthenticityMatchCode == null) {
    return defaultValue ?? [];
  }

  return documentAuthenticityMatchCode
      .map((e) => documentAuthenticityMatchCodeFromJson(e.toString()))
      .toList();
}

List<enums.DocumentAuthenticityMatchCode>?
    documentAuthenticityMatchCodeNullableListFromJson(
  List? documentAuthenticityMatchCode, [
  List<enums.DocumentAuthenticityMatchCode>? defaultValue,
]) {
  if (documentAuthenticityMatchCode == null) {
    return defaultValue;
  }

  return documentAuthenticityMatchCode
      .map((e) => documentAuthenticityMatchCodeFromJson(e.toString()))
      .toList();
}

String? documentDateOfBirthMatchCodeToJson(
    enums.DocumentDateOfBirthMatchCode? documentDateOfBirthMatchCode) {
  return enums.$DocumentDateOfBirthMatchCodeMap[documentDateOfBirthMatchCode];
}

enums.DocumentDateOfBirthMatchCode documentDateOfBirthMatchCodeFromJson(
  Object? documentDateOfBirthMatchCode, [
  enums.DocumentDateOfBirthMatchCode? defaultValue,
]) {
  if (documentDateOfBirthMatchCode is String) {
    return enums.$DocumentDateOfBirthMatchCodeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                documentDateOfBirthMatchCode.toLowerCase(),
            orElse: () => const MapEntry(
                enums.DocumentDateOfBirthMatchCode.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$DocumentDateOfBirthMatchCodeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.DocumentDateOfBirthMatchCode.swaggerGeneratedUnknown;
}

List<String> documentDateOfBirthMatchCodeListToJson(
    List<enums.DocumentDateOfBirthMatchCode>? documentDateOfBirthMatchCode) {
  if (documentDateOfBirthMatchCode == null) {
    return [];
  }

  return documentDateOfBirthMatchCode
      .map((e) => enums.$DocumentDateOfBirthMatchCodeMap[e]!)
      .toList();
}

List<enums.DocumentDateOfBirthMatchCode>
    documentDateOfBirthMatchCodeListFromJson(
  List? documentDateOfBirthMatchCode, [
  List<enums.DocumentDateOfBirthMatchCode>? defaultValue,
]) {
  if (documentDateOfBirthMatchCode == null) {
    return defaultValue ?? [];
  }

  return documentDateOfBirthMatchCode
      .map((e) => documentDateOfBirthMatchCodeFromJson(e.toString()))
      .toList();
}

List<enums.DocumentDateOfBirthMatchCode>?
    documentDateOfBirthMatchCodeNullableListFromJson(
  List? documentDateOfBirthMatchCode, [
  List<enums.DocumentDateOfBirthMatchCode>? defaultValue,
]) {
  if (documentDateOfBirthMatchCode == null) {
    return defaultValue;
  }

  return documentDateOfBirthMatchCode
      .map((e) => documentDateOfBirthMatchCodeFromJson(e.toString()))
      .toList();
}

String? documentNameMatchCodeToJson(
    enums.DocumentNameMatchCode? documentNameMatchCode) {
  return enums.$DocumentNameMatchCodeMap[documentNameMatchCode];
}

enums.DocumentNameMatchCode documentNameMatchCodeFromJson(
  Object? documentNameMatchCode, [
  enums.DocumentNameMatchCode? defaultValue,
]) {
  if (documentNameMatchCode is String) {
    return enums.$DocumentNameMatchCodeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                documentNameMatchCode.toLowerCase(),
            orElse: () => const MapEntry(
                enums.DocumentNameMatchCode.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$DocumentNameMatchCodeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.DocumentNameMatchCode.swaggerGeneratedUnknown;
}

List<String> documentNameMatchCodeListToJson(
    List<enums.DocumentNameMatchCode>? documentNameMatchCode) {
  if (documentNameMatchCode == null) {
    return [];
  }

  return documentNameMatchCode
      .map((e) => enums.$DocumentNameMatchCodeMap[e]!)
      .toList();
}

List<enums.DocumentNameMatchCode> documentNameMatchCodeListFromJson(
  List? documentNameMatchCode, [
  List<enums.DocumentNameMatchCode>? defaultValue,
]) {
  if (documentNameMatchCode == null) {
    return defaultValue ?? [];
  }

  return documentNameMatchCode
      .map((e) => documentNameMatchCodeFromJson(e.toString()))
      .toList();
}

List<enums.DocumentNameMatchCode>? documentNameMatchCodeNullableListFromJson(
  List? documentNameMatchCode, [
  List<enums.DocumentNameMatchCode>? defaultValue,
]) {
  if (documentNameMatchCode == null) {
    return defaultValue;
  }

  return documentNameMatchCode
      .map((e) => documentNameMatchCodeFromJson(e.toString()))
      .toList();
}

String? documentStatusToJson(enums.DocumentStatus? documentStatus) {
  return enums.$DocumentStatusMap[documentStatus];
}

enums.DocumentStatus documentStatusFromJson(
  Object? documentStatus, [
  enums.DocumentStatus? defaultValue,
]) {
  if (documentStatus is String) {
    return enums.$DocumentStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == documentStatus.toLowerCase(),
            orElse: () => const MapEntry(
                enums.DocumentStatus.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$DocumentStatusMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.DocumentStatus.swaggerGeneratedUnknown;
}

List<String> documentStatusListToJson(
    List<enums.DocumentStatus>? documentStatus) {
  if (documentStatus == null) {
    return [];
  }

  return documentStatus.map((e) => enums.$DocumentStatusMap[e]!).toList();
}

List<enums.DocumentStatus> documentStatusListFromJson(
  List? documentStatus, [
  List<enums.DocumentStatus>? defaultValue,
]) {
  if (documentStatus == null) {
    return defaultValue ?? [];
  }

  return documentStatus
      .map((e) => documentStatusFromJson(e.toString()))
      .toList();
}

List<enums.DocumentStatus>? documentStatusNullableListFromJson(
  List? documentStatus, [
  List<enums.DocumentStatus>? defaultValue,
]) {
  if (documentStatus == null) {
    return defaultValue;
  }

  return documentStatus
      .map((e) => documentStatusFromJson(e.toString()))
      .toList();
}

String? entityDocumentTypeToJson(enums.EntityDocumentType? entityDocumentType) {
  return enums.$EntityDocumentTypeMap[entityDocumentType];
}

enums.EntityDocumentType entityDocumentTypeFromJson(
  Object? entityDocumentType, [
  enums.EntityDocumentType? defaultValue,
]) {
  if (entityDocumentType is String) {
    return enums.$EntityDocumentTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == entityDocumentType.toLowerCase(),
            orElse: () => const MapEntry(
                enums.EntityDocumentType.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$EntityDocumentTypeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.EntityDocumentType.swaggerGeneratedUnknown;
}

List<String> entityDocumentTypeListToJson(
    List<enums.EntityDocumentType>? entityDocumentType) {
  if (entityDocumentType == null) {
    return [];
  }

  return entityDocumentType
      .map((e) => enums.$EntityDocumentTypeMap[e]!)
      .toList();
}

List<enums.EntityDocumentType> entityDocumentTypeListFromJson(
  List? entityDocumentType, [
  List<enums.EntityDocumentType>? defaultValue,
]) {
  if (entityDocumentType == null) {
    return defaultValue ?? [];
  }

  return entityDocumentType
      .map((e) => entityDocumentTypeFromJson(e.toString()))
      .toList();
}

List<enums.EntityDocumentType>? entityDocumentTypeNullableListFromJson(
  List? entityDocumentType, [
  List<enums.EntityDocumentType>? defaultValue,
]) {
  if (entityDocumentType == null) {
    return defaultValue;
  }

  return entityDocumentType
      .map((e) => entityDocumentTypeFromJson(e.toString()))
      .toList();
}

String? entityWatchlistCodeToJson(
    enums.EntityWatchlistCode? entityWatchlistCode) {
  return enums.$EntityWatchlistCodeMap[entityWatchlistCode];
}

enums.EntityWatchlistCode entityWatchlistCodeFromJson(
  Object? entityWatchlistCode, [
  enums.EntityWatchlistCode? defaultValue,
]) {
  if (entityWatchlistCode is String) {
    return enums.$EntityWatchlistCodeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                entityWatchlistCode.toLowerCase(),
            orElse: () => const MapEntry(
                enums.EntityWatchlistCode.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$EntityWatchlistCodeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.EntityWatchlistCode.swaggerGeneratedUnknown;
}

List<String> entityWatchlistCodeListToJson(
    List<enums.EntityWatchlistCode>? entityWatchlistCode) {
  if (entityWatchlistCode == null) {
    return [];
  }

  return entityWatchlistCode
      .map((e) => enums.$EntityWatchlistCodeMap[e]!)
      .toList();
}

List<enums.EntityWatchlistCode> entityWatchlistCodeListFromJson(
  List? entityWatchlistCode, [
  List<enums.EntityWatchlistCode>? defaultValue,
]) {
  if (entityWatchlistCode == null) {
    return defaultValue ?? [];
  }

  return entityWatchlistCode
      .map((e) => entityWatchlistCodeFromJson(e.toString()))
      .toList();
}

List<enums.EntityWatchlistCode>? entityWatchlistCodeNullableListFromJson(
  List? entityWatchlistCode, [
  List<enums.EntityWatchlistCode>? defaultValue,
]) {
  if (entityWatchlistCode == null) {
    return defaultValue;
  }

  return entityWatchlistCode
      .map((e) => entityWatchlistCodeFromJson(e.toString()))
      .toList();
}

String? expirationDateToJson(enums.ExpirationDate? expirationDate) {
  return enums.$ExpirationDateMap[expirationDate];
}

enums.ExpirationDate expirationDateFromJson(
  Object? expirationDate, [
  enums.ExpirationDate? defaultValue,
]) {
  if (expirationDate is String) {
    return enums.$ExpirationDateMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == expirationDate.toLowerCase(),
            orElse: () => const MapEntry(
                enums.ExpirationDate.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$ExpirationDateMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.ExpirationDate.swaggerGeneratedUnknown;
}

List<String> expirationDateListToJson(
    List<enums.ExpirationDate>? expirationDate) {
  if (expirationDate == null) {
    return [];
  }

  return expirationDate.map((e) => enums.$ExpirationDateMap[e]!).toList();
}

List<enums.ExpirationDate> expirationDateListFromJson(
  List? expirationDate, [
  List<enums.ExpirationDate>? defaultValue,
]) {
  if (expirationDate == null) {
    return defaultValue ?? [];
  }

  return expirationDate
      .map((e) => expirationDateFromJson(e.toString()))
      .toList();
}

List<enums.ExpirationDate>? expirationDateNullableListFromJson(
  List? expirationDate, [
  List<enums.ExpirationDate>? defaultValue,
]) {
  if (expirationDate == null) {
    return defaultValue;
  }

  return expirationDate
      .map((e) => expirationDateFromJson(e.toString()))
      .toList();
}

String? iDNumberTypeToJson(enums.IDNumberType? iDNumberType) {
  return enums.$IDNumberTypeMap[iDNumberType];
}

enums.IDNumberType iDNumberTypeFromJson(
  Object? iDNumberType, [
  enums.IDNumberType? defaultValue,
]) {
  if (iDNumberType is String) {
    return enums.$IDNumberTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == iDNumberType.toLowerCase(),
            orElse: () =>
                const MapEntry(enums.IDNumberType.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$IDNumberTypeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.IDNumberType.swaggerGeneratedUnknown;
}

List<String> iDNumberTypeListToJson(List<enums.IDNumberType>? iDNumberType) {
  if (iDNumberType == null) {
    return [];
  }

  return iDNumberType.map((e) => enums.$IDNumberTypeMap[e]!).toList();
}

List<enums.IDNumberType> iDNumberTypeListFromJson(
  List? iDNumberType, [
  List<enums.IDNumberType>? defaultValue,
]) {
  if (iDNumberType == null) {
    return defaultValue ?? [];
  }

  return iDNumberType.map((e) => iDNumberTypeFromJson(e.toString())).toList();
}

List<enums.IDNumberType>? iDNumberTypeNullableListFromJson(
  List? iDNumberType, [
  List<enums.IDNumberType>? defaultValue,
]) {
  if (iDNumberType == null) {
    return defaultValue;
  }

  return iDNumberType.map((e) => iDNumberTypeFromJson(e.toString())).toList();
}

String? identityVerificationStatusToJson(
    enums.IdentityVerificationStatus? identityVerificationStatus) {
  return enums.$IdentityVerificationStatusMap[identityVerificationStatus];
}

enums.IdentityVerificationStatus identityVerificationStatusFromJson(
  Object? identityVerificationStatus, [
  enums.IdentityVerificationStatus? defaultValue,
]) {
  if (identityVerificationStatus is String) {
    return enums.$IdentityVerificationStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                identityVerificationStatus.toLowerCase(),
            orElse: () => const MapEntry(
                enums.IdentityVerificationStatus.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$IdentityVerificationStatusMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.IdentityVerificationStatus.swaggerGeneratedUnknown;
}

List<String> identityVerificationStatusListToJson(
    List<enums.IdentityVerificationStatus>? identityVerificationStatus) {
  if (identityVerificationStatus == null) {
    return [];
  }

  return identityVerificationStatus
      .map((e) => enums.$IdentityVerificationStatusMap[e]!)
      .toList();
}

List<enums.IdentityVerificationStatus> identityVerificationStatusListFromJson(
  List? identityVerificationStatus, [
  List<enums.IdentityVerificationStatus>? defaultValue,
]) {
  if (identityVerificationStatus == null) {
    return defaultValue ?? [];
  }

  return identityVerificationStatus
      .map((e) => identityVerificationStatusFromJson(e.toString()))
      .toList();
}

List<enums.IdentityVerificationStatus>?
    identityVerificationStatusNullableListFromJson(
  List? identityVerificationStatus, [
  List<enums.IdentityVerificationStatus>? defaultValue,
]) {
  if (identityVerificationStatus == null) {
    return defaultValue;
  }

  return identityVerificationStatus
      .map((e) => identityVerificationStatusFromJson(e.toString()))
      .toList();
}

String? identityVerificationStepStatusToJson(
    enums.IdentityVerificationStepStatus? identityVerificationStepStatus) {
  return enums
      .$IdentityVerificationStepStatusMap[identityVerificationStepStatus];
}

enums.IdentityVerificationStepStatus identityVerificationStepStatusFromJson(
  Object? identityVerificationStepStatus, [
  enums.IdentityVerificationStepStatus? defaultValue,
]) {
  if (identityVerificationStepStatus is String) {
    return enums.$IdentityVerificationStepStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                identityVerificationStepStatus.toLowerCase(),
            orElse: () => const MapEntry(
                enums.IdentityVerificationStepStatus.swaggerGeneratedUnknown,
                ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$IdentityVerificationStepStatusMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.IdentityVerificationStepStatus.swaggerGeneratedUnknown;
}

List<String> identityVerificationStepStatusListToJson(
    List<enums.IdentityVerificationStepStatus>?
        identityVerificationStepStatus) {
  if (identityVerificationStepStatus == null) {
    return [];
  }

  return identityVerificationStepStatus
      .map((e) => enums.$IdentityVerificationStepStatusMap[e]!)
      .toList();
}

List<enums.IdentityVerificationStepStatus>
    identityVerificationStepStatusListFromJson(
  List? identityVerificationStepStatus, [
  List<enums.IdentityVerificationStepStatus>? defaultValue,
]) {
  if (identityVerificationStepStatus == null) {
    return defaultValue ?? [];
  }

  return identityVerificationStepStatus
      .map((e) => identityVerificationStepStatusFromJson(e.toString()))
      .toList();
}

List<enums.IdentityVerificationStepStatus>?
    identityVerificationStepStatusNullableListFromJson(
  List? identityVerificationStepStatus, [
  List<enums.IdentityVerificationStepStatus>? defaultValue,
]) {
  if (identityVerificationStepStatus == null) {
    return defaultValue;
  }

  return identityVerificationStepStatus
      .map((e) => identityVerificationStepStatusFromJson(e.toString()))
      .toList();
}

String? imageQualityToJson(enums.ImageQuality? imageQuality) {
  return enums.$ImageQualityMap[imageQuality];
}

enums.ImageQuality imageQualityFromJson(
  Object? imageQuality, [
  enums.ImageQuality? defaultValue,
]) {
  if (imageQuality is String) {
    return enums.$ImageQualityMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == imageQuality.toLowerCase(),
            orElse: () =>
                const MapEntry(enums.ImageQuality.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$ImageQualityMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.ImageQuality.swaggerGeneratedUnknown;
}

List<String> imageQualityListToJson(List<enums.ImageQuality>? imageQuality) {
  if (imageQuality == null) {
    return [];
  }

  return imageQuality.map((e) => enums.$ImageQualityMap[e]!).toList();
}

List<enums.ImageQuality> imageQualityListFromJson(
  List? imageQuality, [
  List<enums.ImageQuality>? defaultValue,
]) {
  if (imageQuality == null) {
    return defaultValue ?? [];
  }

  return imageQuality.map((e) => imageQualityFromJson(e.toString())).toList();
}

List<enums.ImageQuality>? imageQualityNullableListFromJson(
  List? imageQuality, [
  List<enums.ImageQuality>? defaultValue,
]) {
  if (imageQuality == null) {
    return defaultValue;
  }

  return imageQuality.map((e) => imageQualityFromJson(e.toString())).toList();
}

String? individualWatchlistCodeToJson(
    enums.IndividualWatchlistCode? individualWatchlistCode) {
  return enums.$IndividualWatchlistCodeMap[individualWatchlistCode];
}

enums.IndividualWatchlistCode individualWatchlistCodeFromJson(
  Object? individualWatchlistCode, [
  enums.IndividualWatchlistCode? defaultValue,
]) {
  if (individualWatchlistCode is String) {
    return enums.$IndividualWatchlistCodeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                individualWatchlistCode.toLowerCase(),
            orElse: () => const MapEntry(
                enums.IndividualWatchlistCode.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$IndividualWatchlistCodeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.IndividualWatchlistCode.swaggerGeneratedUnknown;
}

List<String> individualWatchlistCodeListToJson(
    List<enums.IndividualWatchlistCode>? individualWatchlistCode) {
  if (individualWatchlistCode == null) {
    return [];
  }

  return individualWatchlistCode
      .map((e) => enums.$IndividualWatchlistCodeMap[e]!)
      .toList();
}

List<enums.IndividualWatchlistCode> individualWatchlistCodeListFromJson(
  List? individualWatchlistCode, [
  List<enums.IndividualWatchlistCode>? defaultValue,
]) {
  if (individualWatchlistCode == null) {
    return defaultValue ?? [];
  }

  return individualWatchlistCode
      .map((e) => individualWatchlistCodeFromJson(e.toString()))
      .toList();
}

List<enums.IndividualWatchlistCode>?
    individualWatchlistCodeNullableListFromJson(
  List? individualWatchlistCode, [
  List<enums.IndividualWatchlistCode>? defaultValue,
]) {
  if (individualWatchlistCode == null) {
    return defaultValue;
  }

  return individualWatchlistCode
      .map((e) => individualWatchlistCodeFromJson(e.toString()))
      .toList();
}

String? issuingCountryToJson(enums.IssuingCountry? issuingCountry) {
  return enums.$IssuingCountryMap[issuingCountry];
}

enums.IssuingCountry issuingCountryFromJson(
  Object? issuingCountry, [
  enums.IssuingCountry? defaultValue,
]) {
  if (issuingCountry is String) {
    return enums.$IssuingCountryMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == issuingCountry.toLowerCase(),
            orElse: () => const MapEntry(
                enums.IssuingCountry.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$IssuingCountryMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.IssuingCountry.swaggerGeneratedUnknown;
}

List<String> issuingCountryListToJson(
    List<enums.IssuingCountry>? issuingCountry) {
  if (issuingCountry == null) {
    return [];
  }

  return issuingCountry.map((e) => enums.$IssuingCountryMap[e]!).toList();
}

List<enums.IssuingCountry> issuingCountryListFromJson(
  List? issuingCountry, [
  List<enums.IssuingCountry>? defaultValue,
]) {
  if (issuingCountry == null) {
    return defaultValue ?? [];
  }

  return issuingCountry
      .map((e) => issuingCountryFromJson(e.toString()))
      .toList();
}

List<enums.IssuingCountry>? issuingCountryNullableListFromJson(
  List? issuingCountry, [
  List<enums.IssuingCountry>? defaultValue,
]) {
  if (issuingCountry == null) {
    return defaultValue;
  }

  return issuingCountry
      .map((e) => issuingCountryFromJson(e.toString()))
      .toList();
}

String? matchSummaryCodeToJson(enums.MatchSummaryCode? matchSummaryCode) {
  return enums.$MatchSummaryCodeMap[matchSummaryCode];
}

enums.MatchSummaryCode matchSummaryCodeFromJson(
  Object? matchSummaryCode, [
  enums.MatchSummaryCode? defaultValue,
]) {
  if (matchSummaryCode is String) {
    return enums.$MatchSummaryCodeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == matchSummaryCode.toLowerCase(),
            orElse: () => const MapEntry(
                enums.MatchSummaryCode.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$MatchSummaryCodeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.MatchSummaryCode.swaggerGeneratedUnknown;
}

List<String> matchSummaryCodeListToJson(
    List<enums.MatchSummaryCode>? matchSummaryCode) {
  if (matchSummaryCode == null) {
    return [];
  }

  return matchSummaryCode.map((e) => enums.$MatchSummaryCodeMap[e]!).toList();
}

List<enums.MatchSummaryCode> matchSummaryCodeListFromJson(
  List? matchSummaryCode, [
  List<enums.MatchSummaryCode>? defaultValue,
]) {
  if (matchSummaryCode == null) {
    return defaultValue ?? [];
  }

  return matchSummaryCode
      .map((e) => matchSummaryCodeFromJson(e.toString()))
      .toList();
}

List<enums.MatchSummaryCode>? matchSummaryCodeNullableListFromJson(
  List? matchSummaryCode, [
  List<enums.MatchSummaryCode>? defaultValue,
]) {
  if (matchSummaryCode == null) {
    return defaultValue;
  }

  return matchSummaryCode
      .map((e) => matchSummaryCodeFromJson(e.toString()))
      .toList();
}

String? pOBoxStatusToJson(enums.POBoxStatus? pOBoxStatus) {
  return enums.$POBoxStatusMap[pOBoxStatus];
}

enums.POBoxStatus pOBoxStatusFromJson(
  Object? pOBoxStatus, [
  enums.POBoxStatus? defaultValue,
]) {
  if (pOBoxStatus is String) {
    return enums.$POBoxStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == pOBoxStatus.toLowerCase(),
            orElse: () =>
                const MapEntry(enums.POBoxStatus.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$POBoxStatusMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.POBoxStatus.swaggerGeneratedUnknown;
}

List<String> pOBoxStatusListToJson(List<enums.POBoxStatus>? pOBoxStatus) {
  if (pOBoxStatus == null) {
    return [];
  }

  return pOBoxStatus.map((e) => enums.$POBoxStatusMap[e]!).toList();
}

List<enums.POBoxStatus> pOBoxStatusListFromJson(
  List? pOBoxStatus, [
  List<enums.POBoxStatus>? defaultValue,
]) {
  if (pOBoxStatus == null) {
    return defaultValue ?? [];
  }

  return pOBoxStatus.map((e) => pOBoxStatusFromJson(e.toString())).toList();
}

List<enums.POBoxStatus>? pOBoxStatusNullableListFromJson(
  List? pOBoxStatus, [
  List<enums.POBoxStatus>? defaultValue,
]) {
  if (pOBoxStatus == null) {
    return defaultValue;
  }

  return pOBoxStatus.map((e) => pOBoxStatusFromJson(e.toString())).toList();
}

String? phoneTypeToJson(enums.PhoneType? phoneType) {
  return enums.$PhoneTypeMap[phoneType];
}

enums.PhoneType phoneTypeFromJson(
  Object? phoneType, [
  enums.PhoneType? defaultValue,
]) {
  if (phoneType is String) {
    return enums.$PhoneTypeMap.entries
        .firstWhere(
            (element) => element.value.toLowerCase() == phoneType.toLowerCase(),
            orElse: () =>
                const MapEntry(enums.PhoneType.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$PhoneTypeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.PhoneType.swaggerGeneratedUnknown;
}

List<String> phoneTypeListToJson(List<enums.PhoneType>? phoneType) {
  if (phoneType == null) {
    return [];
  }

  return phoneType.map((e) => enums.$PhoneTypeMap[e]!).toList();
}

List<enums.PhoneType> phoneTypeListFromJson(
  List? phoneType, [
  List<enums.PhoneType>? defaultValue,
]) {
  if (phoneType == null) {
    return defaultValue ?? [];
  }

  return phoneType.map((e) => phoneTypeFromJson(e.toString())).toList();
}

List<enums.PhoneType>? phoneTypeNullableListFromJson(
  List? phoneType, [
  List<enums.PhoneType>? defaultValue,
]) {
  if (phoneType == null) {
    return defaultValue;
  }

  return phoneType.map((e) => phoneTypeFromJson(e.toString())).toList();
}

String? physicalDocumentCategoryToJson(
    enums.PhysicalDocumentCategory? physicalDocumentCategory) {
  return enums.$PhysicalDocumentCategoryMap[physicalDocumentCategory];
}

enums.PhysicalDocumentCategory physicalDocumentCategoryFromJson(
  Object? physicalDocumentCategory, [
  enums.PhysicalDocumentCategory? defaultValue,
]) {
  if (physicalDocumentCategory is String) {
    return enums.$PhysicalDocumentCategoryMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                physicalDocumentCategory.toLowerCase(),
            orElse: () => const MapEntry(
                enums.PhysicalDocumentCategory.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$PhysicalDocumentCategoryMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.PhysicalDocumentCategory.swaggerGeneratedUnknown;
}

List<String> physicalDocumentCategoryListToJson(
    List<enums.PhysicalDocumentCategory>? physicalDocumentCategory) {
  if (physicalDocumentCategory == null) {
    return [];
  }

  return physicalDocumentCategory
      .map((e) => enums.$PhysicalDocumentCategoryMap[e]!)
      .toList();
}

List<enums.PhysicalDocumentCategory> physicalDocumentCategoryListFromJson(
  List? physicalDocumentCategory, [
  List<enums.PhysicalDocumentCategory>? defaultValue,
]) {
  if (physicalDocumentCategory == null) {
    return defaultValue ?? [];
  }

  return physicalDocumentCategory
      .map((e) => physicalDocumentCategoryFromJson(e.toString()))
      .toList();
}

List<enums.PhysicalDocumentCategory>?
    physicalDocumentCategoryNullableListFromJson(
  List? physicalDocumentCategory, [
  List<enums.PhysicalDocumentCategory>? defaultValue,
]) {
  if (physicalDocumentCategory == null) {
    return defaultValue;
  }

  return physicalDocumentCategory
      .map((e) => physicalDocumentCategoryFromJson(e.toString()))
      .toList();
}

String? programNameSensitivityToJson(
    enums.ProgramNameSensitivity? programNameSensitivity) {
  return enums.$ProgramNameSensitivityMap[programNameSensitivity];
}

enums.ProgramNameSensitivity programNameSensitivityFromJson(
  Object? programNameSensitivity, [
  enums.ProgramNameSensitivity? defaultValue,
]) {
  if (programNameSensitivity is String) {
    return enums.$ProgramNameSensitivityMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                programNameSensitivity.toLowerCase(),
            orElse: () => const MapEntry(
                enums.ProgramNameSensitivity.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$ProgramNameSensitivityMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.ProgramNameSensitivity.swaggerGeneratedUnknown;
}

List<String> programNameSensitivityListToJson(
    List<enums.ProgramNameSensitivity>? programNameSensitivity) {
  if (programNameSensitivity == null) {
    return [];
  }

  return programNameSensitivity
      .map((e) => enums.$ProgramNameSensitivityMap[e]!)
      .toList();
}

List<enums.ProgramNameSensitivity> programNameSensitivityListFromJson(
  List? programNameSensitivity, [
  List<enums.ProgramNameSensitivity>? defaultValue,
]) {
  if (programNameSensitivity == null) {
    return defaultValue ?? [];
  }

  return programNameSensitivity
      .map((e) => programNameSensitivityFromJson(e.toString()))
      .toList();
}

List<enums.ProgramNameSensitivity>? programNameSensitivityNullableListFromJson(
  List? programNameSensitivity, [
  List<enums.ProgramNameSensitivity>? defaultValue,
]) {
  if (programNameSensitivity == null) {
    return defaultValue;
  }

  return programNameSensitivity
      .map((e) => programNameSensitivityFromJson(e.toString()))
      .toList();
}

String? sourceToJson(enums.Source? source) {
  return enums.$SourceMap[source];
}

enums.Source sourceFromJson(
  Object? source, [
  enums.Source? defaultValue,
]) {
  if (source is String) {
    return enums.$SourceMap.entries
        .firstWhere(
            (element) => element.value.toLowerCase() == source.toLowerCase(),
            orElse: () =>
                const MapEntry(enums.Source.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$SourceMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ?? defaultValue ?? enums.Source.swaggerGeneratedUnknown;
}

List<String> sourceListToJson(List<enums.Source>? source) {
  if (source == null) {
    return [];
  }

  return source.map((e) => enums.$SourceMap[e]!).toList();
}

List<enums.Source> sourceListFromJson(
  List? source, [
  List<enums.Source>? defaultValue,
]) {
  if (source == null) {
    return defaultValue ?? [];
  }

  return source.map((e) => sourceFromJson(e.toString())).toList();
}

List<enums.Source>? sourceNullableListFromJson(
  List? source, [
  List<enums.Source>? defaultValue,
]) {
  if (source == null) {
    return defaultValue;
  }

  return source.map((e) => sourceFromJson(e.toString())).toList();
}

String? strategyToJson(enums.Strategy? strategy) {
  return enums.$StrategyMap[strategy];
}

enums.Strategy strategyFromJson(
  Object? strategy, [
  enums.Strategy? defaultValue,
]) {
  if (strategy is String) {
    return enums.$StrategyMap.entries
        .firstWhere(
            (element) => element.value.toLowerCase() == strategy.toLowerCase(),
            orElse: () =>
                const MapEntry(enums.Strategy.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$StrategyMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ?? defaultValue ?? enums.Strategy.swaggerGeneratedUnknown;
}

List<String> strategyListToJson(List<enums.Strategy>? strategy) {
  if (strategy == null) {
    return [];
  }

  return strategy.map((e) => enums.$StrategyMap[e]!).toList();
}

List<enums.Strategy> strategyListFromJson(
  List? strategy, [
  List<enums.Strategy>? defaultValue,
]) {
  if (strategy == null) {
    return defaultValue ?? [];
  }

  return strategy.map((e) => strategyFromJson(e.toString())).toList();
}

List<enums.Strategy>? strategyNullableListFromJson(
  List? strategy, [
  List<enums.Strategy>? defaultValue,
]) {
  if (strategy == null) {
    return defaultValue;
  }

  return strategy.map((e) => strategyFromJson(e.toString())).toList();
}

String? watchlistScreeningDocumentTypeToJson(
    enums.WatchlistScreeningDocumentType? watchlistScreeningDocumentType) {
  return enums
      .$WatchlistScreeningDocumentTypeMap[watchlistScreeningDocumentType];
}

enums.WatchlistScreeningDocumentType watchlistScreeningDocumentTypeFromJson(
  Object? watchlistScreeningDocumentType, [
  enums.WatchlistScreeningDocumentType? defaultValue,
]) {
  if (watchlistScreeningDocumentType is String) {
    return enums.$WatchlistScreeningDocumentTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                watchlistScreeningDocumentType.toLowerCase(),
            orElse: () => const MapEntry(
                enums.WatchlistScreeningDocumentType.swaggerGeneratedUnknown,
                ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$WatchlistScreeningDocumentTypeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.WatchlistScreeningDocumentType.swaggerGeneratedUnknown;
}

List<String> watchlistScreeningDocumentTypeListToJson(
    List<enums.WatchlistScreeningDocumentType>?
        watchlistScreeningDocumentType) {
  if (watchlistScreeningDocumentType == null) {
    return [];
  }

  return watchlistScreeningDocumentType
      .map((e) => enums.$WatchlistScreeningDocumentTypeMap[e]!)
      .toList();
}

List<enums.WatchlistScreeningDocumentType>
    watchlistScreeningDocumentTypeListFromJson(
  List? watchlistScreeningDocumentType, [
  List<enums.WatchlistScreeningDocumentType>? defaultValue,
]) {
  if (watchlistScreeningDocumentType == null) {
    return defaultValue ?? [];
  }

  return watchlistScreeningDocumentType
      .map((e) => watchlistScreeningDocumentTypeFromJson(e.toString()))
      .toList();
}

List<enums.WatchlistScreeningDocumentType>?
    watchlistScreeningDocumentTypeNullableListFromJson(
  List? watchlistScreeningDocumentType, [
  List<enums.WatchlistScreeningDocumentType>? defaultValue,
]) {
  if (watchlistScreeningDocumentType == null) {
    return defaultValue;
  }

  return watchlistScreeningDocumentType
      .map((e) => watchlistScreeningDocumentTypeFromJson(e.toString()))
      .toList();
}

String? watchlistScreeningEntityUpdateRequestResettableFieldToJson(
    enums.WatchlistScreeningEntityUpdateRequestResettableField?
        watchlistScreeningEntityUpdateRequestResettableField) {
  return enums.$WatchlistScreeningEntityUpdateRequestResettableFieldMap[
      watchlistScreeningEntityUpdateRequestResettableField];
}

enums.WatchlistScreeningEntityUpdateRequestResettableField
    watchlistScreeningEntityUpdateRequestResettableFieldFromJson(
  Object? watchlistScreeningEntityUpdateRequestResettableField, [
  enums.WatchlistScreeningEntityUpdateRequestResettableField? defaultValue,
]) {
  if (watchlistScreeningEntityUpdateRequestResettableField is String) {
    return enums
        .$WatchlistScreeningEntityUpdateRequestResettableFieldMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                watchlistScreeningEntityUpdateRequestResettableField
                    .toLowerCase(),
            orElse: () => const MapEntry(
                enums.WatchlistScreeningEntityUpdateRequestResettableField
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$WatchlistScreeningEntityUpdateRequestResettableFieldMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.WatchlistScreeningEntityUpdateRequestResettableField
          .swaggerGeneratedUnknown;
}

List<String> watchlistScreeningEntityUpdateRequestResettableFieldListToJson(
    List<enums.WatchlistScreeningEntityUpdateRequestResettableField>?
        watchlistScreeningEntityUpdateRequestResettableField) {
  if (watchlistScreeningEntityUpdateRequestResettableField == null) {
    return [];
  }

  return watchlistScreeningEntityUpdateRequestResettableField
      .map((e) =>
          enums.$WatchlistScreeningEntityUpdateRequestResettableFieldMap[e]!)
      .toList();
}

List<enums.WatchlistScreeningEntityUpdateRequestResettableField>
    watchlistScreeningEntityUpdateRequestResettableFieldListFromJson(
  List? watchlistScreeningEntityUpdateRequestResettableField, [
  List<enums.WatchlistScreeningEntityUpdateRequestResettableField>?
      defaultValue,
]) {
  if (watchlistScreeningEntityUpdateRequestResettableField == null) {
    return defaultValue ?? [];
  }

  return watchlistScreeningEntityUpdateRequestResettableField
      .map((e) => watchlistScreeningEntityUpdateRequestResettableFieldFromJson(
          e.toString()))
      .toList();
}

List<enums.WatchlistScreeningEntityUpdateRequestResettableField>?
    watchlistScreeningEntityUpdateRequestResettableFieldNullableListFromJson(
  List? watchlistScreeningEntityUpdateRequestResettableField, [
  List<enums.WatchlistScreeningEntityUpdateRequestResettableField>?
      defaultValue,
]) {
  if (watchlistScreeningEntityUpdateRequestResettableField == null) {
    return defaultValue;
  }

  return watchlistScreeningEntityUpdateRequestResettableField
      .map((e) => watchlistScreeningEntityUpdateRequestResettableFieldFromJson(
          e.toString()))
      .toList();
}

String? watchlistScreeningHitStatusToJson(
    enums.WatchlistScreeningHitStatus? watchlistScreeningHitStatus) {
  return enums.$WatchlistScreeningHitStatusMap[watchlistScreeningHitStatus];
}

enums.WatchlistScreeningHitStatus watchlistScreeningHitStatusFromJson(
  Object? watchlistScreeningHitStatus, [
  enums.WatchlistScreeningHitStatus? defaultValue,
]) {
  if (watchlistScreeningHitStatus is String) {
    return enums.$WatchlistScreeningHitStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                watchlistScreeningHitStatus.toLowerCase(),
            orElse: () => const MapEntry(
                enums.WatchlistScreeningHitStatus.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$WatchlistScreeningHitStatusMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.WatchlistScreeningHitStatus.swaggerGeneratedUnknown;
}

List<String> watchlistScreeningHitStatusListToJson(
    List<enums.WatchlistScreeningHitStatus>? watchlistScreeningHitStatus) {
  if (watchlistScreeningHitStatus == null) {
    return [];
  }

  return watchlistScreeningHitStatus
      .map((e) => enums.$WatchlistScreeningHitStatusMap[e]!)
      .toList();
}

List<enums.WatchlistScreeningHitStatus> watchlistScreeningHitStatusListFromJson(
  List? watchlistScreeningHitStatus, [
  List<enums.WatchlistScreeningHitStatus>? defaultValue,
]) {
  if (watchlistScreeningHitStatus == null) {
    return defaultValue ?? [];
  }

  return watchlistScreeningHitStatus
      .map((e) => watchlistScreeningHitStatusFromJson(e.toString()))
      .toList();
}

List<enums.WatchlistScreeningHitStatus>?
    watchlistScreeningHitStatusNullableListFromJson(
  List? watchlistScreeningHitStatus, [
  List<enums.WatchlistScreeningHitStatus>? defaultValue,
]) {
  if (watchlistScreeningHitStatus == null) {
    return defaultValue;
  }

  return watchlistScreeningHitStatus
      .map((e) => watchlistScreeningHitStatusFromJson(e.toString()))
      .toList();
}

String? watchlistScreeningIndividualUpdateRequestResettableFieldToJson(
    enums.WatchlistScreeningIndividualUpdateRequestResettableField?
        watchlistScreeningIndividualUpdateRequestResettableField) {
  return enums.$WatchlistScreeningIndividualUpdateRequestResettableFieldMap[
      watchlistScreeningIndividualUpdateRequestResettableField];
}

enums.WatchlistScreeningIndividualUpdateRequestResettableField
    watchlistScreeningIndividualUpdateRequestResettableFieldFromJson(
  Object? watchlistScreeningIndividualUpdateRequestResettableField, [
  enums.WatchlistScreeningIndividualUpdateRequestResettableField? defaultValue,
]) {
  if (watchlistScreeningIndividualUpdateRequestResettableField is String) {
    return enums
        .$WatchlistScreeningIndividualUpdateRequestResettableFieldMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                watchlistScreeningIndividualUpdateRequestResettableField
                    .toLowerCase(),
            orElse: () => const MapEntry(
                enums.WatchlistScreeningIndividualUpdateRequestResettableField
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums
          .$WatchlistScreeningIndividualUpdateRequestResettableFieldMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.WatchlistScreeningIndividualUpdateRequestResettableField
          .swaggerGeneratedUnknown;
}

List<String> watchlistScreeningIndividualUpdateRequestResettableFieldListToJson(
    List<enums.WatchlistScreeningIndividualUpdateRequestResettableField>?
        watchlistScreeningIndividualUpdateRequestResettableField) {
  if (watchlistScreeningIndividualUpdateRequestResettableField == null) {
    return [];
  }

  return watchlistScreeningIndividualUpdateRequestResettableField
      .map((e) => enums
          .$WatchlistScreeningIndividualUpdateRequestResettableFieldMap[e]!)
      .toList();
}

List<enums.WatchlistScreeningIndividualUpdateRequestResettableField>
    watchlistScreeningIndividualUpdateRequestResettableFieldListFromJson(
  List? watchlistScreeningIndividualUpdateRequestResettableField, [
  List<enums.WatchlistScreeningIndividualUpdateRequestResettableField>?
      defaultValue,
]) {
  if (watchlistScreeningIndividualUpdateRequestResettableField == null) {
    return defaultValue ?? [];
  }

  return watchlistScreeningIndividualUpdateRequestResettableField
      .map((e) =>
          watchlistScreeningIndividualUpdateRequestResettableFieldFromJson(
              e.toString()))
      .toList();
}

List<enums.WatchlistScreeningIndividualUpdateRequestResettableField>?
    watchlistScreeningIndividualUpdateRequestResettableFieldNullableListFromJson(
  List? watchlistScreeningIndividualUpdateRequestResettableField, [
  List<enums.WatchlistScreeningIndividualUpdateRequestResettableField>?
      defaultValue,
]) {
  if (watchlistScreeningIndividualUpdateRequestResettableField == null) {
    return defaultValue;
  }

  return watchlistScreeningIndividualUpdateRequestResettableField
      .map((e) =>
          watchlistScreeningIndividualUpdateRequestResettableFieldFromJson(
              e.toString()))
      .toList();
}

String? watchlistScreeningStatusToJson(
    enums.WatchlistScreeningStatus? watchlistScreeningStatus) {
  return enums.$WatchlistScreeningStatusMap[watchlistScreeningStatus];
}

enums.WatchlistScreeningStatus watchlistScreeningStatusFromJson(
  Object? watchlistScreeningStatus, [
  enums.WatchlistScreeningStatus? defaultValue,
]) {
  if (watchlistScreeningStatus is String) {
    return enums.$WatchlistScreeningStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                watchlistScreeningStatus.toLowerCase(),
            orElse: () => const MapEntry(
                enums.WatchlistScreeningStatus.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$WatchlistScreeningStatusMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.WatchlistScreeningStatus.swaggerGeneratedUnknown;
}

List<String> watchlistScreeningStatusListToJson(
    List<enums.WatchlistScreeningStatus>? watchlistScreeningStatus) {
  if (watchlistScreeningStatus == null) {
    return [];
  }

  return watchlistScreeningStatus
      .map((e) => enums.$WatchlistScreeningStatusMap[e]!)
      .toList();
}

List<enums.WatchlistScreeningStatus> watchlistScreeningStatusListFromJson(
  List? watchlistScreeningStatus, [
  List<enums.WatchlistScreeningStatus>? defaultValue,
]) {
  if (watchlistScreeningStatus == null) {
    return defaultValue ?? [];
  }

  return watchlistScreeningStatus
      .map((e) => watchlistScreeningStatusFromJson(e.toString()))
      .toList();
}

List<enums.WatchlistScreeningStatus>?
    watchlistScreeningStatusNullableListFromJson(
  List? watchlistScreeningStatus, [
  List<enums.WatchlistScreeningStatus>? defaultValue,
]) {
  if (watchlistScreeningStatus == null) {
    return defaultValue;
  }

  return watchlistScreeningStatus
      .map((e) => watchlistScreeningStatusFromJson(e.toString()))
      .toList();
}

String? weakAliasDeterminationToJson(
    enums.WeakAliasDetermination? weakAliasDetermination) {
  return enums.$WeakAliasDeterminationMap[weakAliasDetermination];
}

enums.WeakAliasDetermination weakAliasDeterminationFromJson(
  Object? weakAliasDetermination, [
  enums.WeakAliasDetermination? defaultValue,
]) {
  if (weakAliasDetermination is String) {
    return enums.$WeakAliasDeterminationMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                weakAliasDetermination.toLowerCase(),
            orElse: () => const MapEntry(
                enums.WeakAliasDetermination.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$WeakAliasDeterminationMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.WeakAliasDetermination.swaggerGeneratedUnknown;
}

List<String> weakAliasDeterminationListToJson(
    List<enums.WeakAliasDetermination>? weakAliasDetermination) {
  if (weakAliasDetermination == null) {
    return [];
  }

  return weakAliasDetermination
      .map((e) => enums.$WeakAliasDeterminationMap[e]!)
      .toList();
}

List<enums.WeakAliasDetermination> weakAliasDeterminationListFromJson(
  List? weakAliasDetermination, [
  List<enums.WeakAliasDetermination>? defaultValue,
]) {
  if (weakAliasDetermination == null) {
    return defaultValue ?? [];
  }

  return weakAliasDetermination
      .map((e) => weakAliasDeterminationFromJson(e.toString()))
      .toList();
}

List<enums.WeakAliasDetermination>? weakAliasDeterminationNullableListFromJson(
  List? weakAliasDetermination, [
  List<enums.WeakAliasDetermination>? defaultValue,
]) {
  if (weakAliasDetermination == null) {
    return defaultValue;
  }

  return weakAliasDetermination
      .map((e) => weakAliasDeterminationFromJson(e.toString()))
      .toList();
}

String? loanIdentifierTypeToJson(enums.LoanIdentifierType? loanIdentifierType) {
  return enums.$LoanIdentifierTypeMap[loanIdentifierType];
}

enums.LoanIdentifierType loanIdentifierTypeFromJson(
  Object? loanIdentifierType, [
  enums.LoanIdentifierType? defaultValue,
]) {
  if (loanIdentifierType is String) {
    return enums.$LoanIdentifierTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == loanIdentifierType.toLowerCase(),
            orElse: () => const MapEntry(
                enums.LoanIdentifierType.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$LoanIdentifierTypeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.LoanIdentifierType.swaggerGeneratedUnknown;
}

List<String> loanIdentifierTypeListToJson(
    List<enums.LoanIdentifierType>? loanIdentifierType) {
  if (loanIdentifierType == null) {
    return [];
  }

  return loanIdentifierType
      .map((e) => enums.$LoanIdentifierTypeMap[e]!)
      .toList();
}

List<enums.LoanIdentifierType> loanIdentifierTypeListFromJson(
  List? loanIdentifierType, [
  List<enums.LoanIdentifierType>? defaultValue,
]) {
  if (loanIdentifierType == null) {
    return defaultValue ?? [];
  }

  return loanIdentifierType
      .map((e) => loanIdentifierTypeFromJson(e.toString()))
      .toList();
}

List<enums.LoanIdentifierType>? loanIdentifierTypeNullableListFromJson(
  List? loanIdentifierType, [
  List<enums.LoanIdentifierType>? defaultValue,
]) {
  if (loanIdentifierType == null) {
    return defaultValue;
  }

  return loanIdentifierType
      .map((e) => loanIdentifierTypeFromJson(e.toString()))
      .toList();
}

String? partyRoleTypeToJson(enums.PartyRoleType? partyRoleType) {
  return enums.$PartyRoleTypeMap[partyRoleType];
}

enums.PartyRoleType partyRoleTypeFromJson(
  Object? partyRoleType, [
  enums.PartyRoleType? defaultValue,
]) {
  if (partyRoleType is String) {
    return enums.$PartyRoleTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == partyRoleType.toLowerCase(),
            orElse: () =>
                const MapEntry(enums.PartyRoleType.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$PartyRoleTypeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.PartyRoleType.swaggerGeneratedUnknown;
}

List<String> partyRoleTypeListToJson(List<enums.PartyRoleType>? partyRoleType) {
  if (partyRoleType == null) {
    return [];
  }

  return partyRoleType.map((e) => enums.$PartyRoleTypeMap[e]!).toList();
}

List<enums.PartyRoleType> partyRoleTypeListFromJson(
  List? partyRoleType, [
  List<enums.PartyRoleType>? defaultValue,
]) {
  if (partyRoleType == null) {
    return defaultValue ?? [];
  }

  return partyRoleType.map((e) => partyRoleTypeFromJson(e.toString())).toList();
}

List<enums.PartyRoleType>? partyRoleTypeNullableListFromJson(
  List? partyRoleType, [
  List<enums.PartyRoleType>? defaultValue,
]) {
  if (partyRoleType == null) {
    return defaultValue;
  }

  return partyRoleType.map((e) => partyRoleTypeFromJson(e.toString())).toList();
}

String? taxpayerIdentifierTypeToJson(
    enums.TaxpayerIdentifierType? taxpayerIdentifierType) {
  return enums.$TaxpayerIdentifierTypeMap[taxpayerIdentifierType];
}

enums.TaxpayerIdentifierType taxpayerIdentifierTypeFromJson(
  Object? taxpayerIdentifierType, [
  enums.TaxpayerIdentifierType? defaultValue,
]) {
  if (taxpayerIdentifierType is String) {
    return enums.$TaxpayerIdentifierTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                taxpayerIdentifierType.toLowerCase(),
            orElse: () => const MapEntry(
                enums.TaxpayerIdentifierType.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$TaxpayerIdentifierTypeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.TaxpayerIdentifierType.swaggerGeneratedUnknown;
}

List<String> taxpayerIdentifierTypeListToJson(
    List<enums.TaxpayerIdentifierType>? taxpayerIdentifierType) {
  if (taxpayerIdentifierType == null) {
    return [];
  }

  return taxpayerIdentifierType
      .map((e) => enums.$TaxpayerIdentifierTypeMap[e]!)
      .toList();
}

List<enums.TaxpayerIdentifierType> taxpayerIdentifierTypeListFromJson(
  List? taxpayerIdentifierType, [
  List<enums.TaxpayerIdentifierType>? defaultValue,
]) {
  if (taxpayerIdentifierType == null) {
    return defaultValue ?? [];
  }

  return taxpayerIdentifierType
      .map((e) => taxpayerIdentifierTypeFromJson(e.toString()))
      .toList();
}

List<enums.TaxpayerIdentifierType>? taxpayerIdentifierTypeNullableListFromJson(
  List? taxpayerIdentifierType, [
  List<enums.TaxpayerIdentifierType>? defaultValue,
]) {
  if (taxpayerIdentifierType == null) {
    return defaultValue;
  }

  return taxpayerIdentifierType
      .map((e) => taxpayerIdentifierTypeFromJson(e.toString()))
      .toList();
}

String? serviceProductFulfillmentIdentifierToJson(
    enums.ServiceProductFulfillmentIdentifier?
        serviceProductFulfillmentIdentifier) {
  return enums.$ServiceProductFulfillmentIdentifierMap[
      serviceProductFulfillmentIdentifier];
}

enums.ServiceProductFulfillmentIdentifier
    serviceProductFulfillmentIdentifierFromJson(
  Object? serviceProductFulfillmentIdentifier, [
  enums.ServiceProductFulfillmentIdentifier? defaultValue,
]) {
  if (serviceProductFulfillmentIdentifier is String) {
    return enums.$ServiceProductFulfillmentIdentifierMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                serviceProductFulfillmentIdentifier.toLowerCase(),
            orElse: () => const MapEntry(
                enums.ServiceProductFulfillmentIdentifier
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$ServiceProductFulfillmentIdentifierMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.ServiceProductFulfillmentIdentifier.swaggerGeneratedUnknown;
}

List<String> serviceProductFulfillmentIdentifierListToJson(
    List<enums.ServiceProductFulfillmentIdentifier>?
        serviceProductFulfillmentIdentifier) {
  if (serviceProductFulfillmentIdentifier == null) {
    return [];
  }

  return serviceProductFulfillmentIdentifier
      .map((e) => enums.$ServiceProductFulfillmentIdentifierMap[e]!)
      .toList();
}

List<enums.ServiceProductFulfillmentIdentifier>
    serviceProductFulfillmentIdentifierListFromJson(
  List? serviceProductFulfillmentIdentifier, [
  List<enums.ServiceProductFulfillmentIdentifier>? defaultValue,
]) {
  if (serviceProductFulfillmentIdentifier == null) {
    return defaultValue ?? [];
  }

  return serviceProductFulfillmentIdentifier
      .map((e) => serviceProductFulfillmentIdentifierFromJson(e.toString()))
      .toList();
}

List<enums.ServiceProductFulfillmentIdentifier>?
    serviceProductFulfillmentIdentifierNullableListFromJson(
  List? serviceProductFulfillmentIdentifier, [
  List<enums.ServiceProductFulfillmentIdentifier>? defaultValue,
]) {
  if (serviceProductFulfillmentIdentifier == null) {
    return defaultValue;
  }

  return serviceProductFulfillmentIdentifier
      .map((e) => serviceProductFulfillmentIdentifierFromJson(e.toString()))
      .toList();
}

String? assetTypeToJson(enums.AssetType? assetType) {
  return enums.$AssetTypeMap[assetType];
}

enums.AssetType assetTypeFromJson(
  Object? assetType, [
  enums.AssetType? defaultValue,
]) {
  if (assetType is String) {
    return enums.$AssetTypeMap.entries
        .firstWhere(
            (element) => element.value.toLowerCase() == assetType.toLowerCase(),
            orElse: () =>
                const MapEntry(enums.AssetType.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$AssetTypeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.AssetType.swaggerGeneratedUnknown;
}

List<String> assetTypeListToJson(List<enums.AssetType>? assetType) {
  if (assetType == null) {
    return [];
  }

  return assetType.map((e) => enums.$AssetTypeMap[e]!).toList();
}

List<enums.AssetType> assetTypeListFromJson(
  List? assetType, [
  List<enums.AssetType>? defaultValue,
]) {
  if (assetType == null) {
    return defaultValue ?? [];
  }

  return assetType.map((e) => assetTypeFromJson(e.toString())).toList();
}

List<enums.AssetType>? assetTypeNullableListFromJson(
  List? assetType, [
  List<enums.AssetType>? defaultValue,
]) {
  if (assetType == null) {
    return defaultValue;
  }

  return assetType.map((e) => assetTypeFromJson(e.toString())).toList();
}

String? assetTransactionTypeToJson(
    enums.AssetTransactionType? assetTransactionType) {
  return enums.$AssetTransactionTypeMap[assetTransactionType];
}

enums.AssetTransactionType assetTransactionTypeFromJson(
  Object? assetTransactionType, [
  enums.AssetTransactionType? defaultValue,
]) {
  if (assetTransactionType is String) {
    return enums.$AssetTransactionTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                assetTransactionType.toLowerCase(),
            orElse: () => const MapEntry(
                enums.AssetTransactionType.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$AssetTransactionTypeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.AssetTransactionType.swaggerGeneratedUnknown;
}

List<String> assetTransactionTypeListToJson(
    List<enums.AssetTransactionType>? assetTransactionType) {
  if (assetTransactionType == null) {
    return [];
  }

  return assetTransactionType
      .map((e) => enums.$AssetTransactionTypeMap[e]!)
      .toList();
}

List<enums.AssetTransactionType> assetTransactionTypeListFromJson(
  List? assetTransactionType, [
  List<enums.AssetTransactionType>? defaultValue,
]) {
  if (assetTransactionType == null) {
    return defaultValue ?? [];
  }

  return assetTransactionType
      .map((e) => assetTransactionTypeFromJson(e.toString()))
      .toList();
}

List<enums.AssetTransactionType>? assetTransactionTypeNullableListFromJson(
  List? assetTransactionType, [
  List<enums.AssetTransactionType>? defaultValue,
]) {
  if (assetTransactionType == null) {
    return defaultValue;
  }

  return assetTransactionType
      .map((e) => assetTransactionTypeFromJson(e.toString()))
      .toList();
}

String? assetTransactionCategoryTypeToJson(
    enums.AssetTransactionCategoryType? assetTransactionCategoryType) {
  return enums.$AssetTransactionCategoryTypeMap[assetTransactionCategoryType];
}

enums.AssetTransactionCategoryType assetTransactionCategoryTypeFromJson(
  Object? assetTransactionCategoryType, [
  enums.AssetTransactionCategoryType? defaultValue,
]) {
  if (assetTransactionCategoryType is String) {
    return enums.$AssetTransactionCategoryTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                assetTransactionCategoryType.toLowerCase(),
            orElse: () => const MapEntry(
                enums.AssetTransactionCategoryType.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$AssetTransactionCategoryTypeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.AssetTransactionCategoryType.swaggerGeneratedUnknown;
}

List<String> assetTransactionCategoryTypeListToJson(
    List<enums.AssetTransactionCategoryType>? assetTransactionCategoryType) {
  if (assetTransactionCategoryType == null) {
    return [];
  }

  return assetTransactionCategoryType
      .map((e) => enums.$AssetTransactionCategoryTypeMap[e]!)
      .toList();
}

List<enums.AssetTransactionCategoryType>
    assetTransactionCategoryTypeListFromJson(
  List? assetTransactionCategoryType, [
  List<enums.AssetTransactionCategoryType>? defaultValue,
]) {
  if (assetTransactionCategoryType == null) {
    return defaultValue ?? [];
  }

  return assetTransactionCategoryType
      .map((e) => assetTransactionCategoryTypeFromJson(e.toString()))
      .toList();
}

List<enums.AssetTransactionCategoryType>?
    assetTransactionCategoryTypeNullableListFromJson(
  List? assetTransactionCategoryType, [
  List<enums.AssetTransactionCategoryType>? defaultValue,
]) {
  if (assetTransactionCategoryType == null) {
    return defaultValue;
  }

  return assetTransactionCategoryType
      .map((e) => assetTransactionCategoryTypeFromJson(e.toString()))
      .toList();
}

String? itemUpdateTypeToJson(enums.ItemUpdateType? itemUpdateType) {
  return enums.$ItemUpdateTypeMap[itemUpdateType];
}

enums.ItemUpdateType itemUpdateTypeFromJson(
  Object? itemUpdateType, [
  enums.ItemUpdateType? defaultValue,
]) {
  if (itemUpdateType is String) {
    return enums.$ItemUpdateTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == itemUpdateType.toLowerCase(),
            orElse: () => const MapEntry(
                enums.ItemUpdateType.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$ItemUpdateTypeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.ItemUpdateType.swaggerGeneratedUnknown;
}

List<String> itemUpdateTypeListToJson(
    List<enums.ItemUpdateType>? itemUpdateType) {
  if (itemUpdateType == null) {
    return [];
  }

  return itemUpdateType.map((e) => enums.$ItemUpdateTypeMap[e]!).toList();
}

List<enums.ItemUpdateType> itemUpdateTypeListFromJson(
  List? itemUpdateType, [
  List<enums.ItemUpdateType>? defaultValue,
]) {
  if (itemUpdateType == null) {
    return defaultValue ?? [];
  }

  return itemUpdateType
      .map((e) => itemUpdateTypeFromJson(e.toString()))
      .toList();
}

List<enums.ItemUpdateType>? itemUpdateTypeNullableListFromJson(
  List? itemUpdateType, [
  List<enums.ItemUpdateType>? defaultValue,
]) {
  if (itemUpdateType == null) {
    return defaultValue;
  }

  return itemUpdateType
      .map((e) => itemUpdateTypeFromJson(e.toString()))
      .toList();
}

String? fDXNotificationCategoryToJson(
    enums.FDXNotificationCategory? fDXNotificationCategory) {
  return enums.$FDXNotificationCategoryMap[fDXNotificationCategory];
}

enums.FDXNotificationCategory fDXNotificationCategoryFromJson(
  Object? fDXNotificationCategory, [
  enums.FDXNotificationCategory? defaultValue,
]) {
  if (fDXNotificationCategory is String) {
    return enums.$FDXNotificationCategoryMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                fDXNotificationCategory.toLowerCase(),
            orElse: () => const MapEntry(
                enums.FDXNotificationCategory.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$FDXNotificationCategoryMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.FDXNotificationCategory.swaggerGeneratedUnknown;
}

List<String> fDXNotificationCategoryListToJson(
    List<enums.FDXNotificationCategory>? fDXNotificationCategory) {
  if (fDXNotificationCategory == null) {
    return [];
  }

  return fDXNotificationCategory
      .map((e) => enums.$FDXNotificationCategoryMap[e]!)
      .toList();
}

List<enums.FDXNotificationCategory> fDXNotificationCategoryListFromJson(
  List? fDXNotificationCategory, [
  List<enums.FDXNotificationCategory>? defaultValue,
]) {
  if (fDXNotificationCategory == null) {
    return defaultValue ?? [];
  }

  return fDXNotificationCategory
      .map((e) => fDXNotificationCategoryFromJson(e.toString()))
      .toList();
}

List<enums.FDXNotificationCategory>?
    fDXNotificationCategoryNullableListFromJson(
  List? fDXNotificationCategory, [
  List<enums.FDXNotificationCategory>? defaultValue,
]) {
  if (fDXNotificationCategory == null) {
    return defaultValue;
  }

  return fDXNotificationCategory
      .map((e) => fDXNotificationCategoryFromJson(e.toString()))
      .toList();
}

String? fDXNotificationTypeToJson(
    enums.FDXNotificationType? fDXNotificationType) {
  return enums.$FDXNotificationTypeMap[fDXNotificationType];
}

enums.FDXNotificationType fDXNotificationTypeFromJson(
  Object? fDXNotificationType, [
  enums.FDXNotificationType? defaultValue,
]) {
  if (fDXNotificationType is String) {
    return enums.$FDXNotificationTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                fDXNotificationType.toLowerCase(),
            orElse: () => const MapEntry(
                enums.FDXNotificationType.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$FDXNotificationTypeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.FDXNotificationType.swaggerGeneratedUnknown;
}

List<String> fDXNotificationTypeListToJson(
    List<enums.FDXNotificationType>? fDXNotificationType) {
  if (fDXNotificationType == null) {
    return [];
  }

  return fDXNotificationType
      .map((e) => enums.$FDXNotificationTypeMap[e]!)
      .toList();
}

List<enums.FDXNotificationType> fDXNotificationTypeListFromJson(
  List? fDXNotificationType, [
  List<enums.FDXNotificationType>? defaultValue,
]) {
  if (fDXNotificationType == null) {
    return defaultValue ?? [];
  }

  return fDXNotificationType
      .map((e) => fDXNotificationTypeFromJson(e.toString()))
      .toList();
}

List<enums.FDXNotificationType>? fDXNotificationTypeNullableListFromJson(
  List? fDXNotificationType, [
  List<enums.FDXNotificationType>? defaultValue,
]) {
  if (fDXNotificationType == null) {
    return defaultValue;
  }

  return fDXNotificationType
      .map((e) => fDXNotificationTypeFromJson(e.toString()))
      .toList();
}

String? fDXNotificationSeverityToJson(
    enums.FDXNotificationSeverity? fDXNotificationSeverity) {
  return enums.$FDXNotificationSeverityMap[fDXNotificationSeverity];
}

enums.FDXNotificationSeverity fDXNotificationSeverityFromJson(
  Object? fDXNotificationSeverity, [
  enums.FDXNotificationSeverity? defaultValue,
]) {
  if (fDXNotificationSeverity is String) {
    return enums.$FDXNotificationSeverityMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                fDXNotificationSeverity.toLowerCase(),
            orElse: () => const MapEntry(
                enums.FDXNotificationSeverity.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$FDXNotificationSeverityMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.FDXNotificationSeverity.swaggerGeneratedUnknown;
}

List<String> fDXNotificationSeverityListToJson(
    List<enums.FDXNotificationSeverity>? fDXNotificationSeverity) {
  if (fDXNotificationSeverity == null) {
    return [];
  }

  return fDXNotificationSeverity
      .map((e) => enums.$FDXNotificationSeverityMap[e]!)
      .toList();
}

List<enums.FDXNotificationSeverity> fDXNotificationSeverityListFromJson(
  List? fDXNotificationSeverity, [
  List<enums.FDXNotificationSeverity>? defaultValue,
]) {
  if (fDXNotificationSeverity == null) {
    return defaultValue ?? [];
  }

  return fDXNotificationSeverity
      .map((e) => fDXNotificationSeverityFromJson(e.toString()))
      .toList();
}

List<enums.FDXNotificationSeverity>?
    fDXNotificationSeverityNullableListFromJson(
  List? fDXNotificationSeverity, [
  List<enums.FDXNotificationSeverity>? defaultValue,
]) {
  if (fDXNotificationSeverity == null) {
    return defaultValue;
  }

  return fDXNotificationSeverity
      .map((e) => fDXNotificationSeverityFromJson(e.toString()))
      .toList();
}

String? fDXNotificationPriorityToJson(
    enums.FDXNotificationPriority? fDXNotificationPriority) {
  return enums.$FDXNotificationPriorityMap[fDXNotificationPriority];
}

enums.FDXNotificationPriority fDXNotificationPriorityFromJson(
  Object? fDXNotificationPriority, [
  enums.FDXNotificationPriority? defaultValue,
]) {
  if (fDXNotificationPriority is String) {
    return enums.$FDXNotificationPriorityMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                fDXNotificationPriority.toLowerCase(),
            orElse: () => const MapEntry(
                enums.FDXNotificationPriority.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$FDXNotificationPriorityMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.FDXNotificationPriority.swaggerGeneratedUnknown;
}

List<String> fDXNotificationPriorityListToJson(
    List<enums.FDXNotificationPriority>? fDXNotificationPriority) {
  if (fDXNotificationPriority == null) {
    return [];
  }

  return fDXNotificationPriority
      .map((e) => enums.$FDXNotificationPriorityMap[e]!)
      .toList();
}

List<enums.FDXNotificationPriority> fDXNotificationPriorityListFromJson(
  List? fDXNotificationPriority, [
  List<enums.FDXNotificationPriority>? defaultValue,
]) {
  if (fDXNotificationPriority == null) {
    return defaultValue ?? [];
  }

  return fDXNotificationPriority
      .map((e) => fDXNotificationPriorityFromJson(e.toString()))
      .toList();
}

List<enums.FDXNotificationPriority>?
    fDXNotificationPriorityNullableListFromJson(
  List? fDXNotificationPriority, [
  List<enums.FDXNotificationPriority>? defaultValue,
]) {
  if (fDXNotificationPriority == null) {
    return defaultValue;
  }

  return fDXNotificationPriority
      .map((e) => fDXNotificationPriorityFromJson(e.toString()))
      .toList();
}

String? fDXPartyTypeToJson(enums.FDXPartyType? fDXPartyType) {
  return enums.$FDXPartyTypeMap[fDXPartyType];
}

enums.FDXPartyType fDXPartyTypeFromJson(
  Object? fDXPartyType, [
  enums.FDXPartyType? defaultValue,
]) {
  if (fDXPartyType is String) {
    return enums.$FDXPartyTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == fDXPartyType.toLowerCase(),
            orElse: () =>
                const MapEntry(enums.FDXPartyType.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$FDXPartyTypeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.FDXPartyType.swaggerGeneratedUnknown;
}

List<String> fDXPartyTypeListToJson(List<enums.FDXPartyType>? fDXPartyType) {
  if (fDXPartyType == null) {
    return [];
  }

  return fDXPartyType.map((e) => enums.$FDXPartyTypeMap[e]!).toList();
}

List<enums.FDXPartyType> fDXPartyTypeListFromJson(
  List? fDXPartyType, [
  List<enums.FDXPartyType>? defaultValue,
]) {
  if (fDXPartyType == null) {
    return defaultValue ?? [];
  }

  return fDXPartyType.map((e) => fDXPartyTypeFromJson(e.toString())).toList();
}

List<enums.FDXPartyType>? fDXPartyTypeNullableListFromJson(
  List? fDXPartyType, [
  List<enums.FDXPartyType>? defaultValue,
]) {
  if (fDXPartyType == null) {
    return defaultValue;
  }

  return fDXPartyType.map((e) => fDXPartyTypeFromJson(e.toString())).toList();
}

String? fDXPartyRegistryToJson(enums.FDXPartyRegistry? fDXPartyRegistry) {
  return enums.$FDXPartyRegistryMap[fDXPartyRegistry];
}

enums.FDXPartyRegistry fDXPartyRegistryFromJson(
  Object? fDXPartyRegistry, [
  enums.FDXPartyRegistry? defaultValue,
]) {
  if (fDXPartyRegistry is String) {
    return enums.$FDXPartyRegistryMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == fDXPartyRegistry.toLowerCase(),
            orElse: () => const MapEntry(
                enums.FDXPartyRegistry.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$FDXPartyRegistryMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.FDXPartyRegistry.swaggerGeneratedUnknown;
}

List<String> fDXPartyRegistryListToJson(
    List<enums.FDXPartyRegistry>? fDXPartyRegistry) {
  if (fDXPartyRegistry == null) {
    return [];
  }

  return fDXPartyRegistry.map((e) => enums.$FDXPartyRegistryMap[e]!).toList();
}

List<enums.FDXPartyRegistry> fDXPartyRegistryListFromJson(
  List? fDXPartyRegistry, [
  List<enums.FDXPartyRegistry>? defaultValue,
]) {
  if (fDXPartyRegistry == null) {
    return defaultValue ?? [];
  }

  return fDXPartyRegistry
      .map((e) => fDXPartyRegistryFromJson(e.toString()))
      .toList();
}

List<enums.FDXPartyRegistry>? fDXPartyRegistryNullableListFromJson(
  List? fDXPartyRegistry, [
  List<enums.FDXPartyRegistry>? defaultValue,
]) {
  if (fDXPartyRegistry == null) {
    return defaultValue;
  }

  return fDXPartyRegistry
      .map((e) => fDXPartyRegistryFromJson(e.toString()))
      .toList();
}

String? fDXNotificationPayloadIdTypeToJson(
    enums.FDXNotificationPayloadIdType? fDXNotificationPayloadIdType) {
  return enums.$FDXNotificationPayloadIdTypeMap[fDXNotificationPayloadIdType];
}

enums.FDXNotificationPayloadIdType fDXNotificationPayloadIdTypeFromJson(
  Object? fDXNotificationPayloadIdType, [
  enums.FDXNotificationPayloadIdType? defaultValue,
]) {
  if (fDXNotificationPayloadIdType is String) {
    return enums.$FDXNotificationPayloadIdTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                fDXNotificationPayloadIdType.toLowerCase(),
            orElse: () => const MapEntry(
                enums.FDXNotificationPayloadIdType.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$FDXNotificationPayloadIdTypeMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.FDXNotificationPayloadIdType.swaggerGeneratedUnknown;
}

List<String> fDXNotificationPayloadIdTypeListToJson(
    List<enums.FDXNotificationPayloadIdType>? fDXNotificationPayloadIdType) {
  if (fDXNotificationPayloadIdType == null) {
    return [];
  }

  return fDXNotificationPayloadIdType
      .map((e) => enums.$FDXNotificationPayloadIdTypeMap[e]!)
      .toList();
}

List<enums.FDXNotificationPayloadIdType>
    fDXNotificationPayloadIdTypeListFromJson(
  List? fDXNotificationPayloadIdType, [
  List<enums.FDXNotificationPayloadIdType>? defaultValue,
]) {
  if (fDXNotificationPayloadIdType == null) {
    return defaultValue ?? [];
  }

  return fDXNotificationPayloadIdType
      .map((e) => fDXNotificationPayloadIdTypeFromJson(e.toString()))
      .toList();
}

List<enums.FDXNotificationPayloadIdType>?
    fDXNotificationPayloadIdTypeNullableListFromJson(
  List? fDXNotificationPayloadIdType, [
  List<enums.FDXNotificationPayloadIdType>? defaultValue,
]) {
  if (fDXNotificationPayloadIdType == null) {
    return defaultValue;
  }

  return fDXNotificationPayloadIdType
      .map((e) => fDXNotificationPayloadIdTypeFromJson(e.toString()))
      .toList();
}

String? fDXHateoasLinkActionToJson(
    enums.FDXHateoasLinkAction? fDXHateoasLinkAction) {
  return enums.$FDXHateoasLinkActionMap[fDXHateoasLinkAction];
}

enums.FDXHateoasLinkAction fDXHateoasLinkActionFromJson(
  Object? fDXHateoasLinkAction, [
  enums.FDXHateoasLinkAction? defaultValue,
]) {
  if (fDXHateoasLinkAction is String) {
    return enums.$FDXHateoasLinkActionMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                fDXHateoasLinkAction.toLowerCase(),
            orElse: () => const MapEntry(
                enums.FDXHateoasLinkAction.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$FDXHateoasLinkActionMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.FDXHateoasLinkAction.swaggerGeneratedUnknown;
}

List<String> fDXHateoasLinkActionListToJson(
    List<enums.FDXHateoasLinkAction>? fDXHateoasLinkAction) {
  if (fDXHateoasLinkAction == null) {
    return [];
  }

  return fDXHateoasLinkAction
      .map((e) => enums.$FDXHateoasLinkActionMap[e]!)
      .toList();
}

List<enums.FDXHateoasLinkAction> fDXHateoasLinkActionListFromJson(
  List? fDXHateoasLinkAction, [
  List<enums.FDXHateoasLinkAction>? defaultValue,
]) {
  if (fDXHateoasLinkAction == null) {
    return defaultValue ?? [];
  }

  return fDXHateoasLinkAction
      .map((e) => fDXHateoasLinkActionFromJson(e.toString()))
      .toList();
}

List<enums.FDXHateoasLinkAction>? fDXHateoasLinkActionNullableListFromJson(
  List? fDXHateoasLinkAction, [
  List<enums.FDXHateoasLinkAction>? defaultValue,
]) {
  if (fDXHateoasLinkAction == null) {
    return defaultValue;
  }

  return fDXHateoasLinkAction
      .map((e) => fDXHateoasLinkActionFromJson(e.toString()))
      .toList();
}

String? fDXContentTypesToJson(enums.FDXContentTypes? fDXContentTypes) {
  return enums.$FDXContentTypesMap[fDXContentTypes];
}

enums.FDXContentTypes fDXContentTypesFromJson(
  Object? fDXContentTypes, [
  enums.FDXContentTypes? defaultValue,
]) {
  if (fDXContentTypes is String) {
    return enums.$FDXContentTypesMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == fDXContentTypes.toLowerCase(),
            orElse: () => const MapEntry(
                enums.FDXContentTypes.swaggerGeneratedUnknown, ''))
        .key;
  }

  final parsedResult = defaultValue == null
      ? null
      : enums.$FDXContentTypesMap.entries
          .firstWhereOrNull((element) => element.value == defaultValue)
          ?.key;

  return parsedResult ??
      defaultValue ??
      enums.FDXContentTypes.swaggerGeneratedUnknown;
}

List<String> fDXContentTypesListToJson(
    List<enums.FDXContentTypes>? fDXContentTypes) {
  if (fDXContentTypes == null) {
    return [];
  }

  return fDXContentTypes.map((e) => enums.$FDXContentTypesMap[e]!).toList();
}

List<enums.FDXContentTypes> fDXContentTypesListFromJson(
  List? fDXContentTypes, [
  List<enums.FDXContentTypes>? defaultValue,
]) {
  if (fDXContentTypes == null) {
    return defaultValue ?? [];
  }

  return fDXContentTypes
      .map((e) => fDXContentTypesFromJson(e.toString()))
      .toList();
}

List<enums.FDXContentTypes>? fDXContentTypesNullableListFromJson(
  List? fDXContentTypes, [
  List<enums.FDXContentTypes>? defaultValue,
]) {
  if (fDXContentTypes == null) {
    return defaultValue;
  }

  return fDXContentTypes
      .map((e) => fDXContentTypesFromJson(e.toString()))
      .toList();
}

typedef $JsonFactory<T> = T Function(Map<String, dynamic> json);

class $CustomJsonDecoder {
  $CustomJsonDecoder(this.factories);

  final Map<Type, $JsonFactory> factories;

  dynamic decode<T>(dynamic entity) {
    if (entity is Iterable) {
      return _decodeList<T>(entity);
    }

    if (entity is T) {
      return entity;
    }

    if (isTypeOf<T, Map>()) {
      return entity;
    }

    if (isTypeOf<T, Iterable>()) {
      return entity;
    }

    if (entity is Map<String, dynamic>) {
      return _decodeMap<T>(entity);
    }

    return entity;
  }

  T _decodeMap<T>(Map<String, dynamic> values) {
    final jsonFactory = factories[T];
    if (jsonFactory == null || jsonFactory is! $JsonFactory<T>) {
      return throw "Could not find factory for type $T. Is '$T: $T.fromJsonFactory' included in the CustomJsonDecoder instance creation in bootstrapper.dart?";
    }

    return jsonFactory(values);
  }

  List<T> _decodeList<T>(Iterable values) =>
      values.where((v) => v != null).map<T>((v) => decode<T>(v) as T).toList();
}

class $JsonSerializableConverter extends chopper.JsonConverter {
  @override
  FutureOr<chopper.Response<ResultType>> convertResponse<ResultType, Item>(
      chopper.Response response) async {
    if (response.bodyString.isEmpty) {
      // In rare cases, when let's say 204 (no content) is returned -
      // we cannot decode the missing json with the result type specified
      return chopper.Response(response.base, null, error: response.error);
    }

    final jsonRes = await super.convertResponse(response);
    return jsonRes.copyWith<ResultType>(
        body: $jsonDecoder.decode<Item>(jsonRes.body) as ResultType);
  }
}

final $jsonDecoder = $CustomJsonDecoder(generatedMapping);

// ignore: unused_element
String? _dateToJson(DateTime? date) {
  if (date == null) {
    return null;
  }

  final year = date.year.toString();
  final month = date.month < 10 ? '0${date.month}' : date.month.toString();
  final day = date.day < 10 ? '0${date.day}' : date.day.toString();

  return '$year-$month-$day';
}

class Wrapped<T> {
  final T value;
  const Wrapped.value(this.value);
}
