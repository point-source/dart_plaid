import 'package:json_annotation/json_annotation.dart';
import 'package:collection/collection.dart';

import 'package:chopper/chopper.dart';
import 'client_mapping.dart';
import 'package:chopper/chopper.dart' as chopper;
import 'plaid_service.enums.swagger.dart' as enums;
export 'plaid_service.enums.swagger.dart';

part 'plaid_service.swagger.chopper.dart';
part 'plaid_service.swagger.g.dart';

// **************************************************************************
// SwaggerChopperGenerator
// **************************************************************************

@ChopperApi()
abstract class PlaidService extends ChopperService {
  static PlaidService create({ChopperClient? client, String? baseUrl}) {
    if (client != null) {
      return _$PlaidService(client);
    }

    final newClient = ChopperClient(
        services: [_$PlaidService()],
        converter: $JsonSerializableConverter(),
        baseUrl: baseUrl ?? 'http://');
    return _$PlaidService(newClient);
  }

  ///List a user’s connected applications
  Future<chopper.Response<ItemApplicationListResponse>> itemApplicationListPost(
      {required ItemApplicationListRequest? body}) {
    generatedMapping.putIfAbsent(ItemApplicationListResponse,
        () => ItemApplicationListResponse.fromJsonFactory);

    return _itemApplicationListPost(body: body);
  }

  ///List a user’s connected applications
  @Post(path: '/item/application/list')
  Future<chopper.Response<ItemApplicationListResponse>>
      _itemApplicationListPost(
          {@Body() required ItemApplicationListRequest? body});

  ///Update the scopes of access for a particular application
  Future<chopper.Response<ItemApplicationScopesUpdateResponse>>
      itemApplicationScopesUpdatePost(
          {required ItemApplicationScopesUpdateRequest? body}) {
    generatedMapping.putIfAbsent(ItemApplicationScopesUpdateResponse,
        () => ItemApplicationScopesUpdateResponse.fromJsonFactory);

    return _itemApplicationScopesUpdatePost(body: body);
  }

  ///Update the scopes of access for a particular application
  @Post(path: '/item/application/scopes/update')
  Future<chopper.Response<ItemApplicationScopesUpdateResponse>>
      _itemApplicationScopesUpdatePost(
          {@Body() required ItemApplicationScopesUpdateRequest? body});

  ///Retrieve information about a Plaid application
  Future<chopper.Response<ApplicationGetResponse>> applicationGetPost(
      {required ApplicationGetRequest? body}) {
    generatedMapping.putIfAbsent(
        ApplicationGetResponse, () => ApplicationGetResponse.fromJsonFactory);

    return _applicationGetPost(body: body);
  }

  ///Retrieve information about a Plaid application
  @Post(path: '/application/get')
  Future<chopper.Response<ApplicationGetResponse>> _applicationGetPost(
      {@Body() required ApplicationGetRequest? body});

  ///Retrieve an Item
  Future<chopper.Response<ItemGetResponse>> itemGetPost(
      {required ItemGetRequest? body}) {
    generatedMapping.putIfAbsent(
        ItemGetResponse, () => ItemGetResponse.fromJsonFactory);

    return _itemGetPost(body: body);
  }

  ///Retrieve an Item
  @Post(path: '/item/get')
  Future<chopper.Response<ItemGetResponse>> _itemGetPost(
      {@Body() required ItemGetRequest? body});

  ///Retrieve auth data
  Future<chopper.Response<AuthGetResponse>> authGetPost(
      {required AuthGetRequest? body}) {
    generatedMapping.putIfAbsent(
        AuthGetResponse, () => AuthGetResponse.fromJsonFactory);

    return _authGetPost(body: body);
  }

  ///Retrieve auth data
  @Post(path: '/auth/get')
  Future<chopper.Response<AuthGetResponse>> _authGetPost(
      {@Body() required AuthGetRequest? body});

  ///Get transaction data
  Future<chopper.Response<TransactionsGetResponse>> transactionsGetPost(
      {required TransactionsGetRequest? body}) {
    generatedMapping.putIfAbsent(
        TransactionsGetResponse, () => TransactionsGetResponse.fromJsonFactory);

    return _transactionsGetPost(body: body);
  }

  ///Get transaction data
  @Post(path: '/transactions/get')
  Future<chopper.Response<TransactionsGetResponse>> _transactionsGetPost(
      {@Body() required TransactionsGetRequest? body});

  ///Refresh transaction data
  Future<chopper.Response<TransactionsRefreshResponse>> transactionsRefreshPost(
      {required TransactionsRefreshRequest? body}) {
    generatedMapping.putIfAbsent(TransactionsRefreshResponse,
        () => TransactionsRefreshResponse.fromJsonFactory);

    return _transactionsRefreshPost(body: body);
  }

  ///Refresh transaction data
  @Post(path: '/transactions/refresh')
  Future<chopper.Response<TransactionsRefreshResponse>>
      _transactionsRefreshPost(
          {@Body() required TransactionsRefreshRequest? body});

  ///Get streams of recurring transactions
  Future<chopper.Response<TransactionsRecurringGetResponse>>
      transactionsRecurringGetPost(
          {required TransactionsRecurringGetRequest? body}) {
    generatedMapping.putIfAbsent(TransactionsRecurringGetResponse,
        () => TransactionsRecurringGetResponse.fromJsonFactory);

    return _transactionsRecurringGetPost(body: body);
  }

  ///Get streams of recurring transactions
  @Post(path: '/transactions/recurring/get')
  Future<chopper.Response<TransactionsRecurringGetResponse>>
      _transactionsRecurringGetPost(
          {@Body() required TransactionsRecurringGetRequest? body});

  ///Get incremental transaction updates on an item
  Future<chopper.Response<TransactionsSyncResponse>> transactionsSyncPost(
      {required TransactionsSyncRequest? body}) {
    generatedMapping.putIfAbsent(TransactionsSyncResponse,
        () => TransactionsSyncResponse.fromJsonFactory);

    return _transactionsSyncPost(body: body);
  }

  ///Get incremental transaction updates on an item
  @Post(path: '/transactions/sync')
  Future<chopper.Response<TransactionsSyncResponse>> _transactionsSyncPost(
      {@Body() required TransactionsSyncRequest? body});

  ///Get details of all supported institutions
  Future<chopper.Response<InstitutionsGetResponse>> institutionsGetPost(
      {required InstitutionsGetRequest? body}) {
    generatedMapping.putIfAbsent(
        InstitutionsGetResponse, () => InstitutionsGetResponse.fromJsonFactory);

    return _institutionsGetPost(body: body);
  }

  ///Get details of all supported institutions
  @Post(path: '/institutions/get')
  Future<chopper.Response<InstitutionsGetResponse>> _institutionsGetPost(
      {@Body() required InstitutionsGetRequest? body});

  ///Search institutions
  Future<chopper.Response<InstitutionsSearchResponse>> institutionsSearchPost(
      {required InstitutionsSearchRequest? body}) {
    generatedMapping.putIfAbsent(InstitutionsSearchResponse,
        () => InstitutionsSearchResponse.fromJsonFactory);

    return _institutionsSearchPost(body: body);
  }

  ///Search institutions
  @Post(path: '/institutions/search')
  Future<chopper.Response<InstitutionsSearchResponse>> _institutionsSearchPost(
      {@Body() required InstitutionsSearchRequest? body});

  ///Get details of an institution
  Future<chopper.Response<InstitutionsGetByIdResponse>> institutionsGetByIdPost(
      {required InstitutionsGetByIdRequest? body}) {
    generatedMapping.putIfAbsent(InstitutionsGetByIdResponse,
        () => InstitutionsGetByIdResponse.fromJsonFactory);

    return _institutionsGetByIdPost(body: body);
  }

  ///Get details of an institution
  @Post(path: '/institutions/get_by_id')
  Future<chopper.Response<InstitutionsGetByIdResponse>>
      _institutionsGetByIdPost(
          {@Body() required InstitutionsGetByIdRequest? body});

  ///Remove an Item
  Future<chopper.Response<ItemRemoveResponse>> itemRemovePost(
      {required ItemRemoveRequest? body}) {
    generatedMapping.putIfAbsent(
        ItemRemoveResponse, () => ItemRemoveResponse.fromJsonFactory);

    return _itemRemovePost(body: body);
  }

  ///Remove an Item
  @Post(path: '/item/remove')
  Future<chopper.Response<ItemRemoveResponse>> _itemRemovePost(
      {@Body() required ItemRemoveRequest? body});

  ///Retrieve accounts
  Future<chopper.Response<AccountsGetResponse>> accountsGetPost(
      {required AccountsGetRequest? body}) {
    generatedMapping.putIfAbsent(
        AccountsGetResponse, () => AccountsGetResponse.fromJsonFactory);

    return _accountsGetPost(body: body);
  }

  ///Retrieve accounts
  @Post(path: '/accounts/get')
  Future<chopper.Response<AccountsGetResponse>> _accountsGetPost(
      {@Body() required AccountsGetRequest? body});

  ///Get Categories
  Future<chopper.Response<CategoriesGetResponse>> categoriesGetPost(
      {required CategoriesGetRequest? body}) {
    generatedMapping.putIfAbsent(
        CategoriesGetResponse, () => CategoriesGetResponse.fromJsonFactory);

    return _categoriesGetPost(body: body);
  }

  ///Get Categories
  @Post(path: '/categories/get')
  Future<chopper.Response<CategoriesGetResponse>> _categoriesGetPost(
      {@Body() required CategoriesGetRequest? body});

  ///Create a test Item and processor token
  Future<chopper.Response<SandboxProcessorTokenCreateResponse>>
      sandboxProcessorTokenCreatePost(
          {required SandboxProcessorTokenCreateRequest? body}) {
    generatedMapping.putIfAbsent(SandboxProcessorTokenCreateResponse,
        () => SandboxProcessorTokenCreateResponse.fromJsonFactory);

    return _sandboxProcessorTokenCreatePost(body: body);
  }

  ///Create a test Item and processor token
  @Post(path: '/sandbox/processor_token/create')
  Future<chopper.Response<SandboxProcessorTokenCreateResponse>>
      _sandboxProcessorTokenCreatePost(
          {@Body() required SandboxProcessorTokenCreateRequest? body});

  ///Create a test Item
  Future<chopper.Response<SandboxPublicTokenCreateResponse>>
      sandboxPublicTokenCreatePost(
          {required SandboxPublicTokenCreateRequest? body}) {
    generatedMapping.putIfAbsent(SandboxPublicTokenCreateResponse,
        () => SandboxPublicTokenCreateResponse.fromJsonFactory);

    return _sandboxPublicTokenCreatePost(body: body);
  }

  ///Create a test Item
  @Post(path: '/sandbox/public_token/create')
  Future<chopper.Response<SandboxPublicTokenCreateResponse>>
      _sandboxPublicTokenCreatePost(
          {@Body() required SandboxPublicTokenCreateRequest? body});

  ///Fire a test webhook
  Future<chopper.Response<SandboxItemFireWebhookResponse>>
      sandboxItemFireWebhookPost(
          {required SandboxItemFireWebhookRequest? body}) {
    generatedMapping.putIfAbsent(SandboxItemFireWebhookResponse,
        () => SandboxItemFireWebhookResponse.fromJsonFactory);

    return _sandboxItemFireWebhookPost(body: body);
  }

  ///Fire a test webhook
  @Post(path: '/sandbox/item/fire_webhook')
  Future<chopper.Response<SandboxItemFireWebhookResponse>>
      _sandboxItemFireWebhookPost(
          {@Body() required SandboxItemFireWebhookRequest? body});

  ///Retrieve real-time balance data
  Future<chopper.Response<AccountsGetResponse>> accountsBalanceGetPost(
      {required AccountsBalanceGetRequest? body}) {
    generatedMapping.putIfAbsent(
        AccountsGetResponse, () => AccountsGetResponse.fromJsonFactory);

    return _accountsBalanceGetPost(body: body);
  }

  ///Retrieve real-time balance data
  @Post(path: '/accounts/balance/get')
  Future<chopper.Response<AccountsGetResponse>> _accountsBalanceGetPost(
      {@Body() required AccountsBalanceGetRequest? body});

  ///Retrieve identity data
  Future<chopper.Response<IdentityGetResponse>> identityGetPost(
      {required IdentityGetRequest? body}) {
    generatedMapping.putIfAbsent(
        IdentityGetResponse, () => IdentityGetResponse.fromJsonFactory);

    return _identityGetPost(body: body);
  }

  ///Retrieve identity data
  @Post(path: '/identity/get')
  Future<chopper.Response<IdentityGetResponse>> _identityGetPost(
      {@Body() required IdentityGetRequest? body});

  ///Retrieve Auth data
  Future<chopper.Response<ProcessorAuthGetResponse>> processorAuthGetPost(
      {required ProcessorAuthGetRequest? body}) {
    generatedMapping.putIfAbsent(ProcessorAuthGetResponse,
        () => ProcessorAuthGetResponse.fromJsonFactory);

    return _processorAuthGetPost(body: body);
  }

  ///Retrieve Auth data
  @Post(path: '/processor/auth/get')
  Future<chopper.Response<ProcessorAuthGetResponse>> _processorAuthGetPost(
      {@Body() required ProcessorAuthGetRequest? body});

  ///Create a bank transfer as a processor
  Future<chopper.Response<ProcessorBankTransferCreateResponse>>
      processorBankTransferCreatePost(
          {required ProcessorBankTransferCreateRequest? body}) {
    generatedMapping.putIfAbsent(ProcessorBankTransferCreateResponse,
        () => ProcessorBankTransferCreateResponse.fromJsonFactory);

    return _processorBankTransferCreatePost(body: body);
  }

  ///Create a bank transfer as a processor
  @Post(path: '/processor/bank_transfer/create')
  Future<chopper.Response<ProcessorBankTransferCreateResponse>>
      _processorBankTransferCreatePost(
          {@Body() required ProcessorBankTransferCreateRequest? body});

  ///Retrieve Identity data
  Future<chopper.Response<ProcessorIdentityGetResponse>>
      processorIdentityGetPost({required ProcessorIdentityGetRequest? body}) {
    generatedMapping.putIfAbsent(ProcessorIdentityGetResponse,
        () => ProcessorIdentityGetResponse.fromJsonFactory);

    return _processorIdentityGetPost(body: body);
  }

  ///Retrieve Identity data
  @Post(path: '/processor/identity/get')
  Future<chopper.Response<ProcessorIdentityGetResponse>>
      _processorIdentityGetPost(
          {@Body() required ProcessorIdentityGetRequest? body});

  ///Retrieve Balance data
  Future<chopper.Response<ProcessorBalanceGetResponse>> processorBalanceGetPost(
      {required ProcessorBalanceGetRequest? body}) {
    generatedMapping.putIfAbsent(ProcessorBalanceGetResponse,
        () => ProcessorBalanceGetResponse.fromJsonFactory);

    return _processorBalanceGetPost(body: body);
  }

  ///Retrieve Balance data
  @Post(path: '/processor/balance/get')
  Future<chopper.Response<ProcessorBalanceGetResponse>>
      _processorBalanceGetPost(
          {@Body() required ProcessorBalanceGetRequest? body});

  ///Update Webhook URL
  Future<chopper.Response<ItemWebhookUpdateResponse>> itemWebhookUpdatePost(
      {required ItemWebhookUpdateRequest? body}) {
    generatedMapping.putIfAbsent(ItemWebhookUpdateResponse,
        () => ItemWebhookUpdateResponse.fromJsonFactory);

    return _itemWebhookUpdatePost(body: body);
  }

  ///Update Webhook URL
  @Post(path: '/item/webhook/update')
  Future<chopper.Response<ItemWebhookUpdateResponse>> _itemWebhookUpdatePost(
      {@Body() required ItemWebhookUpdateRequest? body});

  ///Invalidate access_token
  Future<chopper.Response<ItemAccessTokenInvalidateResponse>>
      itemAccessTokenInvalidatePost(
          {required ItemAccessTokenInvalidateRequest? body}) {
    generatedMapping.putIfAbsent(ItemAccessTokenInvalidateResponse,
        () => ItemAccessTokenInvalidateResponse.fromJsonFactory);

    return _itemAccessTokenInvalidatePost(body: body);
  }

  ///Invalidate access_token
  @Post(path: '/item/access_token/invalidate')
  Future<chopper.Response<ItemAccessTokenInvalidateResponse>>
      _itemAccessTokenInvalidatePost(
          {@Body() required ItemAccessTokenInvalidateRequest? body});

  ///Get webhook verification key
  Future<chopper.Response<WebhookVerificationKeyGetResponse>>
      webhookVerificationKeyGetPost(
          {required WebhookVerificationKeyGetRequest? body}) {
    generatedMapping.putIfAbsent(WebhookVerificationKeyGetResponse,
        () => WebhookVerificationKeyGetResponse.fromJsonFactory);

    return _webhookVerificationKeyGetPost(body: body);
  }

  ///Get webhook verification key
  @Post(path: '/webhook_verification_key/get')
  Future<chopper.Response<WebhookVerificationKeyGetResponse>>
      _webhookVerificationKeyGetPost(
          {@Body() required WebhookVerificationKeyGetRequest? body});

  ///Retrieve Liabilities data
  Future<chopper.Response<LiabilitiesGetResponse>> liabilitiesGetPost(
      {required LiabilitiesGetRequest? body}) {
    generatedMapping.putIfAbsent(
        LiabilitiesGetResponse, () => LiabilitiesGetResponse.fromJsonFactory);

    return _liabilitiesGetPost(body: body);
  }

  ///Retrieve Liabilities data
  @Post(path: '/liabilities/get')
  Future<chopper.Response<LiabilitiesGetResponse>> _liabilitiesGetPost(
      {@Body() required LiabilitiesGetRequest? body});

  ///Create payment recipient
  Future<chopper.Response<PaymentInitiationRecipientCreateResponse>>
      paymentInitiationRecipientCreatePost(
          {required PaymentInitiationRecipientCreateRequest? body}) {
    generatedMapping.putIfAbsent(PaymentInitiationRecipientCreateResponse,
        () => PaymentInitiationRecipientCreateResponse.fromJsonFactory);

    return _paymentInitiationRecipientCreatePost(body: body);
  }

  ///Create payment recipient
  @Post(path: '/payment_initiation/recipient/create')
  Future<chopper.Response<PaymentInitiationRecipientCreateResponse>>
      _paymentInitiationRecipientCreatePost(
          {@Body() required PaymentInitiationRecipientCreateRequest? body});

  ///Reverse an existing payment
  Future<chopper.Response<PaymentInitiationPaymentReverseResponse>>
      paymentInitiationPaymentReversePost(
          {required PaymentInitiationPaymentReverseRequest? body}) {
    generatedMapping.putIfAbsent(PaymentInitiationPaymentReverseResponse,
        () => PaymentInitiationPaymentReverseResponse.fromJsonFactory);

    return _paymentInitiationPaymentReversePost(body: body);
  }

  ///Reverse an existing payment
  @Post(path: '/payment_initiation/payment/reverse')
  Future<chopper.Response<PaymentInitiationPaymentReverseResponse>>
      _paymentInitiationPaymentReversePost(
          {@Body() required PaymentInitiationPaymentReverseRequest? body});

  ///Get payment recipient
  Future<chopper.Response<PaymentInitiationRecipientGetResponse>>
      paymentInitiationRecipientGetPost(
          {required PaymentInitiationRecipientGetRequest? body}) {
    generatedMapping.putIfAbsent(PaymentInitiationRecipientGetResponse,
        () => PaymentInitiationRecipientGetResponse.fromJsonFactory);

    return _paymentInitiationRecipientGetPost(body: body);
  }

  ///Get payment recipient
  @Post(path: '/payment_initiation/recipient/get')
  Future<chopper.Response<PaymentInitiationRecipientGetResponse>>
      _paymentInitiationRecipientGetPost(
          {@Body() required PaymentInitiationRecipientGetRequest? body});

  ///List payment recipients
  Future<chopper.Response<PaymentInitiationRecipientListResponse>>
      paymentInitiationRecipientListPost(
          {required PaymentInitiationRecipientListRequest? body}) {
    generatedMapping.putIfAbsent(PaymentInitiationRecipientListResponse,
        () => PaymentInitiationRecipientListResponse.fromJsonFactory);

    return _paymentInitiationRecipientListPost(body: body);
  }

  ///List payment recipients
  @Post(path: '/payment_initiation/recipient/list')
  Future<chopper.Response<PaymentInitiationRecipientListResponse>>
      _paymentInitiationRecipientListPost(
          {@Body() required PaymentInitiationRecipientListRequest? body});

  ///Create a payment
  Future<chopper.Response<PaymentInitiationPaymentCreateResponse>>
      paymentInitiationPaymentCreatePost(
          {required PaymentInitiationPaymentCreateRequest? body}) {
    generatedMapping.putIfAbsent(PaymentInitiationPaymentCreateResponse,
        () => PaymentInitiationPaymentCreateResponse.fromJsonFactory);

    return _paymentInitiationPaymentCreatePost(body: body);
  }

  ///Create a payment
  @Post(path: '/payment_initiation/payment/create')
  Future<chopper.Response<PaymentInitiationPaymentCreateResponse>>
      _paymentInitiationPaymentCreatePost(
          {@Body() required PaymentInitiationPaymentCreateRequest? body});

  ///Create payment token
  Future<chopper.Response<PaymentInitiationPaymentTokenCreateResponse>>
      paymentInitiationPaymentTokenCreatePost(
          {required PaymentInitiationPaymentTokenCreateRequest? body}) {
    generatedMapping.putIfAbsent(PaymentInitiationPaymentTokenCreateResponse,
        () => PaymentInitiationPaymentTokenCreateResponse.fromJsonFactory);

    return _paymentInitiationPaymentTokenCreatePost(body: body);
  }

  ///Create payment token
  @Post(path: '/payment_initiation/payment/token/create')
  Future<chopper.Response<PaymentInitiationPaymentTokenCreateResponse>>
      _paymentInitiationPaymentTokenCreatePost(
          {@Body() required PaymentInitiationPaymentTokenCreateRequest? body});

  ///Force a Sandbox Item into an error state
  Future<chopper.Response<SandboxItemResetLoginResponse>>
      sandboxItemResetLoginPost({required SandboxItemResetLoginRequest? body}) {
    generatedMapping.putIfAbsent(SandboxItemResetLoginResponse,
        () => SandboxItemResetLoginResponse.fromJsonFactory);

    return _sandboxItemResetLoginPost(body: body);
  }

  ///Force a Sandbox Item into an error state
  @Post(path: '/sandbox/item/reset_login')
  Future<chopper.Response<SandboxItemResetLoginResponse>>
      _sandboxItemResetLoginPost(
          {@Body() required SandboxItemResetLoginRequest? body});

  ///Set verification status for Sandbox account
  Future<chopper.Response<SandboxItemSetVerificationStatusResponse>>
      sandboxItemSetVerificationStatusPost(
          {required SandboxItemSetVerificationStatusRequest? body}) {
    generatedMapping.putIfAbsent(SandboxItemSetVerificationStatusResponse,
        () => SandboxItemSetVerificationStatusResponse.fromJsonFactory);

    return _sandboxItemSetVerificationStatusPost(body: body);
  }

  ///Set verification status for Sandbox account
  @Post(path: '/sandbox/item/set_verification_status')
  Future<chopper.Response<SandboxItemSetVerificationStatusResponse>>
      _sandboxItemSetVerificationStatusPost(
          {@Body() required SandboxItemSetVerificationStatusRequest? body});

  ///Exchange public token for an access token
  Future<chopper.Response<ItemPublicTokenExchangeResponse>>
      itemPublicTokenExchangePost(
          {required ItemPublicTokenExchangeRequest? body}) {
    generatedMapping.putIfAbsent(ItemPublicTokenExchangeResponse,
        () => ItemPublicTokenExchangeResponse.fromJsonFactory);

    return _itemPublicTokenExchangePost(body: body);
  }

  ///Exchange public token for an access token
  @Post(path: '/item/public_token/exchange')
  Future<chopper.Response<ItemPublicTokenExchangeResponse>>
      _itemPublicTokenExchangePost(
          {@Body() required ItemPublicTokenExchangeRequest? body});

  ///Create public token
  Future<chopper.Response<ItemPublicTokenCreateResponse>>
      itemPublicTokenCreatePost({required ItemPublicTokenCreateRequest? body}) {
    generatedMapping.putIfAbsent(ItemPublicTokenCreateResponse,
        () => ItemPublicTokenCreateResponse.fromJsonFactory);

    return _itemPublicTokenCreatePost(body: body);
  }

  ///Create public token
  @Post(path: '/item/public_token/create')
  Future<chopper.Response<ItemPublicTokenCreateResponse>>
      _itemPublicTokenCreatePost(
          {@Body() required ItemPublicTokenCreateRequest? body});

  ///Get payment details
  Future<chopper.Response<PaymentInitiationPaymentGetResponse>>
      paymentInitiationPaymentGetPost(
          {required PaymentInitiationPaymentGetRequest? body}) {
    generatedMapping.putIfAbsent(PaymentInitiationPaymentGetResponse,
        () => PaymentInitiationPaymentGetResponse.fromJsonFactory);

    return _paymentInitiationPaymentGetPost(body: body);
  }

  ///Get payment details
  @Post(path: '/payment_initiation/payment/get')
  Future<chopper.Response<PaymentInitiationPaymentGetResponse>>
      _paymentInitiationPaymentGetPost(
          {@Body() required PaymentInitiationPaymentGetRequest? body});

  ///List payments
  Future<chopper.Response<PaymentInitiationPaymentListResponse>>
      paymentInitiationPaymentListPost(
          {required PaymentInitiationPaymentListRequest? body}) {
    generatedMapping.putIfAbsent(PaymentInitiationPaymentListResponse,
        () => PaymentInitiationPaymentListResponse.fromJsonFactory);

    return _paymentInitiationPaymentListPost(body: body);
  }

  ///List payments
  @Post(path: '/payment_initiation/payment/list')
  Future<chopper.Response<PaymentInitiationPaymentListResponse>>
      _paymentInitiationPaymentListPost(
          {@Body() required PaymentInitiationPaymentListRequest? body});

  ///Create an Asset Report
  Future<chopper.Response<AssetReportCreateResponse>> assetReportCreatePost(
      {required AssetReportCreateRequest? body}) {
    generatedMapping.putIfAbsent(AssetReportCreateResponse,
        () => AssetReportCreateResponse.fromJsonFactory);

    return _assetReportCreatePost(body: body);
  }

  ///Create an Asset Report
  @Post(path: '/asset_report/create')
  Future<chopper.Response<AssetReportCreateResponse>> _assetReportCreatePost(
      {@Body() required AssetReportCreateRequest? body});

  ///Refresh an Asset Report
  Future<chopper.Response<AssetReportRefreshResponse>> assetReportRefreshPost(
      {required AssetReportRefreshRequest? body}) {
    generatedMapping.putIfAbsent(AssetReportRefreshResponse,
        () => AssetReportRefreshResponse.fromJsonFactory);

    return _assetReportRefreshPost(body: body);
  }

  ///Refresh an Asset Report
  @Post(path: '/asset_report/refresh')
  Future<chopper.Response<AssetReportRefreshResponse>> _assetReportRefreshPost(
      {@Body() required AssetReportRefreshRequest? body});

  ///Delete an Asset Report
  Future<chopper.Response<AssetReportRemoveResponse>> assetReportRemovePost(
      {required AssetReportRemoveRequest? body}) {
    generatedMapping.putIfAbsent(AssetReportRemoveResponse,
        () => AssetReportRemoveResponse.fromJsonFactory);

    return _assetReportRemovePost(body: body);
  }

  ///Delete an Asset Report
  @Post(path: '/asset_report/remove')
  Future<chopper.Response<AssetReportRemoveResponse>> _assetReportRemovePost(
      {@Body() required AssetReportRemoveRequest? body});

  ///Filter Asset Report
  Future<chopper.Response<AssetReportFilterResponse>> assetReportFilterPost(
      {required AssetReportFilterRequest? body}) {
    generatedMapping.putIfAbsent(AssetReportFilterResponse,
        () => AssetReportFilterResponse.fromJsonFactory);

    return _assetReportFilterPost(body: body);
  }

  ///Filter Asset Report
  @Post(path: '/asset_report/filter')
  Future<chopper.Response<AssetReportFilterResponse>> _assetReportFilterPost(
      {@Body() required AssetReportFilterRequest? body});

  ///Retrieve an Asset Report
  Future<chopper.Response<AssetReportGetResponse>> assetReportGetPost(
      {required AssetReportGetRequest? body}) {
    generatedMapping.putIfAbsent(
        AssetReportGetResponse, () => AssetReportGetResponse.fromJsonFactory);

    return _assetReportGetPost(body: body);
  }

  ///Retrieve an Asset Report
  @Post(path: '/asset_report/get')
  Future<chopper.Response<AssetReportGetResponse>> _assetReportGetPost(
      {@Body() required AssetReportGetRequest? body});

  ///Retrieve a PDF Asset Report
  Future<chopper.Response<Object>> assetReportPdfGetPost(
      {required AssetReportPDFGetRequest? body}) {
    return _assetReportPdfGetPost(body: body);
  }

  ///Retrieve a PDF Asset Report
  @Post(path: '/asset_report/pdf/get')
  Future<chopper.Response<Object>> _assetReportPdfGetPost(
      {@Body() required AssetReportPDFGetRequest? body});

  ///Create Asset Report Audit Copy
  Future<chopper.Response<AssetReportAuditCopyCreateResponse>>
      assetReportAuditCopyCreatePost(
          {required AssetReportAuditCopyCreateRequest? body}) {
    generatedMapping.putIfAbsent(AssetReportAuditCopyCreateResponse,
        () => AssetReportAuditCopyCreateResponse.fromJsonFactory);

    return _assetReportAuditCopyCreatePost(body: body);
  }

  ///Create Asset Report Audit Copy
  @Post(path: '/asset_report/audit_copy/create')
  Future<chopper.Response<AssetReportAuditCopyCreateResponse>>
      _assetReportAuditCopyCreatePost(
          {@Body() required AssetReportAuditCopyCreateRequest? body});

  ///Remove Asset Report Audit Copy
  Future<chopper.Response<AssetReportAuditCopyRemoveResponse>>
      assetReportAuditCopyRemovePost(
          {required AssetReportAuditCopyRemoveRequest? body}) {
    generatedMapping.putIfAbsent(AssetReportAuditCopyRemoveResponse,
        () => AssetReportAuditCopyRemoveResponse.fromJsonFactory);

    return _assetReportAuditCopyRemovePost(body: body);
  }

  ///Remove Asset Report Audit Copy
  @Post(path: '/asset_report/audit_copy/remove')
  Future<chopper.Response<AssetReportAuditCopyRemoveResponse>>
      _assetReportAuditCopyRemovePost(
          {@Body() required AssetReportAuditCopyRemoveRequest? body});

  ///Get Investment holdings
  Future<chopper.Response<InvestmentsHoldingsGetResponse>>
      investmentsHoldingsGetPost(
          {required InvestmentsHoldingsGetRequest? body}) {
    generatedMapping.putIfAbsent(InvestmentsHoldingsGetResponse,
        () => InvestmentsHoldingsGetResponse.fromJsonFactory);

    return _investmentsHoldingsGetPost(body: body);
  }

  ///Get Investment holdings
  @Post(path: '/investments/holdings/get')
  Future<chopper.Response<InvestmentsHoldingsGetResponse>>
      _investmentsHoldingsGetPost(
          {@Body() required InvestmentsHoldingsGetRequest? body});

  ///Get investment transactions
  Future<chopper.Response<InvestmentsTransactionsGetResponse>>
      investmentsTransactionsGetPost(
          {required InvestmentsTransactionsGetRequest? body}) {
    generatedMapping.putIfAbsent(InvestmentsTransactionsGetResponse,
        () => InvestmentsTransactionsGetResponse.fromJsonFactory);

    return _investmentsTransactionsGetPost(body: body);
  }

  ///Get investment transactions
  @Post(path: '/investments/transactions/get')
  Future<chopper.Response<InvestmentsTransactionsGetResponse>>
      _investmentsTransactionsGetPost(
          {@Body() required InvestmentsTransactionsGetRequest? body});

  ///Create processor token
  Future<chopper.Response<ProcessorTokenCreateResponse>>
      processorTokenCreatePost({required ProcessorTokenCreateRequest? body}) {
    generatedMapping.putIfAbsent(ProcessorTokenCreateResponse,
        () => ProcessorTokenCreateResponse.fromJsonFactory);

    return _processorTokenCreatePost(body: body);
  }

  ///Create processor token
  @Post(path: '/processor/token/create')
  Future<chopper.Response<ProcessorTokenCreateResponse>>
      _processorTokenCreatePost(
          {@Body() required ProcessorTokenCreateRequest? body});

  ///Create Stripe bank account token
  Future<chopper.Response<ProcessorStripeBankAccountTokenCreateResponse>>
      processorStripeBankAccountTokenCreatePost(
          {required ProcessorStripeBankAccountTokenCreateRequest? body}) {
    generatedMapping.putIfAbsent(ProcessorStripeBankAccountTokenCreateResponse,
        () => ProcessorStripeBankAccountTokenCreateResponse.fromJsonFactory);

    return _processorStripeBankAccountTokenCreatePost(body: body);
  }

  ///Create Stripe bank account token
  @Post(path: '/processor/stripe/bank_account_token/create')
  Future<chopper.Response<ProcessorStripeBankAccountTokenCreateResponse>>
      _processorStripeBankAccountTokenCreatePost(
          {@Body()
              required ProcessorStripeBankAccountTokenCreateRequest? body});

  ///Create Apex bank account token
  Future<chopper.Response<ProcessorTokenCreateResponse>>
      processorApexProcessorTokenCreatePost(
          {required ProcessorApexProcessorTokenCreateRequest? body}) {
    generatedMapping.putIfAbsent(ProcessorTokenCreateResponse,
        () => ProcessorTokenCreateResponse.fromJsonFactory);

    return _processorApexProcessorTokenCreatePost(body: body);
  }

  ///Create Apex bank account token
  @Post(path: '/processor/apex/processor_token/create')
  Future<chopper.Response<ProcessorTokenCreateResponse>>
      _processorApexProcessorTokenCreatePost(
          {@Body() required ProcessorApexProcessorTokenCreateRequest? body});

  ///Create a deposit switch
  Future<chopper.Response<DepositSwitchCreateResponse>> depositSwitchCreatePost(
      {required DepositSwitchCreateRequest? body}) {
    generatedMapping.putIfAbsent(DepositSwitchCreateResponse,
        () => DepositSwitchCreateResponse.fromJsonFactory);

    return _depositSwitchCreatePost(body: body);
  }

  ///Create a deposit switch
  @Post(path: '/deposit_switch/create')
  Future<chopper.Response<DepositSwitchCreateResponse>>
      _depositSwitchCreatePost(
          {@Body() required DepositSwitchCreateRequest? body});

  ///Import Item
  Future<chopper.Response<ItemImportResponse>> itemImportPost(
      {required ItemImportRequest? body}) {
    generatedMapping.putIfAbsent(
        ItemImportResponse, () => ItemImportResponse.fromJsonFactory);

    return _itemImportPost(body: body);
  }

  ///Import Item
  @Post(path: '/item/import')
  Future<chopper.Response<ItemImportResponse>> _itemImportPost(
      {@Body() required ItemImportRequest? body});

  ///Create a deposit switch token
  Future<chopper.Response<DepositSwitchTokenCreateResponse>>
      depositSwitchTokenCreatePost(
          {required DepositSwitchTokenCreateRequest? body}) {
    generatedMapping.putIfAbsent(DepositSwitchTokenCreateResponse,
        () => DepositSwitchTokenCreateResponse.fromJsonFactory);

    return _depositSwitchTokenCreatePost(body: body);
  }

  ///Create a deposit switch token
  @Post(path: '/deposit_switch/token/create')
  Future<chopper.Response<DepositSwitchTokenCreateResponse>>
      _depositSwitchTokenCreatePost(
          {@Body() required DepositSwitchTokenCreateRequest? body});

  ///Create Link Token
  Future<chopper.Response<LinkTokenCreateResponse>> linkTokenCreatePost(
      {required LinkTokenCreateRequest? body}) {
    generatedMapping.putIfAbsent(
        LinkTokenCreateResponse, () => LinkTokenCreateResponse.fromJsonFactory);

    return _linkTokenCreatePost(body: body);
  }

  ///Create Link Token
  @Post(path: '/link/token/create')
  Future<chopper.Response<LinkTokenCreateResponse>> _linkTokenCreatePost(
      {@Body() required LinkTokenCreateRequest? body});

  ///Get Link Token
  Future<chopper.Response<LinkTokenGetResponse>> linkTokenGetPost(
      {required LinkTokenGetRequest? body}) {
    generatedMapping.putIfAbsent(
        LinkTokenGetResponse, () => LinkTokenGetResponse.fromJsonFactory);

    return _linkTokenGetPost(body: body);
  }

  ///Get Link Token
  @Post(path: '/link/token/get')
  Future<chopper.Response<LinkTokenGetResponse>> _linkTokenGetPost(
      {@Body() required LinkTokenGetRequest? body});

  ///Retrieve an Asset Report Audit Copy
  Future<chopper.Response<AssetReportGetResponse>> assetReportAuditCopyGetPost(
      {required AssetReportAuditCopyGetRequest? body}) {
    generatedMapping.putIfAbsent(
        AssetReportGetResponse, () => AssetReportGetResponse.fromJsonFactory);

    return _assetReportAuditCopyGetPost(body: body);
  }

  ///Retrieve an Asset Report Audit Copy
  @Post(path: '/asset_report/audit_copy/get')
  Future<chopper.Response<AssetReportGetResponse>> _assetReportAuditCopyGetPost(
      {@Body() required AssetReportAuditCopyGetRequest? body});

  ///Retrieve a deposit switch
  Future<chopper.Response<DepositSwitchGetResponse>> depositSwitchGetPost(
      {required DepositSwitchGetRequest? body}) {
    generatedMapping.putIfAbsent(DepositSwitchGetResponse,
        () => DepositSwitchGetResponse.fromJsonFactory);

    return _depositSwitchGetPost(body: body);
  }

  ///Retrieve a deposit switch
  @Post(path: '/deposit_switch/get')
  Future<chopper.Response<DepositSwitchGetResponse>> _depositSwitchGetPost(
      {@Body() required DepositSwitchGetRequest? body});

  ///Retrieve a transfer
  Future<chopper.Response<TransferGetResponse>> transferGetPost(
      {required TransferGetRequest? body}) {
    generatedMapping.putIfAbsent(
        TransferGetResponse, () => TransferGetResponse.fromJsonFactory);

    return _transferGetPost(body: body);
  }

  ///Retrieve a transfer
  @Post(path: '/transfer/get')
  Future<chopper.Response<TransferGetResponse>> _transferGetPost(
      {@Body() required TransferGetRequest? body});

  ///Retrieve a bank transfer
  Future<chopper.Response<BankTransferGetResponse>> bankTransferGetPost(
      {required BankTransferGetRequest? body}) {
    generatedMapping.putIfAbsent(
        BankTransferGetResponse, () => BankTransferGetResponse.fromJsonFactory);

    return _bankTransferGetPost(body: body);
  }

  ///Retrieve a bank transfer
  @Post(path: '/bank_transfer/get')
  Future<chopper.Response<BankTransferGetResponse>> _bankTransferGetPost(
      {@Body() required BankTransferGetRequest? body});

  ///Create a transfer authorization
  Future<chopper.Response<TransferAuthorizationCreateResponse>>
      transferAuthorizationCreatePost(
          {required TransferAuthorizationCreateRequest? body}) {
    generatedMapping.putIfAbsent(TransferAuthorizationCreateResponse,
        () => TransferAuthorizationCreateResponse.fromJsonFactory);

    return _transferAuthorizationCreatePost(body: body);
  }

  ///Create a transfer authorization
  @Post(path: '/transfer/authorization/create')
  Future<chopper.Response<TransferAuthorizationCreateResponse>>
      _transferAuthorizationCreatePost(
          {@Body() required TransferAuthorizationCreateRequest? body});

  ///Create a transfer
  Future<chopper.Response<TransferCreateResponse>> transferCreatePost(
      {required TransferCreateRequest? body}) {
    generatedMapping.putIfAbsent(
        TransferCreateResponse, () => TransferCreateResponse.fromJsonFactory);

    return _transferCreatePost(body: body);
  }

  ///Create a transfer
  @Post(path: '/transfer/create')
  Future<chopper.Response<TransferCreateResponse>> _transferCreatePost(
      {@Body() required TransferCreateRequest? body});

  ///Create a bank transfer
  Future<chopper.Response<BankTransferCreateResponse>> bankTransferCreatePost(
      {required BankTransferCreateRequest? body}) {
    generatedMapping.putIfAbsent(BankTransferCreateResponse,
        () => BankTransferCreateResponse.fromJsonFactory);

    return _bankTransferCreatePost(body: body);
  }

  ///Create a bank transfer
  @Post(path: '/bank_transfer/create')
  Future<chopper.Response<BankTransferCreateResponse>> _bankTransferCreatePost(
      {@Body() required BankTransferCreateRequest? body});

  ///List transfers
  Future<chopper.Response<TransferListResponse>> transferListPost(
      {required TransferListRequest? body}) {
    generatedMapping.putIfAbsent(
        TransferListResponse, () => TransferListResponse.fromJsonFactory);

    return _transferListPost(body: body);
  }

  ///List transfers
  @Post(path: '/transfer/list')
  Future<chopper.Response<TransferListResponse>> _transferListPost(
      {@Body() required TransferListRequest? body});

  ///List bank transfers
  Future<chopper.Response<BankTransferListResponse>> bankTransferListPost(
      {required BankTransferListRequest? body}) {
    generatedMapping.putIfAbsent(BankTransferListResponse,
        () => BankTransferListResponse.fromJsonFactory);

    return _bankTransferListPost(body: body);
  }

  ///List bank transfers
  @Post(path: '/bank_transfer/list')
  Future<chopper.Response<BankTransferListResponse>> _bankTransferListPost(
      {@Body() required BankTransferListRequest? body});

  ///Cancel a transfer
  Future<chopper.Response<TransferCancelResponse>> transferCancelPost(
      {required TransferCancelRequest? body}) {
    generatedMapping.putIfAbsent(
        TransferCancelResponse, () => TransferCancelResponse.fromJsonFactory);

    return _transferCancelPost(body: body);
  }

  ///Cancel a transfer
  @Post(path: '/transfer/cancel')
  Future<chopper.Response<TransferCancelResponse>> _transferCancelPost(
      {@Body() required TransferCancelRequest? body});

  ///Cancel a bank transfer
  Future<chopper.Response<BankTransferCancelResponse>> bankTransferCancelPost(
      {required BankTransferCancelRequest? body}) {
    generatedMapping.putIfAbsent(BankTransferCancelResponse,
        () => BankTransferCancelResponse.fromJsonFactory);

    return _bankTransferCancelPost(body: body);
  }

  ///Cancel a bank transfer
  @Post(path: '/bank_transfer/cancel')
  Future<chopper.Response<BankTransferCancelResponse>> _bankTransferCancelPost(
      {@Body() required BankTransferCancelRequest? body});

  ///List transfer events
  Future<chopper.Response<TransferEventListResponse>> transferEventListPost(
      {required TransferEventListRequest? body}) {
    generatedMapping.putIfAbsent(TransferEventListResponse,
        () => TransferEventListResponse.fromJsonFactory);

    return _transferEventListPost(body: body);
  }

  ///List transfer events
  @Post(path: '/transfer/event/list')
  Future<chopper.Response<TransferEventListResponse>> _transferEventListPost(
      {@Body() required TransferEventListRequest? body});

  ///List bank transfer events
  Future<chopper.Response<BankTransferEventListResponse>>
      bankTransferEventListPost({required BankTransferEventListRequest? body}) {
    generatedMapping.putIfAbsent(BankTransferEventListResponse,
        () => BankTransferEventListResponse.fromJsonFactory);

    return _bankTransferEventListPost(body: body);
  }

  ///List bank transfer events
  @Post(path: '/bank_transfer/event/list')
  Future<chopper.Response<BankTransferEventListResponse>>
      _bankTransferEventListPost(
          {@Body() required BankTransferEventListRequest? body});

  ///Sync transfer events
  Future<chopper.Response<TransferEventSyncResponse>> transferEventSyncPost(
      {required TransferEventSyncRequest? body}) {
    generatedMapping.putIfAbsent(TransferEventSyncResponse,
        () => TransferEventSyncResponse.fromJsonFactory);

    return _transferEventSyncPost(body: body);
  }

  ///Sync transfer events
  @Post(path: '/transfer/event/sync')
  Future<chopper.Response<TransferEventSyncResponse>> _transferEventSyncPost(
      {@Body() required TransferEventSyncRequest? body});

  ///Sync bank transfer events
  Future<chopper.Response<BankTransferEventSyncResponse>>
      bankTransferEventSyncPost({required BankTransferEventSyncRequest? body}) {
    generatedMapping.putIfAbsent(BankTransferEventSyncResponse,
        () => BankTransferEventSyncResponse.fromJsonFactory);

    return _bankTransferEventSyncPost(body: body);
  }

  ///Sync bank transfer events
  @Post(path: '/bank_transfer/event/sync')
  Future<chopper.Response<BankTransferEventSyncResponse>>
      _bankTransferEventSyncPost(
          {@Body() required BankTransferEventSyncRequest? body});

  ///Retrieve a sweep
  Future<chopper.Response<TransferSweepGetResponse>> transferSweepGetPost(
      {required TransferSweepGetRequest? body}) {
    generatedMapping.putIfAbsent(TransferSweepGetResponse,
        () => TransferSweepGetResponse.fromJsonFactory);

    return _transferSweepGetPost(body: body);
  }

  ///Retrieve a sweep
  @Post(path: '/transfer/sweep/get')
  Future<chopper.Response<TransferSweepGetResponse>> _transferSweepGetPost(
      {@Body() required TransferSweepGetRequest? body});

  ///Retrieve a sweep
  Future<chopper.Response<BankTransferSweepGetResponse>>
      bankTransferSweepGetPost({required BankTransferSweepGetRequest? body}) {
    generatedMapping.putIfAbsent(BankTransferSweepGetResponse,
        () => BankTransferSweepGetResponse.fromJsonFactory);

    return _bankTransferSweepGetPost(body: body);
  }

  ///Retrieve a sweep
  @Post(path: '/bank_transfer/sweep/get')
  Future<chopper.Response<BankTransferSweepGetResponse>>
      _bankTransferSweepGetPost(
          {@Body() required BankTransferSweepGetRequest? body});

  ///List sweeps
  Future<chopper.Response<TransferSweepListResponse>> transferSweepListPost(
      {required TransferSweepListRequest? body}) {
    generatedMapping.putIfAbsent(TransferSweepListResponse,
        () => TransferSweepListResponse.fromJsonFactory);

    return _transferSweepListPost(body: body);
  }

  ///List sweeps
  @Post(path: '/transfer/sweep/list')
  Future<chopper.Response<TransferSweepListResponse>> _transferSweepListPost(
      {@Body() required TransferSweepListRequest? body});

  ///List sweeps
  Future<chopper.Response<BankTransferSweepListResponse>>
      bankTransferSweepListPost({required BankTransferSweepListRequest? body}) {
    generatedMapping.putIfAbsent(BankTransferSweepListResponse,
        () => BankTransferSweepListResponse.fromJsonFactory);

    return _bankTransferSweepListPost(body: body);
  }

  ///List sweeps
  @Post(path: '/bank_transfer/sweep/list')
  Future<chopper.Response<BankTransferSweepListResponse>>
      _bankTransferSweepListPost(
          {@Body() required BankTransferSweepListRequest? body});

  ///Get balance of your Bank Transfer account
  Future<chopper.Response<BankTransferBalanceGetResponse>>
      bankTransferBalanceGetPost(
          {required BankTransferBalanceGetRequest? body}) {
    generatedMapping.putIfAbsent(BankTransferBalanceGetResponse,
        () => BankTransferBalanceGetResponse.fromJsonFactory);

    return _bankTransferBalanceGetPost(body: body);
  }

  ///Get balance of your Bank Transfer account
  @Post(path: '/bank_transfer/balance/get')
  Future<chopper.Response<BankTransferBalanceGetResponse>>
      _bankTransferBalanceGetPost(
          {@Body() required BankTransferBalanceGetRequest? body});

  ///Migrate account into Bank Transfers
  Future<chopper.Response<BankTransferMigrateAccountResponse>>
      bankTransferMigrateAccountPost(
          {required BankTransferMigrateAccountRequest? body}) {
    generatedMapping.putIfAbsent(BankTransferMigrateAccountResponse,
        () => BankTransferMigrateAccountResponse.fromJsonFactory);

    return _bankTransferMigrateAccountPost(body: body);
  }

  ///Migrate account into Bank Transfers
  @Post(path: '/bank_transfer/migrate_account')
  Future<chopper.Response<BankTransferMigrateAccountResponse>>
      _bankTransferMigrateAccountPost(
          {@Body() required BankTransferMigrateAccountRequest? body});

  ///Create a transfer intent object to invoke the Transfer UI
  Future<chopper.Response<TransferIntentCreateResponse>>
      transferIntentCreatePost({required TransferIntentCreateRequest? body}) {
    generatedMapping.putIfAbsent(TransferIntentCreateResponse,
        () => TransferIntentCreateResponse.fromJsonFactory);

    return _transferIntentCreatePost(body: body);
  }

  ///Create a transfer intent object to invoke the Transfer UI
  @Post(path: '/transfer/intent/create')
  Future<chopper.Response<TransferIntentCreateResponse>>
      _transferIntentCreatePost(
          {@Body() required TransferIntentCreateRequest? body});

  ///Retrieve more information about a transfer intent
  Future<chopper.Response<TransferIntentGetResponse>> transferIntentGetPost(
      {required TransferIntentGetRequest? body}) {
    generatedMapping.putIfAbsent(TransferIntentGetResponse,
        () => TransferIntentGetResponse.fromJsonFactory);

    return _transferIntentGetPost(body: body);
  }

  ///Retrieve more information about a transfer intent
  @Post(path: '/transfer/intent/get')
  Future<chopper.Response<TransferIntentGetResponse>> _transferIntentGetPost(
      {@Body() required TransferIntentGetRequest? body});

  ///Simulate a bank transfer event in Sandbox
  Future<chopper.Response<SandboxBankTransferSimulateResponse>>
      sandboxBankTransferSimulatePost(
          {required SandboxBankTransferSimulateRequest? body}) {
    generatedMapping.putIfAbsent(SandboxBankTransferSimulateResponse,
        () => SandboxBankTransferSimulateResponse.fromJsonFactory);

    return _sandboxBankTransferSimulatePost(body: body);
  }

  ///Simulate a bank transfer event in Sandbox
  @Post(path: '/sandbox/bank_transfer/simulate')
  Future<chopper.Response<SandboxBankTransferSimulateResponse>>
      _sandboxBankTransferSimulatePost(
          {@Body() required SandboxBankTransferSimulateRequest? body});

  ///Simulate creating a sweep for a set of transfers
  Future<chopper.Response<SandboxTransferSweepSimulateResponse>>
      sandboxTransferSweepSimulatePost(
          {required SandboxTransferSweepSimulateRequest? body}) {
    generatedMapping.putIfAbsent(SandboxTransferSweepSimulateResponse,
        () => SandboxTransferSweepSimulateResponse.fromJsonFactory);

    return _sandboxTransferSweepSimulatePost(body: body);
  }

  ///Simulate creating a sweep for a set of transfers
  @Post(path: '/sandbox/transfer/sweep/simulate')
  Future<chopper.Response<SandboxTransferSweepSimulateResponse>>
      _sandboxTransferSweepSimulatePost(
          {@Body() required SandboxTransferSweepSimulateRequest? body});

  ///Simulate a transfer event in Sandbox
  Future<chopper.Response<SandboxTransferSimulateResponse>>
      sandboxTransferSimulatePost(
          {required SandboxTransferSimulateRequest? body}) {
    generatedMapping.putIfAbsent(SandboxTransferSimulateResponse,
        () => SandboxTransferSimulateResponse.fromJsonFactory);

    return _sandboxTransferSimulatePost(body: body);
  }

  ///Simulate a transfer event in Sandbox
  @Post(path: '/sandbox/transfer/simulate')
  Future<chopper.Response<SandboxTransferSimulateResponse>>
      _sandboxTransferSimulatePost(
          {@Body() required SandboxTransferSimulateRequest? body});

  ///Search employer database
  Future<chopper.Response<EmployersSearchResponse>> employersSearchPost(
      {required EmployersSearchRequest? body}) {
    generatedMapping.putIfAbsent(
        EmployersSearchResponse, () => EmployersSearchResponse.fromJsonFactory);

    return _employersSearchPost(body: body);
  }

  ///Search employer database
  @Post(path: '/employers/search')
  Future<chopper.Response<EmployersSearchResponse>> _employersSearchPost(
      {@Body() required EmployersSearchRequest? body});

  ///(Deprecated) Create an income verification instance
  Future<chopper.Response<IncomeVerificationCreateResponse>>
      incomeVerificationCreatePost(
          {required IncomeVerificationCreateRequest? body}) {
    generatedMapping.putIfAbsent(IncomeVerificationCreateResponse,
        () => IncomeVerificationCreateResponse.fromJsonFactory);

    return _incomeVerificationCreatePost(body: body);
  }

  ///(Deprecated) Create an income verification instance
  @Post(path: '/income/verification/create')
  Future<chopper.Response<IncomeVerificationCreateResponse>>
      _incomeVerificationCreatePost(
          {@Body() required IncomeVerificationCreateRequest? body});

  ///(Deprecated) Retrieve a summary of information derived from income verification
  Future<chopper.Response<IncomeVerificationSummaryGetResponse>>
      incomeVerificationSummaryGetPost(
          {required IncomeVerificationSummaryGetRequest? body}) {
    generatedMapping.putIfAbsent(IncomeVerificationSummaryGetResponse,
        () => IncomeVerificationSummaryGetResponse.fromJsonFactory);

    return _incomeVerificationSummaryGetPost(body: body);
  }

  ///(Deprecated) Retrieve a summary of information derived from income verification
  @Post(path: '/income/verification/summary/get')
  Future<chopper.Response<IncomeVerificationSummaryGetResponse>>
      _incomeVerificationSummaryGetPost(
          {@Body() required IncomeVerificationSummaryGetRequest? body});

  ///(Deprecated) Retrieve information from a single paystub used for income verification
  Future<chopper.Response<IncomeVerificationPaystubGetResponse>>
      incomeVerificationPaystubGetPost(
          {required IncomeVerificationPaystubGetRequest? body}) {
    generatedMapping.putIfAbsent(IncomeVerificationPaystubGetResponse,
        () => IncomeVerificationPaystubGetResponse.fromJsonFactory);

    return _incomeVerificationPaystubGetPost(body: body);
  }

  ///(Deprecated) Retrieve information from a single paystub used for income verification
  @Post(path: '/income/verification/paystub/get')
  Future<chopper.Response<IncomeVerificationPaystubGetResponse>>
      _incomeVerificationPaystubGetPost(
          {@Body() required IncomeVerificationPaystubGetRequest? body});

  ///Retrieve information from the paystubs used for income verification
  Future<chopper.Response<IncomeVerificationPaystubsGetResponse>>
      incomeVerificationPaystubsGetPost(
          {required IncomeVerificationPaystubsGetRequest? body}) {
    generatedMapping.putIfAbsent(IncomeVerificationPaystubsGetResponse,
        () => IncomeVerificationPaystubsGetResponse.fromJsonFactory);

    return _incomeVerificationPaystubsGetPost(body: body);
  }

  ///Retrieve information from the paystubs used for income verification
  @Post(path: '/income/verification/paystubs/get')
  Future<chopper.Response<IncomeVerificationPaystubsGetResponse>>
      _incomeVerificationPaystubsGetPost(
          {@Body() required IncomeVerificationPaystubsGetRequest? body});

  ///Download the original documents used for income verification
  Future<chopper.Response<String>> incomeVerificationDocumentsDownloadPost(
      {required IncomeVerificationDocumentsDownloadRequest? body}) {
    return _incomeVerificationDocumentsDownloadPost(body: body);
  }

  ///Download the original documents used for income verification
  @Post(path: '/income/verification/documents/download')
  Future<chopper.Response<String>> _incomeVerificationDocumentsDownloadPost(
      {@Body() required IncomeVerificationDocumentsDownloadRequest? body});

  ///Refresh an income verification
  Future<chopper.Response<IncomeVerificationRefreshResponse>>
      incomeVerificationRefreshPost(
          {required IncomeVerificationRefreshRequest? body}) {
    generatedMapping.putIfAbsent(IncomeVerificationRefreshResponse,
        () => IncomeVerificationRefreshResponse.fromJsonFactory);

    return _incomeVerificationRefreshPost(body: body);
  }

  ///Refresh an income verification
  @Post(path: '/income/verification/refresh')
  Future<chopper.Response<IncomeVerificationRefreshResponse>>
      _incomeVerificationRefreshPost(
          {@Body() required IncomeVerificationRefreshRequest? body});

  ///Retrieve information from the tax documents used for income verification
  Future<chopper.Response<IncomeVerificationTaxformsGetResponse>>
      incomeVerificationTaxformsGetPost(
          {required IncomeVerificationTaxformsGetRequest? body}) {
    generatedMapping.putIfAbsent(IncomeVerificationTaxformsGetResponse,
        () => IncomeVerificationTaxformsGetResponse.fromJsonFactory);

    return _incomeVerificationTaxformsGetPost(body: body);
  }

  ///Retrieve information from the tax documents used for income verification
  @Post(path: '/income/verification/taxforms/get')
  Future<chopper.Response<IncomeVerificationTaxformsGetResponse>>
      _incomeVerificationTaxformsGetPost(
          {@Body() required IncomeVerificationTaxformsGetRequest? body});

  ///Check a user's eligibility for the income verification product
  Future<chopper.Response<IncomeVerificationPrecheckResponse>>
      incomeVerificationPrecheckPost(
          {required IncomeVerificationPrecheckRequest? body}) {
    generatedMapping.putIfAbsent(IncomeVerificationPrecheckResponse,
        () => IncomeVerificationPrecheckResponse.fromJsonFactory);

    return _incomeVerificationPrecheckPost(body: body);
  }

  ///Check a user's eligibility for the income verification product
  @Post(path: '/income/verification/precheck')
  Future<chopper.Response<IncomeVerificationPrecheckResponse>>
      _incomeVerificationPrecheckPost(
          {@Body() required IncomeVerificationPrecheckRequest? body});

  ///Retrieve a summary of an individual's employment information.
  Future<chopper.Response<EmploymentVerificationGetResponse>>
      employmentVerificationGetPost(
          {required EmploymentVerificationGetRequest? body}) {
    generatedMapping.putIfAbsent(EmploymentVerificationGetResponse,
        () => EmploymentVerificationGetResponse.fromJsonFactory);

    return _employmentVerificationGetPost(body: body);
  }

  ///Retrieve a summary of an individual's employment information.
  @Post(path: '/employment/verification/get')
  Future<chopper.Response<EmploymentVerificationGetResponse>>
      _employmentVerificationGetPost(
          {@Body() required EmploymentVerificationGetRequest? body});

  ///Create a deposit switch without using Plaid Exchange
  Future<chopper.Response<DepositSwitchAltCreateResponse>>
      depositSwitchAltCreatePost(
          {required DepositSwitchAltCreateRequest? body}) {
    generatedMapping.putIfAbsent(DepositSwitchAltCreateResponse,
        () => DepositSwitchAltCreateResponse.fromJsonFactory);

    return _depositSwitchAltCreatePost(body: body);
  }

  ///Create a deposit switch without using Plaid Exchange
  @Post(path: '/deposit_switch/alt/create')
  Future<chopper.Response<DepositSwitchAltCreateResponse>>
      _depositSwitchAltCreatePost(
          {@Body() required DepositSwitchAltCreateRequest? body});

  ///Manually fire a Bank Transfer webhook
  Future<chopper.Response<SandboxBankTransferFireWebhookResponse>>
      sandboxBankTransferFireWebhookPost(
          {required SandboxBankTransferFireWebhookRequest? body}) {
    generatedMapping.putIfAbsent(SandboxBankTransferFireWebhookResponse,
        () => SandboxBankTransferFireWebhookResponse.fromJsonFactory);

    return _sandboxBankTransferFireWebhookPost(body: body);
  }

  ///Manually fire a Bank Transfer webhook
  @Post(path: '/sandbox/bank_transfer/fire_webhook')
  Future<chopper.Response<SandboxBankTransferFireWebhookResponse>>
      _sandboxBankTransferFireWebhookPost(
          {@Body() required SandboxBankTransferFireWebhookRequest? body});

  ///Manually fire an Income webhook
  Future<chopper.Response<SandboxIncomeFireWebhookResponse>>
      sandboxIncomeFireWebhookPost(
          {required SandboxIncomeFireWebhookRequest? body}) {
    generatedMapping.putIfAbsent(SandboxIncomeFireWebhookResponse,
        () => SandboxIncomeFireWebhookResponse.fromJsonFactory);

    return _sandboxIncomeFireWebhookPost(body: body);
  }

  ///Manually fire an Income webhook
  @Post(path: '/sandbox/income/fire_webhook')
  Future<chopper.Response<SandboxIncomeFireWebhookResponse>>
      _sandboxIncomeFireWebhookPost(
          {@Body() required SandboxIncomeFireWebhookRequest? body});

  ///Save the selected accounts when connecting to the Platypus Oauth institution
  Future<chopper.Response<SandboxOauthSelectAccountsResponse>>
      sandboxOauthSelectAccountsPost(
          {required SandboxOauthSelectAccountsRequest? body}) {
    generatedMapping.putIfAbsent(SandboxOauthSelectAccountsResponse,
        () => SandboxOauthSelectAccountsResponse.fromJsonFactory);

    return _sandboxOauthSelectAccountsPost(body: body);
  }

  ///Save the selected accounts when connecting to the Platypus Oauth institution
  @Post(path: '/sandbox/oauth/select_accounts')
  Future<chopper.Response<SandboxOauthSelectAccountsResponse>>
      _sandboxOauthSelectAccountsPost(
          {@Body() required SandboxOauthSelectAccountsRequest? body});

  ///Evaluate a planned ACH transaction
  Future<chopper.Response<SignalEvaluateResponse>> signalEvaluatePost(
      {required SignalEvaluateRequest? body}) {
    generatedMapping.putIfAbsent(
        SignalEvaluateResponse, () => SignalEvaluateResponse.fromJsonFactory);

    return _signalEvaluatePost(body: body);
  }

  ///Evaluate a planned ACH transaction
  @Post(path: '/signal/evaluate')
  Future<chopper.Response<SignalEvaluateResponse>> _signalEvaluatePost(
      {@Body() required SignalEvaluateRequest? body});

  ///Report whether you initiated an ACH transaction
  Future<chopper.Response<SignalDecisionReportResponse>>
      signalDecisionReportPost({required SignalDecisionReportRequest? body}) {
    generatedMapping.putIfAbsent(SignalDecisionReportResponse,
        () => SignalDecisionReportResponse.fromJsonFactory);

    return _signalDecisionReportPost(body: body);
  }

  ///Report whether you initiated an ACH transaction
  @Post(path: '/signal/decision/report')
  Future<chopper.Response<SignalDecisionReportResponse>>
      _signalDecisionReportPost(
          {@Body() required SignalDecisionReportRequest? body});

  ///Report a return for an ACH transaction
  Future<chopper.Response<SignalReturnReportResponse>> signalReturnReportPost(
      {required SignalReturnReportRequest? body}) {
    generatedMapping.putIfAbsent(SignalReturnReportResponse,
        () => SignalReturnReportResponse.fromJsonFactory);

    return _signalReturnReportPost(body: body);
  }

  ///Report a return for an ACH transaction
  @Post(path: '/signal/return/report')
  Future<chopper.Response<SignalReturnReportResponse>> _signalReturnReportPost(
      {@Body() required SignalReturnReportRequest? body});

  ///Fetch an e-wallet
  Future<chopper.Response<WalletGetResponse>> walletGetPost(
      {required WalletGetRequest? body}) {
    generatedMapping.putIfAbsent(
        WalletGetResponse, () => WalletGetResponse.fromJsonFactory);

    return _walletGetPost(body: body);
  }

  ///Fetch an e-wallet
  @Post(path: '/wallet/get')
  Future<chopper.Response<WalletGetResponse>> _walletGetPost(
      {@Body() required WalletGetRequest? body});

  ///Execute a transaction using an e-wallet
  Future<chopper.Response<WalletTransactionExecuteResponse>>
      walletTransactionExecutePost(
          {required WalletTransactionExecuteRequest? body}) {
    generatedMapping.putIfAbsent(WalletTransactionExecuteResponse,
        () => WalletTransactionExecuteResponse.fromJsonFactory);

    return _walletTransactionExecutePost(body: body);
  }

  ///Execute a transaction using an e-wallet
  @Post(path: '/wallet/transaction/execute')
  Future<chopper.Response<WalletTransactionExecuteResponse>>
      _walletTransactionExecutePost(
          {@Body() required WalletTransactionExecuteRequest? body});

  ///List e-wallet transactions
  Future<chopper.Response<WalletTransactionsListResponse>>
      walletTransactionsListPost(
          {required WalletTransactionsListRequest? body}) {
    generatedMapping.putIfAbsent(WalletTransactionsListResponse,
        () => WalletTransactionsListResponse.fromJsonFactory);

    return _walletTransactionsListPost(body: body);
  }

  ///List e-wallet transactions
  @Post(path: '/wallet/transactions/list')
  Future<chopper.Response<WalletTransactionsListResponse>>
      _walletTransactionsListPost(
          {@Body() required WalletTransactionsListRequest? body});
}

@JsonSerializable(explicitToJson: true)
class ItemGetRequest {
  ItemGetRequest({
    this.clientId,
    this.secret,
    this.accessToken,
  });

  factory ItemGetRequest.fromJson(Map<String, dynamic> json) =>
      _$ItemGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'access_token')
  final String? accessToken;
  static const fromJsonFactory = _$ItemGetRequestFromJson;
  static const toJsonFactory = _$ItemGetRequestToJson;
  Map<String, dynamic> toJson() => _$ItemGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ItemGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(accessToken) ^
      runtimeType.hashCode;
}

extension $ItemGetRequestExtension on ItemGetRequest {
  ItemGetRequest copyWith(
      {String? clientId, String? secret, String? accessToken}) {
    return ItemGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        accessToken: accessToken ?? this.accessToken);
  }
}

@JsonSerializable(explicitToJson: true)
class ItemGetResponse {
  ItemGetResponse({
    this.item,
    this.status,
    this.requestId,
  });

  factory ItemGetResponse.fromJson(Map<String, dynamic> json) =>
      _$ItemGetResponseFromJson(json);

  @JsonKey(name: 'item')
  final Item? item;
  @JsonKey(name: 'status')
  final ItemStatusNullable? status;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$ItemGetResponseFromJson;
  static const toJsonFactory = _$ItemGetResponseToJson;
  Map<String, dynamic> toJson() => _$ItemGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ItemGetResponse &&
            (identical(other.item, item) ||
                const DeepCollectionEquality().equals(other.item, item)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(item) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $ItemGetResponseExtension on ItemGetResponse {
  ItemGetResponse copyWith(
      {Item? item, ItemStatusNullable? status, String? requestId}) {
    return ItemGetResponse(
        item: item ?? this.item,
        status: status ?? this.status,
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class AuthGetRequest {
  AuthGetRequest({
    this.clientId,
    this.secret,
    this.accessToken,
    this.options,
  });

  factory AuthGetRequest.fromJson(Map<String, dynamic> json) =>
      _$AuthGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'access_token')
  final String? accessToken;
  @JsonKey(name: 'options')
  final AuthGetRequestOptions? options;
  static const fromJsonFactory = _$AuthGetRequestFromJson;
  static const toJsonFactory = _$AuthGetRequestToJson;
  Map<String, dynamic> toJson() => _$AuthGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AuthGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)) &&
            (identical(other.options, options) ||
                const DeepCollectionEquality().equals(other.options, options)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(accessToken) ^
      const DeepCollectionEquality().hash(options) ^
      runtimeType.hashCode;
}

extension $AuthGetRequestExtension on AuthGetRequest {
  AuthGetRequest copyWith(
      {String? clientId,
      String? secret,
      String? accessToken,
      AuthGetRequestOptions? options}) {
    return AuthGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        accessToken: accessToken ?? this.accessToken,
        options: options ?? this.options);
  }
}

@JsonSerializable(explicitToJson: true)
class AuthGetRequestOptions {
  AuthGetRequestOptions({
    this.accountIds,
  });

  factory AuthGetRequestOptions.fromJson(Map<String, dynamic> json) =>
      _$AuthGetRequestOptionsFromJson(json);

  @JsonKey(name: 'account_ids', defaultValue: <String>[])
  final List<String>? accountIds;
  static const fromJsonFactory = _$AuthGetRequestOptionsFromJson;
  static const toJsonFactory = _$AuthGetRequestOptionsToJson;
  Map<String, dynamic> toJson() => _$AuthGetRequestOptionsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AuthGetRequestOptions &&
            (identical(other.accountIds, accountIds) ||
                const DeepCollectionEquality()
                    .equals(other.accountIds, accountIds)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountIds) ^ runtimeType.hashCode;
}

extension $AuthGetRequestOptionsExtension on AuthGetRequestOptions {
  AuthGetRequestOptions copyWith({List<String>? accountIds}) {
    return AuthGetRequestOptions(accountIds: accountIds ?? this.accountIds);
  }
}

@JsonSerializable(explicitToJson: true)
class AuthGetResponse {
  AuthGetResponse({
    this.accounts,
    this.numbers,
    this.item,
    this.requestId,
  });

  factory AuthGetResponse.fromJson(Map<String, dynamic> json) =>
      _$AuthGetResponseFromJson(json);

  @JsonKey(name: 'accounts', defaultValue: <AccountBase>[])
  final List<AccountBase>? accounts;
  @JsonKey(name: 'numbers')
  final AuthGetNumbers? numbers;
  @JsonKey(name: 'item')
  final Item? item;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$AuthGetResponseFromJson;
  static const toJsonFactory = _$AuthGetResponseToJson;
  Map<String, dynamic> toJson() => _$AuthGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AuthGetResponse &&
            (identical(other.accounts, accounts) ||
                const DeepCollectionEquality()
                    .equals(other.accounts, accounts)) &&
            (identical(other.numbers, numbers) ||
                const DeepCollectionEquality()
                    .equals(other.numbers, numbers)) &&
            (identical(other.item, item) ||
                const DeepCollectionEquality().equals(other.item, item)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accounts) ^
      const DeepCollectionEquality().hash(numbers) ^
      const DeepCollectionEquality().hash(item) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $AuthGetResponseExtension on AuthGetResponse {
  AuthGetResponse copyWith(
      {List<AccountBase>? accounts,
      AuthGetNumbers? numbers,
      Item? item,
      String? requestId}) {
    return AuthGetResponse(
        accounts: accounts ?? this.accounts,
        numbers: numbers ?? this.numbers,
        item: item ?? this.item,
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class AuthGetNumbers {
  AuthGetNumbers({
    this.ach,
    this.eft,
    this.international,
    this.bacs,
  });

  factory AuthGetNumbers.fromJson(Map<String, dynamic> json) =>
      _$AuthGetNumbersFromJson(json);

  @JsonKey(name: 'ach', defaultValue: <NumbersACH>[])
  final List<NumbersACH>? ach;
  @JsonKey(name: 'eft', defaultValue: <NumbersEFT>[])
  final List<NumbersEFT>? eft;
  @JsonKey(name: 'international', defaultValue: <NumbersInternational>[])
  final List<NumbersInternational>? international;
  @JsonKey(name: 'bacs', defaultValue: <NumbersBACS>[])
  final List<NumbersBACS>? bacs;
  static const fromJsonFactory = _$AuthGetNumbersFromJson;
  static const toJsonFactory = _$AuthGetNumbersToJson;
  Map<String, dynamic> toJson() => _$AuthGetNumbersToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AuthGetNumbers &&
            (identical(other.ach, ach) ||
                const DeepCollectionEquality().equals(other.ach, ach)) &&
            (identical(other.eft, eft) ||
                const DeepCollectionEquality().equals(other.eft, eft)) &&
            (identical(other.international, international) ||
                const DeepCollectionEquality()
                    .equals(other.international, international)) &&
            (identical(other.bacs, bacs) ||
                const DeepCollectionEquality().equals(other.bacs, bacs)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ach) ^
      const DeepCollectionEquality().hash(eft) ^
      const DeepCollectionEquality().hash(international) ^
      const DeepCollectionEquality().hash(bacs) ^
      runtimeType.hashCode;
}

extension $AuthGetNumbersExtension on AuthGetNumbers {
  AuthGetNumbers copyWith(
      {List<NumbersACH>? ach,
      List<NumbersEFT>? eft,
      List<NumbersInternational>? international,
      List<NumbersBACS>? bacs}) {
    return AuthGetNumbers(
        ach: ach ?? this.ach,
        eft: eft ?? this.eft,
        international: international ?? this.international,
        bacs: bacs ?? this.bacs);
  }
}

@JsonSerializable(explicitToJson: true)
class TransactionsGetRequest {
  TransactionsGetRequest({
    this.clientId,
    this.options,
    this.accessToken,
    this.secret,
    this.startDate,
    this.endDate,
  });

  factory TransactionsGetRequest.fromJson(Map<String, dynamic> json) =>
      _$TransactionsGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'options')
  final TransactionsGetRequestOptions? options;
  @JsonKey(name: 'access_token')
  final String? accessToken;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'start_date', toJson: _dateToJson)
  final DateTime? startDate;
  @JsonKey(name: 'end_date', toJson: _dateToJson)
  final DateTime? endDate;
  static const fromJsonFactory = _$TransactionsGetRequestFromJson;
  static const toJsonFactory = _$TransactionsGetRequestToJson;
  Map<String, dynamic> toJson() => _$TransactionsGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransactionsGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.options, options) ||
                const DeepCollectionEquality()
                    .equals(other.options, options)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.startDate, startDate) ||
                const DeepCollectionEquality()
                    .equals(other.startDate, startDate)) &&
            (identical(other.endDate, endDate) ||
                const DeepCollectionEquality().equals(other.endDate, endDate)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(options) ^
      const DeepCollectionEquality().hash(accessToken) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(startDate) ^
      const DeepCollectionEquality().hash(endDate) ^
      runtimeType.hashCode;
}

extension $TransactionsGetRequestExtension on TransactionsGetRequest {
  TransactionsGetRequest copyWith(
      {String? clientId,
      TransactionsGetRequestOptions? options,
      String? accessToken,
      String? secret,
      DateTime? startDate,
      DateTime? endDate}) {
    return TransactionsGetRequest(
        clientId: clientId ?? this.clientId,
        options: options ?? this.options,
        accessToken: accessToken ?? this.accessToken,
        secret: secret ?? this.secret,
        startDate: startDate ?? this.startDate,
        endDate: endDate ?? this.endDate);
  }
}

@JsonSerializable(explicitToJson: true)
class TransactionsGetRequestOptions {
  TransactionsGetRequestOptions({
    this.accountIds,
    this.count,
    this.offset,
    this.includeOriginalDescription,
    this.includePersonalFinanceCategoryBeta,
  });

  factory TransactionsGetRequestOptions.fromJson(Map<String, dynamic> json) =>
      _$TransactionsGetRequestOptionsFromJson(json);

  @JsonKey(name: 'account_ids', defaultValue: <String>[])
  final List<String>? accountIds;
  @JsonKey(name: 'count')
  final int? count;
  @JsonKey(name: 'offset')
  final int? offset;
  @JsonKey(name: 'include_original_description', defaultValue: false)
  final bool? includeOriginalDescription;
  @JsonKey(name: 'include_personal_finance_category_beta', defaultValue: false)
  final bool? includePersonalFinanceCategoryBeta;
  static const fromJsonFactory = _$TransactionsGetRequestOptionsFromJson;
  static const toJsonFactory = _$TransactionsGetRequestOptionsToJson;
  Map<String, dynamic> toJson() => _$TransactionsGetRequestOptionsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransactionsGetRequestOptions &&
            (identical(other.accountIds, accountIds) ||
                const DeepCollectionEquality()
                    .equals(other.accountIds, accountIds)) &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)) &&
            (identical(other.offset, offset) ||
                const DeepCollectionEquality().equals(other.offset, offset)) &&
            (identical(other.includeOriginalDescription,
                    includeOriginalDescription) ||
                const DeepCollectionEquality().equals(
                    other.includeOriginalDescription,
                    includeOriginalDescription)) &&
            (identical(other.includePersonalFinanceCategoryBeta,
                    includePersonalFinanceCategoryBeta) ||
                const DeepCollectionEquality().equals(
                    other.includePersonalFinanceCategoryBeta,
                    includePersonalFinanceCategoryBeta)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountIds) ^
      const DeepCollectionEquality().hash(count) ^
      const DeepCollectionEquality().hash(offset) ^
      const DeepCollectionEquality().hash(includeOriginalDescription) ^
      const DeepCollectionEquality().hash(includePersonalFinanceCategoryBeta) ^
      runtimeType.hashCode;
}

extension $TransactionsGetRequestOptionsExtension
    on TransactionsGetRequestOptions {
  TransactionsGetRequestOptions copyWith(
      {List<String>? accountIds,
      int? count,
      int? offset,
      bool? includeOriginalDescription,
      bool? includePersonalFinanceCategoryBeta}) {
    return TransactionsGetRequestOptions(
        accountIds: accountIds ?? this.accountIds,
        count: count ?? this.count,
        offset: offset ?? this.offset,
        includeOriginalDescription:
            includeOriginalDescription ?? this.includeOriginalDescription,
        includePersonalFinanceCategoryBeta:
            includePersonalFinanceCategoryBeta ??
                this.includePersonalFinanceCategoryBeta);
  }
}

@JsonSerializable(explicitToJson: true)
class TransactionsGetResponse {
  TransactionsGetResponse({
    this.accounts,
    this.transactions,
    this.totalTransactions,
    this.item,
    this.requestId,
  });

  factory TransactionsGetResponse.fromJson(Map<String, dynamic> json) =>
      _$TransactionsGetResponseFromJson(json);

  @JsonKey(name: 'accounts', defaultValue: <AccountBase>[])
  final List<AccountBase>? accounts;
  @JsonKey(name: 'transactions', defaultValue: <Transaction>[])
  final List<Transaction>? transactions;
  @JsonKey(name: 'total_transactions')
  final int? totalTransactions;
  @JsonKey(name: 'item')
  final Item? item;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$TransactionsGetResponseFromJson;
  static const toJsonFactory = _$TransactionsGetResponseToJson;
  Map<String, dynamic> toJson() => _$TransactionsGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransactionsGetResponse &&
            (identical(other.accounts, accounts) ||
                const DeepCollectionEquality()
                    .equals(other.accounts, accounts)) &&
            (identical(other.transactions, transactions) ||
                const DeepCollectionEquality()
                    .equals(other.transactions, transactions)) &&
            (identical(other.totalTransactions, totalTransactions) ||
                const DeepCollectionEquality()
                    .equals(other.totalTransactions, totalTransactions)) &&
            (identical(other.item, item) ||
                const DeepCollectionEquality().equals(other.item, item)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accounts) ^
      const DeepCollectionEquality().hash(transactions) ^
      const DeepCollectionEquality().hash(totalTransactions) ^
      const DeepCollectionEquality().hash(item) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $TransactionsGetResponseExtension on TransactionsGetResponse {
  TransactionsGetResponse copyWith(
      {List<AccountBase>? accounts,
      List<Transaction>? transactions,
      int? totalTransactions,
      Item? item,
      String? requestId}) {
    return TransactionsGetResponse(
        accounts: accounts ?? this.accounts,
        transactions: transactions ?? this.transactions,
        totalTransactions: totalTransactions ?? this.totalTransactions,
        item: item ?? this.item,
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class TransactionsRefreshRequest {
  TransactionsRefreshRequest({
    this.clientId,
    this.accessToken,
    this.secret,
  });

  factory TransactionsRefreshRequest.fromJson(Map<String, dynamic> json) =>
      _$TransactionsRefreshRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'access_token')
  final String? accessToken;
  @JsonKey(name: 'secret')
  final String? secret;
  static const fromJsonFactory = _$TransactionsRefreshRequestFromJson;
  static const toJsonFactory = _$TransactionsRefreshRequestToJson;
  Map<String, dynamic> toJson() => _$TransactionsRefreshRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransactionsRefreshRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(accessToken) ^
      const DeepCollectionEquality().hash(secret) ^
      runtimeType.hashCode;
}

extension $TransactionsRefreshRequestExtension on TransactionsRefreshRequest {
  TransactionsRefreshRequest copyWith(
      {String? clientId, String? accessToken, String? secret}) {
    return TransactionsRefreshRequest(
        clientId: clientId ?? this.clientId,
        accessToken: accessToken ?? this.accessToken,
        secret: secret ?? this.secret);
  }
}

@JsonSerializable(explicitToJson: true)
class TransactionsRefreshResponse {
  TransactionsRefreshResponse({
    this.requestId,
  });

  factory TransactionsRefreshResponse.fromJson(Map<String, dynamic> json) =>
      _$TransactionsRefreshResponseFromJson(json);

  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$TransactionsRefreshResponseFromJson;
  static const toJsonFactory = _$TransactionsRefreshResponseToJson;
  Map<String, dynamic> toJson() => _$TransactionsRefreshResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransactionsRefreshResponse &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(requestId) ^ runtimeType.hashCode;
}

extension $TransactionsRefreshResponseExtension on TransactionsRefreshResponse {
  TransactionsRefreshResponse copyWith({String? requestId}) {
    return TransactionsRefreshResponse(requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class TransactionsRecurringGetRequest {
  TransactionsRecurringGetRequest({
    this.clientId,
    this.accessToken,
    this.secret,
    this.accountIds,
  });

  factory TransactionsRecurringGetRequest.fromJson(Map<String, dynamic> json) =>
      _$TransactionsRecurringGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'access_token')
  final String? accessToken;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'account_ids', defaultValue: <String>[])
  final List<String>? accountIds;
  static const fromJsonFactory = _$TransactionsRecurringGetRequestFromJson;
  static const toJsonFactory = _$TransactionsRecurringGetRequestToJson;
  Map<String, dynamic> toJson() =>
      _$TransactionsRecurringGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransactionsRecurringGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.accountIds, accountIds) ||
                const DeepCollectionEquality()
                    .equals(other.accountIds, accountIds)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(accessToken) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(accountIds) ^
      runtimeType.hashCode;
}

extension $TransactionsRecurringGetRequestExtension
    on TransactionsRecurringGetRequest {
  TransactionsRecurringGetRequest copyWith(
      {String? clientId,
      String? accessToken,
      String? secret,
      List<String>? accountIds}) {
    return TransactionsRecurringGetRequest(
        clientId: clientId ?? this.clientId,
        accessToken: accessToken ?? this.accessToken,
        secret: secret ?? this.secret,
        accountIds: accountIds ?? this.accountIds);
  }
}

@JsonSerializable(explicitToJson: true)
class TransactionsRecurringGetResponse {
  TransactionsRecurringGetResponse({
    this.inflowStreams,
    this.outflowStreams,
    this.requestId,
  });

  factory TransactionsRecurringGetResponse.fromJson(
          Map<String, dynamic> json) =>
      _$TransactionsRecurringGetResponseFromJson(json);

  @JsonKey(name: 'inflow_streams', defaultValue: <TransactionStream>[])
  final List<TransactionStream>? inflowStreams;
  @JsonKey(name: 'outflow_streams', defaultValue: <TransactionStream>[])
  final List<TransactionStream>? outflowStreams;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$TransactionsRecurringGetResponseFromJson;
  static const toJsonFactory = _$TransactionsRecurringGetResponseToJson;
  Map<String, dynamic> toJson() =>
      _$TransactionsRecurringGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransactionsRecurringGetResponse &&
            (identical(other.inflowStreams, inflowStreams) ||
                const DeepCollectionEquality()
                    .equals(other.inflowStreams, inflowStreams)) &&
            (identical(other.outflowStreams, outflowStreams) ||
                const DeepCollectionEquality()
                    .equals(other.outflowStreams, outflowStreams)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(inflowStreams) ^
      const DeepCollectionEquality().hash(outflowStreams) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $TransactionsRecurringGetResponseExtension
    on TransactionsRecurringGetResponse {
  TransactionsRecurringGetResponse copyWith(
      {List<TransactionStream>? inflowStreams,
      List<TransactionStream>? outflowStreams,
      String? requestId}) {
    return TransactionsRecurringGetResponse(
        inflowStreams: inflowStreams ?? this.inflowStreams,
        outflowStreams: outflowStreams ?? this.outflowStreams,
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class TransactionsSyncRequest {
  TransactionsSyncRequest({
    this.clientId,
    this.accessToken,
    this.secret,
    this.cursor,
    this.count,
  });

  factory TransactionsSyncRequest.fromJson(Map<String, dynamic> json) =>
      _$TransactionsSyncRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'access_token')
  final String? accessToken;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'cursor')
  final String? cursor;
  @JsonKey(name: 'count')
  final int? count;
  static const fromJsonFactory = _$TransactionsSyncRequestFromJson;
  static const toJsonFactory = _$TransactionsSyncRequestToJson;
  Map<String, dynamic> toJson() => _$TransactionsSyncRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransactionsSyncRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.cursor, cursor) ||
                const DeepCollectionEquality().equals(other.cursor, cursor)) &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(accessToken) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(cursor) ^
      const DeepCollectionEquality().hash(count) ^
      runtimeType.hashCode;
}

extension $TransactionsSyncRequestExtension on TransactionsSyncRequest {
  TransactionsSyncRequest copyWith(
      {String? clientId,
      String? accessToken,
      String? secret,
      String? cursor,
      int? count}) {
    return TransactionsSyncRequest(
        clientId: clientId ?? this.clientId,
        accessToken: accessToken ?? this.accessToken,
        secret: secret ?? this.secret,
        cursor: cursor ?? this.cursor,
        count: count ?? this.count);
  }
}

@JsonSerializable(explicitToJson: true)
class TransactionsSyncResponse {
  TransactionsSyncResponse({
    this.added,
    this.modified,
    this.removed,
    this.nextCursor,
    this.hasMore,
    this.requestId,
  });

  factory TransactionsSyncResponse.fromJson(Map<String, dynamic> json) =>
      _$TransactionsSyncResponseFromJson(json);

  @JsonKey(name: 'added', defaultValue: <Transaction>[])
  final List<Transaction>? added;
  @JsonKey(name: 'modified', defaultValue: <Transaction>[])
  final List<Transaction>? modified;
  @JsonKey(name: 'removed', defaultValue: <RemovedTransaction>[])
  final List<RemovedTransaction>? removed;
  @JsonKey(name: 'next_cursor')
  final String? nextCursor;
  @JsonKey(name: 'has_more')
  final bool? hasMore;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$TransactionsSyncResponseFromJson;
  static const toJsonFactory = _$TransactionsSyncResponseToJson;
  Map<String, dynamic> toJson() => _$TransactionsSyncResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransactionsSyncResponse &&
            (identical(other.added, added) ||
                const DeepCollectionEquality().equals(other.added, added)) &&
            (identical(other.modified, modified) ||
                const DeepCollectionEquality()
                    .equals(other.modified, modified)) &&
            (identical(other.removed, removed) ||
                const DeepCollectionEquality()
                    .equals(other.removed, removed)) &&
            (identical(other.nextCursor, nextCursor) ||
                const DeepCollectionEquality()
                    .equals(other.nextCursor, nextCursor)) &&
            (identical(other.hasMore, hasMore) ||
                const DeepCollectionEquality()
                    .equals(other.hasMore, hasMore)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(added) ^
      const DeepCollectionEquality().hash(modified) ^
      const DeepCollectionEquality().hash(removed) ^
      const DeepCollectionEquality().hash(nextCursor) ^
      const DeepCollectionEquality().hash(hasMore) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $TransactionsSyncResponseExtension on TransactionsSyncResponse {
  TransactionsSyncResponse copyWith(
      {List<Transaction>? added,
      List<Transaction>? modified,
      List<RemovedTransaction>? removed,
      String? nextCursor,
      bool? hasMore,
      String? requestId}) {
    return TransactionsSyncResponse(
        added: added ?? this.added,
        modified: modified ?? this.modified,
        removed: removed ?? this.removed,
        nextCursor: nextCursor ?? this.nextCursor,
        hasMore: hasMore ?? this.hasMore,
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class InstitutionsGetRequest {
  InstitutionsGetRequest({
    this.clientId,
    this.secret,
    this.count,
    this.offset,
    this.countryCodes,
    this.options,
  });

  factory InstitutionsGetRequest.fromJson(Map<String, dynamic> json) =>
      _$InstitutionsGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'count')
  final int? count;
  @JsonKey(name: 'offset')
  final int? offset;
  @JsonKey(
      name: 'country_codes',
      toJson: countryCodeListToJson,
      fromJson: countryCodeListFromJson)
  final List<enums.CountryCode>? countryCodes;
  @JsonKey(name: 'options')
  final InstitutionsGetRequestOptions? options;
  static const fromJsonFactory = _$InstitutionsGetRequestFromJson;
  static const toJsonFactory = _$InstitutionsGetRequestToJson;
  Map<String, dynamic> toJson() => _$InstitutionsGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InstitutionsGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)) &&
            (identical(other.offset, offset) ||
                const DeepCollectionEquality().equals(other.offset, offset)) &&
            (identical(other.countryCodes, countryCodes) ||
                const DeepCollectionEquality()
                    .equals(other.countryCodes, countryCodes)) &&
            (identical(other.options, options) ||
                const DeepCollectionEquality().equals(other.options, options)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(count) ^
      const DeepCollectionEquality().hash(offset) ^
      const DeepCollectionEquality().hash(countryCodes) ^
      const DeepCollectionEquality().hash(options) ^
      runtimeType.hashCode;
}

extension $InstitutionsGetRequestExtension on InstitutionsGetRequest {
  InstitutionsGetRequest copyWith(
      {String? clientId,
      String? secret,
      int? count,
      int? offset,
      List<enums.CountryCode>? countryCodes,
      InstitutionsGetRequestOptions? options}) {
    return InstitutionsGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        count: count ?? this.count,
        offset: offset ?? this.offset,
        countryCodes: countryCodes ?? this.countryCodes,
        options: options ?? this.options);
  }
}

@JsonSerializable(explicitToJson: true)
class InstitutionsGetRequestOptions {
  InstitutionsGetRequestOptions({
    this.products,
    this.routingNumbers,
    this.oauth,
    this.includeOptionalMetadata,
    this.includeAuthMetadata,
    this.includePaymentInitiationMetadata,
  });

  factory InstitutionsGetRequestOptions.fromJson(Map<String, dynamic> json) =>
      _$InstitutionsGetRequestOptionsFromJson(json);

  @JsonKey(
      name: 'products',
      toJson: productsListToJson,
      fromJson: productsListFromJson)
  final List<enums.Products>? products;
  @JsonKey(name: 'routing_numbers', defaultValue: <String>[])
  final List<String>? routingNumbers;
  @JsonKey(name: 'oauth')
  final bool? oauth;
  @JsonKey(name: 'include_optional_metadata')
  final bool? includeOptionalMetadata;
  @JsonKey(name: 'include_auth_metadata', defaultValue: false)
  final bool? includeAuthMetadata;
  @JsonKey(name: 'include_payment_initiation_metadata', defaultValue: false)
  final bool? includePaymentInitiationMetadata;
  static const fromJsonFactory = _$InstitutionsGetRequestOptionsFromJson;
  static const toJsonFactory = _$InstitutionsGetRequestOptionsToJson;
  Map<String, dynamic> toJson() => _$InstitutionsGetRequestOptionsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InstitutionsGetRequestOptions &&
            (identical(other.products, products) ||
                const DeepCollectionEquality()
                    .equals(other.products, products)) &&
            (identical(other.routingNumbers, routingNumbers) ||
                const DeepCollectionEquality()
                    .equals(other.routingNumbers, routingNumbers)) &&
            (identical(other.oauth, oauth) ||
                const DeepCollectionEquality().equals(other.oauth, oauth)) &&
            (identical(
                    other.includeOptionalMetadata, includeOptionalMetadata) ||
                const DeepCollectionEquality().equals(
                    other.includeOptionalMetadata, includeOptionalMetadata)) &&
            (identical(other.includeAuthMetadata, includeAuthMetadata) ||
                const DeepCollectionEquality()
                    .equals(other.includeAuthMetadata, includeAuthMetadata)) &&
            (identical(other.includePaymentInitiationMetadata,
                    includePaymentInitiationMetadata) ||
                const DeepCollectionEquality().equals(
                    other.includePaymentInitiationMetadata,
                    includePaymentInitiationMetadata)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(products) ^
      const DeepCollectionEquality().hash(routingNumbers) ^
      const DeepCollectionEquality().hash(oauth) ^
      const DeepCollectionEquality().hash(includeOptionalMetadata) ^
      const DeepCollectionEquality().hash(includeAuthMetadata) ^
      const DeepCollectionEquality().hash(includePaymentInitiationMetadata) ^
      runtimeType.hashCode;
}

extension $InstitutionsGetRequestOptionsExtension
    on InstitutionsGetRequestOptions {
  InstitutionsGetRequestOptions copyWith(
      {List<enums.Products>? products,
      List<String>? routingNumbers,
      bool? oauth,
      bool? includeOptionalMetadata,
      bool? includeAuthMetadata,
      bool? includePaymentInitiationMetadata}) {
    return InstitutionsGetRequestOptions(
        products: products ?? this.products,
        routingNumbers: routingNumbers ?? this.routingNumbers,
        oauth: oauth ?? this.oauth,
        includeOptionalMetadata:
            includeOptionalMetadata ?? this.includeOptionalMetadata,
        includeAuthMetadata: includeAuthMetadata ?? this.includeAuthMetadata,
        includePaymentInitiationMetadata: includePaymentInitiationMetadata ??
            this.includePaymentInitiationMetadata);
  }
}

@JsonSerializable(explicitToJson: true)
class InstitutionsGetResponse {
  InstitutionsGetResponse({
    this.institutions,
    this.total,
    this.requestId,
  });

  factory InstitutionsGetResponse.fromJson(Map<String, dynamic> json) =>
      _$InstitutionsGetResponseFromJson(json);

  @JsonKey(name: 'institutions', defaultValue: <Institution>[])
  final List<Institution>? institutions;
  @JsonKey(name: 'total')
  final int? total;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$InstitutionsGetResponseFromJson;
  static const toJsonFactory = _$InstitutionsGetResponseToJson;
  Map<String, dynamic> toJson() => _$InstitutionsGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InstitutionsGetResponse &&
            (identical(other.institutions, institutions) ||
                const DeepCollectionEquality()
                    .equals(other.institutions, institutions)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(institutions) ^
      const DeepCollectionEquality().hash(total) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $InstitutionsGetResponseExtension on InstitutionsGetResponse {
  InstitutionsGetResponse copyWith(
      {List<Institution>? institutions, int? total, String? requestId}) {
    return InstitutionsGetResponse(
        institutions: institutions ?? this.institutions,
        total: total ?? this.total,
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class InstitutionsSearchRequest {
  InstitutionsSearchRequest({
    this.clientId,
    this.secret,
    this.query,
    this.products,
    this.countryCodes,
    this.options,
  });

  factory InstitutionsSearchRequest.fromJson(Map<String, dynamic> json) =>
      _$InstitutionsSearchRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'query')
  final String? query;
  @JsonKey(
      name: 'products',
      toJson: productsListToJson,
      fromJson: productsListFromJson)
  final List<enums.Products>? products;
  @JsonKey(
      name: 'country_codes',
      toJson: countryCodeListToJson,
      fromJson: countryCodeListFromJson)
  final List<enums.CountryCode>? countryCodes;
  @JsonKey(name: 'options')
  final InstitutionsSearchRequestOptions? options;
  static const fromJsonFactory = _$InstitutionsSearchRequestFromJson;
  static const toJsonFactory = _$InstitutionsSearchRequestToJson;
  Map<String, dynamic> toJson() => _$InstitutionsSearchRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InstitutionsSearchRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.query, query) ||
                const DeepCollectionEquality().equals(other.query, query)) &&
            (identical(other.products, products) ||
                const DeepCollectionEquality()
                    .equals(other.products, products)) &&
            (identical(other.countryCodes, countryCodes) ||
                const DeepCollectionEquality()
                    .equals(other.countryCodes, countryCodes)) &&
            (identical(other.options, options) ||
                const DeepCollectionEquality().equals(other.options, options)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(query) ^
      const DeepCollectionEquality().hash(products) ^
      const DeepCollectionEquality().hash(countryCodes) ^
      const DeepCollectionEquality().hash(options) ^
      runtimeType.hashCode;
}

extension $InstitutionsSearchRequestExtension on InstitutionsSearchRequest {
  InstitutionsSearchRequest copyWith(
      {String? clientId,
      String? secret,
      String? query,
      List<enums.Products>? products,
      List<enums.CountryCode>? countryCodes,
      InstitutionsSearchRequestOptions? options}) {
    return InstitutionsSearchRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        query: query ?? this.query,
        products: products ?? this.products,
        countryCodes: countryCodes ?? this.countryCodes,
        options: options ?? this.options);
  }
}

@JsonSerializable(explicitToJson: true)
class InstitutionsSearchRequestOptions {
  InstitutionsSearchRequestOptions({
    this.oauth,
    this.includeOptionalMetadata,
    this.includeAuthMetadata,
    this.includePaymentInitiationMetadata,
    this.paymentInitiation,
  });

  factory InstitutionsSearchRequestOptions.fromJson(
          Map<String, dynamic> json) =>
      _$InstitutionsSearchRequestOptionsFromJson(json);

  @JsonKey(name: 'oauth')
  final bool? oauth;
  @JsonKey(name: 'include_optional_metadata')
  final bool? includeOptionalMetadata;
  @JsonKey(name: 'include_auth_metadata', defaultValue: false)
  final bool? includeAuthMetadata;
  @JsonKey(name: 'include_payment_initiation_metadata', defaultValue: false)
  final bool? includePaymentInitiationMetadata;
  @JsonKey(name: 'payment_initiation')
  final InstitutionsSearchPaymentInitiationOptions? paymentInitiation;
  static const fromJsonFactory = _$InstitutionsSearchRequestOptionsFromJson;
  static const toJsonFactory = _$InstitutionsSearchRequestOptionsToJson;
  Map<String, dynamic> toJson() =>
      _$InstitutionsSearchRequestOptionsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InstitutionsSearchRequestOptions &&
            (identical(other.oauth, oauth) ||
                const DeepCollectionEquality().equals(other.oauth, oauth)) &&
            (identical(
                    other.includeOptionalMetadata, includeOptionalMetadata) ||
                const DeepCollectionEquality().equals(
                    other.includeOptionalMetadata, includeOptionalMetadata)) &&
            (identical(other.includeAuthMetadata, includeAuthMetadata) ||
                const DeepCollectionEquality()
                    .equals(other.includeAuthMetadata, includeAuthMetadata)) &&
            (identical(other.includePaymentInitiationMetadata,
                    includePaymentInitiationMetadata) ||
                const DeepCollectionEquality().equals(
                    other.includePaymentInitiationMetadata,
                    includePaymentInitiationMetadata)) &&
            (identical(other.paymentInitiation, paymentInitiation) ||
                const DeepCollectionEquality()
                    .equals(other.paymentInitiation, paymentInitiation)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(oauth) ^
      const DeepCollectionEquality().hash(includeOptionalMetadata) ^
      const DeepCollectionEquality().hash(includeAuthMetadata) ^
      const DeepCollectionEquality().hash(includePaymentInitiationMetadata) ^
      const DeepCollectionEquality().hash(paymentInitiation) ^
      runtimeType.hashCode;
}

extension $InstitutionsSearchRequestOptionsExtension
    on InstitutionsSearchRequestOptions {
  InstitutionsSearchRequestOptions copyWith(
      {bool? oauth,
      bool? includeOptionalMetadata,
      bool? includeAuthMetadata,
      bool? includePaymentInitiationMetadata,
      InstitutionsSearchPaymentInitiationOptions? paymentInitiation}) {
    return InstitutionsSearchRequestOptions(
        oauth: oauth ?? this.oauth,
        includeOptionalMetadata:
            includeOptionalMetadata ?? this.includeOptionalMetadata,
        includeAuthMetadata: includeAuthMetadata ?? this.includeAuthMetadata,
        includePaymentInitiationMetadata: includePaymentInitiationMetadata ??
            this.includePaymentInitiationMetadata,
        paymentInitiation: paymentInitiation ?? this.paymentInitiation);
  }
}

@JsonSerializable(explicitToJson: true)
class InstitutionsSearchPaymentInitiationOptions {
  InstitutionsSearchPaymentInitiationOptions({
    this.paymentId,
  });

  factory InstitutionsSearchPaymentInitiationOptions.fromJson(
          Map<String, dynamic> json) =>
      _$InstitutionsSearchPaymentInitiationOptionsFromJson(json);

  @JsonKey(name: 'payment_id')
  final String? paymentId;
  static const fromJsonFactory =
      _$InstitutionsSearchPaymentInitiationOptionsFromJson;
  static const toJsonFactory =
      _$InstitutionsSearchPaymentInitiationOptionsToJson;
  Map<String, dynamic> toJson() =>
      _$InstitutionsSearchPaymentInitiationOptionsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InstitutionsSearchPaymentInitiationOptions &&
            (identical(other.paymentId, paymentId) ||
                const DeepCollectionEquality()
                    .equals(other.paymentId, paymentId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(paymentId) ^ runtimeType.hashCode;
}

extension $InstitutionsSearchPaymentInitiationOptionsExtension
    on InstitutionsSearchPaymentInitiationOptions {
  InstitutionsSearchPaymentInitiationOptions copyWith({String? paymentId}) {
    return InstitutionsSearchPaymentInitiationOptions(
        paymentId: paymentId ?? this.paymentId);
  }
}

@JsonSerializable(explicitToJson: true)
class InstitutionsSearchResponse {
  InstitutionsSearchResponse({
    this.institutions,
    this.requestId,
  });

  factory InstitutionsSearchResponse.fromJson(Map<String, dynamic> json) =>
      _$InstitutionsSearchResponseFromJson(json);

  @JsonKey(name: 'institutions', defaultValue: <Institution>[])
  final List<Institution>? institutions;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$InstitutionsSearchResponseFromJson;
  static const toJsonFactory = _$InstitutionsSearchResponseToJson;
  Map<String, dynamic> toJson() => _$InstitutionsSearchResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InstitutionsSearchResponse &&
            (identical(other.institutions, institutions) ||
                const DeepCollectionEquality()
                    .equals(other.institutions, institutions)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(institutions) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $InstitutionsSearchResponseExtension on InstitutionsSearchResponse {
  InstitutionsSearchResponse copyWith(
      {List<Institution>? institutions, String? requestId}) {
    return InstitutionsSearchResponse(
        institutions: institutions ?? this.institutions,
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class InstitutionsGetByIdRequest {
  InstitutionsGetByIdRequest({
    this.clientId,
    this.secret,
    this.institutionId,
    this.countryCodes,
    this.options,
  });

  factory InstitutionsGetByIdRequest.fromJson(Map<String, dynamic> json) =>
      _$InstitutionsGetByIdRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'institution_id')
  final String? institutionId;
  @JsonKey(
      name: 'country_codes',
      toJson: countryCodeListToJson,
      fromJson: countryCodeListFromJson)
  final List<enums.CountryCode>? countryCodes;
  @JsonKey(name: 'options')
  final InstitutionsGetByIdRequestOptions? options;
  static const fromJsonFactory = _$InstitutionsGetByIdRequestFromJson;
  static const toJsonFactory = _$InstitutionsGetByIdRequestToJson;
  Map<String, dynamic> toJson() => _$InstitutionsGetByIdRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InstitutionsGetByIdRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.institutionId, institutionId) ||
                const DeepCollectionEquality()
                    .equals(other.institutionId, institutionId)) &&
            (identical(other.countryCodes, countryCodes) ||
                const DeepCollectionEquality()
                    .equals(other.countryCodes, countryCodes)) &&
            (identical(other.options, options) ||
                const DeepCollectionEquality().equals(other.options, options)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(institutionId) ^
      const DeepCollectionEquality().hash(countryCodes) ^
      const DeepCollectionEquality().hash(options) ^
      runtimeType.hashCode;
}

extension $InstitutionsGetByIdRequestExtension on InstitutionsGetByIdRequest {
  InstitutionsGetByIdRequest copyWith(
      {String? clientId,
      String? secret,
      String? institutionId,
      List<enums.CountryCode>? countryCodes,
      InstitutionsGetByIdRequestOptions? options}) {
    return InstitutionsGetByIdRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        institutionId: institutionId ?? this.institutionId,
        countryCodes: countryCodes ?? this.countryCodes,
        options: options ?? this.options);
  }
}

@JsonSerializable(explicitToJson: true)
class InstitutionsGetByIdRequestOptions {
  InstitutionsGetByIdRequestOptions({
    this.includeOptionalMetadata,
    this.includeStatus,
    this.includeAuthMetadata,
    this.includePaymentInitiationMetadata,
  });

  factory InstitutionsGetByIdRequestOptions.fromJson(
          Map<String, dynamic> json) =>
      _$InstitutionsGetByIdRequestOptionsFromJson(json);

  @JsonKey(name: 'include_optional_metadata', defaultValue: false)
  final bool? includeOptionalMetadata;
  @JsonKey(name: 'include_status', defaultValue: false)
  final bool? includeStatus;
  @JsonKey(name: 'include_auth_metadata', defaultValue: false)
  final bool? includeAuthMetadata;
  @JsonKey(name: 'include_payment_initiation_metadata', defaultValue: false)
  final bool? includePaymentInitiationMetadata;
  static const fromJsonFactory = _$InstitutionsGetByIdRequestOptionsFromJson;
  static const toJsonFactory = _$InstitutionsGetByIdRequestOptionsToJson;
  Map<String, dynamic> toJson() =>
      _$InstitutionsGetByIdRequestOptionsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InstitutionsGetByIdRequestOptions &&
            (identical(
                    other.includeOptionalMetadata, includeOptionalMetadata) ||
                const DeepCollectionEquality().equals(
                    other.includeOptionalMetadata, includeOptionalMetadata)) &&
            (identical(other.includeStatus, includeStatus) ||
                const DeepCollectionEquality()
                    .equals(other.includeStatus, includeStatus)) &&
            (identical(other.includeAuthMetadata, includeAuthMetadata) ||
                const DeepCollectionEquality()
                    .equals(other.includeAuthMetadata, includeAuthMetadata)) &&
            (identical(other.includePaymentInitiationMetadata,
                    includePaymentInitiationMetadata) ||
                const DeepCollectionEquality().equals(
                    other.includePaymentInitiationMetadata,
                    includePaymentInitiationMetadata)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(includeOptionalMetadata) ^
      const DeepCollectionEquality().hash(includeStatus) ^
      const DeepCollectionEquality().hash(includeAuthMetadata) ^
      const DeepCollectionEquality().hash(includePaymentInitiationMetadata) ^
      runtimeType.hashCode;
}

extension $InstitutionsGetByIdRequestOptionsExtension
    on InstitutionsGetByIdRequestOptions {
  InstitutionsGetByIdRequestOptions copyWith(
      {bool? includeOptionalMetadata,
      bool? includeStatus,
      bool? includeAuthMetadata,
      bool? includePaymentInitiationMetadata}) {
    return InstitutionsGetByIdRequestOptions(
        includeOptionalMetadata:
            includeOptionalMetadata ?? this.includeOptionalMetadata,
        includeStatus: includeStatus ?? this.includeStatus,
        includeAuthMetadata: includeAuthMetadata ?? this.includeAuthMetadata,
        includePaymentInitiationMetadata: includePaymentInitiationMetadata ??
            this.includePaymentInitiationMetadata);
  }
}

@JsonSerializable(explicitToJson: true)
class InstitutionsGetByIdResponse {
  InstitutionsGetByIdResponse({
    this.institution,
    this.requestId,
  });

  factory InstitutionsGetByIdResponse.fromJson(Map<String, dynamic> json) =>
      _$InstitutionsGetByIdResponseFromJson(json);

  @JsonKey(name: 'institution')
  final Institution? institution;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$InstitutionsGetByIdResponseFromJson;
  static const toJsonFactory = _$InstitutionsGetByIdResponseToJson;
  Map<String, dynamic> toJson() => _$InstitutionsGetByIdResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InstitutionsGetByIdResponse &&
            (identical(other.institution, institution) ||
                const DeepCollectionEquality()
                    .equals(other.institution, institution)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(institution) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $InstitutionsGetByIdResponseExtension on InstitutionsGetByIdResponse {
  InstitutionsGetByIdResponse copyWith(
      {Institution? institution, String? requestId}) {
    return InstitutionsGetByIdResponse(
        institution: institution ?? this.institution,
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class ItemRemoveRequest {
  ItemRemoveRequest({
    this.clientId,
    this.secret,
    this.accessToken,
  });

  factory ItemRemoveRequest.fromJson(Map<String, dynamic> json) =>
      _$ItemRemoveRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'access_token')
  final String? accessToken;
  static const fromJsonFactory = _$ItemRemoveRequestFromJson;
  static const toJsonFactory = _$ItemRemoveRequestToJson;
  Map<String, dynamic> toJson() => _$ItemRemoveRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ItemRemoveRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(accessToken) ^
      runtimeType.hashCode;
}

extension $ItemRemoveRequestExtension on ItemRemoveRequest {
  ItemRemoveRequest copyWith(
      {String? clientId, String? secret, String? accessToken}) {
    return ItemRemoveRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        accessToken: accessToken ?? this.accessToken);
  }
}

@JsonSerializable(explicitToJson: true)
class ItemRemoveResponse {
  ItemRemoveResponse({
    this.requestId,
  });

  factory ItemRemoveResponse.fromJson(Map<String, dynamic> json) =>
      _$ItemRemoveResponseFromJson(json);

  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$ItemRemoveResponseFromJson;
  static const toJsonFactory = _$ItemRemoveResponseToJson;
  Map<String, dynamic> toJson() => _$ItemRemoveResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ItemRemoveResponse &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(requestId) ^ runtimeType.hashCode;
}

extension $ItemRemoveResponseExtension on ItemRemoveResponse {
  ItemRemoveResponse copyWith({String? requestId}) {
    return ItemRemoveResponse(requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class AccountsGetRequest {
  AccountsGetRequest({
    this.clientId,
    this.secret,
    this.accessToken,
    this.options,
  });

  factory AccountsGetRequest.fromJson(Map<String, dynamic> json) =>
      _$AccountsGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'access_token')
  final String? accessToken;
  @JsonKey(name: 'options')
  final AccountsGetRequestOptions? options;
  static const fromJsonFactory = _$AccountsGetRequestFromJson;
  static const toJsonFactory = _$AccountsGetRequestToJson;
  Map<String, dynamic> toJson() => _$AccountsGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AccountsGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)) &&
            (identical(other.options, options) ||
                const DeepCollectionEquality().equals(other.options, options)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(accessToken) ^
      const DeepCollectionEquality().hash(options) ^
      runtimeType.hashCode;
}

extension $AccountsGetRequestExtension on AccountsGetRequest {
  AccountsGetRequest copyWith(
      {String? clientId,
      String? secret,
      String? accessToken,
      AccountsGetRequestOptions? options}) {
    return AccountsGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        accessToken: accessToken ?? this.accessToken,
        options: options ?? this.options);
  }
}

@JsonSerializable(explicitToJson: true)
class AccountsGetRequestOptions {
  AccountsGetRequestOptions({
    this.accountIds,
  });

  factory AccountsGetRequestOptions.fromJson(Map<String, dynamic> json) =>
      _$AccountsGetRequestOptionsFromJson(json);

  @JsonKey(name: 'account_ids', defaultValue: <String>[])
  final List<String>? accountIds;
  static const fromJsonFactory = _$AccountsGetRequestOptionsFromJson;
  static const toJsonFactory = _$AccountsGetRequestOptionsToJson;
  Map<String, dynamic> toJson() => _$AccountsGetRequestOptionsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AccountsGetRequestOptions &&
            (identical(other.accountIds, accountIds) ||
                const DeepCollectionEquality()
                    .equals(other.accountIds, accountIds)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountIds) ^ runtimeType.hashCode;
}

extension $AccountsGetRequestOptionsExtension on AccountsGetRequestOptions {
  AccountsGetRequestOptions copyWith({List<String>? accountIds}) {
    return AccountsGetRequestOptions(accountIds: accountIds ?? this.accountIds);
  }
}

@JsonSerializable(explicitToJson: true)
class AccountsGetResponse {
  AccountsGetResponse({
    this.accounts,
    this.item,
    this.requestId,
  });

  factory AccountsGetResponse.fromJson(Map<String, dynamic> json) =>
      _$AccountsGetResponseFromJson(json);

  @JsonKey(name: 'accounts', defaultValue: <AccountBase>[])
  final List<AccountBase>? accounts;
  @JsonKey(name: 'item')
  final Item? item;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$AccountsGetResponseFromJson;
  static const toJsonFactory = _$AccountsGetResponseToJson;
  Map<String, dynamic> toJson() => _$AccountsGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AccountsGetResponse &&
            (identical(other.accounts, accounts) ||
                const DeepCollectionEquality()
                    .equals(other.accounts, accounts)) &&
            (identical(other.item, item) ||
                const DeepCollectionEquality().equals(other.item, item)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accounts) ^
      const DeepCollectionEquality().hash(item) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $AccountsGetResponseExtension on AccountsGetResponse {
  AccountsGetResponse copyWith(
      {List<AccountBase>? accounts, Item? item, String? requestId}) {
    return AccountsGetResponse(
        accounts: accounts ?? this.accounts,
        item: item ?? this.item,
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class CategoriesGetRequest {
  CategoriesGetRequest();

  factory CategoriesGetRequest.fromJson(Map<String, dynamic> json) =>
      _$CategoriesGetRequestFromJson(json);

  static const fromJsonFactory = _$CategoriesGetRequestFromJson;
  static const toJsonFactory = _$CategoriesGetRequestToJson;
  Map<String, dynamic> toJson() => _$CategoriesGetRequestToJson(this);

  @override
  int get hashCode => runtimeType.hashCode;
}

@JsonSerializable(explicitToJson: true)
class CategoriesGetResponse {
  CategoriesGetResponse({
    this.categories,
    this.requestId,
  });

  factory CategoriesGetResponse.fromJson(Map<String, dynamic> json) =>
      _$CategoriesGetResponseFromJson(json);

  @JsonKey(name: 'categories', defaultValue: <Category>[])
  final List<Category>? categories;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$CategoriesGetResponseFromJson;
  static const toJsonFactory = _$CategoriesGetResponseToJson;
  Map<String, dynamic> toJson() => _$CategoriesGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CategoriesGetResponse &&
            (identical(other.categories, categories) ||
                const DeepCollectionEquality()
                    .equals(other.categories, categories)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(categories) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $CategoriesGetResponseExtension on CategoriesGetResponse {
  CategoriesGetResponse copyWith(
      {List<Category>? categories, String? requestId}) {
    return CategoriesGetResponse(
        categories: categories ?? this.categories,
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class SandboxProcessorTokenCreateRequest {
  SandboxProcessorTokenCreateRequest({
    this.clientId,
    this.secret,
    this.institutionId,
    this.options,
  });

  factory SandboxProcessorTokenCreateRequest.fromJson(
          Map<String, dynamic> json) =>
      _$SandboxProcessorTokenCreateRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'institution_id')
  final String? institutionId;
  @JsonKey(name: 'options')
  final SandboxProcessorTokenCreateRequestOptions? options;
  static const fromJsonFactory = _$SandboxProcessorTokenCreateRequestFromJson;
  static const toJsonFactory = _$SandboxProcessorTokenCreateRequestToJson;
  Map<String, dynamic> toJson() =>
      _$SandboxProcessorTokenCreateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SandboxProcessorTokenCreateRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.institutionId, institutionId) ||
                const DeepCollectionEquality()
                    .equals(other.institutionId, institutionId)) &&
            (identical(other.options, options) ||
                const DeepCollectionEquality().equals(other.options, options)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(institutionId) ^
      const DeepCollectionEquality().hash(options) ^
      runtimeType.hashCode;
}

extension $SandboxProcessorTokenCreateRequestExtension
    on SandboxProcessorTokenCreateRequest {
  SandboxProcessorTokenCreateRequest copyWith(
      {String? clientId,
      String? secret,
      String? institutionId,
      SandboxProcessorTokenCreateRequestOptions? options}) {
    return SandboxProcessorTokenCreateRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        institutionId: institutionId ?? this.institutionId,
        options: options ?? this.options);
  }
}

@JsonSerializable(explicitToJson: true)
class SandboxProcessorTokenCreateRequestOptions {
  SandboxProcessorTokenCreateRequestOptions({
    this.overrideUsername,
    this.overridePassword,
  });

  factory SandboxProcessorTokenCreateRequestOptions.fromJson(
          Map<String, dynamic> json) =>
      _$SandboxProcessorTokenCreateRequestOptionsFromJson(json);

  @JsonKey(name: 'override_username')
  final String? overrideUsername;
  @JsonKey(name: 'override_password')
  final String? overridePassword;
  static const fromJsonFactory =
      _$SandboxProcessorTokenCreateRequestOptionsFromJson;
  static const toJsonFactory =
      _$SandboxProcessorTokenCreateRequestOptionsToJson;
  Map<String, dynamic> toJson() =>
      _$SandboxProcessorTokenCreateRequestOptionsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SandboxProcessorTokenCreateRequestOptions &&
            (identical(other.overrideUsername, overrideUsername) ||
                const DeepCollectionEquality()
                    .equals(other.overrideUsername, overrideUsername)) &&
            (identical(other.overridePassword, overridePassword) ||
                const DeepCollectionEquality()
                    .equals(other.overridePassword, overridePassword)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(overrideUsername) ^
      const DeepCollectionEquality().hash(overridePassword) ^
      runtimeType.hashCode;
}

extension $SandboxProcessorTokenCreateRequestOptionsExtension
    on SandboxProcessorTokenCreateRequestOptions {
  SandboxProcessorTokenCreateRequestOptions copyWith(
      {String? overrideUsername, String? overridePassword}) {
    return SandboxProcessorTokenCreateRequestOptions(
        overrideUsername: overrideUsername ?? this.overrideUsername,
        overridePassword: overridePassword ?? this.overridePassword);
  }
}

@JsonSerializable(explicitToJson: true)
class SandboxProcessorTokenCreateResponse {
  SandboxProcessorTokenCreateResponse({
    this.processorToken,
    this.requestId,
  });

  factory SandboxProcessorTokenCreateResponse.fromJson(
          Map<String, dynamic> json) =>
      _$SandboxProcessorTokenCreateResponseFromJson(json);

  @JsonKey(name: 'processor_token')
  final String? processorToken;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$SandboxProcessorTokenCreateResponseFromJson;
  static const toJsonFactory = _$SandboxProcessorTokenCreateResponseToJson;
  Map<String, dynamic> toJson() =>
      _$SandboxProcessorTokenCreateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SandboxProcessorTokenCreateResponse &&
            (identical(other.processorToken, processorToken) ||
                const DeepCollectionEquality()
                    .equals(other.processorToken, processorToken)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(processorToken) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $SandboxProcessorTokenCreateResponseExtension
    on SandboxProcessorTokenCreateResponse {
  SandboxProcessorTokenCreateResponse copyWith(
      {String? processorToken, String? requestId}) {
    return SandboxProcessorTokenCreateResponse(
        processorToken: processorToken ?? this.processorToken,
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class SandboxPublicTokenCreateRequest {
  SandboxPublicTokenCreateRequest({
    this.clientId,
    this.secret,
    this.institutionId,
    this.initialProducts,
    this.options,
  });

  factory SandboxPublicTokenCreateRequest.fromJson(Map<String, dynamic> json) =>
      _$SandboxPublicTokenCreateRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'institution_id')
  final String? institutionId;
  @JsonKey(
      name: 'initial_products',
      toJson: productsListToJson,
      fromJson: productsListFromJson)
  final List<enums.Products>? initialProducts;
  @JsonKey(name: 'options')
  final SandboxPublicTokenCreateRequestOptions? options;
  static const fromJsonFactory = _$SandboxPublicTokenCreateRequestFromJson;
  static const toJsonFactory = _$SandboxPublicTokenCreateRequestToJson;
  Map<String, dynamic> toJson() =>
      _$SandboxPublicTokenCreateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SandboxPublicTokenCreateRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.institutionId, institutionId) ||
                const DeepCollectionEquality()
                    .equals(other.institutionId, institutionId)) &&
            (identical(other.initialProducts, initialProducts) ||
                const DeepCollectionEquality()
                    .equals(other.initialProducts, initialProducts)) &&
            (identical(other.options, options) ||
                const DeepCollectionEquality().equals(other.options, options)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(institutionId) ^
      const DeepCollectionEquality().hash(initialProducts) ^
      const DeepCollectionEquality().hash(options) ^
      runtimeType.hashCode;
}

extension $SandboxPublicTokenCreateRequestExtension
    on SandboxPublicTokenCreateRequest {
  SandboxPublicTokenCreateRequest copyWith(
      {String? clientId,
      String? secret,
      String? institutionId,
      List<enums.Products>? initialProducts,
      SandboxPublicTokenCreateRequestOptions? options}) {
    return SandboxPublicTokenCreateRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        institutionId: institutionId ?? this.institutionId,
        initialProducts: initialProducts ?? this.initialProducts,
        options: options ?? this.options);
  }
}

@JsonSerializable(explicitToJson: true)
class SandboxPublicTokenCreateRequestOptions {
  SandboxPublicTokenCreateRequestOptions({
    this.webhook,
    this.overrideUsername,
    this.overridePassword,
    this.transactions,
  });

  factory SandboxPublicTokenCreateRequestOptions.fromJson(
          Map<String, dynamic> json) =>
      _$SandboxPublicTokenCreateRequestOptionsFromJson(json);

  @JsonKey(name: 'webhook')
  final String? webhook;
  @JsonKey(name: 'override_username')
  final String? overrideUsername;
  @JsonKey(name: 'override_password')
  final String? overridePassword;
  @JsonKey(name: 'transactions')
  final SandboxPublicTokenCreateRequestOptionsTransactions? transactions;
  static const fromJsonFactory =
      _$SandboxPublicTokenCreateRequestOptionsFromJson;
  static const toJsonFactory = _$SandboxPublicTokenCreateRequestOptionsToJson;
  Map<String, dynamic> toJson() =>
      _$SandboxPublicTokenCreateRequestOptionsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SandboxPublicTokenCreateRequestOptions &&
            (identical(other.webhook, webhook) ||
                const DeepCollectionEquality()
                    .equals(other.webhook, webhook)) &&
            (identical(other.overrideUsername, overrideUsername) ||
                const DeepCollectionEquality()
                    .equals(other.overrideUsername, overrideUsername)) &&
            (identical(other.overridePassword, overridePassword) ||
                const DeepCollectionEquality()
                    .equals(other.overridePassword, overridePassword)) &&
            (identical(other.transactions, transactions) ||
                const DeepCollectionEquality()
                    .equals(other.transactions, transactions)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(webhook) ^
      const DeepCollectionEquality().hash(overrideUsername) ^
      const DeepCollectionEquality().hash(overridePassword) ^
      const DeepCollectionEquality().hash(transactions) ^
      runtimeType.hashCode;
}

extension $SandboxPublicTokenCreateRequestOptionsExtension
    on SandboxPublicTokenCreateRequestOptions {
  SandboxPublicTokenCreateRequestOptions copyWith(
      {String? webhook,
      String? overrideUsername,
      String? overridePassword,
      SandboxPublicTokenCreateRequestOptionsTransactions? transactions}) {
    return SandboxPublicTokenCreateRequestOptions(
        webhook: webhook ?? this.webhook,
        overrideUsername: overrideUsername ?? this.overrideUsername,
        overridePassword: overridePassword ?? this.overridePassword,
        transactions: transactions ?? this.transactions);
  }
}

@JsonSerializable(explicitToJson: true)
class SandboxPublicTokenCreateRequestOptionsTransactions {
  SandboxPublicTokenCreateRequestOptionsTransactions({
    this.startDate,
    this.endDate,
  });

  factory SandboxPublicTokenCreateRequestOptionsTransactions.fromJson(
          Map<String, dynamic> json) =>
      _$SandboxPublicTokenCreateRequestOptionsTransactionsFromJson(json);

  @JsonKey(name: 'start_date', toJson: _dateToJson)
  final DateTime? startDate;
  @JsonKey(name: 'end_date', toJson: _dateToJson)
  final DateTime? endDate;
  static const fromJsonFactory =
      _$SandboxPublicTokenCreateRequestOptionsTransactionsFromJson;
  static const toJsonFactory =
      _$SandboxPublicTokenCreateRequestOptionsTransactionsToJson;
  Map<String, dynamic> toJson() =>
      _$SandboxPublicTokenCreateRequestOptionsTransactionsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SandboxPublicTokenCreateRequestOptionsTransactions &&
            (identical(other.startDate, startDate) ||
                const DeepCollectionEquality()
                    .equals(other.startDate, startDate)) &&
            (identical(other.endDate, endDate) ||
                const DeepCollectionEquality().equals(other.endDate, endDate)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(startDate) ^
      const DeepCollectionEquality().hash(endDate) ^
      runtimeType.hashCode;
}

extension $SandboxPublicTokenCreateRequestOptionsTransactionsExtension
    on SandboxPublicTokenCreateRequestOptionsTransactions {
  SandboxPublicTokenCreateRequestOptionsTransactions copyWith(
      {DateTime? startDate, DateTime? endDate}) {
    return SandboxPublicTokenCreateRequestOptionsTransactions(
        startDate: startDate ?? this.startDate,
        endDate: endDate ?? this.endDate);
  }
}

@JsonSerializable(explicitToJson: true)
class SandboxPublicTokenCreateResponse {
  SandboxPublicTokenCreateResponse({
    this.publicToken,
    this.requestId,
  });

  factory SandboxPublicTokenCreateResponse.fromJson(
          Map<String, dynamic> json) =>
      _$SandboxPublicTokenCreateResponseFromJson(json);

  @JsonKey(name: 'public_token')
  final String? publicToken;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$SandboxPublicTokenCreateResponseFromJson;
  static const toJsonFactory = _$SandboxPublicTokenCreateResponseToJson;
  Map<String, dynamic> toJson() =>
      _$SandboxPublicTokenCreateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SandboxPublicTokenCreateResponse &&
            (identical(other.publicToken, publicToken) ||
                const DeepCollectionEquality()
                    .equals(other.publicToken, publicToken)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(publicToken) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $SandboxPublicTokenCreateResponseExtension
    on SandboxPublicTokenCreateResponse {
  SandboxPublicTokenCreateResponse copyWith(
      {String? publicToken, String? requestId}) {
    return SandboxPublicTokenCreateResponse(
        publicToken: publicToken ?? this.publicToken,
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class SandboxItemFireWebhookRequest {
  SandboxItemFireWebhookRequest({
    this.clientId,
    this.secret,
    this.accessToken,
    this.webhookCode,
  });

  factory SandboxItemFireWebhookRequest.fromJson(Map<String, dynamic> json) =>
      _$SandboxItemFireWebhookRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'access_token')
  final String? accessToken;
  @JsonKey(
      name: 'webhook_code',
      toJson: sandboxItemFireWebhookRequestWebhookCodeToJson,
      fromJson: sandboxItemFireWebhookRequestWebhookCodeFromJson)
  final enums.SandboxItemFireWebhookRequestWebhookCode? webhookCode;
  static const fromJsonFactory = _$SandboxItemFireWebhookRequestFromJson;
  static const toJsonFactory = _$SandboxItemFireWebhookRequestToJson;
  Map<String, dynamic> toJson() => _$SandboxItemFireWebhookRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SandboxItemFireWebhookRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)) &&
            (identical(other.webhookCode, webhookCode) ||
                const DeepCollectionEquality()
                    .equals(other.webhookCode, webhookCode)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(accessToken) ^
      const DeepCollectionEquality().hash(webhookCode) ^
      runtimeType.hashCode;
}

extension $SandboxItemFireWebhookRequestExtension
    on SandboxItemFireWebhookRequest {
  SandboxItemFireWebhookRequest copyWith(
      {String? clientId,
      String? secret,
      String? accessToken,
      enums.SandboxItemFireWebhookRequestWebhookCode? webhookCode}) {
    return SandboxItemFireWebhookRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        accessToken: accessToken ?? this.accessToken,
        webhookCode: webhookCode ?? this.webhookCode);
  }
}

@JsonSerializable(explicitToJson: true)
class SandboxItemFireWebhookResponse {
  SandboxItemFireWebhookResponse({
    this.webhookFired,
    this.requestId,
  });

  factory SandboxItemFireWebhookResponse.fromJson(Map<String, dynamic> json) =>
      _$SandboxItemFireWebhookResponseFromJson(json);

  @JsonKey(name: 'webhook_fired')
  final bool? webhookFired;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$SandboxItemFireWebhookResponseFromJson;
  static const toJsonFactory = _$SandboxItemFireWebhookResponseToJson;
  Map<String, dynamic> toJson() => _$SandboxItemFireWebhookResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SandboxItemFireWebhookResponse &&
            (identical(other.webhookFired, webhookFired) ||
                const DeepCollectionEquality()
                    .equals(other.webhookFired, webhookFired)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(webhookFired) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $SandboxItemFireWebhookResponseExtension
    on SandboxItemFireWebhookResponse {
  SandboxItemFireWebhookResponse copyWith(
      {bool? webhookFired, String? requestId}) {
    return SandboxItemFireWebhookResponse(
        webhookFired: webhookFired ?? this.webhookFired,
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class AccountsBalanceGetRequest {
  AccountsBalanceGetRequest({
    this.accessToken,
    this.secret,
    this.clientId,
    this.options,
  });

  factory AccountsBalanceGetRequest.fromJson(Map<String, dynamic> json) =>
      _$AccountsBalanceGetRequestFromJson(json);

  @JsonKey(name: 'access_token')
  final String? accessToken;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'options')
  final AccountsBalanceGetRequestOptions? options;
  static const fromJsonFactory = _$AccountsBalanceGetRequestFromJson;
  static const toJsonFactory = _$AccountsBalanceGetRequestToJson;
  Map<String, dynamic> toJson() => _$AccountsBalanceGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AccountsBalanceGetRequest &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.options, options) ||
                const DeepCollectionEquality().equals(other.options, options)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accessToken) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(options) ^
      runtimeType.hashCode;
}

extension $AccountsBalanceGetRequestExtension on AccountsBalanceGetRequest {
  AccountsBalanceGetRequest copyWith(
      {String? accessToken,
      String? secret,
      String? clientId,
      AccountsBalanceGetRequestOptions? options}) {
    return AccountsBalanceGetRequest(
        accessToken: accessToken ?? this.accessToken,
        secret: secret ?? this.secret,
        clientId: clientId ?? this.clientId,
        options: options ?? this.options);
  }
}

@JsonSerializable(explicitToJson: true)
class AccountsBalanceGetRequestOptions {
  AccountsBalanceGetRequestOptions({
    this.accountIds,
    this.minLastUpdatedDatetime,
  });

  factory AccountsBalanceGetRequestOptions.fromJson(
          Map<String, dynamic> json) =>
      _$AccountsBalanceGetRequestOptionsFromJson(json);

  @JsonKey(name: 'account_ids', defaultValue: <String>[])
  final List<String>? accountIds;
  @JsonKey(name: 'min_last_updated_datetime')
  final DateTime? minLastUpdatedDatetime;
  static const fromJsonFactory = _$AccountsBalanceGetRequestOptionsFromJson;
  static const toJsonFactory = _$AccountsBalanceGetRequestOptionsToJson;
  Map<String, dynamic> toJson() =>
      _$AccountsBalanceGetRequestOptionsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AccountsBalanceGetRequestOptions &&
            (identical(other.accountIds, accountIds) ||
                const DeepCollectionEquality()
                    .equals(other.accountIds, accountIds)) &&
            (identical(other.minLastUpdatedDatetime, minLastUpdatedDatetime) ||
                const DeepCollectionEquality().equals(
                    other.minLastUpdatedDatetime, minLastUpdatedDatetime)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountIds) ^
      const DeepCollectionEquality().hash(minLastUpdatedDatetime) ^
      runtimeType.hashCode;
}

extension $AccountsBalanceGetRequestOptionsExtension
    on AccountsBalanceGetRequestOptions {
  AccountsBalanceGetRequestOptions copyWith(
      {List<String>? accountIds, DateTime? minLastUpdatedDatetime}) {
    return AccountsBalanceGetRequestOptions(
        accountIds: accountIds ?? this.accountIds,
        minLastUpdatedDatetime:
            minLastUpdatedDatetime ?? this.minLastUpdatedDatetime);
  }
}

@JsonSerializable(explicitToJson: true)
class IdentityGetRequest {
  IdentityGetRequest({
    this.clientId,
    this.secret,
    this.accessToken,
    this.options,
  });

  factory IdentityGetRequest.fromJson(Map<String, dynamic> json) =>
      _$IdentityGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'access_token')
  final String? accessToken;
  @JsonKey(name: 'options')
  final IdentityGetRequestOptions? options;
  static const fromJsonFactory = _$IdentityGetRequestFromJson;
  static const toJsonFactory = _$IdentityGetRequestToJson;
  Map<String, dynamic> toJson() => _$IdentityGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IdentityGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)) &&
            (identical(other.options, options) ||
                const DeepCollectionEquality().equals(other.options, options)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(accessToken) ^
      const DeepCollectionEquality().hash(options) ^
      runtimeType.hashCode;
}

extension $IdentityGetRequestExtension on IdentityGetRequest {
  IdentityGetRequest copyWith(
      {String? clientId,
      String? secret,
      String? accessToken,
      IdentityGetRequestOptions? options}) {
    return IdentityGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        accessToken: accessToken ?? this.accessToken,
        options: options ?? this.options);
  }
}

@JsonSerializable(explicitToJson: true)
class IdentityGetRequestOptions {
  IdentityGetRequestOptions({
    this.accountIds,
  });

  factory IdentityGetRequestOptions.fromJson(Map<String, dynamic> json) =>
      _$IdentityGetRequestOptionsFromJson(json);

  @JsonKey(name: 'account_ids', defaultValue: <String>[])
  final List<String>? accountIds;
  static const fromJsonFactory = _$IdentityGetRequestOptionsFromJson;
  static const toJsonFactory = _$IdentityGetRequestOptionsToJson;
  Map<String, dynamic> toJson() => _$IdentityGetRequestOptionsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IdentityGetRequestOptions &&
            (identical(other.accountIds, accountIds) ||
                const DeepCollectionEquality()
                    .equals(other.accountIds, accountIds)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountIds) ^ runtimeType.hashCode;
}

extension $IdentityGetRequestOptionsExtension on IdentityGetRequestOptions {
  IdentityGetRequestOptions copyWith({List<String>? accountIds}) {
    return IdentityGetRequestOptions(accountIds: accountIds ?? this.accountIds);
  }
}

@JsonSerializable(explicitToJson: true)
class IdentityGetResponse {
  IdentityGetResponse({
    this.accounts,
    this.item,
    this.requestId,
  });

  factory IdentityGetResponse.fromJson(Map<String, dynamic> json) =>
      _$IdentityGetResponseFromJson(json);

  @JsonKey(name: 'accounts', defaultValue: <AccountIdentity>[])
  final List<AccountIdentity>? accounts;
  @JsonKey(name: 'item')
  final Item? item;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$IdentityGetResponseFromJson;
  static const toJsonFactory = _$IdentityGetResponseToJson;
  Map<String, dynamic> toJson() => _$IdentityGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IdentityGetResponse &&
            (identical(other.accounts, accounts) ||
                const DeepCollectionEquality()
                    .equals(other.accounts, accounts)) &&
            (identical(other.item, item) ||
                const DeepCollectionEquality().equals(other.item, item)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accounts) ^
      const DeepCollectionEquality().hash(item) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $IdentityGetResponseExtension on IdentityGetResponse {
  IdentityGetResponse copyWith(
      {List<AccountIdentity>? accounts, Item? item, String? requestId}) {
    return IdentityGetResponse(
        accounts: accounts ?? this.accounts,
        item: item ?? this.item,
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class ProcessorAuthGetRequest {
  ProcessorAuthGetRequest({
    this.clientId,
    this.secret,
    this.processorToken,
  });

  factory ProcessorAuthGetRequest.fromJson(Map<String, dynamic> json) =>
      _$ProcessorAuthGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'processor_token')
  final String? processorToken;
  static const fromJsonFactory = _$ProcessorAuthGetRequestFromJson;
  static const toJsonFactory = _$ProcessorAuthGetRequestToJson;
  Map<String, dynamic> toJson() => _$ProcessorAuthGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ProcessorAuthGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.processorToken, processorToken) ||
                const DeepCollectionEquality()
                    .equals(other.processorToken, processorToken)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(processorToken) ^
      runtimeType.hashCode;
}

extension $ProcessorAuthGetRequestExtension on ProcessorAuthGetRequest {
  ProcessorAuthGetRequest copyWith(
      {String? clientId, String? secret, String? processorToken}) {
    return ProcessorAuthGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        processorToken: processorToken ?? this.processorToken);
  }
}

@JsonSerializable(explicitToJson: true)
class ProcessorAuthGetResponse {
  ProcessorAuthGetResponse({
    this.requestId,
    this.numbers,
    this.account,
  });

  factory ProcessorAuthGetResponse.fromJson(Map<String, dynamic> json) =>
      _$ProcessorAuthGetResponseFromJson(json);

  @JsonKey(name: 'request_id')
  final String? requestId;
  @JsonKey(name: 'numbers')
  final ProcessorNumber? numbers;
  @JsonKey(name: 'account')
  final AccountBase? account;
  static const fromJsonFactory = _$ProcessorAuthGetResponseFromJson;
  static const toJsonFactory = _$ProcessorAuthGetResponseToJson;
  Map<String, dynamic> toJson() => _$ProcessorAuthGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ProcessorAuthGetResponse &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)) &&
            (identical(other.numbers, numbers) ||
                const DeepCollectionEquality()
                    .equals(other.numbers, numbers)) &&
            (identical(other.account, account) ||
                const DeepCollectionEquality().equals(other.account, account)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(requestId) ^
      const DeepCollectionEquality().hash(numbers) ^
      const DeepCollectionEquality().hash(account) ^
      runtimeType.hashCode;
}

extension $ProcessorAuthGetResponseExtension on ProcessorAuthGetResponse {
  ProcessorAuthGetResponse copyWith(
      {String? requestId, ProcessorNumber? numbers, AccountBase? account}) {
    return ProcessorAuthGetResponse(
        requestId: requestId ?? this.requestId,
        numbers: numbers ?? this.numbers,
        account: account ?? this.account);
  }
}

@JsonSerializable(explicitToJson: true)
class ProcessorBankTransferCreateRequest {
  ProcessorBankTransferCreateRequest({
    this.clientId,
    this.secret,
    this.idempotencyKey,
    this.processorToken,
    this.type,
    this.network,
    this.amount,
    this.isoCurrencyCode,
    this.description,
    this.achClass,
    this.user,
    this.customTag,
    this.metadata,
    this.originationAccountId,
  });

  factory ProcessorBankTransferCreateRequest.fromJson(
          Map<String, dynamic> json) =>
      _$ProcessorBankTransferCreateRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'idempotency_key')
  final String? idempotencyKey;
  @JsonKey(name: 'processor_token')
  final String? processorToken;
  @JsonKey(
      name: 'type',
      toJson: bankTransferTypeToJson,
      fromJson: bankTransferTypeFromJson)
  final enums.BankTransferType? type;
  @JsonKey(
      name: 'network',
      toJson: bankTransferNetworkToJson,
      fromJson: bankTransferNetworkFromJson)
  final enums.BankTransferNetwork? network;
  @JsonKey(name: 'amount')
  final String? amount;
  @JsonKey(name: 'iso_currency_code')
  final String? isoCurrencyCode;
  @JsonKey(name: 'description')
  final String? description;
  @JsonKey(
      name: 'ach_class', toJson: aCHClassToJson, fromJson: aCHClassFromJson)
  final enums.ACHClass? achClass;
  @JsonKey(name: 'user')
  final BankTransferUser? user;
  @JsonKey(name: 'custom_tag')
  final String? customTag;
  @JsonKey(name: 'metadata')
  final BankTransferMetadata? metadata;
  @JsonKey(name: 'origination_account_id')
  final String? originationAccountId;
  static const fromJsonFactory = _$ProcessorBankTransferCreateRequestFromJson;
  static const toJsonFactory = _$ProcessorBankTransferCreateRequestToJson;
  Map<String, dynamic> toJson() =>
      _$ProcessorBankTransferCreateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ProcessorBankTransferCreateRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.idempotencyKey, idempotencyKey) ||
                const DeepCollectionEquality()
                    .equals(other.idempotencyKey, idempotencyKey)) &&
            (identical(other.processorToken, processorToken) ||
                const DeepCollectionEquality()
                    .equals(other.processorToken, processorToken)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.network, network) ||
                const DeepCollectionEquality()
                    .equals(other.network, network)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.achClass, achClass) ||
                const DeepCollectionEquality()
                    .equals(other.achClass, achClass)) &&
            (identical(other.user, user) ||
                const DeepCollectionEquality().equals(other.user, user)) &&
            (identical(other.customTag, customTag) ||
                const DeepCollectionEquality()
                    .equals(other.customTag, customTag)) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality()
                    .equals(other.metadata, metadata)) &&
            (identical(other.originationAccountId, originationAccountId) ||
                const DeepCollectionEquality()
                    .equals(other.originationAccountId, originationAccountId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(idempotencyKey) ^
      const DeepCollectionEquality().hash(processorToken) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(network) ^
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(achClass) ^
      const DeepCollectionEquality().hash(user) ^
      const DeepCollectionEquality().hash(customTag) ^
      const DeepCollectionEquality().hash(metadata) ^
      const DeepCollectionEquality().hash(originationAccountId) ^
      runtimeType.hashCode;
}

extension $ProcessorBankTransferCreateRequestExtension
    on ProcessorBankTransferCreateRequest {
  ProcessorBankTransferCreateRequest copyWith(
      {String? clientId,
      String? secret,
      String? idempotencyKey,
      String? processorToken,
      enums.BankTransferType? type,
      enums.BankTransferNetwork? network,
      String? amount,
      String? isoCurrencyCode,
      String? description,
      enums.ACHClass? achClass,
      BankTransferUser? user,
      String? customTag,
      BankTransferMetadata? metadata,
      String? originationAccountId}) {
    return ProcessorBankTransferCreateRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        idempotencyKey: idempotencyKey ?? this.idempotencyKey,
        processorToken: processorToken ?? this.processorToken,
        type: type ?? this.type,
        network: network ?? this.network,
        amount: amount ?? this.amount,
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode,
        description: description ?? this.description,
        achClass: achClass ?? this.achClass,
        user: user ?? this.user,
        customTag: customTag ?? this.customTag,
        metadata: metadata ?? this.metadata,
        originationAccountId:
            originationAccountId ?? this.originationAccountId);
  }
}

@JsonSerializable(explicitToJson: true)
class ProcessorBankTransferCreateResponse {
  ProcessorBankTransferCreateResponse({
    this.bankTransfer,
    this.requestId,
  });

  factory ProcessorBankTransferCreateResponse.fromJson(
          Map<String, dynamic> json) =>
      _$ProcessorBankTransferCreateResponseFromJson(json);

  @JsonKey(name: 'bank_transfer')
  final BankTransfer? bankTransfer;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$ProcessorBankTransferCreateResponseFromJson;
  static const toJsonFactory = _$ProcessorBankTransferCreateResponseToJson;
  Map<String, dynamic> toJson() =>
      _$ProcessorBankTransferCreateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ProcessorBankTransferCreateResponse &&
            (identical(other.bankTransfer, bankTransfer) ||
                const DeepCollectionEquality()
                    .equals(other.bankTransfer, bankTransfer)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(bankTransfer) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $ProcessorBankTransferCreateResponseExtension
    on ProcessorBankTransferCreateResponse {
  ProcessorBankTransferCreateResponse copyWith(
      {BankTransfer? bankTransfer, String? requestId}) {
    return ProcessorBankTransferCreateResponse(
        bankTransfer: bankTransfer ?? this.bankTransfer,
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class ProcessorNumber {
  ProcessorNumber({
    this.ach,
    this.eft,
    this.international,
    this.bacs,
  });

  factory ProcessorNumber.fromJson(Map<String, dynamic> json) =>
      _$ProcessorNumberFromJson(json);

  @JsonKey(name: 'ach')
  final NumbersACHNullable? ach;
  @JsonKey(name: 'eft')
  final NumbersEFTNullable? eft;
  @JsonKey(name: 'international')
  final NumbersInternationalNullable? international;
  @JsonKey(name: 'bacs')
  final NumbersBACSNullable? bacs;
  static const fromJsonFactory = _$ProcessorNumberFromJson;
  static const toJsonFactory = _$ProcessorNumberToJson;
  Map<String, dynamic> toJson() => _$ProcessorNumberToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ProcessorNumber &&
            (identical(other.ach, ach) ||
                const DeepCollectionEquality().equals(other.ach, ach)) &&
            (identical(other.eft, eft) ||
                const DeepCollectionEquality().equals(other.eft, eft)) &&
            (identical(other.international, international) ||
                const DeepCollectionEquality()
                    .equals(other.international, international)) &&
            (identical(other.bacs, bacs) ||
                const DeepCollectionEquality().equals(other.bacs, bacs)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ach) ^
      const DeepCollectionEquality().hash(eft) ^
      const DeepCollectionEquality().hash(international) ^
      const DeepCollectionEquality().hash(bacs) ^
      runtimeType.hashCode;
}

extension $ProcessorNumberExtension on ProcessorNumber {
  ProcessorNumber copyWith(
      {NumbersACHNullable? ach,
      NumbersEFTNullable? eft,
      NumbersInternationalNullable? international,
      NumbersBACSNullable? bacs}) {
    return ProcessorNumber(
        ach: ach ?? this.ach,
        eft: eft ?? this.eft,
        international: international ?? this.international,
        bacs: bacs ?? this.bacs);
  }
}

@JsonSerializable(explicitToJson: true)
class ProcessorIdentityGetRequest {
  ProcessorIdentityGetRequest({
    this.clientId,
    this.secret,
    this.processorToken,
  });

  factory ProcessorIdentityGetRequest.fromJson(Map<String, dynamic> json) =>
      _$ProcessorIdentityGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'processor_token')
  final String? processorToken;
  static const fromJsonFactory = _$ProcessorIdentityGetRequestFromJson;
  static const toJsonFactory = _$ProcessorIdentityGetRequestToJson;
  Map<String, dynamic> toJson() => _$ProcessorIdentityGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ProcessorIdentityGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.processorToken, processorToken) ||
                const DeepCollectionEquality()
                    .equals(other.processorToken, processorToken)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(processorToken) ^
      runtimeType.hashCode;
}

extension $ProcessorIdentityGetRequestExtension on ProcessorIdentityGetRequest {
  ProcessorIdentityGetRequest copyWith(
      {String? clientId, String? secret, String? processorToken}) {
    return ProcessorIdentityGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        processorToken: processorToken ?? this.processorToken);
  }
}

@JsonSerializable(explicitToJson: true)
class ProcessorIdentityGetResponse {
  ProcessorIdentityGetResponse({
    this.account,
    this.requestId,
  });

  factory ProcessorIdentityGetResponse.fromJson(Map<String, dynamic> json) =>
      _$ProcessorIdentityGetResponseFromJson(json);

  @JsonKey(name: 'account')
  final AccountIdentity? account;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$ProcessorIdentityGetResponseFromJson;
  static const toJsonFactory = _$ProcessorIdentityGetResponseToJson;
  Map<String, dynamic> toJson() => _$ProcessorIdentityGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ProcessorIdentityGetResponse &&
            (identical(other.account, account) ||
                const DeepCollectionEquality()
                    .equals(other.account, account)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(account) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $ProcessorIdentityGetResponseExtension
    on ProcessorIdentityGetResponse {
  ProcessorIdentityGetResponse copyWith(
      {AccountIdentity? account, String? requestId}) {
    return ProcessorIdentityGetResponse(
        account: account ?? this.account,
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class ProcessorBalanceGetRequest {
  ProcessorBalanceGetRequest({
    this.clientId,
    this.secret,
    this.processorToken,
    this.options,
  });

  factory ProcessorBalanceGetRequest.fromJson(Map<String, dynamic> json) =>
      _$ProcessorBalanceGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'processor_token')
  final String? processorToken;
  @JsonKey(name: 'options')
  final ProcessorBalanceGetRequestOptions? options;
  static const fromJsonFactory = _$ProcessorBalanceGetRequestFromJson;
  static const toJsonFactory = _$ProcessorBalanceGetRequestToJson;
  Map<String, dynamic> toJson() => _$ProcessorBalanceGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ProcessorBalanceGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.processorToken, processorToken) ||
                const DeepCollectionEquality()
                    .equals(other.processorToken, processorToken)) &&
            (identical(other.options, options) ||
                const DeepCollectionEquality().equals(other.options, options)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(processorToken) ^
      const DeepCollectionEquality().hash(options) ^
      runtimeType.hashCode;
}

extension $ProcessorBalanceGetRequestExtension on ProcessorBalanceGetRequest {
  ProcessorBalanceGetRequest copyWith(
      {String? clientId,
      String? secret,
      String? processorToken,
      ProcessorBalanceGetRequestOptions? options}) {
    return ProcessorBalanceGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        processorToken: processorToken ?? this.processorToken,
        options: options ?? this.options);
  }
}

@JsonSerializable(explicitToJson: true)
class ProcessorBalanceGetRequestOptions {
  ProcessorBalanceGetRequestOptions({
    this.minLastUpdatedDatetime,
  });

  factory ProcessorBalanceGetRequestOptions.fromJson(
          Map<String, dynamic> json) =>
      _$ProcessorBalanceGetRequestOptionsFromJson(json);

  @JsonKey(name: 'min_last_updated_datetime')
  final DateTime? minLastUpdatedDatetime;
  static const fromJsonFactory = _$ProcessorBalanceGetRequestOptionsFromJson;
  static const toJsonFactory = _$ProcessorBalanceGetRequestOptionsToJson;
  Map<String, dynamic> toJson() =>
      _$ProcessorBalanceGetRequestOptionsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ProcessorBalanceGetRequestOptions &&
            (identical(other.minLastUpdatedDatetime, minLastUpdatedDatetime) ||
                const DeepCollectionEquality().equals(
                    other.minLastUpdatedDatetime, minLastUpdatedDatetime)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(minLastUpdatedDatetime) ^
      runtimeType.hashCode;
}

extension $ProcessorBalanceGetRequestOptionsExtension
    on ProcessorBalanceGetRequestOptions {
  ProcessorBalanceGetRequestOptions copyWith(
      {DateTime? minLastUpdatedDatetime}) {
    return ProcessorBalanceGetRequestOptions(
        minLastUpdatedDatetime:
            minLastUpdatedDatetime ?? this.minLastUpdatedDatetime);
  }
}

@JsonSerializable(explicitToJson: true)
class ProcessorBalanceGetResponse {
  ProcessorBalanceGetResponse({
    this.account,
    this.requestId,
  });

  factory ProcessorBalanceGetResponse.fromJson(Map<String, dynamic> json) =>
      _$ProcessorBalanceGetResponseFromJson(json);

  @JsonKey(name: 'account')
  final AccountBase? account;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$ProcessorBalanceGetResponseFromJson;
  static const toJsonFactory = _$ProcessorBalanceGetResponseToJson;
  Map<String, dynamic> toJson() => _$ProcessorBalanceGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ProcessorBalanceGetResponse &&
            (identical(other.account, account) ||
                const DeepCollectionEquality()
                    .equals(other.account, account)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(account) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $ProcessorBalanceGetResponseExtension on ProcessorBalanceGetResponse {
  ProcessorBalanceGetResponse copyWith(
      {AccountBase? account, String? requestId}) {
    return ProcessorBalanceGetResponse(
        account: account ?? this.account,
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class ItemWebhookUpdateRequest {
  ItemWebhookUpdateRequest({
    this.clientId,
    this.secret,
    this.accessToken,
    this.webhook,
  });

  factory ItemWebhookUpdateRequest.fromJson(Map<String, dynamic> json) =>
      _$ItemWebhookUpdateRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'access_token')
  final String? accessToken;
  @JsonKey(name: 'webhook')
  final String? webhook;
  static const fromJsonFactory = _$ItemWebhookUpdateRequestFromJson;
  static const toJsonFactory = _$ItemWebhookUpdateRequestToJson;
  Map<String, dynamic> toJson() => _$ItemWebhookUpdateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ItemWebhookUpdateRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)) &&
            (identical(other.webhook, webhook) ||
                const DeepCollectionEquality().equals(other.webhook, webhook)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(accessToken) ^
      const DeepCollectionEquality().hash(webhook) ^
      runtimeType.hashCode;
}

extension $ItemWebhookUpdateRequestExtension on ItemWebhookUpdateRequest {
  ItemWebhookUpdateRequest copyWith(
      {String? clientId,
      String? secret,
      String? accessToken,
      String? webhook}) {
    return ItemWebhookUpdateRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        accessToken: accessToken ?? this.accessToken,
        webhook: webhook ?? this.webhook);
  }
}

@JsonSerializable(explicitToJson: true)
class ItemWebhookUpdateResponse {
  ItemWebhookUpdateResponse({
    this.item,
    this.requestId,
  });

  factory ItemWebhookUpdateResponse.fromJson(Map<String, dynamic> json) =>
      _$ItemWebhookUpdateResponseFromJson(json);

  @JsonKey(name: 'item')
  final Item? item;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$ItemWebhookUpdateResponseFromJson;
  static const toJsonFactory = _$ItemWebhookUpdateResponseToJson;
  Map<String, dynamic> toJson() => _$ItemWebhookUpdateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ItemWebhookUpdateResponse &&
            (identical(other.item, item) ||
                const DeepCollectionEquality().equals(other.item, item)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(item) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $ItemWebhookUpdateResponseExtension on ItemWebhookUpdateResponse {
  ItemWebhookUpdateResponse copyWith({Item? item, String? requestId}) {
    return ItemWebhookUpdateResponse(
        item: item ?? this.item, requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class ItemAccessTokenInvalidateRequest {
  ItemAccessTokenInvalidateRequest({
    this.clientId,
    this.secret,
    this.accessToken,
  });

  factory ItemAccessTokenInvalidateRequest.fromJson(
          Map<String, dynamic> json) =>
      _$ItemAccessTokenInvalidateRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'access_token')
  final String? accessToken;
  static const fromJsonFactory = _$ItemAccessTokenInvalidateRequestFromJson;
  static const toJsonFactory = _$ItemAccessTokenInvalidateRequestToJson;
  Map<String, dynamic> toJson() =>
      _$ItemAccessTokenInvalidateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ItemAccessTokenInvalidateRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(accessToken) ^
      runtimeType.hashCode;
}

extension $ItemAccessTokenInvalidateRequestExtension
    on ItemAccessTokenInvalidateRequest {
  ItemAccessTokenInvalidateRequest copyWith(
      {String? clientId, String? secret, String? accessToken}) {
    return ItemAccessTokenInvalidateRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        accessToken: accessToken ?? this.accessToken);
  }
}

@JsonSerializable(explicitToJson: true)
class ItemAccessTokenInvalidateResponse {
  ItemAccessTokenInvalidateResponse({
    this.newAccessToken,
    this.requestId,
  });

  factory ItemAccessTokenInvalidateResponse.fromJson(
          Map<String, dynamic> json) =>
      _$ItemAccessTokenInvalidateResponseFromJson(json);

  @JsonKey(name: 'new_access_token')
  final String? newAccessToken;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$ItemAccessTokenInvalidateResponseFromJson;
  static const toJsonFactory = _$ItemAccessTokenInvalidateResponseToJson;
  Map<String, dynamic> toJson() =>
      _$ItemAccessTokenInvalidateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ItemAccessTokenInvalidateResponse &&
            (identical(other.newAccessToken, newAccessToken) ||
                const DeepCollectionEquality()
                    .equals(other.newAccessToken, newAccessToken)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(newAccessToken) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $ItemAccessTokenInvalidateResponseExtension
    on ItemAccessTokenInvalidateResponse {
  ItemAccessTokenInvalidateResponse copyWith(
      {String? newAccessToken, String? requestId}) {
    return ItemAccessTokenInvalidateResponse(
        newAccessToken: newAccessToken ?? this.newAccessToken,
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class WebhookVerificationKeyGetRequest {
  WebhookVerificationKeyGetRequest({
    this.clientId,
    this.secret,
    this.keyId,
  });

  factory WebhookVerificationKeyGetRequest.fromJson(
          Map<String, dynamic> json) =>
      _$WebhookVerificationKeyGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'key_id')
  final String? keyId;
  static const fromJsonFactory = _$WebhookVerificationKeyGetRequestFromJson;
  static const toJsonFactory = _$WebhookVerificationKeyGetRequestToJson;
  Map<String, dynamic> toJson() =>
      _$WebhookVerificationKeyGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WebhookVerificationKeyGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.keyId, keyId) ||
                const DeepCollectionEquality().equals(other.keyId, keyId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(keyId) ^
      runtimeType.hashCode;
}

extension $WebhookVerificationKeyGetRequestExtension
    on WebhookVerificationKeyGetRequest {
  WebhookVerificationKeyGetRequest copyWith(
      {String? clientId, String? secret, String? keyId}) {
    return WebhookVerificationKeyGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        keyId: keyId ?? this.keyId);
  }
}

@JsonSerializable(explicitToJson: true)
class WebhookVerificationKeyGetResponse {
  WebhookVerificationKeyGetResponse({
    this.key,
    this.requestId,
  });

  factory WebhookVerificationKeyGetResponse.fromJson(
          Map<String, dynamic> json) =>
      _$WebhookVerificationKeyGetResponseFromJson(json);

  @JsonKey(name: 'key')
  final JWKPublicKey? key;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$WebhookVerificationKeyGetResponseFromJson;
  static const toJsonFactory = _$WebhookVerificationKeyGetResponseToJson;
  Map<String, dynamic> toJson() =>
      _$WebhookVerificationKeyGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WebhookVerificationKeyGetResponse &&
            (identical(other.key, key) ||
                const DeepCollectionEquality().equals(other.key, key)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(key) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $WebhookVerificationKeyGetResponseExtension
    on WebhookVerificationKeyGetResponse {
  WebhookVerificationKeyGetResponse copyWith(
      {JWKPublicKey? key, String? requestId}) {
    return WebhookVerificationKeyGetResponse(
        key: key ?? this.key, requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class JWKPublicKey {
  JWKPublicKey({
    this.alg,
    this.crv,
    this.kid,
    this.kty,
    this.use,
    this.x,
    this.y,
    this.createdAt,
    this.expiredAt,
  });

  factory JWKPublicKey.fromJson(Map<String, dynamic> json) =>
      _$JWKPublicKeyFromJson(json);

  @JsonKey(name: 'alg')
  final String? alg;
  @JsonKey(name: 'crv')
  final String? crv;
  @JsonKey(name: 'kid')
  final String? kid;
  @JsonKey(name: 'kty')
  final String? kty;
  @JsonKey(name: 'use')
  final String? use;
  @JsonKey(name: 'x')
  final String? x;
  @JsonKey(name: 'y')
  final String? y;
  @JsonKey(name: 'created_at')
  final int? createdAt;
  @JsonKey(name: 'expired_at')
  final int? expiredAt;
  static const fromJsonFactory = _$JWKPublicKeyFromJson;
  static const toJsonFactory = _$JWKPublicKeyToJson;
  Map<String, dynamic> toJson() => _$JWKPublicKeyToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is JWKPublicKey &&
            (identical(other.alg, alg) ||
                const DeepCollectionEquality().equals(other.alg, alg)) &&
            (identical(other.crv, crv) ||
                const DeepCollectionEquality().equals(other.crv, crv)) &&
            (identical(other.kid, kid) ||
                const DeepCollectionEquality().equals(other.kid, kid)) &&
            (identical(other.kty, kty) ||
                const DeepCollectionEquality().equals(other.kty, kty)) &&
            (identical(other.use, use) ||
                const DeepCollectionEquality().equals(other.use, use)) &&
            (identical(other.x, x) ||
                const DeepCollectionEquality().equals(other.x, x)) &&
            (identical(other.y, y) ||
                const DeepCollectionEquality().equals(other.y, y)) &&
            (identical(other.createdAt, createdAt) ||
                const DeepCollectionEquality()
                    .equals(other.createdAt, createdAt)) &&
            (identical(other.expiredAt, expiredAt) ||
                const DeepCollectionEquality()
                    .equals(other.expiredAt, expiredAt)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(alg) ^
      const DeepCollectionEquality().hash(crv) ^
      const DeepCollectionEquality().hash(kid) ^
      const DeepCollectionEquality().hash(kty) ^
      const DeepCollectionEquality().hash(use) ^
      const DeepCollectionEquality().hash(x) ^
      const DeepCollectionEquality().hash(y) ^
      const DeepCollectionEquality().hash(createdAt) ^
      const DeepCollectionEquality().hash(expiredAt) ^
      runtimeType.hashCode;
}

extension $JWKPublicKeyExtension on JWKPublicKey {
  JWKPublicKey copyWith(
      {String? alg,
      String? crv,
      String? kid,
      String? kty,
      String? use,
      String? x,
      String? y,
      int? createdAt,
      int? expiredAt}) {
    return JWKPublicKey(
        alg: alg ?? this.alg,
        crv: crv ?? this.crv,
        kid: kid ?? this.kid,
        kty: kty ?? this.kty,
        use: use ?? this.use,
        x: x ?? this.x,
        y: y ?? this.y,
        createdAt: createdAt ?? this.createdAt,
        expiredAt: expiredAt ?? this.expiredAt);
  }
}

@JsonSerializable(explicitToJson: true)
class LiabilitiesGetRequest {
  LiabilitiesGetRequest({
    this.clientId,
    this.secret,
    this.accessToken,
    this.options,
  });

  factory LiabilitiesGetRequest.fromJson(Map<String, dynamic> json) =>
      _$LiabilitiesGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'access_token')
  final String? accessToken;
  @JsonKey(name: 'options')
  final LiabilitiesGetRequestOptions? options;
  static const fromJsonFactory = _$LiabilitiesGetRequestFromJson;
  static const toJsonFactory = _$LiabilitiesGetRequestToJson;
  Map<String, dynamic> toJson() => _$LiabilitiesGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LiabilitiesGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)) &&
            (identical(other.options, options) ||
                const DeepCollectionEquality().equals(other.options, options)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(accessToken) ^
      const DeepCollectionEquality().hash(options) ^
      runtimeType.hashCode;
}

extension $LiabilitiesGetRequestExtension on LiabilitiesGetRequest {
  LiabilitiesGetRequest copyWith(
      {String? clientId,
      String? secret,
      String? accessToken,
      LiabilitiesGetRequestOptions? options}) {
    return LiabilitiesGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        accessToken: accessToken ?? this.accessToken,
        options: options ?? this.options);
  }
}

@JsonSerializable(explicitToJson: true)
class LiabilitiesGetRequestOptions {
  LiabilitiesGetRequestOptions({
    this.accountIds,
  });

  factory LiabilitiesGetRequestOptions.fromJson(Map<String, dynamic> json) =>
      _$LiabilitiesGetRequestOptionsFromJson(json);

  @JsonKey(name: 'account_ids', defaultValue: <String>[])
  final List<String>? accountIds;
  static const fromJsonFactory = _$LiabilitiesGetRequestOptionsFromJson;
  static const toJsonFactory = _$LiabilitiesGetRequestOptionsToJson;
  Map<String, dynamic> toJson() => _$LiabilitiesGetRequestOptionsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LiabilitiesGetRequestOptions &&
            (identical(other.accountIds, accountIds) ||
                const DeepCollectionEquality()
                    .equals(other.accountIds, accountIds)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountIds) ^ runtimeType.hashCode;
}

extension $LiabilitiesGetRequestOptionsExtension
    on LiabilitiesGetRequestOptions {
  LiabilitiesGetRequestOptions copyWith({List<String>? accountIds}) {
    return LiabilitiesGetRequestOptions(
        accountIds: accountIds ?? this.accountIds);
  }
}

@JsonSerializable(explicitToJson: true)
class LiabilitiesGetResponse {
  LiabilitiesGetResponse({
    this.accounts,
    this.item,
    this.liabilities,
    this.requestId,
  });

  factory LiabilitiesGetResponse.fromJson(Map<String, dynamic> json) =>
      _$LiabilitiesGetResponseFromJson(json);

  @JsonKey(name: 'accounts', defaultValue: <AccountBase>[])
  final List<AccountBase>? accounts;
  @JsonKey(name: 'item')
  final Item? item;
  @JsonKey(name: 'liabilities')
  final LiabilitiesObject? liabilities;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$LiabilitiesGetResponseFromJson;
  static const toJsonFactory = _$LiabilitiesGetResponseToJson;
  Map<String, dynamic> toJson() => _$LiabilitiesGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LiabilitiesGetResponse &&
            (identical(other.accounts, accounts) ||
                const DeepCollectionEquality()
                    .equals(other.accounts, accounts)) &&
            (identical(other.item, item) ||
                const DeepCollectionEquality().equals(other.item, item)) &&
            (identical(other.liabilities, liabilities) ||
                const DeepCollectionEquality()
                    .equals(other.liabilities, liabilities)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accounts) ^
      const DeepCollectionEquality().hash(item) ^
      const DeepCollectionEquality().hash(liabilities) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $LiabilitiesGetResponseExtension on LiabilitiesGetResponse {
  LiabilitiesGetResponse copyWith(
      {List<AccountBase>? accounts,
      Item? item,
      LiabilitiesObject? liabilities,
      String? requestId}) {
    return LiabilitiesGetResponse(
        accounts: accounts ?? this.accounts,
        item: item ?? this.item,
        liabilities: liabilities ?? this.liabilities,
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentInitiationRecipientCreateRequest {
  PaymentInitiationRecipientCreateRequest({
    this.clientId,
    this.secret,
    this.name,
    this.iban,
    this.bacs,
    this.address,
  });

  factory PaymentInitiationRecipientCreateRequest.fromJson(
          Map<String, dynamic> json) =>
      _$PaymentInitiationRecipientCreateRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'iban')
  final String? iban;
  @JsonKey(name: 'bacs')
  final RecipientBACSNullable? bacs;
  @JsonKey(name: 'address')
  final PaymentInitiationAddress? address;
  static const fromJsonFactory =
      _$PaymentInitiationRecipientCreateRequestFromJson;
  static const toJsonFactory = _$PaymentInitiationRecipientCreateRequestToJson;
  Map<String, dynamic> toJson() =>
      _$PaymentInitiationRecipientCreateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentInitiationRecipientCreateRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.iban, iban) ||
                const DeepCollectionEquality().equals(other.iban, iban)) &&
            (identical(other.bacs, bacs) ||
                const DeepCollectionEquality().equals(other.bacs, bacs)) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality().equals(other.address, address)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(iban) ^
      const DeepCollectionEquality().hash(bacs) ^
      const DeepCollectionEquality().hash(address) ^
      runtimeType.hashCode;
}

extension $PaymentInitiationRecipientCreateRequestExtension
    on PaymentInitiationRecipientCreateRequest {
  PaymentInitiationRecipientCreateRequest copyWith(
      {String? clientId,
      String? secret,
      String? name,
      String? iban,
      RecipientBACSNullable? bacs,
      PaymentInitiationAddress? address}) {
    return PaymentInitiationRecipientCreateRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        name: name ?? this.name,
        iban: iban ?? this.iban,
        bacs: bacs ?? this.bacs,
        address: address ?? this.address);
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentInitiationRecipientCreateResponse {
  PaymentInitiationRecipientCreateResponse({
    this.recipientId,
    this.requestId,
  });

  factory PaymentInitiationRecipientCreateResponse.fromJson(
          Map<String, dynamic> json) =>
      _$PaymentInitiationRecipientCreateResponseFromJson(json);

  @JsonKey(name: 'recipient_id')
  final String? recipientId;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory =
      _$PaymentInitiationRecipientCreateResponseFromJson;
  static const toJsonFactory = _$PaymentInitiationRecipientCreateResponseToJson;
  Map<String, dynamic> toJson() =>
      _$PaymentInitiationRecipientCreateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentInitiationRecipientCreateResponse &&
            (identical(other.recipientId, recipientId) ||
                const DeepCollectionEquality()
                    .equals(other.recipientId, recipientId)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(recipientId) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $PaymentInitiationRecipientCreateResponseExtension
    on PaymentInitiationRecipientCreateResponse {
  PaymentInitiationRecipientCreateResponse copyWith(
      {String? recipientId, String? requestId}) {
    return PaymentInitiationRecipientCreateResponse(
        recipientId: recipientId ?? this.recipientId,
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentInitiationPaymentReverseResponse {
  PaymentInitiationPaymentReverseResponse({
    this.refundId,
    this.status,
    this.requestId,
  });

  factory PaymentInitiationPaymentReverseResponse.fromJson(
          Map<String, dynamic> json) =>
      _$PaymentInitiationPaymentReverseResponseFromJson(json);

  @JsonKey(name: 'refund_id')
  final String? refundId;
  @JsonKey(
      name: 'status',
      toJson: paymentInitiationPaymentReverseResponseStatusToJson,
      fromJson: paymentInitiationPaymentReverseResponseStatusFromJson)
  final enums.PaymentInitiationPaymentReverseResponseStatus? status;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory =
      _$PaymentInitiationPaymentReverseResponseFromJson;
  static const toJsonFactory = _$PaymentInitiationPaymentReverseResponseToJson;
  Map<String, dynamic> toJson() =>
      _$PaymentInitiationPaymentReverseResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentInitiationPaymentReverseResponse &&
            (identical(other.refundId, refundId) ||
                const DeepCollectionEquality()
                    .equals(other.refundId, refundId)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(refundId) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $PaymentInitiationPaymentReverseResponseExtension
    on PaymentInitiationPaymentReverseResponse {
  PaymentInitiationPaymentReverseResponse copyWith(
      {String? refundId,
      enums.PaymentInitiationPaymentReverseResponseStatus? status,
      String? requestId}) {
    return PaymentInitiationPaymentReverseResponse(
        refundId: refundId ?? this.refundId,
        status: status ?? this.status,
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentInitiationRecipientGetRequest {
  PaymentInitiationRecipientGetRequest({
    this.clientId,
    this.secret,
    this.recipientId,
  });

  factory PaymentInitiationRecipientGetRequest.fromJson(
          Map<String, dynamic> json) =>
      _$PaymentInitiationRecipientGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'recipient_id')
  final String? recipientId;
  static const fromJsonFactory = _$PaymentInitiationRecipientGetRequestFromJson;
  static const toJsonFactory = _$PaymentInitiationRecipientGetRequestToJson;
  Map<String, dynamic> toJson() =>
      _$PaymentInitiationRecipientGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentInitiationRecipientGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.recipientId, recipientId) ||
                const DeepCollectionEquality()
                    .equals(other.recipientId, recipientId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(recipientId) ^
      runtimeType.hashCode;
}

extension $PaymentInitiationRecipientGetRequestExtension
    on PaymentInitiationRecipientGetRequest {
  PaymentInitiationRecipientGetRequest copyWith(
      {String? clientId, String? secret, String? recipientId}) {
    return PaymentInitiationRecipientGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        recipientId: recipientId ?? this.recipientId);
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentInitiationRecipientGetResponse {
  PaymentInitiationRecipientGetResponse({
    this.requestId,
    this.recipientId,
    this.name,
    this.address,
    this.iban,
    this.bacs,
    this.emiRecipientId,
  });

  factory PaymentInitiationRecipientGetResponse.fromJson(
          Map<String, dynamic> json) =>
      _$PaymentInitiationRecipientGetResponseFromJson(json);

  @JsonKey(name: 'request_id')
  final String? requestId;
  @JsonKey(name: 'recipient_id')
  final String? recipientId;
  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'address')
  final PaymentInitiationAddress? address;
  @JsonKey(name: 'iban')
  final String? iban;
  @JsonKey(name: 'bacs')
  final RecipientBACSNullable? bacs;
  @JsonKey(name: 'emi_recipient_id')
  final String? emiRecipientId;
  static const fromJsonFactory =
      _$PaymentInitiationRecipientGetResponseFromJson;
  static const toJsonFactory = _$PaymentInitiationRecipientGetResponseToJson;
  Map<String, dynamic> toJson() =>
      _$PaymentInitiationRecipientGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentInitiationRecipientGetResponse &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)) &&
            (identical(other.recipientId, recipientId) ||
                const DeepCollectionEquality()
                    .equals(other.recipientId, recipientId)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality()
                    .equals(other.address, address)) &&
            (identical(other.iban, iban) ||
                const DeepCollectionEquality().equals(other.iban, iban)) &&
            (identical(other.bacs, bacs) ||
                const DeepCollectionEquality().equals(other.bacs, bacs)) &&
            (identical(other.emiRecipientId, emiRecipientId) ||
                const DeepCollectionEquality()
                    .equals(other.emiRecipientId, emiRecipientId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(requestId) ^
      const DeepCollectionEquality().hash(recipientId) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(iban) ^
      const DeepCollectionEquality().hash(bacs) ^
      const DeepCollectionEquality().hash(emiRecipientId) ^
      runtimeType.hashCode;
}

extension $PaymentInitiationRecipientGetResponseExtension
    on PaymentInitiationRecipientGetResponse {
  PaymentInitiationRecipientGetResponse copyWith(
      {String? requestId,
      String? recipientId,
      String? name,
      PaymentInitiationAddress? address,
      String? iban,
      RecipientBACSNullable? bacs,
      String? emiRecipientId}) {
    return PaymentInitiationRecipientGetResponse(
        requestId: requestId ?? this.requestId,
        recipientId: recipientId ?? this.recipientId,
        name: name ?? this.name,
        address: address ?? this.address,
        iban: iban ?? this.iban,
        bacs: bacs ?? this.bacs,
        emiRecipientId: emiRecipientId ?? this.emiRecipientId);
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentInitiationRecipient {
  PaymentInitiationRecipient({
    this.recipientId,
    this.name,
    this.address,
    this.iban,
    this.bacs,
    this.emiRecipientId,
  });

  factory PaymentInitiationRecipient.fromJson(Map<String, dynamic> json) =>
      _$PaymentInitiationRecipientFromJson(json);

  @JsonKey(name: 'recipient_id')
  final String? recipientId;
  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'address')
  final PaymentInitiationAddress? address;
  @JsonKey(name: 'iban')
  final String? iban;
  @JsonKey(name: 'bacs')
  final RecipientBACSNullable? bacs;
  @JsonKey(name: 'emi_recipient_id')
  final String? emiRecipientId;
  static const fromJsonFactory = _$PaymentInitiationRecipientFromJson;
  static const toJsonFactory = _$PaymentInitiationRecipientToJson;
  Map<String, dynamic> toJson() => _$PaymentInitiationRecipientToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentInitiationRecipient &&
            (identical(other.recipientId, recipientId) ||
                const DeepCollectionEquality()
                    .equals(other.recipientId, recipientId)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality()
                    .equals(other.address, address)) &&
            (identical(other.iban, iban) ||
                const DeepCollectionEquality().equals(other.iban, iban)) &&
            (identical(other.bacs, bacs) ||
                const DeepCollectionEquality().equals(other.bacs, bacs)) &&
            (identical(other.emiRecipientId, emiRecipientId) ||
                const DeepCollectionEquality()
                    .equals(other.emiRecipientId, emiRecipientId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(recipientId) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(iban) ^
      const DeepCollectionEquality().hash(bacs) ^
      const DeepCollectionEquality().hash(emiRecipientId) ^
      runtimeType.hashCode;
}

extension $PaymentInitiationRecipientExtension on PaymentInitiationRecipient {
  PaymentInitiationRecipient copyWith(
      {String? recipientId,
      String? name,
      PaymentInitiationAddress? address,
      String? iban,
      RecipientBACSNullable? bacs,
      String? emiRecipientId}) {
    return PaymentInitiationRecipient(
        recipientId: recipientId ?? this.recipientId,
        name: name ?? this.name,
        address: address ?? this.address,
        iban: iban ?? this.iban,
        bacs: bacs ?? this.bacs,
        emiRecipientId: emiRecipientId ?? this.emiRecipientId);
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentInitiationRecipientListRequest {
  PaymentInitiationRecipientListRequest({
    this.clientId,
    this.secret,
  });

  factory PaymentInitiationRecipientListRequest.fromJson(
          Map<String, dynamic> json) =>
      _$PaymentInitiationRecipientListRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  static const fromJsonFactory =
      _$PaymentInitiationRecipientListRequestFromJson;
  static const toJsonFactory = _$PaymentInitiationRecipientListRequestToJson;
  Map<String, dynamic> toJson() =>
      _$PaymentInitiationRecipientListRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentInitiationRecipientListRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      runtimeType.hashCode;
}

extension $PaymentInitiationRecipientListRequestExtension
    on PaymentInitiationRecipientListRequest {
  PaymentInitiationRecipientListRequest copyWith(
      {String? clientId, String? secret}) {
    return PaymentInitiationRecipientListRequest(
        clientId: clientId ?? this.clientId, secret: secret ?? this.secret);
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentInitiationRecipientListResponse {
  PaymentInitiationRecipientListResponse({
    this.recipients,
    this.requestId,
  });

  factory PaymentInitiationRecipientListResponse.fromJson(
          Map<String, dynamic> json) =>
      _$PaymentInitiationRecipientListResponseFromJson(json);

  @JsonKey(name: 'recipients', defaultValue: <PaymentInitiationRecipient>[])
  final List<PaymentInitiationRecipient>? recipients;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory =
      _$PaymentInitiationRecipientListResponseFromJson;
  static const toJsonFactory = _$PaymentInitiationRecipientListResponseToJson;
  Map<String, dynamic> toJson() =>
      _$PaymentInitiationRecipientListResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentInitiationRecipientListResponse &&
            (identical(other.recipients, recipients) ||
                const DeepCollectionEquality()
                    .equals(other.recipients, recipients)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(recipients) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $PaymentInitiationRecipientListResponseExtension
    on PaymentInitiationRecipientListResponse {
  PaymentInitiationRecipientListResponse copyWith(
      {List<PaymentInitiationRecipient>? recipients, String? requestId}) {
    return PaymentInitiationRecipientListResponse(
        recipients: recipients ?? this.recipients,
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentInitiationPaymentCreateRequest {
  PaymentInitiationPaymentCreateRequest({
    this.clientId,
    this.secret,
    this.recipientId,
    this.reference,
    this.amount,
    this.schedule,
    this.options,
  });

  factory PaymentInitiationPaymentCreateRequest.fromJson(
          Map<String, dynamic> json) =>
      _$PaymentInitiationPaymentCreateRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'recipient_id')
  final String? recipientId;
  @JsonKey(name: 'reference')
  final String? reference;
  @JsonKey(name: 'amount')
  final PaymentAmount? amount;
  @JsonKey(name: 'schedule')
  final ExternalPaymentScheduleRequest? schedule;
  @JsonKey(name: 'options')
  final ExternalPaymentOptions? options;
  static const fromJsonFactory =
      _$PaymentInitiationPaymentCreateRequestFromJson;
  static const toJsonFactory = _$PaymentInitiationPaymentCreateRequestToJson;
  Map<String, dynamic> toJson() =>
      _$PaymentInitiationPaymentCreateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentInitiationPaymentCreateRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.recipientId, recipientId) ||
                const DeepCollectionEquality()
                    .equals(other.recipientId, recipientId)) &&
            (identical(other.reference, reference) ||
                const DeepCollectionEquality()
                    .equals(other.reference, reference)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.schedule, schedule) ||
                const DeepCollectionEquality()
                    .equals(other.schedule, schedule)) &&
            (identical(other.options, options) ||
                const DeepCollectionEquality().equals(other.options, options)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(recipientId) ^
      const DeepCollectionEquality().hash(reference) ^
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(schedule) ^
      const DeepCollectionEquality().hash(options) ^
      runtimeType.hashCode;
}

extension $PaymentInitiationPaymentCreateRequestExtension
    on PaymentInitiationPaymentCreateRequest {
  PaymentInitiationPaymentCreateRequest copyWith(
      {String? clientId,
      String? secret,
      String? recipientId,
      String? reference,
      PaymentAmount? amount,
      ExternalPaymentScheduleRequest? schedule,
      ExternalPaymentOptions? options}) {
    return PaymentInitiationPaymentCreateRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        recipientId: recipientId ?? this.recipientId,
        reference: reference ?? this.reference,
        amount: amount ?? this.amount,
        schedule: schedule ?? this.schedule,
        options: options ?? this.options);
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentInitiationPaymentReverseRequest {
  PaymentInitiationPaymentReverseRequest({
    this.clientId,
    this.secret,
    this.paymentId,
  });

  factory PaymentInitiationPaymentReverseRequest.fromJson(
          Map<String, dynamic> json) =>
      _$PaymentInitiationPaymentReverseRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'payment_id')
  final String? paymentId;
  static const fromJsonFactory =
      _$PaymentInitiationPaymentReverseRequestFromJson;
  static const toJsonFactory = _$PaymentInitiationPaymentReverseRequestToJson;
  Map<String, dynamic> toJson() =>
      _$PaymentInitiationPaymentReverseRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentInitiationPaymentReverseRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.paymentId, paymentId) ||
                const DeepCollectionEquality()
                    .equals(other.paymentId, paymentId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(paymentId) ^
      runtimeType.hashCode;
}

extension $PaymentInitiationPaymentReverseRequestExtension
    on PaymentInitiationPaymentReverseRequest {
  PaymentInitiationPaymentReverseRequest copyWith(
      {String? clientId, String? secret, String? paymentId}) {
    return PaymentInitiationPaymentReverseRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        paymentId: paymentId ?? this.paymentId);
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentInitiationPaymentCreateResponse {
  PaymentInitiationPaymentCreateResponse({
    this.paymentId,
    this.status,
    this.requestId,
  });

  factory PaymentInitiationPaymentCreateResponse.fromJson(
          Map<String, dynamic> json) =>
      _$PaymentInitiationPaymentCreateResponseFromJson(json);

  @JsonKey(name: 'payment_id')
  final String? paymentId;
  @JsonKey(
      name: 'status',
      toJson: paymentInitiationPaymentCreateResponseStatusToJson,
      fromJson: paymentInitiationPaymentCreateResponseStatusFromJson)
  final enums.PaymentInitiationPaymentCreateResponseStatus? status;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory =
      _$PaymentInitiationPaymentCreateResponseFromJson;
  static const toJsonFactory = _$PaymentInitiationPaymentCreateResponseToJson;
  Map<String, dynamic> toJson() =>
      _$PaymentInitiationPaymentCreateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentInitiationPaymentCreateResponse &&
            (identical(other.paymentId, paymentId) ||
                const DeepCollectionEquality()
                    .equals(other.paymentId, paymentId)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(paymentId) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $PaymentInitiationPaymentCreateResponseExtension
    on PaymentInitiationPaymentCreateResponse {
  PaymentInitiationPaymentCreateResponse copyWith(
      {String? paymentId,
      enums.PaymentInitiationPaymentCreateResponseStatus? status,
      String? requestId}) {
    return PaymentInitiationPaymentCreateResponse(
        paymentId: paymentId ?? this.paymentId,
        status: status ?? this.status,
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class SandboxItemResetLoginRequest {
  SandboxItemResetLoginRequest({
    this.clientId,
    this.secret,
    this.accessToken,
  });

  factory SandboxItemResetLoginRequest.fromJson(Map<String, dynamic> json) =>
      _$SandboxItemResetLoginRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'access_token')
  final String? accessToken;
  static const fromJsonFactory = _$SandboxItemResetLoginRequestFromJson;
  static const toJsonFactory = _$SandboxItemResetLoginRequestToJson;
  Map<String, dynamic> toJson() => _$SandboxItemResetLoginRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SandboxItemResetLoginRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(accessToken) ^
      runtimeType.hashCode;
}

extension $SandboxItemResetLoginRequestExtension
    on SandboxItemResetLoginRequest {
  SandboxItemResetLoginRequest copyWith(
      {String? clientId, String? secret, String? accessToken}) {
    return SandboxItemResetLoginRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        accessToken: accessToken ?? this.accessToken);
  }
}

@JsonSerializable(explicitToJson: true)
class SandboxItemResetLoginResponse {
  SandboxItemResetLoginResponse({
    this.resetLogin,
    this.requestId,
  });

  factory SandboxItemResetLoginResponse.fromJson(Map<String, dynamic> json) =>
      _$SandboxItemResetLoginResponseFromJson(json);

  @JsonKey(name: 'reset_login')
  final bool? resetLogin;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$SandboxItemResetLoginResponseFromJson;
  static const toJsonFactory = _$SandboxItemResetLoginResponseToJson;
  Map<String, dynamic> toJson() => _$SandboxItemResetLoginResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SandboxItemResetLoginResponse &&
            (identical(other.resetLogin, resetLogin) ||
                const DeepCollectionEquality()
                    .equals(other.resetLogin, resetLogin)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(resetLogin) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $SandboxItemResetLoginResponseExtension
    on SandboxItemResetLoginResponse {
  SandboxItemResetLoginResponse copyWith(
      {bool? resetLogin, String? requestId}) {
    return SandboxItemResetLoginResponse(
        resetLogin: resetLogin ?? this.resetLogin,
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class SandboxItemSetVerificationStatusRequest {
  SandboxItemSetVerificationStatusRequest({
    this.clientId,
    this.secret,
    this.accessToken,
    this.accountId,
    this.verificationStatus,
  });

  factory SandboxItemSetVerificationStatusRequest.fromJson(
          Map<String, dynamic> json) =>
      _$SandboxItemSetVerificationStatusRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'access_token')
  final String? accessToken;
  @JsonKey(name: 'account_id')
  final String? accountId;
  @JsonKey(
      name: 'verification_status',
      toJson: sandboxItemSetVerificationStatusRequestVerificationStatusToJson,
      fromJson:
          sandboxItemSetVerificationStatusRequestVerificationStatusFromJson)
  final enums.SandboxItemSetVerificationStatusRequestVerificationStatus?
      verificationStatus;
  static const fromJsonFactory =
      _$SandboxItemSetVerificationStatusRequestFromJson;
  static const toJsonFactory = _$SandboxItemSetVerificationStatusRequestToJson;
  Map<String, dynamic> toJson() =>
      _$SandboxItemSetVerificationStatusRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SandboxItemSetVerificationStatusRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)) &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.verificationStatus, verificationStatus) ||
                const DeepCollectionEquality()
                    .equals(other.verificationStatus, verificationStatus)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(accessToken) ^
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(verificationStatus) ^
      runtimeType.hashCode;
}

extension $SandboxItemSetVerificationStatusRequestExtension
    on SandboxItemSetVerificationStatusRequest {
  SandboxItemSetVerificationStatusRequest copyWith(
      {String? clientId,
      String? secret,
      String? accessToken,
      String? accountId,
      enums.SandboxItemSetVerificationStatusRequestVerificationStatus?
          verificationStatus}) {
    return SandboxItemSetVerificationStatusRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        accessToken: accessToken ?? this.accessToken,
        accountId: accountId ?? this.accountId,
        verificationStatus: verificationStatus ?? this.verificationStatus);
  }
}

@JsonSerializable(explicitToJson: true)
class SandboxItemSetVerificationStatusResponse {
  SandboxItemSetVerificationStatusResponse({
    this.requestId,
  });

  factory SandboxItemSetVerificationStatusResponse.fromJson(
          Map<String, dynamic> json) =>
      _$SandboxItemSetVerificationStatusResponseFromJson(json);

  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory =
      _$SandboxItemSetVerificationStatusResponseFromJson;
  static const toJsonFactory = _$SandboxItemSetVerificationStatusResponseToJson;
  Map<String, dynamic> toJson() =>
      _$SandboxItemSetVerificationStatusResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SandboxItemSetVerificationStatusResponse &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(requestId) ^ runtimeType.hashCode;
}

extension $SandboxItemSetVerificationStatusResponseExtension
    on SandboxItemSetVerificationStatusResponse {
  SandboxItemSetVerificationStatusResponse copyWith({String? requestId}) {
    return SandboxItemSetVerificationStatusResponse(
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class ItemPublicTokenExchangeRequest {
  ItemPublicTokenExchangeRequest({
    this.clientId,
    this.secret,
    this.publicToken,
  });

  factory ItemPublicTokenExchangeRequest.fromJson(Map<String, dynamic> json) =>
      _$ItemPublicTokenExchangeRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'public_token')
  final String? publicToken;
  static const fromJsonFactory = _$ItemPublicTokenExchangeRequestFromJson;
  static const toJsonFactory = _$ItemPublicTokenExchangeRequestToJson;
  Map<String, dynamic> toJson() => _$ItemPublicTokenExchangeRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ItemPublicTokenExchangeRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.publicToken, publicToken) ||
                const DeepCollectionEquality()
                    .equals(other.publicToken, publicToken)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(publicToken) ^
      runtimeType.hashCode;
}

extension $ItemPublicTokenExchangeRequestExtension
    on ItemPublicTokenExchangeRequest {
  ItemPublicTokenExchangeRequest copyWith(
      {String? clientId, String? secret, String? publicToken}) {
    return ItemPublicTokenExchangeRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        publicToken: publicToken ?? this.publicToken);
  }
}

@JsonSerializable(explicitToJson: true)
class ItemPublicTokenExchangeResponse {
  ItemPublicTokenExchangeResponse({
    this.accessToken,
    this.itemId,
    this.requestId,
  });

  factory ItemPublicTokenExchangeResponse.fromJson(Map<String, dynamic> json) =>
      _$ItemPublicTokenExchangeResponseFromJson(json);

  @JsonKey(name: 'access_token')
  final String? accessToken;
  @JsonKey(name: 'item_id')
  final String? itemId;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$ItemPublicTokenExchangeResponseFromJson;
  static const toJsonFactory = _$ItemPublicTokenExchangeResponseToJson;
  Map<String, dynamic> toJson() =>
      _$ItemPublicTokenExchangeResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ItemPublicTokenExchangeResponse &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)) &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accessToken) ^
      const DeepCollectionEquality().hash(itemId) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $ItemPublicTokenExchangeResponseExtension
    on ItemPublicTokenExchangeResponse {
  ItemPublicTokenExchangeResponse copyWith(
      {String? accessToken, String? itemId, String? requestId}) {
    return ItemPublicTokenExchangeResponse(
        accessToken: accessToken ?? this.accessToken,
        itemId: itemId ?? this.itemId,
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class ItemPublicTokenCreateRequest {
  ItemPublicTokenCreateRequest({
    this.clientId,
    this.secret,
    this.accessToken,
  });

  factory ItemPublicTokenCreateRequest.fromJson(Map<String, dynamic> json) =>
      _$ItemPublicTokenCreateRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'access_token')
  final String? accessToken;
  static const fromJsonFactory = _$ItemPublicTokenCreateRequestFromJson;
  static const toJsonFactory = _$ItemPublicTokenCreateRequestToJson;
  Map<String, dynamic> toJson() => _$ItemPublicTokenCreateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ItemPublicTokenCreateRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(accessToken) ^
      runtimeType.hashCode;
}

extension $ItemPublicTokenCreateRequestExtension
    on ItemPublicTokenCreateRequest {
  ItemPublicTokenCreateRequest copyWith(
      {String? clientId, String? secret, String? accessToken}) {
    return ItemPublicTokenCreateRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        accessToken: accessToken ?? this.accessToken);
  }
}

@JsonSerializable(explicitToJson: true)
class ItemPublicTokenCreateResponse {
  ItemPublicTokenCreateResponse({
    this.publicToken,
    this.expiration,
    this.requestId,
  });

  factory ItemPublicTokenCreateResponse.fromJson(Map<String, dynamic> json) =>
      _$ItemPublicTokenCreateResponseFromJson(json);

  @JsonKey(name: 'public_token')
  final String? publicToken;
  @JsonKey(name: 'expiration')
  final DateTime? expiration;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$ItemPublicTokenCreateResponseFromJson;
  static const toJsonFactory = _$ItemPublicTokenCreateResponseToJson;
  Map<String, dynamic> toJson() => _$ItemPublicTokenCreateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ItemPublicTokenCreateResponse &&
            (identical(other.publicToken, publicToken) ||
                const DeepCollectionEquality()
                    .equals(other.publicToken, publicToken)) &&
            (identical(other.expiration, expiration) ||
                const DeepCollectionEquality()
                    .equals(other.expiration, expiration)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(publicToken) ^
      const DeepCollectionEquality().hash(expiration) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $ItemPublicTokenCreateResponseExtension
    on ItemPublicTokenCreateResponse {
  ItemPublicTokenCreateResponse copyWith(
      {String? publicToken, DateTime? expiration, String? requestId}) {
    return ItemPublicTokenCreateResponse(
        publicToken: publicToken ?? this.publicToken,
        expiration: expiration ?? this.expiration,
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentInitiationPaymentGetRequest {
  PaymentInitiationPaymentGetRequest({
    this.clientId,
    this.secret,
    this.paymentId,
  });

  factory PaymentInitiationPaymentGetRequest.fromJson(
          Map<String, dynamic> json) =>
      _$PaymentInitiationPaymentGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'payment_id')
  final String? paymentId;
  static const fromJsonFactory = _$PaymentInitiationPaymentGetRequestFromJson;
  static const toJsonFactory = _$PaymentInitiationPaymentGetRequestToJson;
  Map<String, dynamic> toJson() =>
      _$PaymentInitiationPaymentGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentInitiationPaymentGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.paymentId, paymentId) ||
                const DeepCollectionEquality()
                    .equals(other.paymentId, paymentId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(paymentId) ^
      runtimeType.hashCode;
}

extension $PaymentInitiationPaymentGetRequestExtension
    on PaymentInitiationPaymentGetRequest {
  PaymentInitiationPaymentGetRequest copyWith(
      {String? clientId, String? secret, String? paymentId}) {
    return PaymentInitiationPaymentGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        paymentId: paymentId ?? this.paymentId);
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentInitiationPaymentGetResponse {
  PaymentInitiationPaymentGetResponse({
    this.requestId,
    this.paymentId,
    this.amount,
    this.status,
    this.recipientId,
    this.reference,
    this.adjustedReference,
    this.lastStatusUpdate,
    this.schedule,
    this.refundDetails,
    this.bacs,
    this.iban,
    this.initiatedRefunds,
    this.walletId,
  });

  factory PaymentInitiationPaymentGetResponse.fromJson(
          Map<String, dynamic> json) =>
      _$PaymentInitiationPaymentGetResponseFromJson(json);

  @JsonKey(name: 'request_id')
  final String? requestId;
  @JsonKey(name: 'payment_id')
  final String? paymentId;
  @JsonKey(name: 'amount')
  final PaymentAmount? amount;
  @JsonKey(
      name: 'status',
      toJson: paymentInitiationPaymentStatusToJson,
      fromJson: paymentInitiationPaymentStatusFromJson)
  final enums.PaymentInitiationPaymentStatus? status;
  @JsonKey(name: 'recipient_id')
  final String? recipientId;
  @JsonKey(name: 'reference')
  final String? reference;
  @JsonKey(name: 'adjusted_reference')
  final String? adjustedReference;
  @JsonKey(name: 'last_status_update')
  final DateTime? lastStatusUpdate;
  @JsonKey(name: 'schedule')
  final ExternalPaymentScheduleGet? schedule;
  @JsonKey(name: 'refund_details')
  final ExternalPaymentRefundDetails? refundDetails;
  @JsonKey(name: 'bacs')
  final SenderBACSNullable? bacs;
  @JsonKey(name: 'iban')
  final String? iban;
  @JsonKey(name: 'initiated_refunds', defaultValue: <PaymentInitiationRefund>[])
  final List<PaymentInitiationRefund>? initiatedRefunds;
  @JsonKey(name: 'wallet_id')
  final String? walletId;
  static const fromJsonFactory = _$PaymentInitiationPaymentGetResponseFromJson;
  static const toJsonFactory = _$PaymentInitiationPaymentGetResponseToJson;
  Map<String, dynamic> toJson() =>
      _$PaymentInitiationPaymentGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentInitiationPaymentGetResponse &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)) &&
            (identical(other.paymentId, paymentId) ||
                const DeepCollectionEquality()
                    .equals(other.paymentId, paymentId)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.recipientId, recipientId) ||
                const DeepCollectionEquality()
                    .equals(other.recipientId, recipientId)) &&
            (identical(other.reference, reference) ||
                const DeepCollectionEquality()
                    .equals(other.reference, reference)) &&
            (identical(other.adjustedReference, adjustedReference) ||
                const DeepCollectionEquality()
                    .equals(other.adjustedReference, adjustedReference)) &&
            (identical(other.lastStatusUpdate, lastStatusUpdate) ||
                const DeepCollectionEquality()
                    .equals(other.lastStatusUpdate, lastStatusUpdate)) &&
            (identical(other.schedule, schedule) ||
                const DeepCollectionEquality()
                    .equals(other.schedule, schedule)) &&
            (identical(other.refundDetails, refundDetails) ||
                const DeepCollectionEquality()
                    .equals(other.refundDetails, refundDetails)) &&
            (identical(other.bacs, bacs) ||
                const DeepCollectionEquality().equals(other.bacs, bacs)) &&
            (identical(other.iban, iban) ||
                const DeepCollectionEquality().equals(other.iban, iban)) &&
            (identical(other.initiatedRefunds, initiatedRefunds) ||
                const DeepCollectionEquality()
                    .equals(other.initiatedRefunds, initiatedRefunds)) &&
            (identical(other.walletId, walletId) ||
                const DeepCollectionEquality()
                    .equals(other.walletId, walletId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(requestId) ^
      const DeepCollectionEquality().hash(paymentId) ^
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(recipientId) ^
      const DeepCollectionEquality().hash(reference) ^
      const DeepCollectionEquality().hash(adjustedReference) ^
      const DeepCollectionEquality().hash(lastStatusUpdate) ^
      const DeepCollectionEquality().hash(schedule) ^
      const DeepCollectionEquality().hash(refundDetails) ^
      const DeepCollectionEquality().hash(bacs) ^
      const DeepCollectionEquality().hash(iban) ^
      const DeepCollectionEquality().hash(initiatedRefunds) ^
      const DeepCollectionEquality().hash(walletId) ^
      runtimeType.hashCode;
}

extension $PaymentInitiationPaymentGetResponseExtension
    on PaymentInitiationPaymentGetResponse {
  PaymentInitiationPaymentGetResponse copyWith(
      {String? requestId,
      String? paymentId,
      PaymentAmount? amount,
      enums.PaymentInitiationPaymentStatus? status,
      String? recipientId,
      String? reference,
      String? adjustedReference,
      DateTime? lastStatusUpdate,
      ExternalPaymentScheduleGet? schedule,
      ExternalPaymentRefundDetails? refundDetails,
      SenderBACSNullable? bacs,
      String? iban,
      List<PaymentInitiationRefund>? initiatedRefunds,
      String? walletId}) {
    return PaymentInitiationPaymentGetResponse(
        requestId: requestId ?? this.requestId,
        paymentId: paymentId ?? this.paymentId,
        amount: amount ?? this.amount,
        status: status ?? this.status,
        recipientId: recipientId ?? this.recipientId,
        reference: reference ?? this.reference,
        adjustedReference: adjustedReference ?? this.adjustedReference,
        lastStatusUpdate: lastStatusUpdate ?? this.lastStatusUpdate,
        schedule: schedule ?? this.schedule,
        refundDetails: refundDetails ?? this.refundDetails,
        bacs: bacs ?? this.bacs,
        iban: iban ?? this.iban,
        initiatedRefunds: initiatedRefunds ?? this.initiatedRefunds,
        walletId: walletId ?? this.walletId);
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentInitiationPayment {
  PaymentInitiationPayment({
    this.paymentId,
    this.amount,
    this.status,
    this.recipientId,
    this.reference,
    this.adjustedReference,
    this.lastStatusUpdate,
    this.schedule,
    this.refundDetails,
    this.bacs,
    this.iban,
    this.initiatedRefunds,
    this.walletId,
  });

  factory PaymentInitiationPayment.fromJson(Map<String, dynamic> json) =>
      _$PaymentInitiationPaymentFromJson(json);

  @JsonKey(name: 'payment_id')
  final String? paymentId;
  @JsonKey(name: 'amount')
  final PaymentAmount? amount;
  @JsonKey(
      name: 'status',
      toJson: paymentInitiationPaymentStatusToJson,
      fromJson: paymentInitiationPaymentStatusFromJson)
  final enums.PaymentInitiationPaymentStatus? status;
  @JsonKey(name: 'recipient_id')
  final String? recipientId;
  @JsonKey(name: 'reference')
  final String? reference;
  @JsonKey(name: 'adjusted_reference')
  final String? adjustedReference;
  @JsonKey(name: 'last_status_update')
  final DateTime? lastStatusUpdate;
  @JsonKey(name: 'schedule')
  final ExternalPaymentScheduleGet? schedule;
  @JsonKey(name: 'refund_details')
  final ExternalPaymentRefundDetails? refundDetails;
  @JsonKey(name: 'bacs')
  final SenderBACSNullable? bacs;
  @JsonKey(name: 'iban')
  final String? iban;
  @JsonKey(name: 'initiated_refunds', defaultValue: <PaymentInitiationRefund>[])
  final List<PaymentInitiationRefund>? initiatedRefunds;
  @JsonKey(name: 'wallet_id')
  final String? walletId;
  static const fromJsonFactory = _$PaymentInitiationPaymentFromJson;
  static const toJsonFactory = _$PaymentInitiationPaymentToJson;
  Map<String, dynamic> toJson() => _$PaymentInitiationPaymentToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentInitiationPayment &&
            (identical(other.paymentId, paymentId) ||
                const DeepCollectionEquality()
                    .equals(other.paymentId, paymentId)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.recipientId, recipientId) ||
                const DeepCollectionEquality()
                    .equals(other.recipientId, recipientId)) &&
            (identical(other.reference, reference) ||
                const DeepCollectionEquality()
                    .equals(other.reference, reference)) &&
            (identical(other.adjustedReference, adjustedReference) ||
                const DeepCollectionEquality()
                    .equals(other.adjustedReference, adjustedReference)) &&
            (identical(other.lastStatusUpdate, lastStatusUpdate) ||
                const DeepCollectionEquality()
                    .equals(other.lastStatusUpdate, lastStatusUpdate)) &&
            (identical(other.schedule, schedule) ||
                const DeepCollectionEquality()
                    .equals(other.schedule, schedule)) &&
            (identical(other.refundDetails, refundDetails) ||
                const DeepCollectionEquality()
                    .equals(other.refundDetails, refundDetails)) &&
            (identical(other.bacs, bacs) ||
                const DeepCollectionEquality().equals(other.bacs, bacs)) &&
            (identical(other.iban, iban) ||
                const DeepCollectionEquality().equals(other.iban, iban)) &&
            (identical(other.initiatedRefunds, initiatedRefunds) ||
                const DeepCollectionEquality()
                    .equals(other.initiatedRefunds, initiatedRefunds)) &&
            (identical(other.walletId, walletId) ||
                const DeepCollectionEquality()
                    .equals(other.walletId, walletId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(paymentId) ^
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(recipientId) ^
      const DeepCollectionEquality().hash(reference) ^
      const DeepCollectionEquality().hash(adjustedReference) ^
      const DeepCollectionEquality().hash(lastStatusUpdate) ^
      const DeepCollectionEquality().hash(schedule) ^
      const DeepCollectionEquality().hash(refundDetails) ^
      const DeepCollectionEquality().hash(bacs) ^
      const DeepCollectionEquality().hash(iban) ^
      const DeepCollectionEquality().hash(initiatedRefunds) ^
      const DeepCollectionEquality().hash(walletId) ^
      runtimeType.hashCode;
}

extension $PaymentInitiationPaymentExtension on PaymentInitiationPayment {
  PaymentInitiationPayment copyWith(
      {String? paymentId,
      PaymentAmount? amount,
      enums.PaymentInitiationPaymentStatus? status,
      String? recipientId,
      String? reference,
      String? adjustedReference,
      DateTime? lastStatusUpdate,
      ExternalPaymentScheduleGet? schedule,
      ExternalPaymentRefundDetails? refundDetails,
      SenderBACSNullable? bacs,
      String? iban,
      List<PaymentInitiationRefund>? initiatedRefunds,
      String? walletId}) {
    return PaymentInitiationPayment(
        paymentId: paymentId ?? this.paymentId,
        amount: amount ?? this.amount,
        status: status ?? this.status,
        recipientId: recipientId ?? this.recipientId,
        reference: reference ?? this.reference,
        adjustedReference: adjustedReference ?? this.adjustedReference,
        lastStatusUpdate: lastStatusUpdate ?? this.lastStatusUpdate,
        schedule: schedule ?? this.schedule,
        refundDetails: refundDetails ?? this.refundDetails,
        bacs: bacs ?? this.bacs,
        iban: iban ?? this.iban,
        initiatedRefunds: initiatedRefunds ?? this.initiatedRefunds,
        walletId: walletId ?? this.walletId);
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentInitiationRefund {
  PaymentInitiationRefund({
    this.refundId,
    this.amount,
    this.status,
    this.lastStatusUpdate,
  });

  factory PaymentInitiationRefund.fromJson(Map<String, dynamic> json) =>
      _$PaymentInitiationRefundFromJson(json);

  @JsonKey(name: 'refund_id')
  final String? refundId;
  @JsonKey(name: 'amount')
  final PaymentAmount? amount;
  @JsonKey(
      name: 'status',
      toJson: paymentInitiationRefundStatusToJson,
      fromJson: paymentInitiationRefundStatusFromJson)
  final enums.PaymentInitiationRefundStatus? status;
  @JsonKey(name: 'last_status_update')
  final DateTime? lastStatusUpdate;
  static const fromJsonFactory = _$PaymentInitiationRefundFromJson;
  static const toJsonFactory = _$PaymentInitiationRefundToJson;
  Map<String, dynamic> toJson() => _$PaymentInitiationRefundToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentInitiationRefund &&
            (identical(other.refundId, refundId) ||
                const DeepCollectionEquality()
                    .equals(other.refundId, refundId)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.lastStatusUpdate, lastStatusUpdate) ||
                const DeepCollectionEquality()
                    .equals(other.lastStatusUpdate, lastStatusUpdate)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(refundId) ^
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(lastStatusUpdate) ^
      runtimeType.hashCode;
}

extension $PaymentInitiationRefundExtension on PaymentInitiationRefund {
  PaymentInitiationRefund copyWith(
      {String? refundId,
      PaymentAmount? amount,
      enums.PaymentInitiationRefundStatus? status,
      DateTime? lastStatusUpdate}) {
    return PaymentInitiationRefund(
        refundId: refundId ?? this.refundId,
        amount: amount ?? this.amount,
        status: status ?? this.status,
        lastStatusUpdate: lastStatusUpdate ?? this.lastStatusUpdate);
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentInitiationPaymentTokenCreateRequest {
  PaymentInitiationPaymentTokenCreateRequest({
    this.clientId,
    this.secret,
    this.paymentId,
  });

  factory PaymentInitiationPaymentTokenCreateRequest.fromJson(
          Map<String, dynamic> json) =>
      _$PaymentInitiationPaymentTokenCreateRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'payment_id')
  final String? paymentId;
  static const fromJsonFactory =
      _$PaymentInitiationPaymentTokenCreateRequestFromJson;
  static const toJsonFactory =
      _$PaymentInitiationPaymentTokenCreateRequestToJson;
  Map<String, dynamic> toJson() =>
      _$PaymentInitiationPaymentTokenCreateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentInitiationPaymentTokenCreateRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.paymentId, paymentId) ||
                const DeepCollectionEquality()
                    .equals(other.paymentId, paymentId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(paymentId) ^
      runtimeType.hashCode;
}

extension $PaymentInitiationPaymentTokenCreateRequestExtension
    on PaymentInitiationPaymentTokenCreateRequest {
  PaymentInitiationPaymentTokenCreateRequest copyWith(
      {String? clientId, String? secret, String? paymentId}) {
    return PaymentInitiationPaymentTokenCreateRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        paymentId: paymentId ?? this.paymentId);
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentInitiationPaymentTokenCreateResponse {
  PaymentInitiationPaymentTokenCreateResponse({
    this.paymentToken,
    this.paymentTokenExpirationTime,
    this.requestId,
  });

  factory PaymentInitiationPaymentTokenCreateResponse.fromJson(
          Map<String, dynamic> json) =>
      _$PaymentInitiationPaymentTokenCreateResponseFromJson(json);

  @JsonKey(name: 'payment_token')
  final String? paymentToken;
  @JsonKey(name: 'payment_token_expiration_time')
  final DateTime? paymentTokenExpirationTime;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory =
      _$PaymentInitiationPaymentTokenCreateResponseFromJson;
  static const toJsonFactory =
      _$PaymentInitiationPaymentTokenCreateResponseToJson;
  Map<String, dynamic> toJson() =>
      _$PaymentInitiationPaymentTokenCreateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentInitiationPaymentTokenCreateResponse &&
            (identical(other.paymentToken, paymentToken) ||
                const DeepCollectionEquality()
                    .equals(other.paymentToken, paymentToken)) &&
            (identical(other.paymentTokenExpirationTime,
                    paymentTokenExpirationTime) ||
                const DeepCollectionEquality().equals(
                    other.paymentTokenExpirationTime,
                    paymentTokenExpirationTime)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(paymentToken) ^
      const DeepCollectionEquality().hash(paymentTokenExpirationTime) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $PaymentInitiationPaymentTokenCreateResponseExtension
    on PaymentInitiationPaymentTokenCreateResponse {
  PaymentInitiationPaymentTokenCreateResponse copyWith(
      {String? paymentToken,
      DateTime? paymentTokenExpirationTime,
      String? requestId}) {
    return PaymentInitiationPaymentTokenCreateResponse(
        paymentToken: paymentToken ?? this.paymentToken,
        paymentTokenExpirationTime:
            paymentTokenExpirationTime ?? this.paymentTokenExpirationTime,
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentInitiationPaymentListRequest {
  PaymentInitiationPaymentListRequest({
    this.clientId,
    this.secret,
    this.count,
    this.cursor,
  });

  factory PaymentInitiationPaymentListRequest.fromJson(
          Map<String, dynamic> json) =>
      _$PaymentInitiationPaymentListRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'count')
  final int? count;
  @JsonKey(name: 'cursor')
  final DateTime? cursor;
  static const fromJsonFactory = _$PaymentInitiationPaymentListRequestFromJson;
  static const toJsonFactory = _$PaymentInitiationPaymentListRequestToJson;
  Map<String, dynamic> toJson() =>
      _$PaymentInitiationPaymentListRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentInitiationPaymentListRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)) &&
            (identical(other.cursor, cursor) ||
                const DeepCollectionEquality().equals(other.cursor, cursor)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(count) ^
      const DeepCollectionEquality().hash(cursor) ^
      runtimeType.hashCode;
}

extension $PaymentInitiationPaymentListRequestExtension
    on PaymentInitiationPaymentListRequest {
  PaymentInitiationPaymentListRequest copyWith(
      {String? clientId, String? secret, int? count, DateTime? cursor}) {
    return PaymentInitiationPaymentListRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        count: count ?? this.count,
        cursor: cursor ?? this.cursor);
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentInitiationPaymentListResponse {
  PaymentInitiationPaymentListResponse({
    this.payments,
    this.nextCursor,
    this.requestId,
  });

  factory PaymentInitiationPaymentListResponse.fromJson(
          Map<String, dynamic> json) =>
      _$PaymentInitiationPaymentListResponseFromJson(json);

  @JsonKey(name: 'payments', defaultValue: <PaymentInitiationPayment>[])
  final List<PaymentInitiationPayment>? payments;
  @JsonKey(name: 'next_cursor')
  final DateTime? nextCursor;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$PaymentInitiationPaymentListResponseFromJson;
  static const toJsonFactory = _$PaymentInitiationPaymentListResponseToJson;
  Map<String, dynamic> toJson() =>
      _$PaymentInitiationPaymentListResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentInitiationPaymentListResponse &&
            (identical(other.payments, payments) ||
                const DeepCollectionEquality()
                    .equals(other.payments, payments)) &&
            (identical(other.nextCursor, nextCursor) ||
                const DeepCollectionEquality()
                    .equals(other.nextCursor, nextCursor)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(payments) ^
      const DeepCollectionEquality().hash(nextCursor) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $PaymentInitiationPaymentListResponseExtension
    on PaymentInitiationPaymentListResponse {
  PaymentInitiationPaymentListResponse copyWith(
      {List<PaymentInitiationPayment>? payments,
      DateTime? nextCursor,
      String? requestId}) {
    return PaymentInitiationPaymentListResponse(
        payments: payments ?? this.payments,
        nextCursor: nextCursor ?? this.nextCursor,
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class AssetReportCreateRequest {
  AssetReportCreateRequest({
    this.clientId,
    this.secret,
    this.accessTokens,
    this.daysRequested,
    this.options,
  });

  factory AssetReportCreateRequest.fromJson(Map<String, dynamic> json) =>
      _$AssetReportCreateRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'access_tokens', defaultValue: <String>[])
  final List<String>? accessTokens;
  @JsonKey(name: 'days_requested')
  final int? daysRequested;
  @JsonKey(name: 'options')
  final AssetReportCreateRequestOptions? options;
  static const fromJsonFactory = _$AssetReportCreateRequestFromJson;
  static const toJsonFactory = _$AssetReportCreateRequestToJson;
  Map<String, dynamic> toJson() => _$AssetReportCreateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AssetReportCreateRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.accessTokens, accessTokens) ||
                const DeepCollectionEquality()
                    .equals(other.accessTokens, accessTokens)) &&
            (identical(other.daysRequested, daysRequested) ||
                const DeepCollectionEquality()
                    .equals(other.daysRequested, daysRequested)) &&
            (identical(other.options, options) ||
                const DeepCollectionEquality().equals(other.options, options)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(accessTokens) ^
      const DeepCollectionEquality().hash(daysRequested) ^
      const DeepCollectionEquality().hash(options) ^
      runtimeType.hashCode;
}

extension $AssetReportCreateRequestExtension on AssetReportCreateRequest {
  AssetReportCreateRequest copyWith(
      {String? clientId,
      String? secret,
      List<String>? accessTokens,
      int? daysRequested,
      AssetReportCreateRequestOptions? options}) {
    return AssetReportCreateRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        accessTokens: accessTokens ?? this.accessTokens,
        daysRequested: daysRequested ?? this.daysRequested,
        options: options ?? this.options);
  }
}

@JsonSerializable(explicitToJson: true)
class AssetReportCreateRequestOptions {
  AssetReportCreateRequestOptions({
    this.clientReportId,
    this.webhook,
    this.user,
  });

  factory AssetReportCreateRequestOptions.fromJson(Map<String, dynamic> json) =>
      _$AssetReportCreateRequestOptionsFromJson(json);

  @JsonKey(name: 'client_report_id')
  final String? clientReportId;
  @JsonKey(name: 'webhook')
  final String? webhook;
  @JsonKey(name: 'user')
  final AssetReportUser? user;
  static const fromJsonFactory = _$AssetReportCreateRequestOptionsFromJson;
  static const toJsonFactory = _$AssetReportCreateRequestOptionsToJson;
  Map<String, dynamic> toJson() =>
      _$AssetReportCreateRequestOptionsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AssetReportCreateRequestOptions &&
            (identical(other.clientReportId, clientReportId) ||
                const DeepCollectionEquality()
                    .equals(other.clientReportId, clientReportId)) &&
            (identical(other.webhook, webhook) ||
                const DeepCollectionEquality()
                    .equals(other.webhook, webhook)) &&
            (identical(other.user, user) ||
                const DeepCollectionEquality().equals(other.user, user)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientReportId) ^
      const DeepCollectionEquality().hash(webhook) ^
      const DeepCollectionEquality().hash(user) ^
      runtimeType.hashCode;
}

extension $AssetReportCreateRequestOptionsExtension
    on AssetReportCreateRequestOptions {
  AssetReportCreateRequestOptions copyWith(
      {String? clientReportId, String? webhook, AssetReportUser? user}) {
    return AssetReportCreateRequestOptions(
        clientReportId: clientReportId ?? this.clientReportId,
        webhook: webhook ?? this.webhook,
        user: user ?? this.user);
  }
}

@JsonSerializable(explicitToJson: true)
class AssetReportCreateResponse {
  AssetReportCreateResponse({
    this.assetReportToken,
    this.assetReportId,
    this.requestId,
  });

  factory AssetReportCreateResponse.fromJson(Map<String, dynamic> json) =>
      _$AssetReportCreateResponseFromJson(json);

  @JsonKey(name: 'asset_report_token')
  final String? assetReportToken;
  @JsonKey(name: 'asset_report_id')
  final String? assetReportId;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$AssetReportCreateResponseFromJson;
  static const toJsonFactory = _$AssetReportCreateResponseToJson;
  Map<String, dynamic> toJson() => _$AssetReportCreateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AssetReportCreateResponse &&
            (identical(other.assetReportToken, assetReportToken) ||
                const DeepCollectionEquality()
                    .equals(other.assetReportToken, assetReportToken)) &&
            (identical(other.assetReportId, assetReportId) ||
                const DeepCollectionEquality()
                    .equals(other.assetReportId, assetReportId)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(assetReportToken) ^
      const DeepCollectionEquality().hash(assetReportId) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $AssetReportCreateResponseExtension on AssetReportCreateResponse {
  AssetReportCreateResponse copyWith(
      {String? assetReportToken, String? assetReportId, String? requestId}) {
    return AssetReportCreateResponse(
        assetReportToken: assetReportToken ?? this.assetReportToken,
        assetReportId: assetReportId ?? this.assetReportId,
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class AssetReportRefreshRequest {
  AssetReportRefreshRequest({
    this.clientId,
    this.secret,
    this.assetReportToken,
    this.daysRequested,
    this.options,
  });

  factory AssetReportRefreshRequest.fromJson(Map<String, dynamic> json) =>
      _$AssetReportRefreshRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'asset_report_token')
  final String? assetReportToken;
  @JsonKey(name: 'days_requested')
  final int? daysRequested;
  @JsonKey(name: 'options')
  final AssetReportRefreshRequestOptions? options;
  static const fromJsonFactory = _$AssetReportRefreshRequestFromJson;
  static const toJsonFactory = _$AssetReportRefreshRequestToJson;
  Map<String, dynamic> toJson() => _$AssetReportRefreshRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AssetReportRefreshRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.assetReportToken, assetReportToken) ||
                const DeepCollectionEquality()
                    .equals(other.assetReportToken, assetReportToken)) &&
            (identical(other.daysRequested, daysRequested) ||
                const DeepCollectionEquality()
                    .equals(other.daysRequested, daysRequested)) &&
            (identical(other.options, options) ||
                const DeepCollectionEquality().equals(other.options, options)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(assetReportToken) ^
      const DeepCollectionEquality().hash(daysRequested) ^
      const DeepCollectionEquality().hash(options) ^
      runtimeType.hashCode;
}

extension $AssetReportRefreshRequestExtension on AssetReportRefreshRequest {
  AssetReportRefreshRequest copyWith(
      {String? clientId,
      String? secret,
      String? assetReportToken,
      int? daysRequested,
      AssetReportRefreshRequestOptions? options}) {
    return AssetReportRefreshRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        assetReportToken: assetReportToken ?? this.assetReportToken,
        daysRequested: daysRequested ?? this.daysRequested,
        options: options ?? this.options);
  }
}

@JsonSerializable(explicitToJson: true)
class AssetReportRefreshRequestOptions {
  AssetReportRefreshRequestOptions({
    this.clientReportId,
    this.webhook,
    this.user,
  });

  factory AssetReportRefreshRequestOptions.fromJson(
          Map<String, dynamic> json) =>
      _$AssetReportRefreshRequestOptionsFromJson(json);

  @JsonKey(name: 'client_report_id')
  final String? clientReportId;
  @JsonKey(name: 'webhook')
  final String? webhook;
  @JsonKey(name: 'user')
  final AssetReportUser? user;
  static const fromJsonFactory = _$AssetReportRefreshRequestOptionsFromJson;
  static const toJsonFactory = _$AssetReportRefreshRequestOptionsToJson;
  Map<String, dynamic> toJson() =>
      _$AssetReportRefreshRequestOptionsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AssetReportRefreshRequestOptions &&
            (identical(other.clientReportId, clientReportId) ||
                const DeepCollectionEquality()
                    .equals(other.clientReportId, clientReportId)) &&
            (identical(other.webhook, webhook) ||
                const DeepCollectionEquality()
                    .equals(other.webhook, webhook)) &&
            (identical(other.user, user) ||
                const DeepCollectionEquality().equals(other.user, user)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientReportId) ^
      const DeepCollectionEquality().hash(webhook) ^
      const DeepCollectionEquality().hash(user) ^
      runtimeType.hashCode;
}

extension $AssetReportRefreshRequestOptionsExtension
    on AssetReportRefreshRequestOptions {
  AssetReportRefreshRequestOptions copyWith(
      {String? clientReportId, String? webhook, AssetReportUser? user}) {
    return AssetReportRefreshRequestOptions(
        clientReportId: clientReportId ?? this.clientReportId,
        webhook: webhook ?? this.webhook,
        user: user ?? this.user);
  }
}

@JsonSerializable(explicitToJson: true)
class AssetReportRefreshResponse {
  AssetReportRefreshResponse({
    this.assetReportId,
    this.assetReportToken,
    this.requestId,
  });

  factory AssetReportRefreshResponse.fromJson(Map<String, dynamic> json) =>
      _$AssetReportRefreshResponseFromJson(json);

  @JsonKey(name: 'asset_report_id')
  final String? assetReportId;
  @JsonKey(name: 'asset_report_token')
  final String? assetReportToken;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$AssetReportRefreshResponseFromJson;
  static const toJsonFactory = _$AssetReportRefreshResponseToJson;
  Map<String, dynamic> toJson() => _$AssetReportRefreshResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AssetReportRefreshResponse &&
            (identical(other.assetReportId, assetReportId) ||
                const DeepCollectionEquality()
                    .equals(other.assetReportId, assetReportId)) &&
            (identical(other.assetReportToken, assetReportToken) ||
                const DeepCollectionEquality()
                    .equals(other.assetReportToken, assetReportToken)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(assetReportId) ^
      const DeepCollectionEquality().hash(assetReportToken) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $AssetReportRefreshResponseExtension on AssetReportRefreshResponse {
  AssetReportRefreshResponse copyWith(
      {String? assetReportId, String? assetReportToken, String? requestId}) {
    return AssetReportRefreshResponse(
        assetReportId: assetReportId ?? this.assetReportId,
        assetReportToken: assetReportToken ?? this.assetReportToken,
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class AssetReportRemoveRequest {
  AssetReportRemoveRequest({
    this.clientId,
    this.secret,
    this.assetReportToken,
  });

  factory AssetReportRemoveRequest.fromJson(Map<String, dynamic> json) =>
      _$AssetReportRemoveRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'asset_report_token')
  final String? assetReportToken;
  static const fromJsonFactory = _$AssetReportRemoveRequestFromJson;
  static const toJsonFactory = _$AssetReportRemoveRequestToJson;
  Map<String, dynamic> toJson() => _$AssetReportRemoveRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AssetReportRemoveRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.assetReportToken, assetReportToken) ||
                const DeepCollectionEquality()
                    .equals(other.assetReportToken, assetReportToken)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(assetReportToken) ^
      runtimeType.hashCode;
}

extension $AssetReportRemoveRequestExtension on AssetReportRemoveRequest {
  AssetReportRemoveRequest copyWith(
      {String? clientId, String? secret, String? assetReportToken}) {
    return AssetReportRemoveRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        assetReportToken: assetReportToken ?? this.assetReportToken);
  }
}

@JsonSerializable(explicitToJson: true)
class AssetReportRemoveResponse {
  AssetReportRemoveResponse({
    this.removed,
    this.requestId,
  });

  factory AssetReportRemoveResponse.fromJson(Map<String, dynamic> json) =>
      _$AssetReportRemoveResponseFromJson(json);

  @JsonKey(name: 'removed')
  final bool? removed;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$AssetReportRemoveResponseFromJson;
  static const toJsonFactory = _$AssetReportRemoveResponseToJson;
  Map<String, dynamic> toJson() => _$AssetReportRemoveResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AssetReportRemoveResponse &&
            (identical(other.removed, removed) ||
                const DeepCollectionEquality()
                    .equals(other.removed, removed)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(removed) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $AssetReportRemoveResponseExtension on AssetReportRemoveResponse {
  AssetReportRemoveResponse copyWith({bool? removed, String? requestId}) {
    return AssetReportRemoveResponse(
        removed: removed ?? this.removed,
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class AssetReportFilterRequest {
  AssetReportFilterRequest({
    this.clientId,
    this.secret,
    this.assetReportToken,
    this.accountIdsToExclude,
  });

  factory AssetReportFilterRequest.fromJson(Map<String, dynamic> json) =>
      _$AssetReportFilterRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'asset_report_token')
  final String? assetReportToken;
  @JsonKey(name: 'account_ids_to_exclude', defaultValue: <String>[])
  final List<String>? accountIdsToExclude;
  static const fromJsonFactory = _$AssetReportFilterRequestFromJson;
  static const toJsonFactory = _$AssetReportFilterRequestToJson;
  Map<String, dynamic> toJson() => _$AssetReportFilterRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AssetReportFilterRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.assetReportToken, assetReportToken) ||
                const DeepCollectionEquality()
                    .equals(other.assetReportToken, assetReportToken)) &&
            (identical(other.accountIdsToExclude, accountIdsToExclude) ||
                const DeepCollectionEquality()
                    .equals(other.accountIdsToExclude, accountIdsToExclude)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(assetReportToken) ^
      const DeepCollectionEquality().hash(accountIdsToExclude) ^
      runtimeType.hashCode;
}

extension $AssetReportFilterRequestExtension on AssetReportFilterRequest {
  AssetReportFilterRequest copyWith(
      {String? clientId,
      String? secret,
      String? assetReportToken,
      List<String>? accountIdsToExclude}) {
    return AssetReportFilterRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        assetReportToken: assetReportToken ?? this.assetReportToken,
        accountIdsToExclude: accountIdsToExclude ?? this.accountIdsToExclude);
  }
}

@JsonSerializable(explicitToJson: true)
class AssetReportFilterResponse {
  AssetReportFilterResponse({
    this.assetReportToken,
    this.assetReportId,
    this.requestId,
  });

  factory AssetReportFilterResponse.fromJson(Map<String, dynamic> json) =>
      _$AssetReportFilterResponseFromJson(json);

  @JsonKey(name: 'asset_report_token')
  final String? assetReportToken;
  @JsonKey(name: 'asset_report_id')
  final String? assetReportId;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$AssetReportFilterResponseFromJson;
  static const toJsonFactory = _$AssetReportFilterResponseToJson;
  Map<String, dynamic> toJson() => _$AssetReportFilterResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AssetReportFilterResponse &&
            (identical(other.assetReportToken, assetReportToken) ||
                const DeepCollectionEquality()
                    .equals(other.assetReportToken, assetReportToken)) &&
            (identical(other.assetReportId, assetReportId) ||
                const DeepCollectionEquality()
                    .equals(other.assetReportId, assetReportId)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(assetReportToken) ^
      const DeepCollectionEquality().hash(assetReportId) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $AssetReportFilterResponseExtension on AssetReportFilterResponse {
  AssetReportFilterResponse copyWith(
      {String? assetReportToken, String? assetReportId, String? requestId}) {
    return AssetReportFilterResponse(
        assetReportToken: assetReportToken ?? this.assetReportToken,
        assetReportId: assetReportId ?? this.assetReportId,
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class AssetReportGetRequest {
  AssetReportGetRequest({
    this.clientId,
    this.secret,
    this.assetReportToken,
    this.includeInsights,
  });

  factory AssetReportGetRequest.fromJson(Map<String, dynamic> json) =>
      _$AssetReportGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'asset_report_token')
  final String? assetReportToken;
  @JsonKey(name: 'include_insights', defaultValue: false)
  final bool? includeInsights;
  static const fromJsonFactory = _$AssetReportGetRequestFromJson;
  static const toJsonFactory = _$AssetReportGetRequestToJson;
  Map<String, dynamic> toJson() => _$AssetReportGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AssetReportGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.assetReportToken, assetReportToken) ||
                const DeepCollectionEquality()
                    .equals(other.assetReportToken, assetReportToken)) &&
            (identical(other.includeInsights, includeInsights) ||
                const DeepCollectionEquality()
                    .equals(other.includeInsights, includeInsights)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(assetReportToken) ^
      const DeepCollectionEquality().hash(includeInsights) ^
      runtimeType.hashCode;
}

extension $AssetReportGetRequestExtension on AssetReportGetRequest {
  AssetReportGetRequest copyWith(
      {String? clientId,
      String? secret,
      String? assetReportToken,
      bool? includeInsights}) {
    return AssetReportGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        assetReportToken: assetReportToken ?? this.assetReportToken,
        includeInsights: includeInsights ?? this.includeInsights);
  }
}

@JsonSerializable(explicitToJson: true)
class AssetReportGetResponse {
  AssetReportGetResponse({
    this.report,
    this.warnings,
    this.requestId,
  });

  factory AssetReportGetResponse.fromJson(Map<String, dynamic> json) =>
      _$AssetReportGetResponseFromJson(json);

  @JsonKey(name: 'report')
  final AssetReport? report;
  @JsonKey(name: 'warnings', defaultValue: <Warning>[])
  final List<Warning>? warnings;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$AssetReportGetResponseFromJson;
  static const toJsonFactory = _$AssetReportGetResponseToJson;
  Map<String, dynamic> toJson() => _$AssetReportGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AssetReportGetResponse &&
            (identical(other.report, report) ||
                const DeepCollectionEquality().equals(other.report, report)) &&
            (identical(other.warnings, warnings) ||
                const DeepCollectionEquality()
                    .equals(other.warnings, warnings)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(report) ^
      const DeepCollectionEquality().hash(warnings) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $AssetReportGetResponseExtension on AssetReportGetResponse {
  AssetReportGetResponse copyWith(
      {AssetReport? report, List<Warning>? warnings, String? requestId}) {
    return AssetReportGetResponse(
        report: report ?? this.report,
        warnings: warnings ?? this.warnings,
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class AssetReportPDFGetRequest {
  AssetReportPDFGetRequest({
    this.clientId,
    this.secret,
    this.assetReportToken,
  });

  factory AssetReportPDFGetRequest.fromJson(Map<String, dynamic> json) =>
      _$AssetReportPDFGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'asset_report_token')
  final String? assetReportToken;
  static const fromJsonFactory = _$AssetReportPDFGetRequestFromJson;
  static const toJsonFactory = _$AssetReportPDFGetRequestToJson;
  Map<String, dynamic> toJson() => _$AssetReportPDFGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AssetReportPDFGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.assetReportToken, assetReportToken) ||
                const DeepCollectionEquality()
                    .equals(other.assetReportToken, assetReportToken)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(assetReportToken) ^
      runtimeType.hashCode;
}

extension $AssetReportPDFGetRequestExtension on AssetReportPDFGetRequest {
  AssetReportPDFGetRequest copyWith(
      {String? clientId, String? secret, String? assetReportToken}) {
    return AssetReportPDFGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        assetReportToken: assetReportToken ?? this.assetReportToken);
  }
}

@JsonSerializable(explicitToJson: true)
class AssetReportAuditCopyCreateRequest {
  AssetReportAuditCopyCreateRequest({
    this.clientId,
    this.secret,
    this.assetReportToken,
    this.auditorId,
  });

  factory AssetReportAuditCopyCreateRequest.fromJson(
          Map<String, dynamic> json) =>
      _$AssetReportAuditCopyCreateRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'asset_report_token')
  final String? assetReportToken;
  @JsonKey(name: 'auditor_id')
  final String? auditorId;
  static const fromJsonFactory = _$AssetReportAuditCopyCreateRequestFromJson;
  static const toJsonFactory = _$AssetReportAuditCopyCreateRequestToJson;
  Map<String, dynamic> toJson() =>
      _$AssetReportAuditCopyCreateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AssetReportAuditCopyCreateRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.assetReportToken, assetReportToken) ||
                const DeepCollectionEquality()
                    .equals(other.assetReportToken, assetReportToken)) &&
            (identical(other.auditorId, auditorId) ||
                const DeepCollectionEquality()
                    .equals(other.auditorId, auditorId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(assetReportToken) ^
      const DeepCollectionEquality().hash(auditorId) ^
      runtimeType.hashCode;
}

extension $AssetReportAuditCopyCreateRequestExtension
    on AssetReportAuditCopyCreateRequest {
  AssetReportAuditCopyCreateRequest copyWith(
      {String? clientId,
      String? secret,
      String? assetReportToken,
      String? auditorId}) {
    return AssetReportAuditCopyCreateRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        assetReportToken: assetReportToken ?? this.assetReportToken,
        auditorId: auditorId ?? this.auditorId);
  }
}

@JsonSerializable(explicitToJson: true)
class AssetReportAuditCopyCreateResponse {
  AssetReportAuditCopyCreateResponse({
    this.auditCopyToken,
    this.requestId,
  });

  factory AssetReportAuditCopyCreateResponse.fromJson(
          Map<String, dynamic> json) =>
      _$AssetReportAuditCopyCreateResponseFromJson(json);

  @JsonKey(name: 'audit_copy_token')
  final String? auditCopyToken;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$AssetReportAuditCopyCreateResponseFromJson;
  static const toJsonFactory = _$AssetReportAuditCopyCreateResponseToJson;
  Map<String, dynamic> toJson() =>
      _$AssetReportAuditCopyCreateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AssetReportAuditCopyCreateResponse &&
            (identical(other.auditCopyToken, auditCopyToken) ||
                const DeepCollectionEquality()
                    .equals(other.auditCopyToken, auditCopyToken)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(auditCopyToken) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $AssetReportAuditCopyCreateResponseExtension
    on AssetReportAuditCopyCreateResponse {
  AssetReportAuditCopyCreateResponse copyWith(
      {String? auditCopyToken, String? requestId}) {
    return AssetReportAuditCopyCreateResponse(
        auditCopyToken: auditCopyToken ?? this.auditCopyToken,
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class AssetReportAuditCopyRemoveRequest {
  AssetReportAuditCopyRemoveRequest({
    this.clientId,
    this.secret,
    this.auditCopyToken,
  });

  factory AssetReportAuditCopyRemoveRequest.fromJson(
          Map<String, dynamic> json) =>
      _$AssetReportAuditCopyRemoveRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'audit_copy_token')
  final String? auditCopyToken;
  static const fromJsonFactory = _$AssetReportAuditCopyRemoveRequestFromJson;
  static const toJsonFactory = _$AssetReportAuditCopyRemoveRequestToJson;
  Map<String, dynamic> toJson() =>
      _$AssetReportAuditCopyRemoveRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AssetReportAuditCopyRemoveRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.auditCopyToken, auditCopyToken) ||
                const DeepCollectionEquality()
                    .equals(other.auditCopyToken, auditCopyToken)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(auditCopyToken) ^
      runtimeType.hashCode;
}

extension $AssetReportAuditCopyRemoveRequestExtension
    on AssetReportAuditCopyRemoveRequest {
  AssetReportAuditCopyRemoveRequest copyWith(
      {String? clientId, String? secret, String? auditCopyToken}) {
    return AssetReportAuditCopyRemoveRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        auditCopyToken: auditCopyToken ?? this.auditCopyToken);
  }
}

@JsonSerializable(explicitToJson: true)
class AssetReportAuditCopyRemoveResponse {
  AssetReportAuditCopyRemoveResponse({
    this.removed,
    this.requestId,
  });

  factory AssetReportAuditCopyRemoveResponse.fromJson(
          Map<String, dynamic> json) =>
      _$AssetReportAuditCopyRemoveResponseFromJson(json);

  @JsonKey(name: 'removed')
  final bool? removed;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$AssetReportAuditCopyRemoveResponseFromJson;
  static const toJsonFactory = _$AssetReportAuditCopyRemoveResponseToJson;
  Map<String, dynamic> toJson() =>
      _$AssetReportAuditCopyRemoveResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AssetReportAuditCopyRemoveResponse &&
            (identical(other.removed, removed) ||
                const DeepCollectionEquality()
                    .equals(other.removed, removed)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(removed) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $AssetReportAuditCopyRemoveResponseExtension
    on AssetReportAuditCopyRemoveResponse {
  AssetReportAuditCopyRemoveResponse copyWith(
      {bool? removed, String? requestId}) {
    return AssetReportAuditCopyRemoveResponse(
        removed: removed ?? this.removed,
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class InvestmentsHoldingsGetRequest {
  InvestmentsHoldingsGetRequest({
    this.clientId,
    this.secret,
    this.accessToken,
    this.options,
  });

  factory InvestmentsHoldingsGetRequest.fromJson(Map<String, dynamic> json) =>
      _$InvestmentsHoldingsGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'access_token')
  final String? accessToken;
  @JsonKey(name: 'options')
  final InvestmentHoldingsGetRequestOptions? options;
  static const fromJsonFactory = _$InvestmentsHoldingsGetRequestFromJson;
  static const toJsonFactory = _$InvestmentsHoldingsGetRequestToJson;
  Map<String, dynamic> toJson() => _$InvestmentsHoldingsGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvestmentsHoldingsGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)) &&
            (identical(other.options, options) ||
                const DeepCollectionEquality().equals(other.options, options)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(accessToken) ^
      const DeepCollectionEquality().hash(options) ^
      runtimeType.hashCode;
}

extension $InvestmentsHoldingsGetRequestExtension
    on InvestmentsHoldingsGetRequest {
  InvestmentsHoldingsGetRequest copyWith(
      {String? clientId,
      String? secret,
      String? accessToken,
      InvestmentHoldingsGetRequestOptions? options}) {
    return InvestmentsHoldingsGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        accessToken: accessToken ?? this.accessToken,
        options: options ?? this.options);
  }
}

@JsonSerializable(explicitToJson: true)
class InvestmentHoldingsGetRequestOptions {
  InvestmentHoldingsGetRequestOptions({
    this.accountIds,
  });

  factory InvestmentHoldingsGetRequestOptions.fromJson(
          Map<String, dynamic> json) =>
      _$InvestmentHoldingsGetRequestOptionsFromJson(json);

  @JsonKey(name: 'account_ids', defaultValue: <String>[])
  final List<String>? accountIds;
  static const fromJsonFactory = _$InvestmentHoldingsGetRequestOptionsFromJson;
  static const toJsonFactory = _$InvestmentHoldingsGetRequestOptionsToJson;
  Map<String, dynamic> toJson() =>
      _$InvestmentHoldingsGetRequestOptionsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvestmentHoldingsGetRequestOptions &&
            (identical(other.accountIds, accountIds) ||
                const DeepCollectionEquality()
                    .equals(other.accountIds, accountIds)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountIds) ^ runtimeType.hashCode;
}

extension $InvestmentHoldingsGetRequestOptionsExtension
    on InvestmentHoldingsGetRequestOptions {
  InvestmentHoldingsGetRequestOptions copyWith({List<String>? accountIds}) {
    return InvestmentHoldingsGetRequestOptions(
        accountIds: accountIds ?? this.accountIds);
  }
}

@JsonSerializable(explicitToJson: true)
class InvestmentsHoldingsGetResponse {
  InvestmentsHoldingsGetResponse({
    this.accounts,
    this.holdings,
    this.securities,
    this.item,
    this.requestId,
  });

  factory InvestmentsHoldingsGetResponse.fromJson(Map<String, dynamic> json) =>
      _$InvestmentsHoldingsGetResponseFromJson(json);

  @JsonKey(name: 'accounts', defaultValue: <AccountBase>[])
  final List<AccountBase>? accounts;
  @JsonKey(name: 'holdings', defaultValue: <Holding>[])
  final List<Holding>? holdings;
  @JsonKey(name: 'securities', defaultValue: <Security>[])
  final List<Security>? securities;
  @JsonKey(name: 'item')
  final Item? item;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$InvestmentsHoldingsGetResponseFromJson;
  static const toJsonFactory = _$InvestmentsHoldingsGetResponseToJson;
  Map<String, dynamic> toJson() => _$InvestmentsHoldingsGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvestmentsHoldingsGetResponse &&
            (identical(other.accounts, accounts) ||
                const DeepCollectionEquality()
                    .equals(other.accounts, accounts)) &&
            (identical(other.holdings, holdings) ||
                const DeepCollectionEquality()
                    .equals(other.holdings, holdings)) &&
            (identical(other.securities, securities) ||
                const DeepCollectionEquality()
                    .equals(other.securities, securities)) &&
            (identical(other.item, item) ||
                const DeepCollectionEquality().equals(other.item, item)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accounts) ^
      const DeepCollectionEquality().hash(holdings) ^
      const DeepCollectionEquality().hash(securities) ^
      const DeepCollectionEquality().hash(item) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $InvestmentsHoldingsGetResponseExtension
    on InvestmentsHoldingsGetResponse {
  InvestmentsHoldingsGetResponse copyWith(
      {List<AccountBase>? accounts,
      List<Holding>? holdings,
      List<Security>? securities,
      Item? item,
      String? requestId}) {
    return InvestmentsHoldingsGetResponse(
        accounts: accounts ?? this.accounts,
        holdings: holdings ?? this.holdings,
        securities: securities ?? this.securities,
        item: item ?? this.item,
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class InvestmentsTransactionsGetRequest {
  InvestmentsTransactionsGetRequest({
    this.clientId,
    this.secret,
    this.accessToken,
    this.startDate,
    this.endDate,
    this.options,
  });

  factory InvestmentsTransactionsGetRequest.fromJson(
          Map<String, dynamic> json) =>
      _$InvestmentsTransactionsGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'access_token')
  final String? accessToken;
  @JsonKey(name: 'start_date', toJson: _dateToJson)
  final DateTime? startDate;
  @JsonKey(name: 'end_date', toJson: _dateToJson)
  final DateTime? endDate;
  @JsonKey(name: 'options')
  final InvestmentsTransactionsGetRequestOptions? options;
  static const fromJsonFactory = _$InvestmentsTransactionsGetRequestFromJson;
  static const toJsonFactory = _$InvestmentsTransactionsGetRequestToJson;
  Map<String, dynamic> toJson() =>
      _$InvestmentsTransactionsGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvestmentsTransactionsGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)) &&
            (identical(other.startDate, startDate) ||
                const DeepCollectionEquality()
                    .equals(other.startDate, startDate)) &&
            (identical(other.endDate, endDate) ||
                const DeepCollectionEquality()
                    .equals(other.endDate, endDate)) &&
            (identical(other.options, options) ||
                const DeepCollectionEquality().equals(other.options, options)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(accessToken) ^
      const DeepCollectionEquality().hash(startDate) ^
      const DeepCollectionEquality().hash(endDate) ^
      const DeepCollectionEquality().hash(options) ^
      runtimeType.hashCode;
}

extension $InvestmentsTransactionsGetRequestExtension
    on InvestmentsTransactionsGetRequest {
  InvestmentsTransactionsGetRequest copyWith(
      {String? clientId,
      String? secret,
      String? accessToken,
      DateTime? startDate,
      DateTime? endDate,
      InvestmentsTransactionsGetRequestOptions? options}) {
    return InvestmentsTransactionsGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        accessToken: accessToken ?? this.accessToken,
        startDate: startDate ?? this.startDate,
        endDate: endDate ?? this.endDate,
        options: options ?? this.options);
  }
}

@JsonSerializable(explicitToJson: true)
class InvestmentsTransactionsGetRequestOptions {
  InvestmentsTransactionsGetRequestOptions({
    this.accountIds,
    this.count,
    this.offset,
  });

  factory InvestmentsTransactionsGetRequestOptions.fromJson(
          Map<String, dynamic> json) =>
      _$InvestmentsTransactionsGetRequestOptionsFromJson(json);

  @JsonKey(name: 'account_ids', defaultValue: <String>[])
  final List<String>? accountIds;
  @JsonKey(name: 'count')
  final int? count;
  @JsonKey(name: 'offset')
  final int? offset;
  static const fromJsonFactory =
      _$InvestmentsTransactionsGetRequestOptionsFromJson;
  static const toJsonFactory = _$InvestmentsTransactionsGetRequestOptionsToJson;
  Map<String, dynamic> toJson() =>
      _$InvestmentsTransactionsGetRequestOptionsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvestmentsTransactionsGetRequestOptions &&
            (identical(other.accountIds, accountIds) ||
                const DeepCollectionEquality()
                    .equals(other.accountIds, accountIds)) &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)) &&
            (identical(other.offset, offset) ||
                const DeepCollectionEquality().equals(other.offset, offset)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountIds) ^
      const DeepCollectionEquality().hash(count) ^
      const DeepCollectionEquality().hash(offset) ^
      runtimeType.hashCode;
}

extension $InvestmentsTransactionsGetRequestOptionsExtension
    on InvestmentsTransactionsGetRequestOptions {
  InvestmentsTransactionsGetRequestOptions copyWith(
      {List<String>? accountIds, int? count, int? offset}) {
    return InvestmentsTransactionsGetRequestOptions(
        accountIds: accountIds ?? this.accountIds,
        count: count ?? this.count,
        offset: offset ?? this.offset);
  }
}

@JsonSerializable(explicitToJson: true)
class InvestmentsTransactionsGetResponse {
  InvestmentsTransactionsGetResponse({
    this.item,
    this.accounts,
    this.securities,
    this.investmentTransactions,
    this.totalInvestmentTransactions,
    this.requestId,
  });

  factory InvestmentsTransactionsGetResponse.fromJson(
          Map<String, dynamic> json) =>
      _$InvestmentsTransactionsGetResponseFromJson(json);

  @JsonKey(name: 'item')
  final Item? item;
  @JsonKey(name: 'accounts', defaultValue: <AccountBase>[])
  final List<AccountBase>? accounts;
  @JsonKey(name: 'securities', defaultValue: <Security>[])
  final List<Security>? securities;
  @JsonKey(
      name: 'investment_transactions', defaultValue: <InvestmentTransaction>[])
  final List<InvestmentTransaction>? investmentTransactions;
  @JsonKey(name: 'total_investment_transactions')
  final int? totalInvestmentTransactions;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$InvestmentsTransactionsGetResponseFromJson;
  static const toJsonFactory = _$InvestmentsTransactionsGetResponseToJson;
  Map<String, dynamic> toJson() =>
      _$InvestmentsTransactionsGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvestmentsTransactionsGetResponse &&
            (identical(other.item, item) ||
                const DeepCollectionEquality().equals(other.item, item)) &&
            (identical(other.accounts, accounts) ||
                const DeepCollectionEquality()
                    .equals(other.accounts, accounts)) &&
            (identical(other.securities, securities) ||
                const DeepCollectionEquality()
                    .equals(other.securities, securities)) &&
            (identical(other.investmentTransactions, investmentTransactions) ||
                const DeepCollectionEquality().equals(
                    other.investmentTransactions, investmentTransactions)) &&
            (identical(other.totalInvestmentTransactions,
                    totalInvestmentTransactions) ||
                const DeepCollectionEquality().equals(
                    other.totalInvestmentTransactions,
                    totalInvestmentTransactions)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(item) ^
      const DeepCollectionEquality().hash(accounts) ^
      const DeepCollectionEquality().hash(securities) ^
      const DeepCollectionEquality().hash(investmentTransactions) ^
      const DeepCollectionEquality().hash(totalInvestmentTransactions) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $InvestmentsTransactionsGetResponseExtension
    on InvestmentsTransactionsGetResponse {
  InvestmentsTransactionsGetResponse copyWith(
      {Item? item,
      List<AccountBase>? accounts,
      List<Security>? securities,
      List<InvestmentTransaction>? investmentTransactions,
      int? totalInvestmentTransactions,
      String? requestId}) {
    return InvestmentsTransactionsGetResponse(
        item: item ?? this.item,
        accounts: accounts ?? this.accounts,
        securities: securities ?? this.securities,
        investmentTransactions:
            investmentTransactions ?? this.investmentTransactions,
        totalInvestmentTransactions:
            totalInvestmentTransactions ?? this.totalInvestmentTransactions,
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class ProcessorTokenCreateRequest {
  ProcessorTokenCreateRequest({
    this.clientId,
    this.secret,
    this.accessToken,
    this.accountId,
    this.processor,
  });

  factory ProcessorTokenCreateRequest.fromJson(Map<String, dynamic> json) =>
      _$ProcessorTokenCreateRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'access_token')
  final String? accessToken;
  @JsonKey(name: 'account_id')
  final String? accountId;
  @JsonKey(
      name: 'processor',
      toJson: processorTokenCreateRequestProcessorToJson,
      fromJson: processorTokenCreateRequestProcessorFromJson)
  final enums.ProcessorTokenCreateRequestProcessor? processor;
  static const fromJsonFactory = _$ProcessorTokenCreateRequestFromJson;
  static const toJsonFactory = _$ProcessorTokenCreateRequestToJson;
  Map<String, dynamic> toJson() => _$ProcessorTokenCreateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ProcessorTokenCreateRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)) &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.processor, processor) ||
                const DeepCollectionEquality()
                    .equals(other.processor, processor)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(accessToken) ^
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(processor) ^
      runtimeType.hashCode;
}

extension $ProcessorTokenCreateRequestExtension on ProcessorTokenCreateRequest {
  ProcessorTokenCreateRequest copyWith(
      {String? clientId,
      String? secret,
      String? accessToken,
      String? accountId,
      enums.ProcessorTokenCreateRequestProcessor? processor}) {
    return ProcessorTokenCreateRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        accessToken: accessToken ?? this.accessToken,
        accountId: accountId ?? this.accountId,
        processor: processor ?? this.processor);
  }
}

@JsonSerializable(explicitToJson: true)
class ProcessorTokenCreateResponse {
  ProcessorTokenCreateResponse({
    this.processorToken,
    this.requestId,
  });

  factory ProcessorTokenCreateResponse.fromJson(Map<String, dynamic> json) =>
      _$ProcessorTokenCreateResponseFromJson(json);

  @JsonKey(name: 'processor_token')
  final String? processorToken;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$ProcessorTokenCreateResponseFromJson;
  static const toJsonFactory = _$ProcessorTokenCreateResponseToJson;
  Map<String, dynamic> toJson() => _$ProcessorTokenCreateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ProcessorTokenCreateResponse &&
            (identical(other.processorToken, processorToken) ||
                const DeepCollectionEquality()
                    .equals(other.processorToken, processorToken)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(processorToken) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $ProcessorTokenCreateResponseExtension
    on ProcessorTokenCreateResponse {
  ProcessorTokenCreateResponse copyWith(
      {String? processorToken, String? requestId}) {
    return ProcessorTokenCreateResponse(
        processorToken: processorToken ?? this.processorToken,
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class ProcessorStripeBankAccountTokenCreateRequest {
  ProcessorStripeBankAccountTokenCreateRequest({
    this.clientId,
    this.secret,
    this.accessToken,
    this.accountId,
  });

  factory ProcessorStripeBankAccountTokenCreateRequest.fromJson(
          Map<String, dynamic> json) =>
      _$ProcessorStripeBankAccountTokenCreateRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'access_token')
  final String? accessToken;
  @JsonKey(name: 'account_id')
  final String? accountId;
  static const fromJsonFactory =
      _$ProcessorStripeBankAccountTokenCreateRequestFromJson;
  static const toJsonFactory =
      _$ProcessorStripeBankAccountTokenCreateRequestToJson;
  Map<String, dynamic> toJson() =>
      _$ProcessorStripeBankAccountTokenCreateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ProcessorStripeBankAccountTokenCreateRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)) &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(accessToken) ^
      const DeepCollectionEquality().hash(accountId) ^
      runtimeType.hashCode;
}

extension $ProcessorStripeBankAccountTokenCreateRequestExtension
    on ProcessorStripeBankAccountTokenCreateRequest {
  ProcessorStripeBankAccountTokenCreateRequest copyWith(
      {String? clientId,
      String? secret,
      String? accessToken,
      String? accountId}) {
    return ProcessorStripeBankAccountTokenCreateRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        accessToken: accessToken ?? this.accessToken,
        accountId: accountId ?? this.accountId);
  }
}

@JsonSerializable(explicitToJson: true)
class ProcessorStripeBankAccountTokenCreateResponse {
  ProcessorStripeBankAccountTokenCreateResponse({
    this.stripeBankAccountToken,
    this.requestId,
  });

  factory ProcessorStripeBankAccountTokenCreateResponse.fromJson(
          Map<String, dynamic> json) =>
      _$ProcessorStripeBankAccountTokenCreateResponseFromJson(json);

  @JsonKey(name: 'stripe_bank_account_token')
  final String? stripeBankAccountToken;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory =
      _$ProcessorStripeBankAccountTokenCreateResponseFromJson;
  static const toJsonFactory =
      _$ProcessorStripeBankAccountTokenCreateResponseToJson;
  Map<String, dynamic> toJson() =>
      _$ProcessorStripeBankAccountTokenCreateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ProcessorStripeBankAccountTokenCreateResponse &&
            (identical(other.stripeBankAccountToken, stripeBankAccountToken) ||
                const DeepCollectionEquality().equals(
                    other.stripeBankAccountToken, stripeBankAccountToken)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(stripeBankAccountToken) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $ProcessorStripeBankAccountTokenCreateResponseExtension
    on ProcessorStripeBankAccountTokenCreateResponse {
  ProcessorStripeBankAccountTokenCreateResponse copyWith(
      {String? stripeBankAccountToken, String? requestId}) {
    return ProcessorStripeBankAccountTokenCreateResponse(
        stripeBankAccountToken:
            stripeBankAccountToken ?? this.stripeBankAccountToken,
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class ProcessorApexProcessorTokenCreateRequest {
  ProcessorApexProcessorTokenCreateRequest({
    this.clientId,
    this.secret,
    this.accessToken,
    this.accountId,
  });

  factory ProcessorApexProcessorTokenCreateRequest.fromJson(
          Map<String, dynamic> json) =>
      _$ProcessorApexProcessorTokenCreateRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'access_token')
  final String? accessToken;
  @JsonKey(name: 'account_id')
  final String? accountId;
  static const fromJsonFactory =
      _$ProcessorApexProcessorTokenCreateRequestFromJson;
  static const toJsonFactory = _$ProcessorApexProcessorTokenCreateRequestToJson;
  Map<String, dynamic> toJson() =>
      _$ProcessorApexProcessorTokenCreateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ProcessorApexProcessorTokenCreateRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)) &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(accessToken) ^
      const DeepCollectionEquality().hash(accountId) ^
      runtimeType.hashCode;
}

extension $ProcessorApexProcessorTokenCreateRequestExtension
    on ProcessorApexProcessorTokenCreateRequest {
  ProcessorApexProcessorTokenCreateRequest copyWith(
      {String? clientId,
      String? secret,
      String? accessToken,
      String? accountId}) {
    return ProcessorApexProcessorTokenCreateRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        accessToken: accessToken ?? this.accessToken,
        accountId: accountId ?? this.accountId);
  }
}

@JsonSerializable(explicitToJson: true)
class DepositSwitchCreateRequest {
  DepositSwitchCreateRequest({
    this.clientId,
    this.secret,
    this.targetAccessToken,
    this.targetAccountId,
    this.countryCode,
    this.options,
  });

  factory DepositSwitchCreateRequest.fromJson(Map<String, dynamic> json) =>
      _$DepositSwitchCreateRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'target_access_token')
  final String? targetAccessToken;
  @JsonKey(name: 'target_account_id')
  final String? targetAccountId;
  @JsonKey(
      name: 'country_code',
      toJson: depositSwitchCreateRequestCountryCodeToJson,
      fromJson: depositSwitchCreateRequestCountryCodeFromJson)
  final enums.DepositSwitchCreateRequestCountryCode? countryCode;
  @JsonKey(name: 'options')
  final DepositSwitchCreateRequestOptions? options;
  static const fromJsonFactory = _$DepositSwitchCreateRequestFromJson;
  static const toJsonFactory = _$DepositSwitchCreateRequestToJson;
  Map<String, dynamic> toJson() => _$DepositSwitchCreateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is DepositSwitchCreateRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.targetAccessToken, targetAccessToken) ||
                const DeepCollectionEquality()
                    .equals(other.targetAccessToken, targetAccessToken)) &&
            (identical(other.targetAccountId, targetAccountId) ||
                const DeepCollectionEquality()
                    .equals(other.targetAccountId, targetAccountId)) &&
            (identical(other.countryCode, countryCode) ||
                const DeepCollectionEquality()
                    .equals(other.countryCode, countryCode)) &&
            (identical(other.options, options) ||
                const DeepCollectionEquality().equals(other.options, options)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(targetAccessToken) ^
      const DeepCollectionEquality().hash(targetAccountId) ^
      const DeepCollectionEquality().hash(countryCode) ^
      const DeepCollectionEquality().hash(options) ^
      runtimeType.hashCode;
}

extension $DepositSwitchCreateRequestExtension on DepositSwitchCreateRequest {
  DepositSwitchCreateRequest copyWith(
      {String? clientId,
      String? secret,
      String? targetAccessToken,
      String? targetAccountId,
      enums.DepositSwitchCreateRequestCountryCode? countryCode,
      DepositSwitchCreateRequestOptions? options}) {
    return DepositSwitchCreateRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        targetAccessToken: targetAccessToken ?? this.targetAccessToken,
        targetAccountId: targetAccountId ?? this.targetAccountId,
        countryCode: countryCode ?? this.countryCode,
        options: options ?? this.options);
  }
}

@JsonSerializable(explicitToJson: true)
class DepositSwitchCreateRequestOptions {
  DepositSwitchCreateRequestOptions({
    this.webhook,
    this.transactionItemAccessTokens,
  });

  factory DepositSwitchCreateRequestOptions.fromJson(
          Map<String, dynamic> json) =>
      _$DepositSwitchCreateRequestOptionsFromJson(json);

  @JsonKey(name: 'webhook')
  final String? webhook;
  @JsonKey(name: 'transaction_item_access_tokens', defaultValue: <String>[])
  final List<String>? transactionItemAccessTokens;
  static const fromJsonFactory = _$DepositSwitchCreateRequestOptionsFromJson;
  static const toJsonFactory = _$DepositSwitchCreateRequestOptionsToJson;
  Map<String, dynamic> toJson() =>
      _$DepositSwitchCreateRequestOptionsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is DepositSwitchCreateRequestOptions &&
            (identical(other.webhook, webhook) ||
                const DeepCollectionEquality()
                    .equals(other.webhook, webhook)) &&
            (identical(other.transactionItemAccessTokens,
                    transactionItemAccessTokens) ||
                const DeepCollectionEquality().equals(
                    other.transactionItemAccessTokens,
                    transactionItemAccessTokens)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(webhook) ^
      const DeepCollectionEquality().hash(transactionItemAccessTokens) ^
      runtimeType.hashCode;
}

extension $DepositSwitchCreateRequestOptionsExtension
    on DepositSwitchCreateRequestOptions {
  DepositSwitchCreateRequestOptions copyWith(
      {String? webhook, List<String>? transactionItemAccessTokens}) {
    return DepositSwitchCreateRequestOptions(
        webhook: webhook ?? this.webhook,
        transactionItemAccessTokens:
            transactionItemAccessTokens ?? this.transactionItemAccessTokens);
  }
}

@JsonSerializable(explicitToJson: true)
class DepositSwitchCreateResponse {
  DepositSwitchCreateResponse({
    this.depositSwitchId,
    this.requestId,
  });

  factory DepositSwitchCreateResponse.fromJson(Map<String, dynamic> json) =>
      _$DepositSwitchCreateResponseFromJson(json);

  @JsonKey(name: 'deposit_switch_id')
  final String? depositSwitchId;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$DepositSwitchCreateResponseFromJson;
  static const toJsonFactory = _$DepositSwitchCreateResponseToJson;
  Map<String, dynamic> toJson() => _$DepositSwitchCreateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is DepositSwitchCreateResponse &&
            (identical(other.depositSwitchId, depositSwitchId) ||
                const DeepCollectionEquality()
                    .equals(other.depositSwitchId, depositSwitchId)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(depositSwitchId) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $DepositSwitchCreateResponseExtension on DepositSwitchCreateResponse {
  DepositSwitchCreateResponse copyWith(
      {String? depositSwitchId, String? requestId}) {
    return DepositSwitchCreateResponse(
        depositSwitchId: depositSwitchId ?? this.depositSwitchId,
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class ItemImportRequest {
  ItemImportRequest({
    this.clientId,
    this.secret,
    this.products,
    this.userAuth,
    this.options,
  });

  factory ItemImportRequest.fromJson(Map<String, dynamic> json) =>
      _$ItemImportRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(
      name: 'products',
      toJson: productsListToJson,
      fromJson: productsListFromJson)
  final List<enums.Products>? products;
  @JsonKey(name: 'user_auth')
  final ItemImportRequestUserAuth? userAuth;
  @JsonKey(name: 'options')
  final ItemImportRequestOptions? options;
  static const fromJsonFactory = _$ItemImportRequestFromJson;
  static const toJsonFactory = _$ItemImportRequestToJson;
  Map<String, dynamic> toJson() => _$ItemImportRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ItemImportRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.products, products) ||
                const DeepCollectionEquality()
                    .equals(other.products, products)) &&
            (identical(other.userAuth, userAuth) ||
                const DeepCollectionEquality()
                    .equals(other.userAuth, userAuth)) &&
            (identical(other.options, options) ||
                const DeepCollectionEquality().equals(other.options, options)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(products) ^
      const DeepCollectionEquality().hash(userAuth) ^
      const DeepCollectionEquality().hash(options) ^
      runtimeType.hashCode;
}

extension $ItemImportRequestExtension on ItemImportRequest {
  ItemImportRequest copyWith(
      {String? clientId,
      String? secret,
      List<enums.Products>? products,
      ItemImportRequestUserAuth? userAuth,
      ItemImportRequestOptions? options}) {
    return ItemImportRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        products: products ?? this.products,
        userAuth: userAuth ?? this.userAuth,
        options: options ?? this.options);
  }
}

@JsonSerializable(explicitToJson: true)
class ItemImportRequestOptions {
  ItemImportRequestOptions({
    this.webhook,
  });

  factory ItemImportRequestOptions.fromJson(Map<String, dynamic> json) =>
      _$ItemImportRequestOptionsFromJson(json);

  @JsonKey(name: 'webhook')
  final String? webhook;
  static const fromJsonFactory = _$ItemImportRequestOptionsFromJson;
  static const toJsonFactory = _$ItemImportRequestOptionsToJson;
  Map<String, dynamic> toJson() => _$ItemImportRequestOptionsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ItemImportRequestOptions &&
            (identical(other.webhook, webhook) ||
                const DeepCollectionEquality().equals(other.webhook, webhook)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(webhook) ^ runtimeType.hashCode;
}

extension $ItemImportRequestOptionsExtension on ItemImportRequestOptions {
  ItemImportRequestOptions copyWith({String? webhook}) {
    return ItemImportRequestOptions(webhook: webhook ?? this.webhook);
  }
}

@JsonSerializable(explicitToJson: true)
class ItemImportRequestUserAuth {
  ItemImportRequestUserAuth({
    this.userId,
    this.authToken,
  });

  factory ItemImportRequestUserAuth.fromJson(Map<String, dynamic> json) =>
      _$ItemImportRequestUserAuthFromJson(json);

  @JsonKey(name: 'user_id')
  final String? userId;
  @JsonKey(name: 'auth_token')
  final String? authToken;
  static const fromJsonFactory = _$ItemImportRequestUserAuthFromJson;
  static const toJsonFactory = _$ItemImportRequestUserAuthToJson;
  Map<String, dynamic> toJson() => _$ItemImportRequestUserAuthToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ItemImportRequestUserAuth &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)) &&
            (identical(other.authToken, authToken) ||
                const DeepCollectionEquality()
                    .equals(other.authToken, authToken)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(userId) ^
      const DeepCollectionEquality().hash(authToken) ^
      runtimeType.hashCode;
}

extension $ItemImportRequestUserAuthExtension on ItemImportRequestUserAuth {
  ItemImportRequestUserAuth copyWith({String? userId, String? authToken}) {
    return ItemImportRequestUserAuth(
        userId: userId ?? this.userId, authToken: authToken ?? this.authToken);
  }
}

@JsonSerializable(explicitToJson: true)
class ItemImportResponse {
  ItemImportResponse({
    this.accessToken,
    this.requestId,
  });

  factory ItemImportResponse.fromJson(Map<String, dynamic> json) =>
      _$ItemImportResponseFromJson(json);

  @JsonKey(name: 'access_token')
  final String? accessToken;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$ItemImportResponseFromJson;
  static const toJsonFactory = _$ItemImportResponseToJson;
  Map<String, dynamic> toJson() => _$ItemImportResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ItemImportResponse &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accessToken) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $ItemImportResponseExtension on ItemImportResponse {
  ItemImportResponse copyWith({String? accessToken, String? requestId}) {
    return ItemImportResponse(
        accessToken: accessToken ?? this.accessToken,
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class DepositSwitchTokenCreateRequest {
  DepositSwitchTokenCreateRequest({
    this.clientId,
    this.secret,
    this.depositSwitchId,
  });

  factory DepositSwitchTokenCreateRequest.fromJson(Map<String, dynamic> json) =>
      _$DepositSwitchTokenCreateRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'deposit_switch_id')
  final String? depositSwitchId;
  static const fromJsonFactory = _$DepositSwitchTokenCreateRequestFromJson;
  static const toJsonFactory = _$DepositSwitchTokenCreateRequestToJson;
  Map<String, dynamic> toJson() =>
      _$DepositSwitchTokenCreateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is DepositSwitchTokenCreateRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.depositSwitchId, depositSwitchId) ||
                const DeepCollectionEquality()
                    .equals(other.depositSwitchId, depositSwitchId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(depositSwitchId) ^
      runtimeType.hashCode;
}

extension $DepositSwitchTokenCreateRequestExtension
    on DepositSwitchTokenCreateRequest {
  DepositSwitchTokenCreateRequest copyWith(
      {String? clientId, String? secret, String? depositSwitchId}) {
    return DepositSwitchTokenCreateRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        depositSwitchId: depositSwitchId ?? this.depositSwitchId);
  }
}

@JsonSerializable(explicitToJson: true)
class DepositSwitchTokenCreateResponse {
  DepositSwitchTokenCreateResponse({
    this.depositSwitchToken,
    this.depositSwitchTokenExpirationTime,
    this.requestId,
  });

  factory DepositSwitchTokenCreateResponse.fromJson(
          Map<String, dynamic> json) =>
      _$DepositSwitchTokenCreateResponseFromJson(json);

  @JsonKey(name: 'deposit_switch_token')
  final String? depositSwitchToken;
  @JsonKey(name: 'deposit_switch_token_expiration_time')
  final String? depositSwitchTokenExpirationTime;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$DepositSwitchTokenCreateResponseFromJson;
  static const toJsonFactory = _$DepositSwitchTokenCreateResponseToJson;
  Map<String, dynamic> toJson() =>
      _$DepositSwitchTokenCreateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is DepositSwitchTokenCreateResponse &&
            (identical(other.depositSwitchToken, depositSwitchToken) ||
                const DeepCollectionEquality()
                    .equals(other.depositSwitchToken, depositSwitchToken)) &&
            (identical(other.depositSwitchTokenExpirationTime,
                    depositSwitchTokenExpirationTime) ||
                const DeepCollectionEquality().equals(
                    other.depositSwitchTokenExpirationTime,
                    depositSwitchTokenExpirationTime)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(depositSwitchToken) ^
      const DeepCollectionEquality().hash(depositSwitchTokenExpirationTime) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $DepositSwitchTokenCreateResponseExtension
    on DepositSwitchTokenCreateResponse {
  DepositSwitchTokenCreateResponse copyWith(
      {String? depositSwitchToken,
      String? depositSwitchTokenExpirationTime,
      String? requestId}) {
    return DepositSwitchTokenCreateResponse(
        depositSwitchToken: depositSwitchToken ?? this.depositSwitchToken,
        depositSwitchTokenExpirationTime: depositSwitchTokenExpirationTime ??
            this.depositSwitchTokenExpirationTime,
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class LinkTokenGetRequest {
  LinkTokenGetRequest({
    this.clientId,
    this.secret,
    this.linkToken,
  });

  factory LinkTokenGetRequest.fromJson(Map<String, dynamic> json) =>
      _$LinkTokenGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'link_token')
  final String? linkToken;
  static const fromJsonFactory = _$LinkTokenGetRequestFromJson;
  static const toJsonFactory = _$LinkTokenGetRequestToJson;
  Map<String, dynamic> toJson() => _$LinkTokenGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LinkTokenGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.linkToken, linkToken) ||
                const DeepCollectionEquality()
                    .equals(other.linkToken, linkToken)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(linkToken) ^
      runtimeType.hashCode;
}

extension $LinkTokenGetRequestExtension on LinkTokenGetRequest {
  LinkTokenGetRequest copyWith(
      {String? clientId, String? secret, String? linkToken}) {
    return LinkTokenGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        linkToken: linkToken ?? this.linkToken);
  }
}

@JsonSerializable(explicitToJson: true)
class LinkTokenCreateRequest {
  LinkTokenCreateRequest({
    this.clientId,
    this.secret,
    this.clientName,
    this.language,
    this.countryCodes,
    this.user,
    this.products,
    this.webhook,
    this.accessToken,
    this.linkCustomizationName,
    this.redirectUri,
    this.androidPackageName,
    this.accountFilters,
    this.euConfig,
    this.institutionId,
    this.paymentInitiation,
    this.depositSwitch,
    this.incomeVerification,
    this.auth,
    this.transfer,
    this.update,
  });

  factory LinkTokenCreateRequest.fromJson(Map<String, dynamic> json) =>
      _$LinkTokenCreateRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'client_name')
  final String? clientName;
  @JsonKey(name: 'language')
  final String? language;
  @JsonKey(
      name: 'country_codes',
      toJson: countryCodeListToJson,
      fromJson: countryCodeListFromJson)
  final List<enums.CountryCode>? countryCodes;
  @JsonKey(name: 'user')
  final LinkTokenCreateRequestUser? user;
  @JsonKey(
      name: 'products',
      toJson: productsListToJson,
      fromJson: productsListFromJson)
  final List<enums.Products>? products;
  @JsonKey(name: 'webhook')
  final String? webhook;
  @JsonKey(name: 'access_token')
  final String? accessToken;
  @JsonKey(name: 'link_customization_name')
  final String? linkCustomizationName;
  @JsonKey(name: 'redirect_uri')
  final String? redirectUri;
  @JsonKey(name: 'android_package_name')
  final String? androidPackageName;
  @JsonKey(name: 'account_filters')
  final LinkTokenAccountFilters? accountFilters;
  @JsonKey(name: 'eu_config')
  final LinkTokenEUConfig? euConfig;
  @JsonKey(name: 'institution_id')
  final String? institutionId;
  @JsonKey(name: 'payment_initiation')
  final LinkTokenCreateRequestPaymentInitiation? paymentInitiation;
  @JsonKey(name: 'deposit_switch')
  final LinkTokenCreateRequestDepositSwitch? depositSwitch;
  @JsonKey(name: 'income_verification')
  final LinkTokenCreateRequestIncomeVerification? incomeVerification;
  @JsonKey(name: 'auth')
  final LinkTokenCreateRequestAuth? auth;
  @JsonKey(name: 'transfer')
  final LinkTokenCreateRequestTransfer? transfer;
  @JsonKey(name: 'update')
  final LinkTokenCreateRequestUpdate? update;
  static const fromJsonFactory = _$LinkTokenCreateRequestFromJson;
  static const toJsonFactory = _$LinkTokenCreateRequestToJson;
  Map<String, dynamic> toJson() => _$LinkTokenCreateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LinkTokenCreateRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.clientName, clientName) ||
                const DeepCollectionEquality()
                    .equals(other.clientName, clientName)) &&
            (identical(other.language, language) ||
                const DeepCollectionEquality()
                    .equals(other.language, language)) &&
            (identical(other.countryCodes, countryCodes) ||
                const DeepCollectionEquality()
                    .equals(other.countryCodes, countryCodes)) &&
            (identical(other.user, user) ||
                const DeepCollectionEquality().equals(other.user, user)) &&
            (identical(other.products, products) ||
                const DeepCollectionEquality()
                    .equals(other.products, products)) &&
            (identical(other.webhook, webhook) ||
                const DeepCollectionEquality()
                    .equals(other.webhook, webhook)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)) &&
            (identical(other.linkCustomizationName, linkCustomizationName) ||
                const DeepCollectionEquality().equals(
                    other.linkCustomizationName, linkCustomizationName)) &&
            (identical(other.redirectUri, redirectUri) ||
                const DeepCollectionEquality()
                    .equals(other.redirectUri, redirectUri)) &&
            (identical(other.androidPackageName, androidPackageName) ||
                const DeepCollectionEquality()
                    .equals(other.androidPackageName, androidPackageName)) &&
            (identical(other.accountFilters, accountFilters) ||
                const DeepCollectionEquality()
                    .equals(other.accountFilters, accountFilters)) &&
            (identical(other.euConfig, euConfig) ||
                const DeepCollectionEquality()
                    .equals(other.euConfig, euConfig)) &&
            (identical(other.institutionId, institutionId) ||
                const DeepCollectionEquality()
                    .equals(other.institutionId, institutionId)) &&
            (identical(other.paymentInitiation, paymentInitiation) ||
                const DeepCollectionEquality()
                    .equals(other.paymentInitiation, paymentInitiation)) &&
            (identical(other.depositSwitch, depositSwitch) ||
                const DeepCollectionEquality()
                    .equals(other.depositSwitch, depositSwitch)) &&
            (identical(other.incomeVerification, incomeVerification) ||
                const DeepCollectionEquality()
                    .equals(other.incomeVerification, incomeVerification)) &&
            (identical(other.auth, auth) ||
                const DeepCollectionEquality().equals(other.auth, auth)) &&
            (identical(other.transfer, transfer) ||
                const DeepCollectionEquality()
                    .equals(other.transfer, transfer)) &&
            (identical(other.update, update) ||
                const DeepCollectionEquality().equals(other.update, update)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(clientName) ^
      const DeepCollectionEquality().hash(language) ^
      const DeepCollectionEquality().hash(countryCodes) ^
      const DeepCollectionEquality().hash(user) ^
      const DeepCollectionEquality().hash(products) ^
      const DeepCollectionEquality().hash(webhook) ^
      const DeepCollectionEquality().hash(accessToken) ^
      const DeepCollectionEquality().hash(linkCustomizationName) ^
      const DeepCollectionEquality().hash(redirectUri) ^
      const DeepCollectionEquality().hash(androidPackageName) ^
      const DeepCollectionEquality().hash(accountFilters) ^
      const DeepCollectionEquality().hash(euConfig) ^
      const DeepCollectionEquality().hash(institutionId) ^
      const DeepCollectionEquality().hash(paymentInitiation) ^
      const DeepCollectionEquality().hash(depositSwitch) ^
      const DeepCollectionEquality().hash(incomeVerification) ^
      const DeepCollectionEquality().hash(auth) ^
      const DeepCollectionEquality().hash(transfer) ^
      const DeepCollectionEquality().hash(update) ^
      runtimeType.hashCode;
}

extension $LinkTokenCreateRequestExtension on LinkTokenCreateRequest {
  LinkTokenCreateRequest copyWith(
      {String? clientId,
      String? secret,
      String? clientName,
      String? language,
      List<enums.CountryCode>? countryCodes,
      LinkTokenCreateRequestUser? user,
      List<enums.Products>? products,
      String? webhook,
      String? accessToken,
      String? linkCustomizationName,
      String? redirectUri,
      String? androidPackageName,
      LinkTokenAccountFilters? accountFilters,
      LinkTokenEUConfig? euConfig,
      String? institutionId,
      LinkTokenCreateRequestPaymentInitiation? paymentInitiation,
      LinkTokenCreateRequestDepositSwitch? depositSwitch,
      LinkTokenCreateRequestIncomeVerification? incomeVerification,
      LinkTokenCreateRequestAuth? auth,
      LinkTokenCreateRequestTransfer? transfer,
      LinkTokenCreateRequestUpdate? update}) {
    return LinkTokenCreateRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        clientName: clientName ?? this.clientName,
        language: language ?? this.language,
        countryCodes: countryCodes ?? this.countryCodes,
        user: user ?? this.user,
        products: products ?? this.products,
        webhook: webhook ?? this.webhook,
        accessToken: accessToken ?? this.accessToken,
        linkCustomizationName:
            linkCustomizationName ?? this.linkCustomizationName,
        redirectUri: redirectUri ?? this.redirectUri,
        androidPackageName: androidPackageName ?? this.androidPackageName,
        accountFilters: accountFilters ?? this.accountFilters,
        euConfig: euConfig ?? this.euConfig,
        institutionId: institutionId ?? this.institutionId,
        paymentInitiation: paymentInitiation ?? this.paymentInitiation,
        depositSwitch: depositSwitch ?? this.depositSwitch,
        incomeVerification: incomeVerification ?? this.incomeVerification,
        auth: auth ?? this.auth,
        transfer: transfer ?? this.transfer,
        update: update ?? this.update);
  }
}

@JsonSerializable(explicitToJson: true)
class LinkTokenAccountFilters {
  LinkTokenAccountFilters({
    this.depository,
    this.credit,
    this.loan,
    this.investment,
  });

  factory LinkTokenAccountFilters.fromJson(Map<String, dynamic> json) =>
      _$LinkTokenAccountFiltersFromJson(json);

  @JsonKey(name: 'depository')
  final DepositoryFilter? depository;
  @JsonKey(name: 'credit')
  final CreditFilter? credit;
  @JsonKey(name: 'loan')
  final LoanFilter? loan;
  @JsonKey(name: 'investment')
  final InvestmentFilter? investment;
  static const fromJsonFactory = _$LinkTokenAccountFiltersFromJson;
  static const toJsonFactory = _$LinkTokenAccountFiltersToJson;
  Map<String, dynamic> toJson() => _$LinkTokenAccountFiltersToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LinkTokenAccountFilters &&
            (identical(other.depository, depository) ||
                const DeepCollectionEquality()
                    .equals(other.depository, depository)) &&
            (identical(other.credit, credit) ||
                const DeepCollectionEquality().equals(other.credit, credit)) &&
            (identical(other.loan, loan) ||
                const DeepCollectionEquality().equals(other.loan, loan)) &&
            (identical(other.investment, investment) ||
                const DeepCollectionEquality()
                    .equals(other.investment, investment)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(depository) ^
      const DeepCollectionEquality().hash(credit) ^
      const DeepCollectionEquality().hash(loan) ^
      const DeepCollectionEquality().hash(investment) ^
      runtimeType.hashCode;
}

extension $LinkTokenAccountFiltersExtension on LinkTokenAccountFilters {
  LinkTokenAccountFilters copyWith(
      {DepositoryFilter? depository,
      CreditFilter? credit,
      LoanFilter? loan,
      InvestmentFilter? investment}) {
    return LinkTokenAccountFilters(
        depository: depository ?? this.depository,
        credit: credit ?? this.credit,
        loan: loan ?? this.loan,
        investment: investment ?? this.investment);
  }
}

@JsonSerializable(explicitToJson: true)
class LinkTokenEUConfig {
  LinkTokenEUConfig({
    this.headless,
  });

  factory LinkTokenEUConfig.fromJson(Map<String, dynamic> json) =>
      _$LinkTokenEUConfigFromJson(json);

  @JsonKey(name: 'headless')
  final bool? headless;
  static const fromJsonFactory = _$LinkTokenEUConfigFromJson;
  static const toJsonFactory = _$LinkTokenEUConfigToJson;
  Map<String, dynamic> toJson() => _$LinkTokenEUConfigToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LinkTokenEUConfig &&
            (identical(other.headless, headless) ||
                const DeepCollectionEquality()
                    .equals(other.headless, headless)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(headless) ^ runtimeType.hashCode;
}

extension $LinkTokenEUConfigExtension on LinkTokenEUConfig {
  LinkTokenEUConfig copyWith({bool? headless}) {
    return LinkTokenEUConfig(headless: headless ?? this.headless);
  }
}

@JsonSerializable(explicitToJson: true)
class LinkTokenCreateRequestPaymentInitiation {
  LinkTokenCreateRequestPaymentInitiation({
    this.paymentId,
  });

  factory LinkTokenCreateRequestPaymentInitiation.fromJson(
          Map<String, dynamic> json) =>
      _$LinkTokenCreateRequestPaymentInitiationFromJson(json);

  @JsonKey(name: 'payment_id')
  final String? paymentId;
  static const fromJsonFactory =
      _$LinkTokenCreateRequestPaymentInitiationFromJson;
  static const toJsonFactory = _$LinkTokenCreateRequestPaymentInitiationToJson;
  Map<String, dynamic> toJson() =>
      _$LinkTokenCreateRequestPaymentInitiationToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LinkTokenCreateRequestPaymentInitiation &&
            (identical(other.paymentId, paymentId) ||
                const DeepCollectionEquality()
                    .equals(other.paymentId, paymentId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(paymentId) ^ runtimeType.hashCode;
}

extension $LinkTokenCreateRequestPaymentInitiationExtension
    on LinkTokenCreateRequestPaymentInitiation {
  LinkTokenCreateRequestPaymentInitiation copyWith({String? paymentId}) {
    return LinkTokenCreateRequestPaymentInitiation(
        paymentId: paymentId ?? this.paymentId);
  }
}

@JsonSerializable(explicitToJson: true)
class LinkTokenCreateRequestDepositSwitch {
  LinkTokenCreateRequestDepositSwitch({
    this.depositSwitchId,
  });

  factory LinkTokenCreateRequestDepositSwitch.fromJson(
          Map<String, dynamic> json) =>
      _$LinkTokenCreateRequestDepositSwitchFromJson(json);

  @JsonKey(name: 'deposit_switch_id')
  final String? depositSwitchId;
  static const fromJsonFactory = _$LinkTokenCreateRequestDepositSwitchFromJson;
  static const toJsonFactory = _$LinkTokenCreateRequestDepositSwitchToJson;
  Map<String, dynamic> toJson() =>
      _$LinkTokenCreateRequestDepositSwitchToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LinkTokenCreateRequestDepositSwitch &&
            (identical(other.depositSwitchId, depositSwitchId) ||
                const DeepCollectionEquality()
                    .equals(other.depositSwitchId, depositSwitchId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(depositSwitchId) ^
      runtimeType.hashCode;
}

extension $LinkTokenCreateRequestDepositSwitchExtension
    on LinkTokenCreateRequestDepositSwitch {
  LinkTokenCreateRequestDepositSwitch copyWith({String? depositSwitchId}) {
    return LinkTokenCreateRequestDepositSwitch(
        depositSwitchId: depositSwitchId ?? this.depositSwitchId);
  }
}

@JsonSerializable(explicitToJson: true)
class LinkTokenCreateRequestTransfer {
  LinkTokenCreateRequestTransfer({
    this.intentId,
  });

  factory LinkTokenCreateRequestTransfer.fromJson(Map<String, dynamic> json) =>
      _$LinkTokenCreateRequestTransferFromJson(json);

  @JsonKey(name: 'intent_id')
  final String? intentId;
  static const fromJsonFactory = _$LinkTokenCreateRequestTransferFromJson;
  static const toJsonFactory = _$LinkTokenCreateRequestTransferToJson;
  Map<String, dynamic> toJson() => _$LinkTokenCreateRequestTransferToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LinkTokenCreateRequestTransfer &&
            (identical(other.intentId, intentId) ||
                const DeepCollectionEquality()
                    .equals(other.intentId, intentId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(intentId) ^ runtimeType.hashCode;
}

extension $LinkTokenCreateRequestTransferExtension
    on LinkTokenCreateRequestTransfer {
  LinkTokenCreateRequestTransfer copyWith({String? intentId}) {
    return LinkTokenCreateRequestTransfer(intentId: intentId ?? this.intentId);
  }
}

@JsonSerializable(explicitToJson: true)
class LinkTokenCreateRequestAuth {
  LinkTokenCreateRequestAuth({
    this.flowType,
  });

  factory LinkTokenCreateRequestAuth.fromJson(Map<String, dynamic> json) =>
      _$LinkTokenCreateRequestAuthFromJson(json);

  @JsonKey(
      name: 'flow_type',
      toJson: linkTokenCreateRequestAuthFlowTypeToJson,
      fromJson: linkTokenCreateRequestAuthFlowTypeFromJson)
  final enums.LinkTokenCreateRequestAuthFlowType? flowType;
  static const fromJsonFactory = _$LinkTokenCreateRequestAuthFromJson;
  static const toJsonFactory = _$LinkTokenCreateRequestAuthToJson;
  Map<String, dynamic> toJson() => _$LinkTokenCreateRequestAuthToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LinkTokenCreateRequestAuth &&
            (identical(other.flowType, flowType) ||
                const DeepCollectionEquality()
                    .equals(other.flowType, flowType)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(flowType) ^ runtimeType.hashCode;
}

extension $LinkTokenCreateRequestAuthExtension on LinkTokenCreateRequestAuth {
  LinkTokenCreateRequestAuth copyWith(
      {enums.LinkTokenCreateRequestAuthFlowType? flowType}) {
    return LinkTokenCreateRequestAuth(flowType: flowType ?? this.flowType);
  }
}

@JsonSerializable(explicitToJson: true)
class LinkTokenCreateRequestUser {
  LinkTokenCreateRequestUser({
    this.clientUserId,
    this.legalName,
    this.phoneNumber,
    this.phoneNumberVerifiedTime,
    this.emailAddress,
    this.emailAddressVerifiedTime,
    this.ssn,
    this.dateOfBirth,
  });

  factory LinkTokenCreateRequestUser.fromJson(Map<String, dynamic> json) =>
      _$LinkTokenCreateRequestUserFromJson(json);

  @JsonKey(name: 'client_user_id')
  final String? clientUserId;
  @JsonKey(name: 'legal_name')
  final String? legalName;
  @JsonKey(name: 'phone_number')
  final String? phoneNumber;
  @JsonKey(name: 'phone_number_verified_time')
  final DateTime? phoneNumberVerifiedTime;
  @JsonKey(name: 'email_address')
  final String? emailAddress;
  @JsonKey(name: 'email_address_verified_time')
  final DateTime? emailAddressVerifiedTime;
  @JsonKey(name: 'ssn')
  final String? ssn;
  @JsonKey(name: 'date_of_birth', toJson: _dateToJson)
  final DateTime? dateOfBirth;
  static const fromJsonFactory = _$LinkTokenCreateRequestUserFromJson;
  static const toJsonFactory = _$LinkTokenCreateRequestUserToJson;
  Map<String, dynamic> toJson() => _$LinkTokenCreateRequestUserToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LinkTokenCreateRequestUser &&
            (identical(other.clientUserId, clientUserId) ||
                const DeepCollectionEquality()
                    .equals(other.clientUserId, clientUserId)) &&
            (identical(other.legalName, legalName) ||
                const DeepCollectionEquality()
                    .equals(other.legalName, legalName)) &&
            (identical(other.phoneNumber, phoneNumber) ||
                const DeepCollectionEquality()
                    .equals(other.phoneNumber, phoneNumber)) &&
            (identical(
                    other.phoneNumberVerifiedTime, phoneNumberVerifiedTime) ||
                const DeepCollectionEquality().equals(
                    other.phoneNumberVerifiedTime, phoneNumberVerifiedTime)) &&
            (identical(other.emailAddress, emailAddress) ||
                const DeepCollectionEquality()
                    .equals(other.emailAddress, emailAddress)) &&
            (identical(
                    other.emailAddressVerifiedTime, emailAddressVerifiedTime) ||
                const DeepCollectionEquality().equals(
                    other.emailAddressVerifiedTime,
                    emailAddressVerifiedTime)) &&
            (identical(other.ssn, ssn) ||
                const DeepCollectionEquality().equals(other.ssn, ssn)) &&
            (identical(other.dateOfBirth, dateOfBirth) ||
                const DeepCollectionEquality()
                    .equals(other.dateOfBirth, dateOfBirth)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientUserId) ^
      const DeepCollectionEquality().hash(legalName) ^
      const DeepCollectionEquality().hash(phoneNumber) ^
      const DeepCollectionEquality().hash(phoneNumberVerifiedTime) ^
      const DeepCollectionEquality().hash(emailAddress) ^
      const DeepCollectionEquality().hash(emailAddressVerifiedTime) ^
      const DeepCollectionEquality().hash(ssn) ^
      const DeepCollectionEquality().hash(dateOfBirth) ^
      runtimeType.hashCode;
}

extension $LinkTokenCreateRequestUserExtension on LinkTokenCreateRequestUser {
  LinkTokenCreateRequestUser copyWith(
      {String? clientUserId,
      String? legalName,
      String? phoneNumber,
      DateTime? phoneNumberVerifiedTime,
      String? emailAddress,
      DateTime? emailAddressVerifiedTime,
      String? ssn,
      DateTime? dateOfBirth}) {
    return LinkTokenCreateRequestUser(
        clientUserId: clientUserId ?? this.clientUserId,
        legalName: legalName ?? this.legalName,
        phoneNumber: phoneNumber ?? this.phoneNumber,
        phoneNumberVerifiedTime:
            phoneNumberVerifiedTime ?? this.phoneNumberVerifiedTime,
        emailAddress: emailAddress ?? this.emailAddress,
        emailAddressVerifiedTime:
            emailAddressVerifiedTime ?? this.emailAddressVerifiedTime,
        ssn: ssn ?? this.ssn,
        dateOfBirth: dateOfBirth ?? this.dateOfBirth);
  }
}

@JsonSerializable(explicitToJson: true)
class LinkTokenCreateRequestUpdate {
  LinkTokenCreateRequestUpdate({
    this.accountSelectionEnabled,
  });

  factory LinkTokenCreateRequestUpdate.fromJson(Map<String, dynamic> json) =>
      _$LinkTokenCreateRequestUpdateFromJson(json);

  @JsonKey(name: 'account_selection_enabled', defaultValue: false)
  final bool? accountSelectionEnabled;
  static const fromJsonFactory = _$LinkTokenCreateRequestUpdateFromJson;
  static const toJsonFactory = _$LinkTokenCreateRequestUpdateToJson;
  Map<String, dynamic> toJson() => _$LinkTokenCreateRequestUpdateToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LinkTokenCreateRequestUpdate &&
            (identical(
                    other.accountSelectionEnabled, accountSelectionEnabled) ||
                const DeepCollectionEquality().equals(
                    other.accountSelectionEnabled, accountSelectionEnabled)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountSelectionEnabled) ^
      runtimeType.hashCode;
}

extension $LinkTokenCreateRequestUpdateExtension
    on LinkTokenCreateRequestUpdate {
  LinkTokenCreateRequestUpdate copyWith({bool? accountSelectionEnabled}) {
    return LinkTokenCreateRequestUpdate(
        accountSelectionEnabled:
            accountSelectionEnabled ?? this.accountSelectionEnabled);
  }
}

@JsonSerializable(explicitToJson: true)
class LinkTokenCreateRequestAccountSubtypes {
  LinkTokenCreateRequestAccountSubtypes({
    this.depository,
    this.credit,
    this.loan,
    this.investment,
  });

  factory LinkTokenCreateRequestAccountSubtypes.fromJson(
          Map<String, dynamic> json) =>
      _$LinkTokenCreateRequestAccountSubtypesFromJson(json);

  @JsonKey(name: 'depository')
  final Map<String, dynamic>? depository;
  @JsonKey(name: 'credit')
  final Map<String, dynamic>? credit;
  @JsonKey(name: 'loan')
  final Map<String, dynamic>? loan;
  @JsonKey(name: 'investment')
  final Map<String, dynamic>? investment;
  static const fromJsonFactory =
      _$LinkTokenCreateRequestAccountSubtypesFromJson;
  static const toJsonFactory = _$LinkTokenCreateRequestAccountSubtypesToJson;
  Map<String, dynamic> toJson() =>
      _$LinkTokenCreateRequestAccountSubtypesToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LinkTokenCreateRequestAccountSubtypes &&
            (identical(other.depository, depository) ||
                const DeepCollectionEquality()
                    .equals(other.depository, depository)) &&
            (identical(other.credit, credit) ||
                const DeepCollectionEquality().equals(other.credit, credit)) &&
            (identical(other.loan, loan) ||
                const DeepCollectionEquality().equals(other.loan, loan)) &&
            (identical(other.investment, investment) ||
                const DeepCollectionEquality()
                    .equals(other.investment, investment)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(depository) ^
      const DeepCollectionEquality().hash(credit) ^
      const DeepCollectionEquality().hash(loan) ^
      const DeepCollectionEquality().hash(investment) ^
      runtimeType.hashCode;
}

extension $LinkTokenCreateRequestAccountSubtypesExtension
    on LinkTokenCreateRequestAccountSubtypes {
  LinkTokenCreateRequestAccountSubtypes copyWith(
      {Map<String, dynamic>? depository,
      Map<String, dynamic>? credit,
      Map<String, dynamic>? loan,
      Map<String, dynamic>? investment}) {
    return LinkTokenCreateRequestAccountSubtypes(
        depository: depository ?? this.depository,
        credit: credit ?? this.credit,
        loan: loan ?? this.loan,
        investment: investment ?? this.investment);
  }
}

@JsonSerializable(explicitToJson: true)
class LinkTokenGetResponse {
  LinkTokenGetResponse({
    this.linkToken,
    this.createdAt,
    this.expiration,
    this.metadata,
    this.requestId,
  });

  factory LinkTokenGetResponse.fromJson(Map<String, dynamic> json) =>
      _$LinkTokenGetResponseFromJson(json);

  @JsonKey(name: 'link_token')
  final String? linkToken;
  @JsonKey(name: 'created_at')
  final DateTime? createdAt;
  @JsonKey(name: 'expiration')
  final DateTime? expiration;
  @JsonKey(name: 'metadata')
  final LinkTokenGetMetadataResponse? metadata;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$LinkTokenGetResponseFromJson;
  static const toJsonFactory = _$LinkTokenGetResponseToJson;
  Map<String, dynamic> toJson() => _$LinkTokenGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LinkTokenGetResponse &&
            (identical(other.linkToken, linkToken) ||
                const DeepCollectionEquality()
                    .equals(other.linkToken, linkToken)) &&
            (identical(other.createdAt, createdAt) ||
                const DeepCollectionEquality()
                    .equals(other.createdAt, createdAt)) &&
            (identical(other.expiration, expiration) ||
                const DeepCollectionEquality()
                    .equals(other.expiration, expiration)) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality()
                    .equals(other.metadata, metadata)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(linkToken) ^
      const DeepCollectionEquality().hash(createdAt) ^
      const DeepCollectionEquality().hash(expiration) ^
      const DeepCollectionEquality().hash(metadata) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $LinkTokenGetResponseExtension on LinkTokenGetResponse {
  LinkTokenGetResponse copyWith(
      {String? linkToken,
      DateTime? createdAt,
      DateTime? expiration,
      LinkTokenGetMetadataResponse? metadata,
      String? requestId}) {
    return LinkTokenGetResponse(
        linkToken: linkToken ?? this.linkToken,
        createdAt: createdAt ?? this.createdAt,
        expiration: expiration ?? this.expiration,
        metadata: metadata ?? this.metadata,
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class LinkTokenGetMetadataResponse {
  LinkTokenGetMetadataResponse({
    this.initialProducts,
    this.webhook,
    this.countryCodes,
    this.language,
    this.accountFilters,
    this.redirectUri,
    this.clientName,
  });

  factory LinkTokenGetMetadataResponse.fromJson(Map<String, dynamic> json) =>
      _$LinkTokenGetMetadataResponseFromJson(json);

  @JsonKey(
      name: 'initial_products',
      toJson: productsListToJson,
      fromJson: productsListFromJson)
  final List<enums.Products>? initialProducts;
  @JsonKey(name: 'webhook')
  final String? webhook;
  @JsonKey(
      name: 'country_codes',
      toJson: countryCodeListToJson,
      fromJson: countryCodeListFromJson)
  final List<enums.CountryCode>? countryCodes;
  @JsonKey(name: 'language')
  final String? language;
  @JsonKey(name: 'account_filters')
  final AccountFiltersResponse? accountFilters;
  @JsonKey(name: 'redirect_uri')
  final String? redirectUri;
  @JsonKey(name: 'client_name')
  final String? clientName;
  static const fromJsonFactory = _$LinkTokenGetMetadataResponseFromJson;
  static const toJsonFactory = _$LinkTokenGetMetadataResponseToJson;
  Map<String, dynamic> toJson() => _$LinkTokenGetMetadataResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LinkTokenGetMetadataResponse &&
            (identical(other.initialProducts, initialProducts) ||
                const DeepCollectionEquality()
                    .equals(other.initialProducts, initialProducts)) &&
            (identical(other.webhook, webhook) ||
                const DeepCollectionEquality()
                    .equals(other.webhook, webhook)) &&
            (identical(other.countryCodes, countryCodes) ||
                const DeepCollectionEquality()
                    .equals(other.countryCodes, countryCodes)) &&
            (identical(other.language, language) ||
                const DeepCollectionEquality()
                    .equals(other.language, language)) &&
            (identical(other.accountFilters, accountFilters) ||
                const DeepCollectionEquality()
                    .equals(other.accountFilters, accountFilters)) &&
            (identical(other.redirectUri, redirectUri) ||
                const DeepCollectionEquality()
                    .equals(other.redirectUri, redirectUri)) &&
            (identical(other.clientName, clientName) ||
                const DeepCollectionEquality()
                    .equals(other.clientName, clientName)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(initialProducts) ^
      const DeepCollectionEquality().hash(webhook) ^
      const DeepCollectionEquality().hash(countryCodes) ^
      const DeepCollectionEquality().hash(language) ^
      const DeepCollectionEquality().hash(accountFilters) ^
      const DeepCollectionEquality().hash(redirectUri) ^
      const DeepCollectionEquality().hash(clientName) ^
      runtimeType.hashCode;
}

extension $LinkTokenGetMetadataResponseExtension
    on LinkTokenGetMetadataResponse {
  LinkTokenGetMetadataResponse copyWith(
      {List<enums.Products>? initialProducts,
      String? webhook,
      List<enums.CountryCode>? countryCodes,
      String? language,
      AccountFiltersResponse? accountFilters,
      String? redirectUri,
      String? clientName}) {
    return LinkTokenGetMetadataResponse(
        initialProducts: initialProducts ?? this.initialProducts,
        webhook: webhook ?? this.webhook,
        countryCodes: countryCodes ?? this.countryCodes,
        language: language ?? this.language,
        accountFilters: accountFilters ?? this.accountFilters,
        redirectUri: redirectUri ?? this.redirectUri,
        clientName: clientName ?? this.clientName);
  }
}

@JsonSerializable(explicitToJson: true)
class LinkTokenCreateResponse {
  LinkTokenCreateResponse({
    this.linkToken,
    this.expiration,
    this.requestId,
  });

  factory LinkTokenCreateResponse.fromJson(Map<String, dynamic> json) =>
      _$LinkTokenCreateResponseFromJson(json);

  @JsonKey(name: 'link_token')
  final String? linkToken;
  @JsonKey(name: 'expiration')
  final DateTime? expiration;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$LinkTokenCreateResponseFromJson;
  static const toJsonFactory = _$LinkTokenCreateResponseToJson;
  Map<String, dynamic> toJson() => _$LinkTokenCreateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LinkTokenCreateResponse &&
            (identical(other.linkToken, linkToken) ||
                const DeepCollectionEquality()
                    .equals(other.linkToken, linkToken)) &&
            (identical(other.expiration, expiration) ||
                const DeepCollectionEquality()
                    .equals(other.expiration, expiration)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(linkToken) ^
      const DeepCollectionEquality().hash(expiration) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $LinkTokenCreateResponseExtension on LinkTokenCreateResponse {
  LinkTokenCreateResponse copyWith(
      {String? linkToken, DateTime? expiration, String? requestId}) {
    return LinkTokenCreateResponse(
        linkToken: linkToken ?? this.linkToken,
        expiration: expiration ?? this.expiration,
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class Item {
  Item({
    this.itemId,
    this.institutionId,
    this.webhook,
    this.error,
    this.availableProducts,
    this.billedProducts,
    this.products,
    this.consentExpirationTime,
    this.updateType,
  });

  factory Item.fromJson(Map<String, dynamic> json) => _$ItemFromJson(json);

  @JsonKey(name: 'item_id')
  final String? itemId;
  @JsonKey(name: 'institution_id')
  final String? institutionId;
  @JsonKey(name: 'webhook')
  final String? webhook;
  @JsonKey(name: 'error')
  final Error? error;
  @JsonKey(
      name: 'available_products',
      toJson: productsListToJson,
      fromJson: productsListFromJson)
  final List<enums.Products>? availableProducts;
  @JsonKey(
      name: 'billed_products',
      toJson: productsListToJson,
      fromJson: productsListFromJson)
  final List<enums.Products>? billedProducts;
  @JsonKey(
      name: 'products',
      toJson: productsListToJson,
      fromJson: productsListFromJson)
  final List<enums.Products>? products;
  @JsonKey(name: 'consent_expiration_time')
  final DateTime? consentExpirationTime;
  @JsonKey(
      name: 'update_type',
      toJson: itemUpdateTypeToJson,
      fromJson: itemUpdateTypeFromJson)
  final enums.ItemUpdateType? updateType;
  static const fromJsonFactory = _$ItemFromJson;
  static const toJsonFactory = _$ItemToJson;
  Map<String, dynamic> toJson() => _$ItemToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Item &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)) &&
            (identical(other.institutionId, institutionId) ||
                const DeepCollectionEquality()
                    .equals(other.institutionId, institutionId)) &&
            (identical(other.webhook, webhook) ||
                const DeepCollectionEquality()
                    .equals(other.webhook, webhook)) &&
            (identical(other.error, error) ||
                const DeepCollectionEquality().equals(other.error, error)) &&
            (identical(other.availableProducts, availableProducts) ||
                const DeepCollectionEquality()
                    .equals(other.availableProducts, availableProducts)) &&
            (identical(other.billedProducts, billedProducts) ||
                const DeepCollectionEquality()
                    .equals(other.billedProducts, billedProducts)) &&
            (identical(other.products, products) ||
                const DeepCollectionEquality()
                    .equals(other.products, products)) &&
            (identical(other.consentExpirationTime, consentExpirationTime) ||
                const DeepCollectionEquality().equals(
                    other.consentExpirationTime, consentExpirationTime)) &&
            (identical(other.updateType, updateType) ||
                const DeepCollectionEquality()
                    .equals(other.updateType, updateType)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(itemId) ^
      const DeepCollectionEquality().hash(institutionId) ^
      const DeepCollectionEquality().hash(webhook) ^
      const DeepCollectionEquality().hash(error) ^
      const DeepCollectionEquality().hash(availableProducts) ^
      const DeepCollectionEquality().hash(billedProducts) ^
      const DeepCollectionEquality().hash(products) ^
      const DeepCollectionEquality().hash(consentExpirationTime) ^
      const DeepCollectionEquality().hash(updateType) ^
      runtimeType.hashCode;
}

extension $ItemExtension on Item {
  Item copyWith(
      {String? itemId,
      String? institutionId,
      String? webhook,
      Error? error,
      List<enums.Products>? availableProducts,
      List<enums.Products>? billedProducts,
      List<enums.Products>? products,
      DateTime? consentExpirationTime,
      enums.ItemUpdateType? updateType}) {
    return Item(
        itemId: itemId ?? this.itemId,
        institutionId: institutionId ?? this.institutionId,
        webhook: webhook ?? this.webhook,
        error: error ?? this.error,
        availableProducts: availableProducts ?? this.availableProducts,
        billedProducts: billedProducts ?? this.billedProducts,
        products: products ?? this.products,
        consentExpirationTime:
            consentExpirationTime ?? this.consentExpirationTime,
        updateType: updateType ?? this.updateType);
  }
}

@JsonSerializable(explicitToJson: true)
class Error {
  Error({
    this.errorType,
    this.errorCode,
    this.errorMessage,
    this.displayMessage,
    this.requestId,
    this.causes,
    this.status,
    this.documentationUrl,
    this.suggestedAction,
  });

  factory Error.fromJson(Map<String, dynamic> json) => _$ErrorFromJson(json);

  @JsonKey(
      name: 'error_type',
      toJson: errorErrorTypeToJson,
      fromJson: errorErrorTypeFromJson)
  final enums.ErrorErrorType? errorType;
  @JsonKey(name: 'error_code')
  final String? errorCode;
  @JsonKey(name: 'error_message')
  final String? errorMessage;
  @JsonKey(name: 'display_message')
  final String? displayMessage;
  @JsonKey(name: 'request_id')
  final String? requestId;
  @JsonKey(name: 'causes', defaultValue: <Object>[])
  final List<Object>? causes;
  @JsonKey(name: 'status')
  final double? status;
  @JsonKey(name: 'documentation_url')
  final String? documentationUrl;
  @JsonKey(name: 'suggested_action')
  final String? suggestedAction;
  static const fromJsonFactory = _$ErrorFromJson;
  static const toJsonFactory = _$ErrorToJson;
  Map<String, dynamic> toJson() => _$ErrorToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Error &&
            (identical(other.errorType, errorType) ||
                const DeepCollectionEquality()
                    .equals(other.errorType, errorType)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.errorMessage, errorMessage) ||
                const DeepCollectionEquality()
                    .equals(other.errorMessage, errorMessage)) &&
            (identical(other.displayMessage, displayMessage) ||
                const DeepCollectionEquality()
                    .equals(other.displayMessage, displayMessage)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)) &&
            (identical(other.causes, causes) ||
                const DeepCollectionEquality().equals(other.causes, causes)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.documentationUrl, documentationUrl) ||
                const DeepCollectionEquality()
                    .equals(other.documentationUrl, documentationUrl)) &&
            (identical(other.suggestedAction, suggestedAction) ||
                const DeepCollectionEquality()
                    .equals(other.suggestedAction, suggestedAction)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(errorType) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(errorMessage) ^
      const DeepCollectionEquality().hash(displayMessage) ^
      const DeepCollectionEquality().hash(requestId) ^
      const DeepCollectionEquality().hash(causes) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(documentationUrl) ^
      const DeepCollectionEquality().hash(suggestedAction) ^
      runtimeType.hashCode;
}

extension $ErrorExtension on Error {
  Error copyWith(
      {enums.ErrorErrorType? errorType,
      String? errorCode,
      String? errorMessage,
      String? displayMessage,
      String? requestId,
      List<Object>? causes,
      double? status,
      String? documentationUrl,
      String? suggestedAction}) {
    return Error(
        errorType: errorType ?? this.errorType,
        errorCode: errorCode ?? this.errorCode,
        errorMessage: errorMessage ?? this.errorMessage,
        displayMessage: displayMessage ?? this.displayMessage,
        requestId: requestId ?? this.requestId,
        causes: causes ?? this.causes,
        status: status ?? this.status,
        documentationUrl: documentationUrl ?? this.documentationUrl,
        suggestedAction: suggestedAction ?? this.suggestedAction);
  }
}

@JsonSerializable(explicitToJson: true)
class ItemStatusNullable {
  ItemStatusNullable();

  factory ItemStatusNullable.fromJson(Map<String, dynamic> json) =>
      _$ItemStatusNullableFromJson(json);

  static const fromJsonFactory = _$ItemStatusNullableFromJson;
  static const toJsonFactory = _$ItemStatusNullableToJson;
  Map<String, dynamic> toJson() => _$ItemStatusNullableToJson(this);

  @override
  int get hashCode => runtimeType.hashCode;
}

@JsonSerializable(explicitToJson: true)
class ItemStatusTransactions {
  ItemStatusTransactions({
    this.lastSuccessfulUpdate,
    this.lastFailedUpdate,
  });

  factory ItemStatusTransactions.fromJson(Map<String, dynamic> json) =>
      _$ItemStatusTransactionsFromJson(json);

  @JsonKey(name: 'last_successful_update')
  final DateTime? lastSuccessfulUpdate;
  @JsonKey(name: 'last_failed_update')
  final DateTime? lastFailedUpdate;
  static const fromJsonFactory = _$ItemStatusTransactionsFromJson;
  static const toJsonFactory = _$ItemStatusTransactionsToJson;
  Map<String, dynamic> toJson() => _$ItemStatusTransactionsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ItemStatusTransactions &&
            (identical(other.lastSuccessfulUpdate, lastSuccessfulUpdate) ||
                const DeepCollectionEquality().equals(
                    other.lastSuccessfulUpdate, lastSuccessfulUpdate)) &&
            (identical(other.lastFailedUpdate, lastFailedUpdate) ||
                const DeepCollectionEquality()
                    .equals(other.lastFailedUpdate, lastFailedUpdate)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(lastSuccessfulUpdate) ^
      const DeepCollectionEquality().hash(lastFailedUpdate) ^
      runtimeType.hashCode;
}

extension $ItemStatusTransactionsExtension on ItemStatusTransactions {
  ItemStatusTransactions copyWith(
      {DateTime? lastSuccessfulUpdate, DateTime? lastFailedUpdate}) {
    return ItemStatusTransactions(
        lastSuccessfulUpdate: lastSuccessfulUpdate ?? this.lastSuccessfulUpdate,
        lastFailedUpdate: lastFailedUpdate ?? this.lastFailedUpdate);
  }
}

@JsonSerializable(explicitToJson: true)
class ItemStatusInvestments {
  ItemStatusInvestments({
    this.lastSuccessfulUpdate,
    this.lastFailedUpdate,
  });

  factory ItemStatusInvestments.fromJson(Map<String, dynamic> json) =>
      _$ItemStatusInvestmentsFromJson(json);

  @JsonKey(name: 'last_successful_update')
  final DateTime? lastSuccessfulUpdate;
  @JsonKey(name: 'last_failed_update')
  final DateTime? lastFailedUpdate;
  static const fromJsonFactory = _$ItemStatusInvestmentsFromJson;
  static const toJsonFactory = _$ItemStatusInvestmentsToJson;
  Map<String, dynamic> toJson() => _$ItemStatusInvestmentsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ItemStatusInvestments &&
            (identical(other.lastSuccessfulUpdate, lastSuccessfulUpdate) ||
                const DeepCollectionEquality().equals(
                    other.lastSuccessfulUpdate, lastSuccessfulUpdate)) &&
            (identical(other.lastFailedUpdate, lastFailedUpdate) ||
                const DeepCollectionEquality()
                    .equals(other.lastFailedUpdate, lastFailedUpdate)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(lastSuccessfulUpdate) ^
      const DeepCollectionEquality().hash(lastFailedUpdate) ^
      runtimeType.hashCode;
}

extension $ItemStatusInvestmentsExtension on ItemStatusInvestments {
  ItemStatusInvestments copyWith(
      {DateTime? lastSuccessfulUpdate, DateTime? lastFailedUpdate}) {
    return ItemStatusInvestments(
        lastSuccessfulUpdate: lastSuccessfulUpdate ?? this.lastSuccessfulUpdate,
        lastFailedUpdate: lastFailedUpdate ?? this.lastFailedUpdate);
  }
}

@JsonSerializable(explicitToJson: true)
class ItemStatusLastWebhook {
  ItemStatusLastWebhook({
    this.sentAt,
    this.codeSent,
  });

  factory ItemStatusLastWebhook.fromJson(Map<String, dynamic> json) =>
      _$ItemStatusLastWebhookFromJson(json);

  @JsonKey(name: 'sent_at')
  final DateTime? sentAt;
  @JsonKey(name: 'code_sent')
  final String? codeSent;
  static const fromJsonFactory = _$ItemStatusLastWebhookFromJson;
  static const toJsonFactory = _$ItemStatusLastWebhookToJson;
  Map<String, dynamic> toJson() => _$ItemStatusLastWebhookToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ItemStatusLastWebhook &&
            (identical(other.sentAt, sentAt) ||
                const DeepCollectionEquality().equals(other.sentAt, sentAt)) &&
            (identical(other.codeSent, codeSent) ||
                const DeepCollectionEquality()
                    .equals(other.codeSent, codeSent)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(sentAt) ^
      const DeepCollectionEquality().hash(codeSent) ^
      runtimeType.hashCode;
}

extension $ItemStatusLastWebhookExtension on ItemStatusLastWebhook {
  ItemStatusLastWebhook copyWith({DateTime? sentAt, String? codeSent}) {
    return ItemStatusLastWebhook(
        sentAt: sentAt ?? this.sentAt, codeSent: codeSent ?? this.codeSent);
  }
}

@JsonSerializable(explicitToJson: true)
class ItemStatus {
  ItemStatus({
    this.investments,
    this.transactions,
    this.lastWebhook,
  });

  factory ItemStatus.fromJson(Map<String, dynamic> json) =>
      _$ItemStatusFromJson(json);

  @JsonKey(name: 'investments')
  final ItemStatusInvestments? investments;
  @JsonKey(name: 'transactions')
  final ItemStatusTransactions? transactions;
  @JsonKey(name: 'last_webhook')
  final ItemStatusLastWebhook? lastWebhook;
  static const fromJsonFactory = _$ItemStatusFromJson;
  static const toJsonFactory = _$ItemStatusToJson;
  Map<String, dynamic> toJson() => _$ItemStatusToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ItemStatus &&
            (identical(other.investments, investments) ||
                const DeepCollectionEquality()
                    .equals(other.investments, investments)) &&
            (identical(other.transactions, transactions) ||
                const DeepCollectionEquality()
                    .equals(other.transactions, transactions)) &&
            (identical(other.lastWebhook, lastWebhook) ||
                const DeepCollectionEquality()
                    .equals(other.lastWebhook, lastWebhook)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(investments) ^
      const DeepCollectionEquality().hash(transactions) ^
      const DeepCollectionEquality().hash(lastWebhook) ^
      runtimeType.hashCode;
}

extension $ItemStatusExtension on ItemStatus {
  ItemStatus copyWith(
      {ItemStatusInvestments? investments,
      ItemStatusTransactions? transactions,
      ItemStatusLastWebhook? lastWebhook}) {
    return ItemStatus(
        investments: investments ?? this.investments,
        transactions: transactions ?? this.transactions,
        lastWebhook: lastWebhook ?? this.lastWebhook);
  }
}

@JsonSerializable(explicitToJson: true)
class AccountBase {
  AccountBase({
    this.accountId,
    this.balances,
    this.mask,
    this.name,
    this.officialName,
    this.type,
    this.subtype,
    this.verificationStatus,
  });

  factory AccountBase.fromJson(Map<String, dynamic> json) =>
      _$AccountBaseFromJson(json);

  @JsonKey(name: 'account_id')
  final String? accountId;
  @JsonKey(name: 'balances')
  final AccountBalance? balances;
  @JsonKey(name: 'mask')
  final String? mask;
  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'official_name')
  final String? officialName;
  @JsonKey(
      name: 'type', toJson: accountTypeToJson, fromJson: accountTypeFromJson)
  final enums.AccountType? type;
  @JsonKey(
      name: 'subtype',
      toJson: accountSubtypeToJson,
      fromJson: accountSubtypeFromJson)
  final enums.AccountSubtype? subtype;
  @JsonKey(
      name: 'verification_status',
      toJson: accountBaseVerificationStatusToJson,
      fromJson: accountBaseVerificationStatusFromJson)
  final enums.AccountBaseVerificationStatus? verificationStatus;
  static const fromJsonFactory = _$AccountBaseFromJson;
  static const toJsonFactory = _$AccountBaseToJson;
  Map<String, dynamic> toJson() => _$AccountBaseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AccountBase &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.balances, balances) ||
                const DeepCollectionEquality()
                    .equals(other.balances, balances)) &&
            (identical(other.mask, mask) ||
                const DeepCollectionEquality().equals(other.mask, mask)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.officialName, officialName) ||
                const DeepCollectionEquality()
                    .equals(other.officialName, officialName)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.subtype, subtype) ||
                const DeepCollectionEquality()
                    .equals(other.subtype, subtype)) &&
            (identical(other.verificationStatus, verificationStatus) ||
                const DeepCollectionEquality()
                    .equals(other.verificationStatus, verificationStatus)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(balances) ^
      const DeepCollectionEquality().hash(mask) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(officialName) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(subtype) ^
      const DeepCollectionEquality().hash(verificationStatus) ^
      runtimeType.hashCode;
}

extension $AccountBaseExtension on AccountBase {
  AccountBase copyWith(
      {String? accountId,
      AccountBalance? balances,
      String? mask,
      String? name,
      String? officialName,
      enums.AccountType? type,
      enums.AccountSubtype? subtype,
      enums.AccountBaseVerificationStatus? verificationStatus}) {
    return AccountBase(
        accountId: accountId ?? this.accountId,
        balances: balances ?? this.balances,
        mask: mask ?? this.mask,
        name: name ?? this.name,
        officialName: officialName ?? this.officialName,
        type: type ?? this.type,
        subtype: subtype ?? this.subtype,
        verificationStatus: verificationStatus ?? this.verificationStatus);
  }
}

@JsonSerializable(explicitToJson: true)
class AccountBalance {
  AccountBalance({
    this.available,
    this.current,
    this.limit,
    this.isoCurrencyCode,
    this.unofficialCurrencyCode,
    this.lastUpdatedDatetime,
  });

  factory AccountBalance.fromJson(Map<String, dynamic> json) =>
      _$AccountBalanceFromJson(json);

  @JsonKey(name: 'available')
  final double? available;
  @JsonKey(name: 'current')
  final double? current;
  @JsonKey(name: 'limit')
  final double? limit;
  @JsonKey(name: 'iso_currency_code')
  final String? isoCurrencyCode;
  @JsonKey(name: 'unofficial_currency_code')
  final String? unofficialCurrencyCode;
  @JsonKey(name: 'last_updated_datetime')
  final DateTime? lastUpdatedDatetime;
  static const fromJsonFactory = _$AccountBalanceFromJson;
  static const toJsonFactory = _$AccountBalanceToJson;
  Map<String, dynamic> toJson() => _$AccountBalanceToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AccountBalance &&
            (identical(other.available, available) ||
                const DeepCollectionEquality()
                    .equals(other.available, available)) &&
            (identical(other.current, current) ||
                const DeepCollectionEquality()
                    .equals(other.current, current)) &&
            (identical(other.limit, limit) ||
                const DeepCollectionEquality().equals(other.limit, limit)) &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)) &&
            (identical(other.unofficialCurrencyCode, unofficialCurrencyCode) ||
                const DeepCollectionEquality().equals(
                    other.unofficialCurrencyCode, unofficialCurrencyCode)) &&
            (identical(other.lastUpdatedDatetime, lastUpdatedDatetime) ||
                const DeepCollectionEquality()
                    .equals(other.lastUpdatedDatetime, lastUpdatedDatetime)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(available) ^
      const DeepCollectionEquality().hash(current) ^
      const DeepCollectionEquality().hash(limit) ^
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      const DeepCollectionEquality().hash(unofficialCurrencyCode) ^
      const DeepCollectionEquality().hash(lastUpdatedDatetime) ^
      runtimeType.hashCode;
}

extension $AccountBalanceExtension on AccountBalance {
  AccountBalance copyWith(
      {double? available,
      double? current,
      double? limit,
      String? isoCurrencyCode,
      String? unofficialCurrencyCode,
      DateTime? lastUpdatedDatetime}) {
    return AccountBalance(
        available: available ?? this.available,
        current: current ?? this.current,
        limit: limit ?? this.limit,
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode,
        unofficialCurrencyCode:
            unofficialCurrencyCode ?? this.unofficialCurrencyCode,
        lastUpdatedDatetime: lastUpdatedDatetime ?? this.lastUpdatedDatetime);
  }
}

@JsonSerializable(explicitToJson: true)
class NumbersACH {
  NumbersACH({
    this.accountId,
    this.account,
    this.routing,
    this.wireRouting,
  });

  factory NumbersACH.fromJson(Map<String, dynamic> json) =>
      _$NumbersACHFromJson(json);

  @JsonKey(name: 'account_id')
  final String? accountId;
  @JsonKey(name: 'account')
  final String? account;
  @JsonKey(name: 'routing')
  final String? routing;
  @JsonKey(name: 'wire_routing')
  final String? wireRouting;
  static const fromJsonFactory = _$NumbersACHFromJson;
  static const toJsonFactory = _$NumbersACHToJson;
  Map<String, dynamic> toJson() => _$NumbersACHToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is NumbersACH &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.account, account) ||
                const DeepCollectionEquality()
                    .equals(other.account, account)) &&
            (identical(other.routing, routing) ||
                const DeepCollectionEquality()
                    .equals(other.routing, routing)) &&
            (identical(other.wireRouting, wireRouting) ||
                const DeepCollectionEquality()
                    .equals(other.wireRouting, wireRouting)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(account) ^
      const DeepCollectionEquality().hash(routing) ^
      const DeepCollectionEquality().hash(wireRouting) ^
      runtimeType.hashCode;
}

extension $NumbersACHExtension on NumbersACH {
  NumbersACH copyWith(
      {String? accountId,
      String? account,
      String? routing,
      String? wireRouting}) {
    return NumbersACH(
        accountId: accountId ?? this.accountId,
        account: account ?? this.account,
        routing: routing ?? this.routing,
        wireRouting: wireRouting ?? this.wireRouting);
  }
}

@JsonSerializable(explicitToJson: true)
class NumbersACHNullable {
  NumbersACHNullable();

  factory NumbersACHNullable.fromJson(Map<String, dynamic> json) =>
      _$NumbersACHNullableFromJson(json);

  static const fromJsonFactory = _$NumbersACHNullableFromJson;
  static const toJsonFactory = _$NumbersACHNullableToJson;
  Map<String, dynamic> toJson() => _$NumbersACHNullableToJson(this);

  @override
  int get hashCode => runtimeType.hashCode;
}

@JsonSerializable(explicitToJson: true)
class NumbersEFT {
  NumbersEFT({
    this.accountId,
    this.account,
    this.institution,
    this.branch,
  });

  factory NumbersEFT.fromJson(Map<String, dynamic> json) =>
      _$NumbersEFTFromJson(json);

  @JsonKey(name: 'account_id')
  final String? accountId;
  @JsonKey(name: 'account')
  final String? account;
  @JsonKey(name: 'institution')
  final String? institution;
  @JsonKey(name: 'branch')
  final String? branch;
  static const fromJsonFactory = _$NumbersEFTFromJson;
  static const toJsonFactory = _$NumbersEFTToJson;
  Map<String, dynamic> toJson() => _$NumbersEFTToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is NumbersEFT &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.account, account) ||
                const DeepCollectionEquality()
                    .equals(other.account, account)) &&
            (identical(other.institution, institution) ||
                const DeepCollectionEquality()
                    .equals(other.institution, institution)) &&
            (identical(other.branch, branch) ||
                const DeepCollectionEquality().equals(other.branch, branch)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(account) ^
      const DeepCollectionEquality().hash(institution) ^
      const DeepCollectionEquality().hash(branch) ^
      runtimeType.hashCode;
}

extension $NumbersEFTExtension on NumbersEFT {
  NumbersEFT copyWith(
      {String? accountId,
      String? account,
      String? institution,
      String? branch}) {
    return NumbersEFT(
        accountId: accountId ?? this.accountId,
        account: account ?? this.account,
        institution: institution ?? this.institution,
        branch: branch ?? this.branch);
  }
}

@JsonSerializable(explicitToJson: true)
class NumbersEFTNullable {
  NumbersEFTNullable();

  factory NumbersEFTNullable.fromJson(Map<String, dynamic> json) =>
      _$NumbersEFTNullableFromJson(json);

  static const fromJsonFactory = _$NumbersEFTNullableFromJson;
  static const toJsonFactory = _$NumbersEFTNullableToJson;
  Map<String, dynamic> toJson() => _$NumbersEFTNullableToJson(this);

  @override
  int get hashCode => runtimeType.hashCode;
}

@JsonSerializable(explicitToJson: true)
class NumbersInternational {
  NumbersInternational({
    this.accountId,
    this.iban,
    this.bic,
  });

  factory NumbersInternational.fromJson(Map<String, dynamic> json) =>
      _$NumbersInternationalFromJson(json);

  @JsonKey(name: 'account_id')
  final String? accountId;
  @JsonKey(name: 'iban')
  final String? iban;
  @JsonKey(name: 'bic')
  final String? bic;
  static const fromJsonFactory = _$NumbersInternationalFromJson;
  static const toJsonFactory = _$NumbersInternationalToJson;
  Map<String, dynamic> toJson() => _$NumbersInternationalToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is NumbersInternational &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.iban, iban) ||
                const DeepCollectionEquality().equals(other.iban, iban)) &&
            (identical(other.bic, bic) ||
                const DeepCollectionEquality().equals(other.bic, bic)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(iban) ^
      const DeepCollectionEquality().hash(bic) ^
      runtimeType.hashCode;
}

extension $NumbersInternationalExtension on NumbersInternational {
  NumbersInternational copyWith(
      {String? accountId, String? iban, String? bic}) {
    return NumbersInternational(
        accountId: accountId ?? this.accountId,
        iban: iban ?? this.iban,
        bic: bic ?? this.bic);
  }
}

@JsonSerializable(explicitToJson: true)
class NumbersInternationalNullable {
  NumbersInternationalNullable();

  factory NumbersInternationalNullable.fromJson(Map<String, dynamic> json) =>
      _$NumbersInternationalNullableFromJson(json);

  static const fromJsonFactory = _$NumbersInternationalNullableFromJson;
  static const toJsonFactory = _$NumbersInternationalNullableToJson;
  Map<String, dynamic> toJson() => _$NumbersInternationalNullableToJson(this);

  @override
  int get hashCode => runtimeType.hashCode;
}

@JsonSerializable(explicitToJson: true)
class NumbersBACS {
  NumbersBACS({
    this.accountId,
    this.account,
    this.sortCode,
  });

  factory NumbersBACS.fromJson(Map<String, dynamic> json) =>
      _$NumbersBACSFromJson(json);

  @JsonKey(name: 'account_id')
  final String? accountId;
  @JsonKey(name: 'account')
  final String? account;
  @JsonKey(name: 'sort_code')
  final String? sortCode;
  static const fromJsonFactory = _$NumbersBACSFromJson;
  static const toJsonFactory = _$NumbersBACSToJson;
  Map<String, dynamic> toJson() => _$NumbersBACSToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is NumbersBACS &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.account, account) ||
                const DeepCollectionEquality()
                    .equals(other.account, account)) &&
            (identical(other.sortCode, sortCode) ||
                const DeepCollectionEquality()
                    .equals(other.sortCode, sortCode)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(account) ^
      const DeepCollectionEquality().hash(sortCode) ^
      runtimeType.hashCode;
}

extension $NumbersBACSExtension on NumbersBACS {
  NumbersBACS copyWith({String? accountId, String? account, String? sortCode}) {
    return NumbersBACS(
        accountId: accountId ?? this.accountId,
        account: account ?? this.account,
        sortCode: sortCode ?? this.sortCode);
  }
}

@JsonSerializable(explicitToJson: true)
class NumbersBACSNullable {
  NumbersBACSNullable();

  factory NumbersBACSNullable.fromJson(Map<String, dynamic> json) =>
      _$NumbersBACSNullableFromJson(json);

  static const fromJsonFactory = _$NumbersBACSNullableFromJson;
  static const toJsonFactory = _$NumbersBACSNullableToJson;
  Map<String, dynamic> toJson() => _$NumbersBACSNullableToJson(this);

  @override
  int get hashCode => runtimeType.hashCode;
}

@JsonSerializable(explicitToJson: true)
class RecipientBACS {
  RecipientBACS({
    this.account,
    this.sortCode,
  });

  factory RecipientBACS.fromJson(Map<String, dynamic> json) =>
      _$RecipientBACSFromJson(json);

  @JsonKey(name: 'account')
  final String? account;
  @JsonKey(name: 'sort_code')
  final String? sortCode;
  static const fromJsonFactory = _$RecipientBACSFromJson;
  static const toJsonFactory = _$RecipientBACSToJson;
  Map<String, dynamic> toJson() => _$RecipientBACSToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is RecipientBACS &&
            (identical(other.account, account) ||
                const DeepCollectionEquality()
                    .equals(other.account, account)) &&
            (identical(other.sortCode, sortCode) ||
                const DeepCollectionEquality()
                    .equals(other.sortCode, sortCode)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(account) ^
      const DeepCollectionEquality().hash(sortCode) ^
      runtimeType.hashCode;
}

extension $RecipientBACSExtension on RecipientBACS {
  RecipientBACS copyWith({String? account, String? sortCode}) {
    return RecipientBACS(
        account: account ?? this.account, sortCode: sortCode ?? this.sortCode);
  }
}

@JsonSerializable(explicitToJson: true)
class RecipientBACSNullable {
  RecipientBACSNullable();

  factory RecipientBACSNullable.fromJson(Map<String, dynamic> json) =>
      _$RecipientBACSNullableFromJson(json);

  static const fromJsonFactory = _$RecipientBACSNullableFromJson;
  static const toJsonFactory = _$RecipientBACSNullableToJson;
  Map<String, dynamic> toJson() => _$RecipientBACSNullableToJson(this);

  @override
  int get hashCode => runtimeType.hashCode;
}

@JsonSerializable(explicitToJson: true)
class SenderBACSNullable {
  SenderBACSNullable();

  factory SenderBACSNullable.fromJson(Map<String, dynamic> json) =>
      _$SenderBACSNullableFromJson(json);

  static const fromJsonFactory = _$SenderBACSNullableFromJson;
  static const toJsonFactory = _$SenderBACSNullableToJson;
  Map<String, dynamic> toJson() => _$SenderBACSNullableToJson(this);

  @override
  int get hashCode => runtimeType.hashCode;
}

@JsonSerializable(explicitToJson: true)
class PaymentInitiationOptionalRestrictionBacs {
  PaymentInitiationOptionalRestrictionBacs();

  factory PaymentInitiationOptionalRestrictionBacs.fromJson(
          Map<String, dynamic> json) =>
      _$PaymentInitiationOptionalRestrictionBacsFromJson(json);

  static const fromJsonFactory =
      _$PaymentInitiationOptionalRestrictionBacsFromJson;
  static const toJsonFactory = _$PaymentInitiationOptionalRestrictionBacsToJson;
  Map<String, dynamic> toJson() =>
      _$PaymentInitiationOptionalRestrictionBacsToJson(this);

  @override
  int get hashCode => runtimeType.hashCode;
}

@JsonSerializable(explicitToJson: true)
class RemovedTransaction {
  RemovedTransaction({
    this.transactionId,
  });

  factory RemovedTransaction.fromJson(Map<String, dynamic> json) =>
      _$RemovedTransactionFromJson(json);

  @JsonKey(name: 'transaction_id')
  final String? transactionId;
  static const fromJsonFactory = _$RemovedTransactionFromJson;
  static const toJsonFactory = _$RemovedTransactionToJson;
  Map<String, dynamic> toJson() => _$RemovedTransactionToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is RemovedTransaction &&
            (identical(other.transactionId, transactionId) ||
                const DeepCollectionEquality()
                    .equals(other.transactionId, transactionId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(transactionId) ^ runtimeType.hashCode;
}

extension $RemovedTransactionExtension on RemovedTransaction {
  RemovedTransaction copyWith({String? transactionId}) {
    return RemovedTransaction(
        transactionId: transactionId ?? this.transactionId);
  }
}

@JsonSerializable(explicitToJson: true)
class TransactionBase {
  TransactionBase({
    this.transactionType,
    this.pendingTransactionId,
    this.categoryId,
    this.category,
    this.location,
    this.paymentMeta,
    this.accountOwner,
    this.name,
    this.originalDescription,
    this.accountId,
    this.amount,
    this.isoCurrencyCode,
    this.unofficialCurrencyCode,
    this.date,
    this.pending,
    this.transactionId,
    this.merchantName,
    this.checkNumber,
  });

  factory TransactionBase.fromJson(Map<String, dynamic> json) =>
      _$TransactionBaseFromJson(json);

  @JsonKey(
      name: 'transaction_type',
      toJson: transactionBaseTransactionTypeToJson,
      fromJson: transactionBaseTransactionTypeFromJson)
  final enums.TransactionBaseTransactionType? transactionType;
  @JsonKey(name: 'pending_transaction_id')
  final String? pendingTransactionId;
  @JsonKey(name: 'category_id')
  final String? categoryId;
  @JsonKey(name: 'category', defaultValue: <String>[])
  final List<String>? category;
  @JsonKey(name: 'location')
  final Location? location;
  @JsonKey(name: 'payment_meta')
  final PaymentMeta? paymentMeta;
  @JsonKey(name: 'account_owner')
  final String? accountOwner;
  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'original_description')
  final String? originalDescription;
  @JsonKey(name: 'account_id')
  final String? accountId;
  @JsonKey(name: 'amount')
  final double? amount;
  @JsonKey(name: 'iso_currency_code')
  final String? isoCurrencyCode;
  @JsonKey(name: 'unofficial_currency_code')
  final String? unofficialCurrencyCode;
  @JsonKey(name: 'date', toJson: _dateToJson)
  final DateTime? date;
  @JsonKey(name: 'pending')
  final bool? pending;
  @JsonKey(name: 'transaction_id')
  final String? transactionId;
  @JsonKey(name: 'merchant_name')
  final String? merchantName;
  @JsonKey(name: 'check_number')
  final String? checkNumber;
  static const fromJsonFactory = _$TransactionBaseFromJson;
  static const toJsonFactory = _$TransactionBaseToJson;
  Map<String, dynamic> toJson() => _$TransactionBaseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransactionBase &&
            (identical(other.transactionType, transactionType) ||
                const DeepCollectionEquality()
                    .equals(other.transactionType, transactionType)) &&
            (identical(other.pendingTransactionId, pendingTransactionId) ||
                const DeepCollectionEquality().equals(
                    other.pendingTransactionId, pendingTransactionId)) &&
            (identical(other.categoryId, categoryId) ||
                const DeepCollectionEquality()
                    .equals(other.categoryId, categoryId)) &&
            (identical(other.category, category) ||
                const DeepCollectionEquality()
                    .equals(other.category, category)) &&
            (identical(other.location, location) ||
                const DeepCollectionEquality()
                    .equals(other.location, location)) &&
            (identical(other.paymentMeta, paymentMeta) ||
                const DeepCollectionEquality()
                    .equals(other.paymentMeta, paymentMeta)) &&
            (identical(other.accountOwner, accountOwner) ||
                const DeepCollectionEquality()
                    .equals(other.accountOwner, accountOwner)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.originalDescription, originalDescription) ||
                const DeepCollectionEquality()
                    .equals(other.originalDescription, originalDescription)) &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)) &&
            (identical(other.unofficialCurrencyCode, unofficialCurrencyCode) ||
                const DeepCollectionEquality().equals(
                    other.unofficialCurrencyCode, unofficialCurrencyCode)) &&
            (identical(other.date, date) ||
                const DeepCollectionEquality().equals(other.date, date)) &&
            (identical(other.pending, pending) ||
                const DeepCollectionEquality()
                    .equals(other.pending, pending)) &&
            (identical(other.transactionId, transactionId) ||
                const DeepCollectionEquality()
                    .equals(other.transactionId, transactionId)) &&
            (identical(other.merchantName, merchantName) ||
                const DeepCollectionEquality()
                    .equals(other.merchantName, merchantName)) &&
            (identical(other.checkNumber, checkNumber) ||
                const DeepCollectionEquality()
                    .equals(other.checkNumber, checkNumber)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(transactionType) ^
      const DeepCollectionEquality().hash(pendingTransactionId) ^
      const DeepCollectionEquality().hash(categoryId) ^
      const DeepCollectionEquality().hash(category) ^
      const DeepCollectionEquality().hash(location) ^
      const DeepCollectionEquality().hash(paymentMeta) ^
      const DeepCollectionEquality().hash(accountOwner) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(originalDescription) ^
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      const DeepCollectionEquality().hash(unofficialCurrencyCode) ^
      const DeepCollectionEquality().hash(date) ^
      const DeepCollectionEquality().hash(pending) ^
      const DeepCollectionEquality().hash(transactionId) ^
      const DeepCollectionEquality().hash(merchantName) ^
      const DeepCollectionEquality().hash(checkNumber) ^
      runtimeType.hashCode;
}

extension $TransactionBaseExtension on TransactionBase {
  TransactionBase copyWith(
      {enums.TransactionBaseTransactionType? transactionType,
      String? pendingTransactionId,
      String? categoryId,
      List<String>? category,
      Location? location,
      PaymentMeta? paymentMeta,
      String? accountOwner,
      String? name,
      String? originalDescription,
      String? accountId,
      double? amount,
      String? isoCurrencyCode,
      String? unofficialCurrencyCode,
      DateTime? date,
      bool? pending,
      String? transactionId,
      String? merchantName,
      String? checkNumber}) {
    return TransactionBase(
        transactionType: transactionType ?? this.transactionType,
        pendingTransactionId: pendingTransactionId ?? this.pendingTransactionId,
        categoryId: categoryId ?? this.categoryId,
        category: category ?? this.category,
        location: location ?? this.location,
        paymentMeta: paymentMeta ?? this.paymentMeta,
        accountOwner: accountOwner ?? this.accountOwner,
        name: name ?? this.name,
        originalDescription: originalDescription ?? this.originalDescription,
        accountId: accountId ?? this.accountId,
        amount: amount ?? this.amount,
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode,
        unofficialCurrencyCode:
            unofficialCurrencyCode ?? this.unofficialCurrencyCode,
        date: date ?? this.date,
        pending: pending ?? this.pending,
        transactionId: transactionId ?? this.transactionId,
        merchantName: merchantName ?? this.merchantName,
        checkNumber: checkNumber ?? this.checkNumber);
  }
}

@JsonSerializable(explicitToJson: true)
class Transaction {
  Transaction({
    this.paymentChannel,
    this.authorizedDate,
    this.authorizedDatetime,
    this.datetime,
    this.transactionCode,
    this.personalFinanceCategory,
    this.transactionType,
    this.pendingTransactionId,
    this.categoryId,
    this.category,
    this.location,
    this.paymentMeta,
    this.accountOwner,
    this.name,
    this.originalDescription,
    this.accountId,
    this.amount,
    this.isoCurrencyCode,
    this.unofficialCurrencyCode,
    this.date,
    this.pending,
    this.transactionId,
    this.merchantName,
    this.checkNumber,
  });

  factory Transaction.fromJson(Map<String, dynamic> json) =>
      _$TransactionFromJson(json);

  @JsonKey(
      name: 'payment_channel',
      toJson: transactionPaymentChannelToJson,
      fromJson: transactionPaymentChannelFromJson)
  final enums.TransactionPaymentChannel? paymentChannel;
  @JsonKey(name: 'authorized_date', toJson: _dateToJson)
  final DateTime? authorizedDate;
  @JsonKey(name: 'authorized_datetime')
  final DateTime? authorizedDatetime;
  @JsonKey(name: 'datetime')
  final DateTime? datetime;
  @JsonKey(
      name: 'transaction_code',
      toJson: transactionCodeToJson,
      fromJson: transactionCodeFromJson)
  final enums.TransactionCode? transactionCode;
  @JsonKey(name: 'personal_finance_category')
  final dynamic? personalFinanceCategory;
  @JsonKey(
      name: 'transaction_type',
      toJson: transactionTransactionTypeToJson,
      fromJson: transactionTransactionTypeFromJson)
  final enums.TransactionTransactionType? transactionType;
  @JsonKey(name: 'pending_transaction_id')
  final String? pendingTransactionId;
  @JsonKey(name: 'category_id')
  final String? categoryId;
  @JsonKey(name: 'category', defaultValue: <String>[])
  final List<String>? category;
  @JsonKey(name: 'location')
  final Location? location;
  @JsonKey(name: 'payment_meta')
  final PaymentMeta? paymentMeta;
  @JsonKey(name: 'account_owner')
  final String? accountOwner;
  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'original_description')
  final String? originalDescription;
  @JsonKey(name: 'account_id')
  final String? accountId;
  @JsonKey(name: 'amount')
  final double? amount;
  @JsonKey(name: 'iso_currency_code')
  final String? isoCurrencyCode;
  @JsonKey(name: 'unofficial_currency_code')
  final String? unofficialCurrencyCode;
  @JsonKey(name: 'date', toJson: _dateToJson)
  final DateTime? date;
  @JsonKey(name: 'pending')
  final bool? pending;
  @JsonKey(name: 'transaction_id')
  final String? transactionId;
  @JsonKey(name: 'merchant_name')
  final String? merchantName;
  @JsonKey(name: 'check_number')
  final String? checkNumber;
  static const fromJsonFactory = _$TransactionFromJson;
  static const toJsonFactory = _$TransactionToJson;
  Map<String, dynamic> toJson() => _$TransactionToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Transaction &&
            (identical(other.paymentChannel, paymentChannel) ||
                const DeepCollectionEquality()
                    .equals(other.paymentChannel, paymentChannel)) &&
            (identical(other.authorizedDate, authorizedDate) ||
                const DeepCollectionEquality()
                    .equals(other.authorizedDate, authorizedDate)) &&
            (identical(other.authorizedDatetime, authorizedDatetime) ||
                const DeepCollectionEquality()
                    .equals(other.authorizedDatetime, authorizedDatetime)) &&
            (identical(other.datetime, datetime) ||
                const DeepCollectionEquality()
                    .equals(other.datetime, datetime)) &&
            (identical(other.transactionCode, transactionCode) ||
                const DeepCollectionEquality()
                    .equals(other.transactionCode, transactionCode)) &&
            (identical(other.personalFinanceCategory, personalFinanceCategory) ||
                const DeepCollectionEquality().equals(
                    other.personalFinanceCategory, personalFinanceCategory)) &&
            (identical(other.transactionType, transactionType) ||
                const DeepCollectionEquality()
                    .equals(other.transactionType, transactionType)) &&
            (identical(other.pendingTransactionId, pendingTransactionId) ||
                const DeepCollectionEquality().equals(
                    other.pendingTransactionId, pendingTransactionId)) &&
            (identical(other.categoryId, categoryId) ||
                const DeepCollectionEquality()
                    .equals(other.categoryId, categoryId)) &&
            (identical(other.category, category) ||
                const DeepCollectionEquality()
                    .equals(other.category, category)) &&
            (identical(other.location, location) ||
                const DeepCollectionEquality()
                    .equals(other.location, location)) &&
            (identical(other.paymentMeta, paymentMeta) ||
                const DeepCollectionEquality()
                    .equals(other.paymentMeta, paymentMeta)) &&
            (identical(other.accountOwner, accountOwner) ||
                const DeepCollectionEquality()
                    .equals(other.accountOwner, accountOwner)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.originalDescription, originalDescription) ||
                const DeepCollectionEquality()
                    .equals(other.originalDescription, originalDescription)) &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)) &&
            (identical(other.unofficialCurrencyCode, unofficialCurrencyCode) || const DeepCollectionEquality().equals(other.unofficialCurrencyCode, unofficialCurrencyCode)) &&
            (identical(other.date, date) || const DeepCollectionEquality().equals(other.date, date)) &&
            (identical(other.pending, pending) || const DeepCollectionEquality().equals(other.pending, pending)) &&
            (identical(other.transactionId, transactionId) || const DeepCollectionEquality().equals(other.transactionId, transactionId)) &&
            (identical(other.merchantName, merchantName) || const DeepCollectionEquality().equals(other.merchantName, merchantName)) &&
            (identical(other.checkNumber, checkNumber) || const DeepCollectionEquality().equals(other.checkNumber, checkNumber)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(paymentChannel) ^
      const DeepCollectionEquality().hash(authorizedDate) ^
      const DeepCollectionEquality().hash(authorizedDatetime) ^
      const DeepCollectionEquality().hash(datetime) ^
      const DeepCollectionEquality().hash(transactionCode) ^
      const DeepCollectionEquality().hash(personalFinanceCategory) ^
      const DeepCollectionEquality().hash(transactionType) ^
      const DeepCollectionEquality().hash(pendingTransactionId) ^
      const DeepCollectionEquality().hash(categoryId) ^
      const DeepCollectionEquality().hash(category) ^
      const DeepCollectionEquality().hash(location) ^
      const DeepCollectionEquality().hash(paymentMeta) ^
      const DeepCollectionEquality().hash(accountOwner) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(originalDescription) ^
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      const DeepCollectionEquality().hash(unofficialCurrencyCode) ^
      const DeepCollectionEquality().hash(date) ^
      const DeepCollectionEquality().hash(pending) ^
      const DeepCollectionEquality().hash(transactionId) ^
      const DeepCollectionEquality().hash(merchantName) ^
      const DeepCollectionEquality().hash(checkNumber) ^
      runtimeType.hashCode;
}

extension $TransactionExtension on Transaction {
  Transaction copyWith(
      {enums.TransactionPaymentChannel? paymentChannel,
      DateTime? authorizedDate,
      DateTime? authorizedDatetime,
      DateTime? datetime,
      enums.TransactionCode? transactionCode,
      dynamic? personalFinanceCategory,
      enums.TransactionTransactionType? transactionType,
      String? pendingTransactionId,
      String? categoryId,
      List<String>? category,
      Location? location,
      PaymentMeta? paymentMeta,
      String? accountOwner,
      String? name,
      String? originalDescription,
      String? accountId,
      double? amount,
      String? isoCurrencyCode,
      String? unofficialCurrencyCode,
      DateTime? date,
      bool? pending,
      String? transactionId,
      String? merchantName,
      String? checkNumber}) {
    return Transaction(
        paymentChannel: paymentChannel ?? this.paymentChannel,
        authorizedDate: authorizedDate ?? this.authorizedDate,
        authorizedDatetime: authorizedDatetime ?? this.authorizedDatetime,
        datetime: datetime ?? this.datetime,
        transactionCode: transactionCode ?? this.transactionCode,
        personalFinanceCategory:
            personalFinanceCategory ?? this.personalFinanceCategory,
        transactionType: transactionType ?? this.transactionType,
        pendingTransactionId: pendingTransactionId ?? this.pendingTransactionId,
        categoryId: categoryId ?? this.categoryId,
        category: category ?? this.category,
        location: location ?? this.location,
        paymentMeta: paymentMeta ?? this.paymentMeta,
        accountOwner: accountOwner ?? this.accountOwner,
        name: name ?? this.name,
        originalDescription: originalDescription ?? this.originalDescription,
        accountId: accountId ?? this.accountId,
        amount: amount ?? this.amount,
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode,
        unofficialCurrencyCode:
            unofficialCurrencyCode ?? this.unofficialCurrencyCode,
        date: date ?? this.date,
        pending: pending ?? this.pending,
        transactionId: transactionId ?? this.transactionId,
        merchantName: merchantName ?? this.merchantName,
        checkNumber: checkNumber ?? this.checkNumber);
  }
}

@JsonSerializable(explicitToJson: true)
class Location {
  Location({
    this.address,
    this.city,
    this.region,
    this.postalCode,
    this.country,
    this.lat,
    this.lon,
    this.storeNumber,
  });

  factory Location.fromJson(Map<String, dynamic> json) =>
      _$LocationFromJson(json);

  @JsonKey(name: 'address')
  final String? address;
  @JsonKey(name: 'city')
  final String? city;
  @JsonKey(name: 'region')
  final String? region;
  @JsonKey(name: 'postal_code')
  final String? postalCode;
  @JsonKey(name: 'country')
  final String? country;
  @JsonKey(name: 'lat')
  final double? lat;
  @JsonKey(name: 'lon')
  final double? lon;
  @JsonKey(name: 'store_number')
  final String? storeNumber;
  static const fromJsonFactory = _$LocationFromJson;
  static const toJsonFactory = _$LocationToJson;
  Map<String, dynamic> toJson() => _$LocationToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Location &&
            (identical(other.address, address) ||
                const DeepCollectionEquality()
                    .equals(other.address, address)) &&
            (identical(other.city, city) ||
                const DeepCollectionEquality().equals(other.city, city)) &&
            (identical(other.region, region) ||
                const DeepCollectionEquality().equals(other.region, region)) &&
            (identical(other.postalCode, postalCode) ||
                const DeepCollectionEquality()
                    .equals(other.postalCode, postalCode)) &&
            (identical(other.country, country) ||
                const DeepCollectionEquality()
                    .equals(other.country, country)) &&
            (identical(other.lat, lat) ||
                const DeepCollectionEquality().equals(other.lat, lat)) &&
            (identical(other.lon, lon) ||
                const DeepCollectionEquality().equals(other.lon, lon)) &&
            (identical(other.storeNumber, storeNumber) ||
                const DeepCollectionEquality()
                    .equals(other.storeNumber, storeNumber)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(city) ^
      const DeepCollectionEquality().hash(region) ^
      const DeepCollectionEquality().hash(postalCode) ^
      const DeepCollectionEquality().hash(country) ^
      const DeepCollectionEquality().hash(lat) ^
      const DeepCollectionEquality().hash(lon) ^
      const DeepCollectionEquality().hash(storeNumber) ^
      runtimeType.hashCode;
}

extension $LocationExtension on Location {
  Location copyWith(
      {String? address,
      String? city,
      String? region,
      String? postalCode,
      String? country,
      double? lat,
      double? lon,
      String? storeNumber}) {
    return Location(
        address: address ?? this.address,
        city: city ?? this.city,
        region: region ?? this.region,
        postalCode: postalCode ?? this.postalCode,
        country: country ?? this.country,
        lat: lat ?? this.lat,
        lon: lon ?? this.lon,
        storeNumber: storeNumber ?? this.storeNumber);
  }
}

@JsonSerializable(explicitToJson: true)
class TransactionStream {
  TransactionStream({
    this.accountId,
    this.streamId,
    this.categoryId,
    this.category,
    this.description,
    this.firstDate,
    this.lastDate,
    this.frequency,
    this.transactionIds,
    this.averageAmount,
    this.isActive,
  });

  factory TransactionStream.fromJson(Map<String, dynamic> json) =>
      _$TransactionStreamFromJson(json);

  @JsonKey(name: 'account_id')
  final String? accountId;
  @JsonKey(name: 'stream_id')
  final String? streamId;
  @JsonKey(name: 'category_id')
  final String? categoryId;
  @JsonKey(name: 'category', defaultValue: <String>[])
  final List<String>? category;
  @JsonKey(name: 'description')
  final String? description;
  @JsonKey(name: 'first_date', toJson: _dateToJson)
  final DateTime? firstDate;
  @JsonKey(name: 'last_date', toJson: _dateToJson)
  final DateTime? lastDate;
  @JsonKey(
      name: 'frequency',
      toJson: recurringTransactionFrequencyToJson,
      fromJson: recurringTransactionFrequencyFromJson)
  final enums.RecurringTransactionFrequency? frequency;
  @JsonKey(name: 'transaction_ids', defaultValue: <String>[])
  final List<String>? transactionIds;
  @JsonKey(name: 'average_amount')
  final TransactionStreamAmount? averageAmount;
  @JsonKey(name: 'is_active')
  final bool? isActive;
  static const fromJsonFactory = _$TransactionStreamFromJson;
  static const toJsonFactory = _$TransactionStreamToJson;
  Map<String, dynamic> toJson() => _$TransactionStreamToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransactionStream &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.streamId, streamId) ||
                const DeepCollectionEquality()
                    .equals(other.streamId, streamId)) &&
            (identical(other.categoryId, categoryId) ||
                const DeepCollectionEquality()
                    .equals(other.categoryId, categoryId)) &&
            (identical(other.category, category) ||
                const DeepCollectionEquality()
                    .equals(other.category, category)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.firstDate, firstDate) ||
                const DeepCollectionEquality()
                    .equals(other.firstDate, firstDate)) &&
            (identical(other.lastDate, lastDate) ||
                const DeepCollectionEquality()
                    .equals(other.lastDate, lastDate)) &&
            (identical(other.frequency, frequency) ||
                const DeepCollectionEquality()
                    .equals(other.frequency, frequency)) &&
            (identical(other.transactionIds, transactionIds) ||
                const DeepCollectionEquality()
                    .equals(other.transactionIds, transactionIds)) &&
            (identical(other.averageAmount, averageAmount) ||
                const DeepCollectionEquality()
                    .equals(other.averageAmount, averageAmount)) &&
            (identical(other.isActive, isActive) ||
                const DeepCollectionEquality()
                    .equals(other.isActive, isActive)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(streamId) ^
      const DeepCollectionEquality().hash(categoryId) ^
      const DeepCollectionEquality().hash(category) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(firstDate) ^
      const DeepCollectionEquality().hash(lastDate) ^
      const DeepCollectionEquality().hash(frequency) ^
      const DeepCollectionEquality().hash(transactionIds) ^
      const DeepCollectionEquality().hash(averageAmount) ^
      const DeepCollectionEquality().hash(isActive) ^
      runtimeType.hashCode;
}

extension $TransactionStreamExtension on TransactionStream {
  TransactionStream copyWith(
      {String? accountId,
      String? streamId,
      String? categoryId,
      List<String>? category,
      String? description,
      DateTime? firstDate,
      DateTime? lastDate,
      enums.RecurringTransactionFrequency? frequency,
      List<String>? transactionIds,
      TransactionStreamAmount? averageAmount,
      bool? isActive}) {
    return TransactionStream(
        accountId: accountId ?? this.accountId,
        streamId: streamId ?? this.streamId,
        categoryId: categoryId ?? this.categoryId,
        category: category ?? this.category,
        description: description ?? this.description,
        firstDate: firstDate ?? this.firstDate,
        lastDate: lastDate ?? this.lastDate,
        frequency: frequency ?? this.frequency,
        transactionIds: transactionIds ?? this.transactionIds,
        averageAmount: averageAmount ?? this.averageAmount,
        isActive: isActive ?? this.isActive);
  }
}

@JsonSerializable(explicitToJson: true)
class TransactionStreamAmount {
  TransactionStreamAmount({
    this.amount,
    this.isoCurrencyCode,
    this.unofficialCurrencyCode,
  });

  factory TransactionStreamAmount.fromJson(Map<String, dynamic> json) =>
      _$TransactionStreamAmountFromJson(json);

  @JsonKey(name: 'amount')
  final double? amount;
  @JsonKey(name: 'iso_currency_code')
  final String? isoCurrencyCode;
  @JsonKey(name: 'unofficial_currency_code')
  final String? unofficialCurrencyCode;
  static const fromJsonFactory = _$TransactionStreamAmountFromJson;
  static const toJsonFactory = _$TransactionStreamAmountToJson;
  Map<String, dynamic> toJson() => _$TransactionStreamAmountToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransactionStreamAmount &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)) &&
            (identical(other.unofficialCurrencyCode, unofficialCurrencyCode) ||
                const DeepCollectionEquality().equals(
                    other.unofficialCurrencyCode, unofficialCurrencyCode)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      const DeepCollectionEquality().hash(unofficialCurrencyCode) ^
      runtimeType.hashCode;
}

extension $TransactionStreamAmountExtension on TransactionStreamAmount {
  TransactionStreamAmount copyWith(
      {double? amount,
      String? isoCurrencyCode,
      String? unofficialCurrencyCode}) {
    return TransactionStreamAmount(
        amount: amount ?? this.amount,
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode,
        unofficialCurrencyCode:
            unofficialCurrencyCode ?? this.unofficialCurrencyCode);
  }
}

@JsonSerializable(explicitToJson: true)
class Institution {
  Institution({
    this.institutionId,
    this.name,
    this.products,
    this.countryCodes,
    this.url,
    this.primaryColor,
    this.logo,
    this.routingNumbers,
    this.oauth,
    this.status,
    this.paymentInitiationMetadata,
    this.authMetadata,
  });

  factory Institution.fromJson(Map<String, dynamic> json) =>
      _$InstitutionFromJson(json);

  @JsonKey(name: 'institution_id')
  final String? institutionId;
  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(
      name: 'products',
      toJson: productsListToJson,
      fromJson: productsListFromJson)
  final List<enums.Products>? products;
  @JsonKey(
      name: 'country_codes',
      toJson: countryCodeListToJson,
      fromJson: countryCodeListFromJson)
  final List<enums.CountryCode>? countryCodes;
  @JsonKey(name: 'url')
  final String? url;
  @JsonKey(name: 'primary_color')
  final String? primaryColor;
  @JsonKey(name: 'logo')
  final String? logo;
  @JsonKey(name: 'routing_numbers', defaultValue: <String>[])
  final List<String>? routingNumbers;
  @JsonKey(name: 'oauth')
  final bool? oauth;
  @JsonKey(name: 'status')
  final InstitutionStatus? status;
  @JsonKey(name: 'payment_initiation_metadata')
  final PaymentInitiationMetadata? paymentInitiationMetadata;
  @JsonKey(name: 'auth_metadata')
  final AuthMetadata? authMetadata;
  static const fromJsonFactory = _$InstitutionFromJson;
  static const toJsonFactory = _$InstitutionToJson;
  Map<String, dynamic> toJson() => _$InstitutionToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Institution &&
            (identical(other.institutionId, institutionId) ||
                const DeepCollectionEquality()
                    .equals(other.institutionId, institutionId)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.products, products) ||
                const DeepCollectionEquality()
                    .equals(other.products, products)) &&
            (identical(other.countryCodes, countryCodes) ||
                const DeepCollectionEquality()
                    .equals(other.countryCodes, countryCodes)) &&
            (identical(other.url, url) ||
                const DeepCollectionEquality().equals(other.url, url)) &&
            (identical(other.primaryColor, primaryColor) ||
                const DeepCollectionEquality()
                    .equals(other.primaryColor, primaryColor)) &&
            (identical(other.logo, logo) ||
                const DeepCollectionEquality().equals(other.logo, logo)) &&
            (identical(other.routingNumbers, routingNumbers) ||
                const DeepCollectionEquality()
                    .equals(other.routingNumbers, routingNumbers)) &&
            (identical(other.oauth, oauth) ||
                const DeepCollectionEquality().equals(other.oauth, oauth)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.paymentInitiationMetadata,
                    paymentInitiationMetadata) ||
                const DeepCollectionEquality().equals(
                    other.paymentInitiationMetadata,
                    paymentInitiationMetadata)) &&
            (identical(other.authMetadata, authMetadata) ||
                const DeepCollectionEquality()
                    .equals(other.authMetadata, authMetadata)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(institutionId) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(products) ^
      const DeepCollectionEquality().hash(countryCodes) ^
      const DeepCollectionEquality().hash(url) ^
      const DeepCollectionEquality().hash(primaryColor) ^
      const DeepCollectionEquality().hash(logo) ^
      const DeepCollectionEquality().hash(routingNumbers) ^
      const DeepCollectionEquality().hash(oauth) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(paymentInitiationMetadata) ^
      const DeepCollectionEquality().hash(authMetadata) ^
      runtimeType.hashCode;
}

extension $InstitutionExtension on Institution {
  Institution copyWith(
      {String? institutionId,
      String? name,
      List<enums.Products>? products,
      List<enums.CountryCode>? countryCodes,
      String? url,
      String? primaryColor,
      String? logo,
      List<String>? routingNumbers,
      bool? oauth,
      InstitutionStatus? status,
      PaymentInitiationMetadata? paymentInitiationMetadata,
      AuthMetadata? authMetadata}) {
    return Institution(
        institutionId: institutionId ?? this.institutionId,
        name: name ?? this.name,
        products: products ?? this.products,
        countryCodes: countryCodes ?? this.countryCodes,
        url: url ?? this.url,
        primaryColor: primaryColor ?? this.primaryColor,
        logo: logo ?? this.logo,
        routingNumbers: routingNumbers ?? this.routingNumbers,
        oauth: oauth ?? this.oauth,
        status: status ?? this.status,
        paymentInitiationMetadata:
            paymentInitiationMetadata ?? this.paymentInitiationMetadata,
        authMetadata: authMetadata ?? this.authMetadata);
  }
}

@JsonSerializable(explicitToJson: true)
class InstitutionStatus {
  InstitutionStatus({
    this.itemLogins,
    this.transactionsUpdates,
    this.auth,
    this.balance,
    this.identity,
    this.investmentsUpdates,
    this.liabilitiesUpdates,
    this.liabilities,
    this.investments,
    this.healthIncidents,
  });

  factory InstitutionStatus.fromJson(Map<String, dynamic> json) =>
      _$InstitutionStatusFromJson(json);

  @JsonKey(name: 'item_logins')
  final ProductStatus? itemLogins;
  @JsonKey(name: 'transactions_updates')
  final ProductStatus? transactionsUpdates;
  @JsonKey(name: 'auth')
  final ProductStatus? auth;
  @JsonKey(name: 'balance')
  final ProductStatus? balance;
  @JsonKey(name: 'identity')
  final ProductStatus? identity;
  @JsonKey(name: 'investments_updates')
  final ProductStatus? investmentsUpdates;
  @JsonKey(name: 'liabilities_updates')
  final ProductStatus? liabilitiesUpdates;
  @JsonKey(name: 'liabilities')
  final ProductStatus? liabilities;
  @JsonKey(name: 'investments')
  final ProductStatus? investments;
  @JsonKey(name: 'health_incidents', defaultValue: <HealthIncident>[])
  final List<HealthIncident>? healthIncidents;
  static const fromJsonFactory = _$InstitutionStatusFromJson;
  static const toJsonFactory = _$InstitutionStatusToJson;
  Map<String, dynamic> toJson() => _$InstitutionStatusToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InstitutionStatus &&
            (identical(other.itemLogins, itemLogins) ||
                const DeepCollectionEquality()
                    .equals(other.itemLogins, itemLogins)) &&
            (identical(other.transactionsUpdates, transactionsUpdates) ||
                const DeepCollectionEquality()
                    .equals(other.transactionsUpdates, transactionsUpdates)) &&
            (identical(other.auth, auth) ||
                const DeepCollectionEquality().equals(other.auth, auth)) &&
            (identical(other.balance, balance) ||
                const DeepCollectionEquality()
                    .equals(other.balance, balance)) &&
            (identical(other.identity, identity) ||
                const DeepCollectionEquality()
                    .equals(other.identity, identity)) &&
            (identical(other.investmentsUpdates, investmentsUpdates) ||
                const DeepCollectionEquality()
                    .equals(other.investmentsUpdates, investmentsUpdates)) &&
            (identical(other.liabilitiesUpdates, liabilitiesUpdates) ||
                const DeepCollectionEquality()
                    .equals(other.liabilitiesUpdates, liabilitiesUpdates)) &&
            (identical(other.liabilities, liabilities) ||
                const DeepCollectionEquality()
                    .equals(other.liabilities, liabilities)) &&
            (identical(other.investments, investments) ||
                const DeepCollectionEquality()
                    .equals(other.investments, investments)) &&
            (identical(other.healthIncidents, healthIncidents) ||
                const DeepCollectionEquality()
                    .equals(other.healthIncidents, healthIncidents)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(itemLogins) ^
      const DeepCollectionEquality().hash(transactionsUpdates) ^
      const DeepCollectionEquality().hash(auth) ^
      const DeepCollectionEquality().hash(balance) ^
      const DeepCollectionEquality().hash(identity) ^
      const DeepCollectionEquality().hash(investmentsUpdates) ^
      const DeepCollectionEquality().hash(liabilitiesUpdates) ^
      const DeepCollectionEquality().hash(liabilities) ^
      const DeepCollectionEquality().hash(investments) ^
      const DeepCollectionEquality().hash(healthIncidents) ^
      runtimeType.hashCode;
}

extension $InstitutionStatusExtension on InstitutionStatus {
  InstitutionStatus copyWith(
      {ProductStatus? itemLogins,
      ProductStatus? transactionsUpdates,
      ProductStatus? auth,
      ProductStatus? balance,
      ProductStatus? identity,
      ProductStatus? investmentsUpdates,
      ProductStatus? liabilitiesUpdates,
      ProductStatus? liabilities,
      ProductStatus? investments,
      List<HealthIncident>? healthIncidents}) {
    return InstitutionStatus(
        itemLogins: itemLogins ?? this.itemLogins,
        transactionsUpdates: transactionsUpdates ?? this.transactionsUpdates,
        auth: auth ?? this.auth,
        balance: balance ?? this.balance,
        identity: identity ?? this.identity,
        investmentsUpdates: investmentsUpdates ?? this.investmentsUpdates,
        liabilitiesUpdates: liabilitiesUpdates ?? this.liabilitiesUpdates,
        liabilities: liabilities ?? this.liabilities,
        investments: investments ?? this.investments,
        healthIncidents: healthIncidents ?? this.healthIncidents);
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentMeta {
  PaymentMeta({
    this.referenceNumber,
    this.ppdId,
    this.payee,
    this.byOrderOf,
    this.payer,
    this.paymentMethod,
    this.paymentProcessor,
    this.reason,
  });

  factory PaymentMeta.fromJson(Map<String, dynamic> json) =>
      _$PaymentMetaFromJson(json);

  @JsonKey(name: 'reference_number')
  final String? referenceNumber;
  @JsonKey(name: 'ppd_id')
  final String? ppdId;
  @JsonKey(name: 'payee')
  final String? payee;
  @JsonKey(name: 'by_order_of')
  final String? byOrderOf;
  @JsonKey(name: 'payer')
  final String? payer;
  @JsonKey(name: 'payment_method')
  final String? paymentMethod;
  @JsonKey(name: 'payment_processor')
  final String? paymentProcessor;
  @JsonKey(name: 'reason')
  final String? reason;
  static const fromJsonFactory = _$PaymentMetaFromJson;
  static const toJsonFactory = _$PaymentMetaToJson;
  Map<String, dynamic> toJson() => _$PaymentMetaToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentMeta &&
            (identical(other.referenceNumber, referenceNumber) ||
                const DeepCollectionEquality()
                    .equals(other.referenceNumber, referenceNumber)) &&
            (identical(other.ppdId, ppdId) ||
                const DeepCollectionEquality().equals(other.ppdId, ppdId)) &&
            (identical(other.payee, payee) ||
                const DeepCollectionEquality().equals(other.payee, payee)) &&
            (identical(other.byOrderOf, byOrderOf) ||
                const DeepCollectionEquality()
                    .equals(other.byOrderOf, byOrderOf)) &&
            (identical(other.payer, payer) ||
                const DeepCollectionEquality().equals(other.payer, payer)) &&
            (identical(other.paymentMethod, paymentMethod) ||
                const DeepCollectionEquality()
                    .equals(other.paymentMethod, paymentMethod)) &&
            (identical(other.paymentProcessor, paymentProcessor) ||
                const DeepCollectionEquality()
                    .equals(other.paymentProcessor, paymentProcessor)) &&
            (identical(other.reason, reason) ||
                const DeepCollectionEquality().equals(other.reason, reason)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(referenceNumber) ^
      const DeepCollectionEquality().hash(ppdId) ^
      const DeepCollectionEquality().hash(payee) ^
      const DeepCollectionEquality().hash(byOrderOf) ^
      const DeepCollectionEquality().hash(payer) ^
      const DeepCollectionEquality().hash(paymentMethod) ^
      const DeepCollectionEquality().hash(paymentProcessor) ^
      const DeepCollectionEquality().hash(reason) ^
      runtimeType.hashCode;
}

extension $PaymentMetaExtension on PaymentMeta {
  PaymentMeta copyWith(
      {String? referenceNumber,
      String? ppdId,
      String? payee,
      String? byOrderOf,
      String? payer,
      String? paymentMethod,
      String? paymentProcessor,
      String? reason}) {
    return PaymentMeta(
        referenceNumber: referenceNumber ?? this.referenceNumber,
        ppdId: ppdId ?? this.ppdId,
        payee: payee ?? this.payee,
        byOrderOf: byOrderOf ?? this.byOrderOf,
        payer: payer ?? this.payer,
        paymentMethod: paymentMethod ?? this.paymentMethod,
        paymentProcessor: paymentProcessor ?? this.paymentProcessor,
        reason: reason ?? this.reason);
  }
}

@JsonSerializable(explicitToJson: true)
class Category {
  Category({
    this.categoryId,
    this.group,
    this.hierarchy,
  });

  factory Category.fromJson(Map<String, dynamic> json) =>
      _$CategoryFromJson(json);

  @JsonKey(name: 'category_id')
  final String? categoryId;
  @JsonKey(name: 'group')
  final String? group;
  @JsonKey(name: 'hierarchy', defaultValue: <String>[])
  final List<String>? hierarchy;
  static const fromJsonFactory = _$CategoryFromJson;
  static const toJsonFactory = _$CategoryToJson;
  Map<String, dynamic> toJson() => _$CategoryToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Category &&
            (identical(other.categoryId, categoryId) ||
                const DeepCollectionEquality()
                    .equals(other.categoryId, categoryId)) &&
            (identical(other.group, group) ||
                const DeepCollectionEquality().equals(other.group, group)) &&
            (identical(other.hierarchy, hierarchy) ||
                const DeepCollectionEquality()
                    .equals(other.hierarchy, hierarchy)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(categoryId) ^
      const DeepCollectionEquality().hash(group) ^
      const DeepCollectionEquality().hash(hierarchy) ^
      runtimeType.hashCode;
}

extension $CategoryExtension on Category {
  Category copyWith(
      {String? categoryId, String? group, List<String>? hierarchy}) {
    return Category(
        categoryId: categoryId ?? this.categoryId,
        group: group ?? this.group,
        hierarchy: hierarchy ?? this.hierarchy);
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalFinanceCategory {
  PersonalFinanceCategory({
    this.primary,
    this.detailed,
  });

  factory PersonalFinanceCategory.fromJson(Map<String, dynamic> json) =>
      _$PersonalFinanceCategoryFromJson(json);

  @JsonKey(name: 'primary')
  final String? primary;
  @JsonKey(name: 'detailed')
  final String? detailed;
  static const fromJsonFactory = _$PersonalFinanceCategoryFromJson;
  static const toJsonFactory = _$PersonalFinanceCategoryToJson;
  Map<String, dynamic> toJson() => _$PersonalFinanceCategoryToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PersonalFinanceCategory &&
            (identical(other.primary, primary) ||
                const DeepCollectionEquality()
                    .equals(other.primary, primary)) &&
            (identical(other.detailed, detailed) ||
                const DeepCollectionEquality()
                    .equals(other.detailed, detailed)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(primary) ^
      const DeepCollectionEquality().hash(detailed) ^
      runtimeType.hashCode;
}

extension $PersonalFinanceCategoryExtension on PersonalFinanceCategory {
  PersonalFinanceCategory copyWith({String? primary, String? detailed}) {
    return PersonalFinanceCategory(
        primary: primary ?? this.primary, detailed: detailed ?? this.detailed);
  }
}

@JsonSerializable(explicitToJson: true)
class TransactionsRemovedWebhook {
  TransactionsRemovedWebhook({
    this.webhookType,
    this.webhookCode,
    this.error,
    this.removedTransactions,
    this.itemId,
  });

  factory TransactionsRemovedWebhook.fromJson(Map<String, dynamic> json) =>
      _$TransactionsRemovedWebhookFromJson(json);

  @JsonKey(name: 'webhook_type')
  final String? webhookType;
  @JsonKey(name: 'webhook_code')
  final String? webhookCode;
  @JsonKey(name: 'error')
  final Error? error;
  @JsonKey(name: 'removed_transactions', defaultValue: <String>[])
  final List<String>? removedTransactions;
  @JsonKey(name: 'item_id')
  final String? itemId;
  static const fromJsonFactory = _$TransactionsRemovedWebhookFromJson;
  static const toJsonFactory = _$TransactionsRemovedWebhookToJson;
  Map<String, dynamic> toJson() => _$TransactionsRemovedWebhookToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransactionsRemovedWebhook &&
            (identical(other.webhookType, webhookType) ||
                const DeepCollectionEquality()
                    .equals(other.webhookType, webhookType)) &&
            (identical(other.webhookCode, webhookCode) ||
                const DeepCollectionEquality()
                    .equals(other.webhookCode, webhookCode)) &&
            (identical(other.error, error) ||
                const DeepCollectionEquality().equals(other.error, error)) &&
            (identical(other.removedTransactions, removedTransactions) ||
                const DeepCollectionEquality()
                    .equals(other.removedTransactions, removedTransactions)) &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(webhookType) ^
      const DeepCollectionEquality().hash(webhookCode) ^
      const DeepCollectionEquality().hash(error) ^
      const DeepCollectionEquality().hash(removedTransactions) ^
      const DeepCollectionEquality().hash(itemId) ^
      runtimeType.hashCode;
}

extension $TransactionsRemovedWebhookExtension on TransactionsRemovedWebhook {
  TransactionsRemovedWebhook copyWith(
      {String? webhookType,
      String? webhookCode,
      Error? error,
      List<String>? removedTransactions,
      String? itemId}) {
    return TransactionsRemovedWebhook(
        webhookType: webhookType ?? this.webhookType,
        webhookCode: webhookCode ?? this.webhookCode,
        error: error ?? this.error,
        removedTransactions: removedTransactions ?? this.removedTransactions,
        itemId: itemId ?? this.itemId);
  }
}

@JsonSerializable(explicitToJson: true)
class DefaultUpdateWebhook {
  DefaultUpdateWebhook({
    this.webhookType,
    this.webhookCode,
    this.error,
    this.newTransactions,
    this.itemId,
  });

  factory DefaultUpdateWebhook.fromJson(Map<String, dynamic> json) =>
      _$DefaultUpdateWebhookFromJson(json);

  @JsonKey(name: 'webhook_type')
  final String? webhookType;
  @JsonKey(name: 'webhook_code')
  final String? webhookCode;
  @JsonKey(name: 'error')
  final Error? error;
  @JsonKey(name: 'new_transactions')
  final double? newTransactions;
  @JsonKey(name: 'item_id')
  final String? itemId;
  static const fromJsonFactory = _$DefaultUpdateWebhookFromJson;
  static const toJsonFactory = _$DefaultUpdateWebhookToJson;
  Map<String, dynamic> toJson() => _$DefaultUpdateWebhookToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is DefaultUpdateWebhook &&
            (identical(other.webhookType, webhookType) ||
                const DeepCollectionEquality()
                    .equals(other.webhookType, webhookType)) &&
            (identical(other.webhookCode, webhookCode) ||
                const DeepCollectionEquality()
                    .equals(other.webhookCode, webhookCode)) &&
            (identical(other.error, error) ||
                const DeepCollectionEquality().equals(other.error, error)) &&
            (identical(other.newTransactions, newTransactions) ||
                const DeepCollectionEquality()
                    .equals(other.newTransactions, newTransactions)) &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(webhookType) ^
      const DeepCollectionEquality().hash(webhookCode) ^
      const DeepCollectionEquality().hash(error) ^
      const DeepCollectionEquality().hash(newTransactions) ^
      const DeepCollectionEquality().hash(itemId) ^
      runtimeType.hashCode;
}

extension $DefaultUpdateWebhookExtension on DefaultUpdateWebhook {
  DefaultUpdateWebhook copyWith(
      {String? webhookType,
      String? webhookCode,
      Error? error,
      double? newTransactions,
      String? itemId}) {
    return DefaultUpdateWebhook(
        webhookType: webhookType ?? this.webhookType,
        webhookCode: webhookCode ?? this.webhookCode,
        error: error ?? this.error,
        newTransactions: newTransactions ?? this.newTransactions,
        itemId: itemId ?? this.itemId);
  }
}

@JsonSerializable(explicitToJson: true)
class HistoricalUpdateWebhook {
  HistoricalUpdateWebhook({
    this.webhookType,
    this.webhookCode,
    this.error,
    this.newTransactions,
    this.itemId,
  });

  factory HistoricalUpdateWebhook.fromJson(Map<String, dynamic> json) =>
      _$HistoricalUpdateWebhookFromJson(json);

  @JsonKey(name: 'webhook_type')
  final String? webhookType;
  @JsonKey(name: 'webhook_code')
  final String? webhookCode;
  @JsonKey(name: 'error')
  final Error? error;
  @JsonKey(name: 'new_transactions')
  final double? newTransactions;
  @JsonKey(name: 'item_id')
  final String? itemId;
  static const fromJsonFactory = _$HistoricalUpdateWebhookFromJson;
  static const toJsonFactory = _$HistoricalUpdateWebhookToJson;
  Map<String, dynamic> toJson() => _$HistoricalUpdateWebhookToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is HistoricalUpdateWebhook &&
            (identical(other.webhookType, webhookType) ||
                const DeepCollectionEquality()
                    .equals(other.webhookType, webhookType)) &&
            (identical(other.webhookCode, webhookCode) ||
                const DeepCollectionEquality()
                    .equals(other.webhookCode, webhookCode)) &&
            (identical(other.error, error) ||
                const DeepCollectionEquality().equals(other.error, error)) &&
            (identical(other.newTransactions, newTransactions) ||
                const DeepCollectionEquality()
                    .equals(other.newTransactions, newTransactions)) &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(webhookType) ^
      const DeepCollectionEquality().hash(webhookCode) ^
      const DeepCollectionEquality().hash(error) ^
      const DeepCollectionEquality().hash(newTransactions) ^
      const DeepCollectionEquality().hash(itemId) ^
      runtimeType.hashCode;
}

extension $HistoricalUpdateWebhookExtension on HistoricalUpdateWebhook {
  HistoricalUpdateWebhook copyWith(
      {String? webhookType,
      String? webhookCode,
      Error? error,
      double? newTransactions,
      String? itemId}) {
    return HistoricalUpdateWebhook(
        webhookType: webhookType ?? this.webhookType,
        webhookCode: webhookCode ?? this.webhookCode,
        error: error ?? this.error,
        newTransactions: newTransactions ?? this.newTransactions,
        itemId: itemId ?? this.itemId);
  }
}

@JsonSerializable(explicitToJson: true)
class InitialUpdateWebhook {
  InitialUpdateWebhook({
    this.webhookType,
    this.webhookCode,
    this.error,
    this.newTransactions,
    this.itemId,
  });

  factory InitialUpdateWebhook.fromJson(Map<String, dynamic> json) =>
      _$InitialUpdateWebhookFromJson(json);

  @JsonKey(name: 'webhook_type')
  final String? webhookType;
  @JsonKey(name: 'webhook_code')
  final String? webhookCode;
  @JsonKey(name: 'error')
  final String? error;
  @JsonKey(name: 'new_transactions')
  final double? newTransactions;
  @JsonKey(name: 'item_id')
  final String? itemId;
  static const fromJsonFactory = _$InitialUpdateWebhookFromJson;
  static const toJsonFactory = _$InitialUpdateWebhookToJson;
  Map<String, dynamic> toJson() => _$InitialUpdateWebhookToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InitialUpdateWebhook &&
            (identical(other.webhookType, webhookType) ||
                const DeepCollectionEquality()
                    .equals(other.webhookType, webhookType)) &&
            (identical(other.webhookCode, webhookCode) ||
                const DeepCollectionEquality()
                    .equals(other.webhookCode, webhookCode)) &&
            (identical(other.error, error) ||
                const DeepCollectionEquality().equals(other.error, error)) &&
            (identical(other.newTransactions, newTransactions) ||
                const DeepCollectionEquality()
                    .equals(other.newTransactions, newTransactions)) &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(webhookType) ^
      const DeepCollectionEquality().hash(webhookCode) ^
      const DeepCollectionEquality().hash(error) ^
      const DeepCollectionEquality().hash(newTransactions) ^
      const DeepCollectionEquality().hash(itemId) ^
      runtimeType.hashCode;
}

extension $InitialUpdateWebhookExtension on InitialUpdateWebhook {
  InitialUpdateWebhook copyWith(
      {String? webhookType,
      String? webhookCode,
      String? error,
      double? newTransactions,
      String? itemId}) {
    return InitialUpdateWebhook(
        webhookType: webhookType ?? this.webhookType,
        webhookCode: webhookCode ?? this.webhookCode,
        error: error ?? this.error,
        newTransactions: newTransactions ?? this.newTransactions,
        itemId: itemId ?? this.itemId);
  }
}

@JsonSerializable(explicitToJson: true)
class PhoneNumber {
  PhoneNumber({
    this.data,
    this.primary,
    this.type,
  });

  factory PhoneNumber.fromJson(Map<String, dynamic> json) =>
      _$PhoneNumberFromJson(json);

  @JsonKey(name: 'data')
  final String? data;
  @JsonKey(name: 'primary')
  final bool? primary;
  @JsonKey(
      name: 'type',
      toJson: phoneNumberType$ToJson,
      fromJson: phoneNumberType$FromJson)
  final enums.PhoneNumberType$? type;
  static const fromJsonFactory = _$PhoneNumberFromJson;
  static const toJsonFactory = _$PhoneNumberToJson;
  Map<String, dynamic> toJson() => _$PhoneNumberToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PhoneNumber &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)) &&
            (identical(other.primary, primary) ||
                const DeepCollectionEquality()
                    .equals(other.primary, primary)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(data) ^
      const DeepCollectionEquality().hash(primary) ^
      const DeepCollectionEquality().hash(type) ^
      runtimeType.hashCode;
}

extension $PhoneNumberExtension on PhoneNumber {
  PhoneNumber copyWith(
      {String? data, bool? primary, enums.PhoneNumberType$? type}) {
    return PhoneNumber(
        data: data ?? this.data,
        primary: primary ?? this.primary,
        type: type ?? this.type);
  }
}

@JsonSerializable(explicitToJson: true)
class Email {
  Email({
    this.data,
    this.primary,
    this.type,
  });

  factory Email.fromJson(Map<String, dynamic> json) => _$EmailFromJson(json);

  @JsonKey(name: 'data')
  final String? data;
  @JsonKey(name: 'primary')
  final bool? primary;
  @JsonKey(name: 'type', toJson: emailType$ToJson, fromJson: emailType$FromJson)
  final enums.EmailType$? type;
  static const fromJsonFactory = _$EmailFromJson;
  static const toJsonFactory = _$EmailToJson;
  Map<String, dynamic> toJson() => _$EmailToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Email &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)) &&
            (identical(other.primary, primary) ||
                const DeepCollectionEquality()
                    .equals(other.primary, primary)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(data) ^
      const DeepCollectionEquality().hash(primary) ^
      const DeepCollectionEquality().hash(type) ^
      runtimeType.hashCode;
}

extension $EmailExtension on Email {
  Email copyWith({String? data, bool? primary, enums.EmailType$? type}) {
    return Email(
        data: data ?? this.data,
        primary: primary ?? this.primary,
        type: type ?? this.type);
  }
}

@JsonSerializable(explicitToJson: true)
class Address {
  Address({
    this.data,
    this.primary,
  });

  factory Address.fromJson(Map<String, dynamic> json) =>
      _$AddressFromJson(json);

  @JsonKey(name: 'data')
  final AddressData? data;
  @JsonKey(name: 'primary')
  final bool? primary;
  static const fromJsonFactory = _$AddressFromJson;
  static const toJsonFactory = _$AddressToJson;
  Map<String, dynamic> toJson() => _$AddressToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Address &&
            (identical(other.data, data) ||
                const DeepCollectionEquality().equals(other.data, data)) &&
            (identical(other.primary, primary) ||
                const DeepCollectionEquality().equals(other.primary, primary)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(data) ^
      const DeepCollectionEquality().hash(primary) ^
      runtimeType.hashCode;
}

extension $AddressExtension on Address {
  Address copyWith({AddressData? data, bool? primary}) {
    return Address(data: data ?? this.data, primary: primary ?? this.primary);
  }
}

@JsonSerializable(explicitToJson: true)
class AddressNullable {
  AddressNullable();

  factory AddressNullable.fromJson(Map<String, dynamic> json) =>
      _$AddressNullableFromJson(json);

  static const fromJsonFactory = _$AddressNullableFromJson;
  static const toJsonFactory = _$AddressNullableToJson;
  Map<String, dynamic> toJson() => _$AddressNullableToJson(this);

  @override
  int get hashCode => runtimeType.hashCode;
}

@JsonSerializable(explicitToJson: true)
class AddressDataNullable {
  AddressDataNullable();

  factory AddressDataNullable.fromJson(Map<String, dynamic> json) =>
      _$AddressDataNullableFromJson(json);

  static const fromJsonFactory = _$AddressDataNullableFromJson;
  static const toJsonFactory = _$AddressDataNullableToJson;
  Map<String, dynamic> toJson() => _$AddressDataNullableToJson(this);

  @override
  int get hashCode => runtimeType.hashCode;
}

@JsonSerializable(explicitToJson: true)
class AddressData {
  AddressData({
    this.city,
    this.region,
    this.street,
    this.postalCode,
    this.country,
  });

  factory AddressData.fromJson(Map<String, dynamic> json) =>
      _$AddressDataFromJson(json);

  @JsonKey(name: 'city')
  final String? city;
  @JsonKey(name: 'region')
  final String? region;
  @JsonKey(name: 'street')
  final String? street;
  @JsonKey(name: 'postal_code')
  final String? postalCode;
  @JsonKey(name: 'country')
  final String? country;
  static const fromJsonFactory = _$AddressDataFromJson;
  static const toJsonFactory = _$AddressDataToJson;
  Map<String, dynamic> toJson() => _$AddressDataToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AddressData &&
            (identical(other.city, city) ||
                const DeepCollectionEquality().equals(other.city, city)) &&
            (identical(other.region, region) ||
                const DeepCollectionEquality().equals(other.region, region)) &&
            (identical(other.street, street) ||
                const DeepCollectionEquality().equals(other.street, street)) &&
            (identical(other.postalCode, postalCode) ||
                const DeepCollectionEquality()
                    .equals(other.postalCode, postalCode)) &&
            (identical(other.country, country) ||
                const DeepCollectionEquality().equals(other.country, country)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(city) ^
      const DeepCollectionEquality().hash(region) ^
      const DeepCollectionEquality().hash(street) ^
      const DeepCollectionEquality().hash(postalCode) ^
      const DeepCollectionEquality().hash(country) ^
      runtimeType.hashCode;
}

extension $AddressDataExtension on AddressData {
  AddressData copyWith(
      {String? city,
      String? region,
      String? street,
      String? postalCode,
      String? country}) {
    return AddressData(
        city: city ?? this.city,
        region: region ?? this.region,
        street: street ?? this.street,
        postalCode: postalCode ?? this.postalCode,
        country: country ?? this.country);
  }
}

@JsonSerializable(explicitToJson: true)
class HistoricalBalance {
  HistoricalBalance({
    this.date,
    this.current,
    this.isoCurrencyCode,
    this.unofficialCurrencyCode,
  });

  factory HistoricalBalance.fromJson(Map<String, dynamic> json) =>
      _$HistoricalBalanceFromJson(json);

  @JsonKey(name: 'date', toJson: _dateToJson)
  final DateTime? date;
  @JsonKey(name: 'current')
  final double? current;
  @JsonKey(name: 'iso_currency_code')
  final String? isoCurrencyCode;
  @JsonKey(name: 'unofficial_currency_code')
  final String? unofficialCurrencyCode;
  static const fromJsonFactory = _$HistoricalBalanceFromJson;
  static const toJsonFactory = _$HistoricalBalanceToJson;
  Map<String, dynamic> toJson() => _$HistoricalBalanceToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is HistoricalBalance &&
            (identical(other.date, date) ||
                const DeepCollectionEquality().equals(other.date, date)) &&
            (identical(other.current, current) ||
                const DeepCollectionEquality()
                    .equals(other.current, current)) &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)) &&
            (identical(other.unofficialCurrencyCode, unofficialCurrencyCode) ||
                const DeepCollectionEquality().equals(
                    other.unofficialCurrencyCode, unofficialCurrencyCode)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(date) ^
      const DeepCollectionEquality().hash(current) ^
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      const DeepCollectionEquality().hash(unofficialCurrencyCode) ^
      runtimeType.hashCode;
}

extension $HistoricalBalanceExtension on HistoricalBalance {
  HistoricalBalance copyWith(
      {DateTime? date,
      double? current,
      String? isoCurrencyCode,
      String? unofficialCurrencyCode}) {
    return HistoricalBalance(
        date: date ?? this.date,
        current: current ?? this.current,
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode,
        unofficialCurrencyCode:
            unofficialCurrencyCode ?? this.unofficialCurrencyCode);
  }
}

@JsonSerializable(explicitToJson: true)
class Owner {
  Owner({
    this.names,
    this.phoneNumbers,
    this.emails,
    this.addresses,
  });

  factory Owner.fromJson(Map<String, dynamic> json) => _$OwnerFromJson(json);

  @JsonKey(name: 'names', defaultValue: <String>[])
  final List<String>? names;
  @JsonKey(name: 'phone_numbers', defaultValue: <PhoneNumber>[])
  final List<PhoneNumber>? phoneNumbers;
  @JsonKey(name: 'emails', defaultValue: <Email>[])
  final List<Email>? emails;
  @JsonKey(name: 'addresses', defaultValue: <Address>[])
  final List<Address>? addresses;
  static const fromJsonFactory = _$OwnerFromJson;
  static const toJsonFactory = _$OwnerToJson;
  Map<String, dynamic> toJson() => _$OwnerToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Owner &&
            (identical(other.names, names) ||
                const DeepCollectionEquality().equals(other.names, names)) &&
            (identical(other.phoneNumbers, phoneNumbers) ||
                const DeepCollectionEquality()
                    .equals(other.phoneNumbers, phoneNumbers)) &&
            (identical(other.emails, emails) ||
                const DeepCollectionEquality().equals(other.emails, emails)) &&
            (identical(other.addresses, addresses) ||
                const DeepCollectionEquality()
                    .equals(other.addresses, addresses)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(names) ^
      const DeepCollectionEquality().hash(phoneNumbers) ^
      const DeepCollectionEquality().hash(emails) ^
      const DeepCollectionEquality().hash(addresses) ^
      runtimeType.hashCode;
}

extension $OwnerExtension on Owner {
  Owner copyWith(
      {List<String>? names,
      List<PhoneNumber>? phoneNumbers,
      List<Email>? emails,
      List<Address>? addresses}) {
    return Owner(
        names: names ?? this.names,
        phoneNumbers: phoneNumbers ?? this.phoneNumbers,
        emails: emails ?? this.emails,
        addresses: addresses ?? this.addresses);
  }
}

@JsonSerializable(explicitToJson: true)
class OwnerOverride {
  OwnerOverride({
    this.names,
    this.phoneNumbers,
    this.emails,
    this.addresses,
  });

  factory OwnerOverride.fromJson(Map<String, dynamic> json) =>
      _$OwnerOverrideFromJson(json);

  @JsonKey(name: 'names', defaultValue: <String>[])
  final List<String>? names;
  @JsonKey(name: 'phone_numbers', defaultValue: <PhoneNumber>[])
  final List<PhoneNumber>? phoneNumbers;
  @JsonKey(name: 'emails', defaultValue: <Email>[])
  final List<Email>? emails;
  @JsonKey(name: 'addresses', defaultValue: <Address>[])
  final List<Address>? addresses;
  static const fromJsonFactory = _$OwnerOverrideFromJson;
  static const toJsonFactory = _$OwnerOverrideToJson;
  Map<String, dynamic> toJson() => _$OwnerOverrideToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is OwnerOverride &&
            (identical(other.names, names) ||
                const DeepCollectionEquality().equals(other.names, names)) &&
            (identical(other.phoneNumbers, phoneNumbers) ||
                const DeepCollectionEquality()
                    .equals(other.phoneNumbers, phoneNumbers)) &&
            (identical(other.emails, emails) ||
                const DeepCollectionEquality().equals(other.emails, emails)) &&
            (identical(other.addresses, addresses) ||
                const DeepCollectionEquality()
                    .equals(other.addresses, addresses)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(names) ^
      const DeepCollectionEquality().hash(phoneNumbers) ^
      const DeepCollectionEquality().hash(emails) ^
      const DeepCollectionEquality().hash(addresses) ^
      runtimeType.hashCode;
}

extension $OwnerOverrideExtension on OwnerOverride {
  OwnerOverride copyWith(
      {List<String>? names,
      List<PhoneNumber>? phoneNumbers,
      List<Email>? emails,
      List<Address>? addresses}) {
    return OwnerOverride(
        names: names ?? this.names,
        phoneNumbers: phoneNumbers ?? this.phoneNumbers,
        emails: emails ?? this.emails,
        addresses: addresses ?? this.addresses);
  }
}

@JsonSerializable(explicitToJson: true)
class LiabilitiesObject {
  LiabilitiesObject({
    this.credit,
    this.mortgage,
    this.student,
  });

  factory LiabilitiesObject.fromJson(Map<String, dynamic> json) =>
      _$LiabilitiesObjectFromJson(json);

  @JsonKey(name: 'credit', defaultValue: <CreditCardLiability>[])
  final List<CreditCardLiability>? credit;
  @JsonKey(name: 'mortgage', defaultValue: <MortgageLiability>[])
  final List<MortgageLiability>? mortgage;
  @JsonKey(name: 'student', defaultValue: <StudentLoan>[])
  final List<StudentLoan>? student;
  static const fromJsonFactory = _$LiabilitiesObjectFromJson;
  static const toJsonFactory = _$LiabilitiesObjectToJson;
  Map<String, dynamic> toJson() => _$LiabilitiesObjectToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LiabilitiesObject &&
            (identical(other.credit, credit) ||
                const DeepCollectionEquality().equals(other.credit, credit)) &&
            (identical(other.mortgage, mortgage) ||
                const DeepCollectionEquality()
                    .equals(other.mortgage, mortgage)) &&
            (identical(other.student, student) ||
                const DeepCollectionEquality().equals(other.student, student)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(credit) ^
      const DeepCollectionEquality().hash(mortgage) ^
      const DeepCollectionEquality().hash(student) ^
      runtimeType.hashCode;
}

extension $LiabilitiesObjectExtension on LiabilitiesObject {
  LiabilitiesObject copyWith(
      {List<CreditCardLiability>? credit,
      List<MortgageLiability>? mortgage,
      List<StudentLoan>? student}) {
    return LiabilitiesObject(
        credit: credit ?? this.credit,
        mortgage: mortgage ?? this.mortgage,
        student: student ?? this.student);
  }
}

@JsonSerializable(explicitToJson: true)
class StudentLoan {
  StudentLoan({
    this.accountId,
    this.accountNumber,
    this.disbursementDates,
    this.expectedPayoffDate,
    this.guarantor,
    this.interestRatePercentage,
    this.isOverdue,
    this.lastPaymentAmount,
    this.lastPaymentDate,
    this.lastStatementIssueDate,
    this.loanName,
    this.loanStatus,
    this.minimumPaymentAmount,
    this.nextPaymentDueDate,
    this.originationDate,
    this.originationPrincipalAmount,
    this.outstandingInterestAmount,
    this.paymentReferenceNumber,
    this.pslfStatus,
    this.repaymentPlan,
    this.sequenceNumber,
    this.servicerAddress,
    this.ytdInterestPaid,
    this.ytdPrincipalPaid,
  });

  factory StudentLoan.fromJson(Map<String, dynamic> json) =>
      _$StudentLoanFromJson(json);

  @JsonKey(name: 'account_id')
  final String? accountId;
  @JsonKey(name: 'account_number')
  final String? accountNumber;
  @JsonKey(name: 'disbursement_dates', defaultValue: <DateTime>[])
  final List<DateTime>? disbursementDates;
  @JsonKey(name: 'expected_payoff_date', toJson: _dateToJson)
  final DateTime? expectedPayoffDate;
  @JsonKey(name: 'guarantor')
  final String? guarantor;
  @JsonKey(name: 'interest_rate_percentage')
  final double? interestRatePercentage;
  @JsonKey(name: 'is_overdue')
  final bool? isOverdue;
  @JsonKey(name: 'last_payment_amount')
  final double? lastPaymentAmount;
  @JsonKey(name: 'last_payment_date', toJson: _dateToJson)
  final DateTime? lastPaymentDate;
  @JsonKey(name: 'last_statement_issue_date', toJson: _dateToJson)
  final DateTime? lastStatementIssueDate;
  @JsonKey(name: 'loan_name')
  final String? loanName;
  @JsonKey(name: 'loan_status')
  final StudentLoanStatus? loanStatus;
  @JsonKey(name: 'minimum_payment_amount')
  final double? minimumPaymentAmount;
  @JsonKey(name: 'next_payment_due_date', toJson: _dateToJson)
  final DateTime? nextPaymentDueDate;
  @JsonKey(name: 'origination_date', toJson: _dateToJson)
  final DateTime? originationDate;
  @JsonKey(name: 'origination_principal_amount')
  final double? originationPrincipalAmount;
  @JsonKey(name: 'outstanding_interest_amount')
  final double? outstandingInterestAmount;
  @JsonKey(name: 'payment_reference_number')
  final String? paymentReferenceNumber;
  @JsonKey(name: 'pslf_status')
  final PSLFStatus? pslfStatus;
  @JsonKey(name: 'repayment_plan')
  final StudentRepaymentPlan? repaymentPlan;
  @JsonKey(name: 'sequence_number')
  final String? sequenceNumber;
  @JsonKey(name: 'servicer_address')
  final ServicerAddressData? servicerAddress;
  @JsonKey(name: 'ytd_interest_paid')
  final double? ytdInterestPaid;
  @JsonKey(name: 'ytd_principal_paid')
  final double? ytdPrincipalPaid;
  static const fromJsonFactory = _$StudentLoanFromJson;
  static const toJsonFactory = _$StudentLoanToJson;
  Map<String, dynamic> toJson() => _$StudentLoanToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is StudentLoan &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.accountNumber, accountNumber) ||
                const DeepCollectionEquality()
                    .equals(other.accountNumber, accountNumber)) &&
            (identical(other.disbursementDates, disbursementDates) ||
                const DeepCollectionEquality()
                    .equals(other.disbursementDates, disbursementDates)) &&
            (identical(other.expectedPayoffDate, expectedPayoffDate) ||
                const DeepCollectionEquality()
                    .equals(other.expectedPayoffDate, expectedPayoffDate)) &&
            (identical(other.guarantor, guarantor) ||
                const DeepCollectionEquality()
                    .equals(other.guarantor, guarantor)) &&
            (identical(other.interestRatePercentage, interestRatePercentage) ||
                const DeepCollectionEquality().equals(
                    other.interestRatePercentage, interestRatePercentage)) &&
            (identical(other.isOverdue, isOverdue) ||
                const DeepCollectionEquality()
                    .equals(other.isOverdue, isOverdue)) &&
            (identical(other.lastPaymentAmount, lastPaymentAmount) ||
                const DeepCollectionEquality()
                    .equals(other.lastPaymentAmount, lastPaymentAmount)) &&
            (identical(other.lastPaymentDate, lastPaymentDate) ||
                const DeepCollectionEquality()
                    .equals(other.lastPaymentDate, lastPaymentDate)) &&
            (identical(other.lastStatementIssueDate, lastStatementIssueDate) ||
                const DeepCollectionEquality().equals(
                    other.lastStatementIssueDate, lastStatementIssueDate)) &&
            (identical(other.loanName, loanName) ||
                const DeepCollectionEquality()
                    .equals(other.loanName, loanName)) &&
            (identical(other.loanStatus, loanStatus) ||
                const DeepCollectionEquality()
                    .equals(other.loanStatus, loanStatus)) &&
            (identical(other.minimumPaymentAmount, minimumPaymentAmount) ||
                const DeepCollectionEquality().equals(
                    other.minimumPaymentAmount, minimumPaymentAmount)) &&
            (identical(other.nextPaymentDueDate, nextPaymentDueDate) ||
                const DeepCollectionEquality()
                    .equals(other.nextPaymentDueDate, nextPaymentDueDate)) &&
            (identical(other.originationDate, originationDate) ||
                const DeepCollectionEquality()
                    .equals(other.originationDate, originationDate)) &&
            (identical(other.originationPrincipalAmount, originationPrincipalAmount) ||
                const DeepCollectionEquality().equals(
                    other.originationPrincipalAmount,
                    originationPrincipalAmount)) &&
            (identical(other.outstandingInterestAmount, outstandingInterestAmount) ||
                const DeepCollectionEquality().equals(
                    other.outstandingInterestAmount,
                    outstandingInterestAmount)) &&
            (identical(other.paymentReferenceNumber, paymentReferenceNumber) ||
                const DeepCollectionEquality().equals(
                    other.paymentReferenceNumber, paymentReferenceNumber)) &&
            (identical(other.pslfStatus, pslfStatus) ||
                const DeepCollectionEquality()
                    .equals(other.pslfStatus, pslfStatus)) &&
            (identical(other.repaymentPlan, repaymentPlan) || const DeepCollectionEquality().equals(other.repaymentPlan, repaymentPlan)) &&
            (identical(other.sequenceNumber, sequenceNumber) || const DeepCollectionEquality().equals(other.sequenceNumber, sequenceNumber)) &&
            (identical(other.servicerAddress, servicerAddress) || const DeepCollectionEquality().equals(other.servicerAddress, servicerAddress)) &&
            (identical(other.ytdInterestPaid, ytdInterestPaid) || const DeepCollectionEquality().equals(other.ytdInterestPaid, ytdInterestPaid)) &&
            (identical(other.ytdPrincipalPaid, ytdPrincipalPaid) || const DeepCollectionEquality().equals(other.ytdPrincipalPaid, ytdPrincipalPaid)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(accountNumber) ^
      const DeepCollectionEquality().hash(disbursementDates) ^
      const DeepCollectionEquality().hash(expectedPayoffDate) ^
      const DeepCollectionEquality().hash(guarantor) ^
      const DeepCollectionEquality().hash(interestRatePercentage) ^
      const DeepCollectionEquality().hash(isOverdue) ^
      const DeepCollectionEquality().hash(lastPaymentAmount) ^
      const DeepCollectionEquality().hash(lastPaymentDate) ^
      const DeepCollectionEquality().hash(lastStatementIssueDate) ^
      const DeepCollectionEquality().hash(loanName) ^
      const DeepCollectionEquality().hash(loanStatus) ^
      const DeepCollectionEquality().hash(minimumPaymentAmount) ^
      const DeepCollectionEquality().hash(nextPaymentDueDate) ^
      const DeepCollectionEquality().hash(originationDate) ^
      const DeepCollectionEquality().hash(originationPrincipalAmount) ^
      const DeepCollectionEquality().hash(outstandingInterestAmount) ^
      const DeepCollectionEquality().hash(paymentReferenceNumber) ^
      const DeepCollectionEquality().hash(pslfStatus) ^
      const DeepCollectionEquality().hash(repaymentPlan) ^
      const DeepCollectionEquality().hash(sequenceNumber) ^
      const DeepCollectionEquality().hash(servicerAddress) ^
      const DeepCollectionEquality().hash(ytdInterestPaid) ^
      const DeepCollectionEquality().hash(ytdPrincipalPaid) ^
      runtimeType.hashCode;
}

extension $StudentLoanExtension on StudentLoan {
  StudentLoan copyWith(
      {String? accountId,
      String? accountNumber,
      List<DateTime>? disbursementDates,
      DateTime? expectedPayoffDate,
      String? guarantor,
      double? interestRatePercentage,
      bool? isOverdue,
      double? lastPaymentAmount,
      DateTime? lastPaymentDate,
      DateTime? lastStatementIssueDate,
      String? loanName,
      StudentLoanStatus? loanStatus,
      double? minimumPaymentAmount,
      DateTime? nextPaymentDueDate,
      DateTime? originationDate,
      double? originationPrincipalAmount,
      double? outstandingInterestAmount,
      String? paymentReferenceNumber,
      PSLFStatus? pslfStatus,
      StudentRepaymentPlan? repaymentPlan,
      String? sequenceNumber,
      ServicerAddressData? servicerAddress,
      double? ytdInterestPaid,
      double? ytdPrincipalPaid}) {
    return StudentLoan(
        accountId: accountId ?? this.accountId,
        accountNumber: accountNumber ?? this.accountNumber,
        disbursementDates: disbursementDates ?? this.disbursementDates,
        expectedPayoffDate: expectedPayoffDate ?? this.expectedPayoffDate,
        guarantor: guarantor ?? this.guarantor,
        interestRatePercentage:
            interestRatePercentage ?? this.interestRatePercentage,
        isOverdue: isOverdue ?? this.isOverdue,
        lastPaymentAmount: lastPaymentAmount ?? this.lastPaymentAmount,
        lastPaymentDate: lastPaymentDate ?? this.lastPaymentDate,
        lastStatementIssueDate:
            lastStatementIssueDate ?? this.lastStatementIssueDate,
        loanName: loanName ?? this.loanName,
        loanStatus: loanStatus ?? this.loanStatus,
        minimumPaymentAmount: minimumPaymentAmount ?? this.minimumPaymentAmount,
        nextPaymentDueDate: nextPaymentDueDate ?? this.nextPaymentDueDate,
        originationDate: originationDate ?? this.originationDate,
        originationPrincipalAmount:
            originationPrincipalAmount ?? this.originationPrincipalAmount,
        outstandingInterestAmount:
            outstandingInterestAmount ?? this.outstandingInterestAmount,
        paymentReferenceNumber:
            paymentReferenceNumber ?? this.paymentReferenceNumber,
        pslfStatus: pslfStatus ?? this.pslfStatus,
        repaymentPlan: repaymentPlan ?? this.repaymentPlan,
        sequenceNumber: sequenceNumber ?? this.sequenceNumber,
        servicerAddress: servicerAddress ?? this.servicerAddress,
        ytdInterestPaid: ytdInterestPaid ?? this.ytdInterestPaid,
        ytdPrincipalPaid: ytdPrincipalPaid ?? this.ytdPrincipalPaid);
  }
}

@JsonSerializable(explicitToJson: true)
class CreditCardLiability {
  CreditCardLiability({
    this.accountId,
    this.aprs,
    this.isOverdue,
    this.lastPaymentAmount,
    this.lastPaymentDate,
    this.lastStatementIssueDate,
    this.lastStatementBalance,
    this.minimumPaymentAmount,
    this.nextPaymentDueDate,
  });

  factory CreditCardLiability.fromJson(Map<String, dynamic> json) =>
      _$CreditCardLiabilityFromJson(json);

  @JsonKey(name: 'account_id')
  final String? accountId;
  @JsonKey(name: 'aprs', defaultValue: <Apr>[])
  final List<Apr>? aprs;
  @JsonKey(name: 'is_overdue')
  final bool? isOverdue;
  @JsonKey(name: 'last_payment_amount')
  final double? lastPaymentAmount;
  @JsonKey(name: 'last_payment_date', toJson: _dateToJson)
  final DateTime? lastPaymentDate;
  @JsonKey(name: 'last_statement_issue_date', toJson: _dateToJson)
  final DateTime? lastStatementIssueDate;
  @JsonKey(name: 'last_statement_balance')
  final double? lastStatementBalance;
  @JsonKey(name: 'minimum_payment_amount')
  final double? minimumPaymentAmount;
  @JsonKey(name: 'next_payment_due_date', toJson: _dateToJson)
  final DateTime? nextPaymentDueDate;
  static const fromJsonFactory = _$CreditCardLiabilityFromJson;
  static const toJsonFactory = _$CreditCardLiabilityToJson;
  Map<String, dynamic> toJson() => _$CreditCardLiabilityToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CreditCardLiability &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.aprs, aprs) ||
                const DeepCollectionEquality().equals(other.aprs, aprs)) &&
            (identical(other.isOverdue, isOverdue) ||
                const DeepCollectionEquality()
                    .equals(other.isOverdue, isOverdue)) &&
            (identical(other.lastPaymentAmount, lastPaymentAmount) ||
                const DeepCollectionEquality()
                    .equals(other.lastPaymentAmount, lastPaymentAmount)) &&
            (identical(other.lastPaymentDate, lastPaymentDate) ||
                const DeepCollectionEquality()
                    .equals(other.lastPaymentDate, lastPaymentDate)) &&
            (identical(other.lastStatementIssueDate, lastStatementIssueDate) ||
                const DeepCollectionEquality().equals(
                    other.lastStatementIssueDate, lastStatementIssueDate)) &&
            (identical(other.lastStatementBalance, lastStatementBalance) ||
                const DeepCollectionEquality().equals(
                    other.lastStatementBalance, lastStatementBalance)) &&
            (identical(other.minimumPaymentAmount, minimumPaymentAmount) ||
                const DeepCollectionEquality().equals(
                    other.minimumPaymentAmount, minimumPaymentAmount)) &&
            (identical(other.nextPaymentDueDate, nextPaymentDueDate) ||
                const DeepCollectionEquality()
                    .equals(other.nextPaymentDueDate, nextPaymentDueDate)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(aprs) ^
      const DeepCollectionEquality().hash(isOverdue) ^
      const DeepCollectionEquality().hash(lastPaymentAmount) ^
      const DeepCollectionEquality().hash(lastPaymentDate) ^
      const DeepCollectionEquality().hash(lastStatementIssueDate) ^
      const DeepCollectionEquality().hash(lastStatementBalance) ^
      const DeepCollectionEquality().hash(minimumPaymentAmount) ^
      const DeepCollectionEquality().hash(nextPaymentDueDate) ^
      runtimeType.hashCode;
}

extension $CreditCardLiabilityExtension on CreditCardLiability {
  CreditCardLiability copyWith(
      {String? accountId,
      List<Apr>? aprs,
      bool? isOverdue,
      double? lastPaymentAmount,
      DateTime? lastPaymentDate,
      DateTime? lastStatementIssueDate,
      double? lastStatementBalance,
      double? minimumPaymentAmount,
      DateTime? nextPaymentDueDate}) {
    return CreditCardLiability(
        accountId: accountId ?? this.accountId,
        aprs: aprs ?? this.aprs,
        isOverdue: isOverdue ?? this.isOverdue,
        lastPaymentAmount: lastPaymentAmount ?? this.lastPaymentAmount,
        lastPaymentDate: lastPaymentDate ?? this.lastPaymentDate,
        lastStatementIssueDate:
            lastStatementIssueDate ?? this.lastStatementIssueDate,
        lastStatementBalance: lastStatementBalance ?? this.lastStatementBalance,
        minimumPaymentAmount: minimumPaymentAmount ?? this.minimumPaymentAmount,
        nextPaymentDueDate: nextPaymentDueDate ?? this.nextPaymentDueDate);
  }
}

@JsonSerializable(explicitToJson: true)
class MortgageLiability {
  MortgageLiability({
    this.accountId,
    this.accountNumber,
    this.currentLateFee,
    this.escrowBalance,
    this.hasPmi,
    this.hasPrepaymentPenalty,
    this.interestRate,
    this.lastPaymentAmount,
    this.lastPaymentDate,
    this.loanTypeDescription,
    this.loanTerm,
    this.maturityDate,
    this.nextMonthlyPayment,
    this.nextPaymentDueDate,
    this.originationDate,
    this.originationPrincipalAmount,
    this.pastDueAmount,
    this.propertyAddress,
    this.ytdInterestPaid,
    this.ytdPrincipalPaid,
  });

  factory MortgageLiability.fromJson(Map<String, dynamic> json) =>
      _$MortgageLiabilityFromJson(json);

  @JsonKey(name: 'account_id')
  final String? accountId;
  @JsonKey(name: 'account_number')
  final String? accountNumber;
  @JsonKey(name: 'current_late_fee')
  final double? currentLateFee;
  @JsonKey(name: 'escrow_balance')
  final double? escrowBalance;
  @JsonKey(name: 'has_pmi')
  final bool? hasPmi;
  @JsonKey(name: 'has_prepayment_penalty')
  final bool? hasPrepaymentPenalty;
  @JsonKey(name: 'interest_rate')
  final MortgageInterestRate? interestRate;
  @JsonKey(name: 'last_payment_amount')
  final double? lastPaymentAmount;
  @JsonKey(name: 'last_payment_date', toJson: _dateToJson)
  final DateTime? lastPaymentDate;
  @JsonKey(name: 'loan_type_description')
  final String? loanTypeDescription;
  @JsonKey(name: 'loan_term')
  final String? loanTerm;
  @JsonKey(name: 'maturity_date', toJson: _dateToJson)
  final DateTime? maturityDate;
  @JsonKey(name: 'next_monthly_payment')
  final double? nextMonthlyPayment;
  @JsonKey(name: 'next_payment_due_date', toJson: _dateToJson)
  final DateTime? nextPaymentDueDate;
  @JsonKey(name: 'origination_date', toJson: _dateToJson)
  final DateTime? originationDate;
  @JsonKey(name: 'origination_principal_amount')
  final double? originationPrincipalAmount;
  @JsonKey(name: 'past_due_amount')
  final double? pastDueAmount;
  @JsonKey(name: 'property_address')
  final MortgagePropertyAddress? propertyAddress;
  @JsonKey(name: 'ytd_interest_paid')
  final double? ytdInterestPaid;
  @JsonKey(name: 'ytd_principal_paid')
  final double? ytdPrincipalPaid;
  static const fromJsonFactory = _$MortgageLiabilityFromJson;
  static const toJsonFactory = _$MortgageLiabilityToJson;
  Map<String, dynamic> toJson() => _$MortgageLiabilityToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is MortgageLiability &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.accountNumber, accountNumber) ||
                const DeepCollectionEquality()
                    .equals(other.accountNumber, accountNumber)) &&
            (identical(other.currentLateFee, currentLateFee) ||
                const DeepCollectionEquality()
                    .equals(other.currentLateFee, currentLateFee)) &&
            (identical(other.escrowBalance, escrowBalance) ||
                const DeepCollectionEquality()
                    .equals(other.escrowBalance, escrowBalance)) &&
            (identical(other.hasPmi, hasPmi) ||
                const DeepCollectionEquality().equals(other.hasPmi, hasPmi)) &&
            (identical(other.hasPrepaymentPenalty, hasPrepaymentPenalty) ||
                const DeepCollectionEquality().equals(
                    other.hasPrepaymentPenalty, hasPrepaymentPenalty)) &&
            (identical(other.interestRate, interestRate) ||
                const DeepCollectionEquality()
                    .equals(other.interestRate, interestRate)) &&
            (identical(other.lastPaymentAmount, lastPaymentAmount) ||
                const DeepCollectionEquality()
                    .equals(other.lastPaymentAmount, lastPaymentAmount)) &&
            (identical(other.lastPaymentDate, lastPaymentDate) ||
                const DeepCollectionEquality()
                    .equals(other.lastPaymentDate, lastPaymentDate)) &&
            (identical(other.loanTypeDescription, loanTypeDescription) ||
                const DeepCollectionEquality()
                    .equals(other.loanTypeDescription, loanTypeDescription)) &&
            (identical(other.loanTerm, loanTerm) ||
                const DeepCollectionEquality()
                    .equals(other.loanTerm, loanTerm)) &&
            (identical(other.maturityDate, maturityDate) ||
                const DeepCollectionEquality()
                    .equals(other.maturityDate, maturityDate)) &&
            (identical(other.nextMonthlyPayment, nextMonthlyPayment) ||
                const DeepCollectionEquality()
                    .equals(other.nextMonthlyPayment, nextMonthlyPayment)) &&
            (identical(other.nextPaymentDueDate, nextPaymentDueDate) ||
                const DeepCollectionEquality()
                    .equals(other.nextPaymentDueDate, nextPaymentDueDate)) &&
            (identical(other.originationDate, originationDate) ||
                const DeepCollectionEquality()
                    .equals(other.originationDate, originationDate)) &&
            (identical(other.originationPrincipalAmount, originationPrincipalAmount) ||
                const DeepCollectionEquality().equals(
                    other.originationPrincipalAmount,
                    originationPrincipalAmount)) &&
            (identical(other.pastDueAmount, pastDueAmount) ||
                const DeepCollectionEquality()
                    .equals(other.pastDueAmount, pastDueAmount)) &&
            (identical(other.propertyAddress, propertyAddress) ||
                const DeepCollectionEquality()
                    .equals(other.propertyAddress, propertyAddress)) &&
            (identical(other.ytdInterestPaid, ytdInterestPaid) ||
                const DeepCollectionEquality()
                    .equals(other.ytdInterestPaid, ytdInterestPaid)) &&
            (identical(other.ytdPrincipalPaid, ytdPrincipalPaid) ||
                const DeepCollectionEquality()
                    .equals(other.ytdPrincipalPaid, ytdPrincipalPaid)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(accountNumber) ^
      const DeepCollectionEquality().hash(currentLateFee) ^
      const DeepCollectionEquality().hash(escrowBalance) ^
      const DeepCollectionEquality().hash(hasPmi) ^
      const DeepCollectionEquality().hash(hasPrepaymentPenalty) ^
      const DeepCollectionEquality().hash(interestRate) ^
      const DeepCollectionEquality().hash(lastPaymentAmount) ^
      const DeepCollectionEquality().hash(lastPaymentDate) ^
      const DeepCollectionEquality().hash(loanTypeDescription) ^
      const DeepCollectionEquality().hash(loanTerm) ^
      const DeepCollectionEquality().hash(maturityDate) ^
      const DeepCollectionEquality().hash(nextMonthlyPayment) ^
      const DeepCollectionEquality().hash(nextPaymentDueDate) ^
      const DeepCollectionEquality().hash(originationDate) ^
      const DeepCollectionEquality().hash(originationPrincipalAmount) ^
      const DeepCollectionEquality().hash(pastDueAmount) ^
      const DeepCollectionEquality().hash(propertyAddress) ^
      const DeepCollectionEquality().hash(ytdInterestPaid) ^
      const DeepCollectionEquality().hash(ytdPrincipalPaid) ^
      runtimeType.hashCode;
}

extension $MortgageLiabilityExtension on MortgageLiability {
  MortgageLiability copyWith(
      {String? accountId,
      String? accountNumber,
      double? currentLateFee,
      double? escrowBalance,
      bool? hasPmi,
      bool? hasPrepaymentPenalty,
      MortgageInterestRate? interestRate,
      double? lastPaymentAmount,
      DateTime? lastPaymentDate,
      String? loanTypeDescription,
      String? loanTerm,
      DateTime? maturityDate,
      double? nextMonthlyPayment,
      DateTime? nextPaymentDueDate,
      DateTime? originationDate,
      double? originationPrincipalAmount,
      double? pastDueAmount,
      MortgagePropertyAddress? propertyAddress,
      double? ytdInterestPaid,
      double? ytdPrincipalPaid}) {
    return MortgageLiability(
        accountId: accountId ?? this.accountId,
        accountNumber: accountNumber ?? this.accountNumber,
        currentLateFee: currentLateFee ?? this.currentLateFee,
        escrowBalance: escrowBalance ?? this.escrowBalance,
        hasPmi: hasPmi ?? this.hasPmi,
        hasPrepaymentPenalty: hasPrepaymentPenalty ?? this.hasPrepaymentPenalty,
        interestRate: interestRate ?? this.interestRate,
        lastPaymentAmount: lastPaymentAmount ?? this.lastPaymentAmount,
        lastPaymentDate: lastPaymentDate ?? this.lastPaymentDate,
        loanTypeDescription: loanTypeDescription ?? this.loanTypeDescription,
        loanTerm: loanTerm ?? this.loanTerm,
        maturityDate: maturityDate ?? this.maturityDate,
        nextMonthlyPayment: nextMonthlyPayment ?? this.nextMonthlyPayment,
        nextPaymentDueDate: nextPaymentDueDate ?? this.nextPaymentDueDate,
        originationDate: originationDate ?? this.originationDate,
        originationPrincipalAmount:
            originationPrincipalAmount ?? this.originationPrincipalAmount,
        pastDueAmount: pastDueAmount ?? this.pastDueAmount,
        propertyAddress: propertyAddress ?? this.propertyAddress,
        ytdInterestPaid: ytdInterestPaid ?? this.ytdInterestPaid,
        ytdPrincipalPaid: ytdPrincipalPaid ?? this.ytdPrincipalPaid);
  }
}

@JsonSerializable(explicitToJson: true)
class MortgageInterestRate {
  MortgageInterestRate({
    this.percentage,
    this.type,
  });

  factory MortgageInterestRate.fromJson(Map<String, dynamic> json) =>
      _$MortgageInterestRateFromJson(json);

  @JsonKey(name: 'percentage')
  final double? percentage;
  @JsonKey(name: 'type')
  final String? type;
  static const fromJsonFactory = _$MortgageInterestRateFromJson;
  static const toJsonFactory = _$MortgageInterestRateToJson;
  Map<String, dynamic> toJson() => _$MortgageInterestRateToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is MortgageInterestRate &&
            (identical(other.percentage, percentage) ||
                const DeepCollectionEquality()
                    .equals(other.percentage, percentage)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(percentage) ^
      const DeepCollectionEquality().hash(type) ^
      runtimeType.hashCode;
}

extension $MortgageInterestRateExtension on MortgageInterestRate {
  MortgageInterestRate copyWith({double? percentage, String? type}) {
    return MortgageInterestRate(
        percentage: percentage ?? this.percentage, type: type ?? this.type);
  }
}

@JsonSerializable(explicitToJson: true)
class MortgagePropertyAddress {
  MortgagePropertyAddress({
    this.city,
    this.country,
    this.postalCode,
    this.region,
    this.street,
  });

  factory MortgagePropertyAddress.fromJson(Map<String, dynamic> json) =>
      _$MortgagePropertyAddressFromJson(json);

  @JsonKey(name: 'city')
  final String? city;
  @JsonKey(name: 'country')
  final String? country;
  @JsonKey(name: 'postal_code')
  final String? postalCode;
  @JsonKey(name: 'region')
  final String? region;
  @JsonKey(name: 'street')
  final String? street;
  static const fromJsonFactory = _$MortgagePropertyAddressFromJson;
  static const toJsonFactory = _$MortgagePropertyAddressToJson;
  Map<String, dynamic> toJson() => _$MortgagePropertyAddressToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is MortgagePropertyAddress &&
            (identical(other.city, city) ||
                const DeepCollectionEquality().equals(other.city, city)) &&
            (identical(other.country, country) ||
                const DeepCollectionEquality()
                    .equals(other.country, country)) &&
            (identical(other.postalCode, postalCode) ||
                const DeepCollectionEquality()
                    .equals(other.postalCode, postalCode)) &&
            (identical(other.region, region) ||
                const DeepCollectionEquality().equals(other.region, region)) &&
            (identical(other.street, street) ||
                const DeepCollectionEquality().equals(other.street, street)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(city) ^
      const DeepCollectionEquality().hash(country) ^
      const DeepCollectionEquality().hash(postalCode) ^
      const DeepCollectionEquality().hash(region) ^
      const DeepCollectionEquality().hash(street) ^
      runtimeType.hashCode;
}

extension $MortgagePropertyAddressExtension on MortgagePropertyAddress {
  MortgagePropertyAddress copyWith(
      {String? city,
      String? country,
      String? postalCode,
      String? region,
      String? street}) {
    return MortgagePropertyAddress(
        city: city ?? this.city,
        country: country ?? this.country,
        postalCode: postalCode ?? this.postalCode,
        region: region ?? this.region,
        street: street ?? this.street);
  }
}

@JsonSerializable(explicitToJson: true)
class StudentLoanStatus {
  StudentLoanStatus({
    this.endDate,
    this.type,
  });

  factory StudentLoanStatus.fromJson(Map<String, dynamic> json) =>
      _$StudentLoanStatusFromJson(json);

  @JsonKey(name: 'end_date', toJson: _dateToJson)
  final DateTime? endDate;
  @JsonKey(
      name: 'type',
      toJson: studentLoanStatusType$ToJson,
      fromJson: studentLoanStatusType$FromJson)
  final enums.StudentLoanStatusType$? type;
  static const fromJsonFactory = _$StudentLoanStatusFromJson;
  static const toJsonFactory = _$StudentLoanStatusToJson;
  Map<String, dynamic> toJson() => _$StudentLoanStatusToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is StudentLoanStatus &&
            (identical(other.endDate, endDate) ||
                const DeepCollectionEquality()
                    .equals(other.endDate, endDate)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(endDate) ^
      const DeepCollectionEquality().hash(type) ^
      runtimeType.hashCode;
}

extension $StudentLoanStatusExtension on StudentLoanStatus {
  StudentLoanStatus copyWith(
      {DateTime? endDate, enums.StudentLoanStatusType$? type}) {
    return StudentLoanStatus(
        endDate: endDate ?? this.endDate, type: type ?? this.type);
  }
}

@JsonSerializable(explicitToJson: true)
class StudentRepaymentPlan {
  StudentRepaymentPlan({
    this.description,
    this.type,
  });

  factory StudentRepaymentPlan.fromJson(Map<String, dynamic> json) =>
      _$StudentRepaymentPlanFromJson(json);

  @JsonKey(name: 'description')
  final String? description;
  @JsonKey(
      name: 'type',
      toJson: studentRepaymentPlanType$ToJson,
      fromJson: studentRepaymentPlanType$FromJson)
  final enums.StudentRepaymentPlanType$? type;
  static const fromJsonFactory = _$StudentRepaymentPlanFromJson;
  static const toJsonFactory = _$StudentRepaymentPlanToJson;
  Map<String, dynamic> toJson() => _$StudentRepaymentPlanToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is StudentRepaymentPlan &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(type) ^
      runtimeType.hashCode;
}

extension $StudentRepaymentPlanExtension on StudentRepaymentPlan {
  StudentRepaymentPlan copyWith(
      {String? description, enums.StudentRepaymentPlanType$? type}) {
    return StudentRepaymentPlan(
        description: description ?? this.description, type: type ?? this.type);
  }
}

@JsonSerializable(explicitToJson: true)
class PSLFStatus {
  PSLFStatus({
    this.estimatedEligibilityDate,
    this.paymentsMade,
    this.paymentsRemaining,
  });

  factory PSLFStatus.fromJson(Map<String, dynamic> json) =>
      _$PSLFStatusFromJson(json);

  @JsonKey(name: 'estimated_eligibility_date', toJson: _dateToJson)
  final DateTime? estimatedEligibilityDate;
  @JsonKey(name: 'payments_made')
  final double? paymentsMade;
  @JsonKey(name: 'payments_remaining')
  final double? paymentsRemaining;
  static const fromJsonFactory = _$PSLFStatusFromJson;
  static const toJsonFactory = _$PSLFStatusToJson;
  Map<String, dynamic> toJson() => _$PSLFStatusToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PSLFStatus &&
            (identical(
                    other.estimatedEligibilityDate, estimatedEligibilityDate) ||
                const DeepCollectionEquality().equals(
                    other.estimatedEligibilityDate,
                    estimatedEligibilityDate)) &&
            (identical(other.paymentsMade, paymentsMade) ||
                const DeepCollectionEquality()
                    .equals(other.paymentsMade, paymentsMade)) &&
            (identical(other.paymentsRemaining, paymentsRemaining) ||
                const DeepCollectionEquality()
                    .equals(other.paymentsRemaining, paymentsRemaining)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(estimatedEligibilityDate) ^
      const DeepCollectionEquality().hash(paymentsMade) ^
      const DeepCollectionEquality().hash(paymentsRemaining) ^
      runtimeType.hashCode;
}

extension $PSLFStatusExtension on PSLFStatus {
  PSLFStatus copyWith(
      {DateTime? estimatedEligibilityDate,
      double? paymentsMade,
      double? paymentsRemaining}) {
    return PSLFStatus(
        estimatedEligibilityDate:
            estimatedEligibilityDate ?? this.estimatedEligibilityDate,
        paymentsMade: paymentsMade ?? this.paymentsMade,
        paymentsRemaining: paymentsRemaining ?? this.paymentsRemaining);
  }
}

@JsonSerializable(explicitToJson: true)
class ServicerAddressData {
  ServicerAddressData({
    this.city,
    this.region,
    this.street,
    this.postalCode,
    this.country,
  });

  factory ServicerAddressData.fromJson(Map<String, dynamic> json) =>
      _$ServicerAddressDataFromJson(json);

  @JsonKey(name: 'city')
  final String? city;
  @JsonKey(name: 'region')
  final String? region;
  @JsonKey(name: 'street')
  final String? street;
  @JsonKey(name: 'postal_code')
  final String? postalCode;
  @JsonKey(name: 'country')
  final String? country;
  static const fromJsonFactory = _$ServicerAddressDataFromJson;
  static const toJsonFactory = _$ServicerAddressDataToJson;
  Map<String, dynamic> toJson() => _$ServicerAddressDataToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ServicerAddressData &&
            (identical(other.city, city) ||
                const DeepCollectionEquality().equals(other.city, city)) &&
            (identical(other.region, region) ||
                const DeepCollectionEquality().equals(other.region, region)) &&
            (identical(other.street, street) ||
                const DeepCollectionEquality().equals(other.street, street)) &&
            (identical(other.postalCode, postalCode) ||
                const DeepCollectionEquality()
                    .equals(other.postalCode, postalCode)) &&
            (identical(other.country, country) ||
                const DeepCollectionEquality().equals(other.country, country)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(city) ^
      const DeepCollectionEquality().hash(region) ^
      const DeepCollectionEquality().hash(street) ^
      const DeepCollectionEquality().hash(postalCode) ^
      const DeepCollectionEquality().hash(country) ^
      runtimeType.hashCode;
}

extension $ServicerAddressDataExtension on ServicerAddressData {
  ServicerAddressData copyWith(
      {String? city,
      String? region,
      String? street,
      String? postalCode,
      String? country}) {
    return ServicerAddressData(
        city: city ?? this.city,
        region: region ?? this.region,
        street: street ?? this.street,
        postalCode: postalCode ?? this.postalCode,
        country: country ?? this.country);
  }
}

@JsonSerializable(explicitToJson: true)
class Apr {
  Apr({
    this.aprPercentage,
    this.aprType,
    this.balanceSubjectToApr,
    this.interestChargeAmount,
  });

  factory Apr.fromJson(Map<String, dynamic> json) => _$AprFromJson(json);

  @JsonKey(name: 'apr_percentage')
  final double? aprPercentage;
  @JsonKey(
      name: 'apr_type', toJson: aprAprTypeToJson, fromJson: aprAprTypeFromJson)
  final enums.AprAprType? aprType;
  @JsonKey(name: 'balance_subject_to_apr')
  final double? balanceSubjectToApr;
  @JsonKey(name: 'interest_charge_amount')
  final double? interestChargeAmount;
  static const fromJsonFactory = _$AprFromJson;
  static const toJsonFactory = _$AprToJson;
  Map<String, dynamic> toJson() => _$AprToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Apr &&
            (identical(other.aprPercentage, aprPercentage) ||
                const DeepCollectionEquality()
                    .equals(other.aprPercentage, aprPercentage)) &&
            (identical(other.aprType, aprType) ||
                const DeepCollectionEquality()
                    .equals(other.aprType, aprType)) &&
            (identical(other.balanceSubjectToApr, balanceSubjectToApr) ||
                const DeepCollectionEquality()
                    .equals(other.balanceSubjectToApr, balanceSubjectToApr)) &&
            (identical(other.interestChargeAmount, interestChargeAmount) ||
                const DeepCollectionEquality()
                    .equals(other.interestChargeAmount, interestChargeAmount)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(aprPercentage) ^
      const DeepCollectionEquality().hash(aprType) ^
      const DeepCollectionEquality().hash(balanceSubjectToApr) ^
      const DeepCollectionEquality().hash(interestChargeAmount) ^
      runtimeType.hashCode;
}

extension $AprExtension on Apr {
  Apr copyWith(
      {double? aprPercentage,
      enums.AprAprType? aprType,
      double? balanceSubjectToApr,
      double? interestChargeAmount}) {
    return Apr(
        aprPercentage: aprPercentage ?? this.aprPercentage,
        aprType: aprType ?? this.aprType,
        balanceSubjectToApr: balanceSubjectToApr ?? this.balanceSubjectToApr,
        interestChargeAmount:
            interestChargeAmount ?? this.interestChargeAmount);
  }
}

@JsonSerializable(explicitToJson: true)
class AuthMetadata {
  AuthMetadata({
    this.supportedMethods,
  });

  factory AuthMetadata.fromJson(Map<String, dynamic> json) =>
      _$AuthMetadataFromJson(json);

  @JsonKey(name: 'supported_methods')
  final AuthSupportedMethods? supportedMethods;
  static const fromJsonFactory = _$AuthMetadataFromJson;
  static const toJsonFactory = _$AuthMetadataToJson;
  Map<String, dynamic> toJson() => _$AuthMetadataToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AuthMetadata &&
            (identical(other.supportedMethods, supportedMethods) ||
                const DeepCollectionEquality()
                    .equals(other.supportedMethods, supportedMethods)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(supportedMethods) ^
      runtimeType.hashCode;
}

extension $AuthMetadataExtension on AuthMetadata {
  AuthMetadata copyWith({AuthSupportedMethods? supportedMethods}) {
    return AuthMetadata(
        supportedMethods: supportedMethods ?? this.supportedMethods);
  }
}

@JsonSerializable(explicitToJson: true)
class AuthSupportedMethods {
  AuthSupportedMethods({
    this.instantAuth,
    this.instantMatch,
    this.automatedMicroDeposits,
  });

  factory AuthSupportedMethods.fromJson(Map<String, dynamic> json) =>
      _$AuthSupportedMethodsFromJson(json);

  @JsonKey(name: 'instant_auth')
  final bool? instantAuth;
  @JsonKey(name: 'instant_match')
  final bool? instantMatch;
  @JsonKey(name: 'automated_micro_deposits')
  final bool? automatedMicroDeposits;
  static const fromJsonFactory = _$AuthSupportedMethodsFromJson;
  static const toJsonFactory = _$AuthSupportedMethodsToJson;
  Map<String, dynamic> toJson() => _$AuthSupportedMethodsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AuthSupportedMethods &&
            (identical(other.instantAuth, instantAuth) ||
                const DeepCollectionEquality()
                    .equals(other.instantAuth, instantAuth)) &&
            (identical(other.instantMatch, instantMatch) ||
                const DeepCollectionEquality()
                    .equals(other.instantMatch, instantMatch)) &&
            (identical(other.automatedMicroDeposits, automatedMicroDeposits) ||
                const DeepCollectionEquality().equals(
                    other.automatedMicroDeposits, automatedMicroDeposits)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(instantAuth) ^
      const DeepCollectionEquality().hash(instantMatch) ^
      const DeepCollectionEquality().hash(automatedMicroDeposits) ^
      runtimeType.hashCode;
}

extension $AuthSupportedMethodsExtension on AuthSupportedMethods {
  AuthSupportedMethods copyWith(
      {bool? instantAuth, bool? instantMatch, bool? automatedMicroDeposits}) {
    return AuthSupportedMethods(
        instantAuth: instantAuth ?? this.instantAuth,
        instantMatch: instantMatch ?? this.instantMatch,
        automatedMicroDeposits:
            automatedMicroDeposits ?? this.automatedMicroDeposits);
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentInitiationMetadata {
  PaymentInitiationMetadata({
    this.supportsInternationalPayments,
    this.maximumPaymentAmount,
    this.supportsRefundDetails,
    this.standingOrderMetadata,
  });

  factory PaymentInitiationMetadata.fromJson(Map<String, dynamic> json) =>
      _$PaymentInitiationMetadataFromJson(json);

  @JsonKey(name: 'supports_international_payments')
  final bool? supportsInternationalPayments;
  @JsonKey(name: 'maximum_payment_amount')
  final Map<String, dynamic>? maximumPaymentAmount;
  @JsonKey(name: 'supports_refund_details')
  final bool? supportsRefundDetails;
  @JsonKey(name: 'standing_order_metadata')
  final PaymentInitiationStandingOrderMetadata? standingOrderMetadata;
  static const fromJsonFactory = _$PaymentInitiationMetadataFromJson;
  static const toJsonFactory = _$PaymentInitiationMetadataToJson;
  Map<String, dynamic> toJson() => _$PaymentInitiationMetadataToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentInitiationMetadata &&
            (identical(other.supportsInternationalPayments,
                    supportsInternationalPayments) ||
                const DeepCollectionEquality().equals(
                    other.supportsInternationalPayments,
                    supportsInternationalPayments)) &&
            (identical(other.maximumPaymentAmount, maximumPaymentAmount) ||
                const DeepCollectionEquality().equals(
                    other.maximumPaymentAmount, maximumPaymentAmount)) &&
            (identical(other.supportsRefundDetails, supportsRefundDetails) ||
                const DeepCollectionEquality().equals(
                    other.supportsRefundDetails, supportsRefundDetails)) &&
            (identical(other.standingOrderMetadata, standingOrderMetadata) ||
                const DeepCollectionEquality().equals(
                    other.standingOrderMetadata, standingOrderMetadata)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(supportsInternationalPayments) ^
      const DeepCollectionEquality().hash(maximumPaymentAmount) ^
      const DeepCollectionEquality().hash(supportsRefundDetails) ^
      const DeepCollectionEquality().hash(standingOrderMetadata) ^
      runtimeType.hashCode;
}

extension $PaymentInitiationMetadataExtension on PaymentInitiationMetadata {
  PaymentInitiationMetadata copyWith(
      {bool? supportsInternationalPayments,
      Map<String, dynamic>? maximumPaymentAmount,
      bool? supportsRefundDetails,
      PaymentInitiationStandingOrderMetadata? standingOrderMetadata}) {
    return PaymentInitiationMetadata(
        supportsInternationalPayments:
            supportsInternationalPayments ?? this.supportsInternationalPayments,
        maximumPaymentAmount: maximumPaymentAmount ?? this.maximumPaymentAmount,
        supportsRefundDetails:
            supportsRefundDetails ?? this.supportsRefundDetails,
        standingOrderMetadata:
            standingOrderMetadata ?? this.standingOrderMetadata);
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentInitiationStandingOrderMetadata {
  PaymentInitiationStandingOrderMetadata({
    this.supportsStandingOrderEndDate,
    this.supportsStandingOrderNegativeExecutionDays,
    this.validStandingOrderIntervals,
  });

  factory PaymentInitiationStandingOrderMetadata.fromJson(
          Map<String, dynamic> json) =>
      _$PaymentInitiationStandingOrderMetadataFromJson(json);

  @JsonKey(name: 'supports_standing_order_end_date')
  final bool? supportsStandingOrderEndDate;
  @JsonKey(name: 'supports_standing_order_negative_execution_days')
  final bool? supportsStandingOrderNegativeExecutionDays;
  @JsonKey(
      name: 'valid_standing_order_intervals',
      toJson: paymentScheduleIntervalListToJson,
      fromJson: paymentScheduleIntervalListFromJson)
  final List<enums.PaymentScheduleInterval>? validStandingOrderIntervals;
  static const fromJsonFactory =
      _$PaymentInitiationStandingOrderMetadataFromJson;
  static const toJsonFactory = _$PaymentInitiationStandingOrderMetadataToJson;
  Map<String, dynamic> toJson() =>
      _$PaymentInitiationStandingOrderMetadataToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentInitiationStandingOrderMetadata &&
            (identical(other.supportsStandingOrderEndDate,
                    supportsStandingOrderEndDate) ||
                const DeepCollectionEquality().equals(
                    other.supportsStandingOrderEndDate,
                    supportsStandingOrderEndDate)) &&
            (identical(other.supportsStandingOrderNegativeExecutionDays,
                    supportsStandingOrderNegativeExecutionDays) ||
                const DeepCollectionEquality().equals(
                    other.supportsStandingOrderNegativeExecutionDays,
                    supportsStandingOrderNegativeExecutionDays)) &&
            (identical(other.validStandingOrderIntervals,
                    validStandingOrderIntervals) ||
                const DeepCollectionEquality().equals(
                    other.validStandingOrderIntervals,
                    validStandingOrderIntervals)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(supportsStandingOrderEndDate) ^
      const DeepCollectionEquality()
          .hash(supportsStandingOrderNegativeExecutionDays) ^
      const DeepCollectionEquality().hash(validStandingOrderIntervals) ^
      runtimeType.hashCode;
}

extension $PaymentInitiationStandingOrderMetadataExtension
    on PaymentInitiationStandingOrderMetadata {
  PaymentInitiationStandingOrderMetadata copyWith(
      {bool? supportsStandingOrderEndDate,
      bool? supportsStandingOrderNegativeExecutionDays,
      List<enums.PaymentScheduleInterval>? validStandingOrderIntervals}) {
    return PaymentInitiationStandingOrderMetadata(
        supportsStandingOrderEndDate:
            supportsStandingOrderEndDate ?? this.supportsStandingOrderEndDate,
        supportsStandingOrderNegativeExecutionDays:
            supportsStandingOrderNegativeExecutionDays ??
                this.supportsStandingOrderNegativeExecutionDays,
        validStandingOrderIntervals:
            validStandingOrderIntervals ?? this.validStandingOrderIntervals);
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentInitiationAddress {
  PaymentInitiationAddress({
    this.street,
    this.city,
    this.postalCode,
    this.country,
  });

  factory PaymentInitiationAddress.fromJson(Map<String, dynamic> json) =>
      _$PaymentInitiationAddressFromJson(json);

  @JsonKey(name: 'street', defaultValue: <String>[])
  final List<String>? street;
  @JsonKey(name: 'city')
  final String? city;
  @JsonKey(name: 'postal_code')
  final String? postalCode;
  @JsonKey(name: 'country')
  final String? country;
  static const fromJsonFactory = _$PaymentInitiationAddressFromJson;
  static const toJsonFactory = _$PaymentInitiationAddressToJson;
  Map<String, dynamic> toJson() => _$PaymentInitiationAddressToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentInitiationAddress &&
            (identical(other.street, street) ||
                const DeepCollectionEquality().equals(other.street, street)) &&
            (identical(other.city, city) ||
                const DeepCollectionEquality().equals(other.city, city)) &&
            (identical(other.postalCode, postalCode) ||
                const DeepCollectionEquality()
                    .equals(other.postalCode, postalCode)) &&
            (identical(other.country, country) ||
                const DeepCollectionEquality().equals(other.country, country)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(street) ^
      const DeepCollectionEquality().hash(city) ^
      const DeepCollectionEquality().hash(postalCode) ^
      const DeepCollectionEquality().hash(country) ^
      runtimeType.hashCode;
}

extension $PaymentInitiationAddressExtension on PaymentInitiationAddress {
  PaymentInitiationAddress copyWith(
      {List<String>? street,
      String? city,
      String? postalCode,
      String? country}) {
    return PaymentInitiationAddress(
        street: street ?? this.street,
        city: city ?? this.city,
        postalCode: postalCode ?? this.postalCode,
        country: country ?? this.country);
  }
}

@JsonSerializable(explicitToJson: true)
class ExternalPaymentScheduleBase {
  ExternalPaymentScheduleBase({
    this.interval,
    this.intervalExecutionDay,
    this.startDate,
    this.endDate,
    this.adjustedStartDate,
  });

  factory ExternalPaymentScheduleBase.fromJson(Map<String, dynamic> json) =>
      _$ExternalPaymentScheduleBaseFromJson(json);

  @JsonKey(
      name: 'interval',
      toJson: paymentScheduleIntervalToJson,
      fromJson: paymentScheduleIntervalFromJson)
  final enums.PaymentScheduleInterval? interval;
  @JsonKey(name: 'interval_execution_day')
  final int? intervalExecutionDay;
  @JsonKey(name: 'start_date', toJson: _dateToJson)
  final DateTime? startDate;
  @JsonKey(name: 'end_date', toJson: _dateToJson)
  final DateTime? endDate;
  @JsonKey(name: 'adjusted_start_date', toJson: _dateToJson)
  final DateTime? adjustedStartDate;
  static const fromJsonFactory = _$ExternalPaymentScheduleBaseFromJson;
  static const toJsonFactory = _$ExternalPaymentScheduleBaseToJson;
  Map<String, dynamic> toJson() => _$ExternalPaymentScheduleBaseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ExternalPaymentScheduleBase &&
            (identical(other.interval, interval) ||
                const DeepCollectionEquality()
                    .equals(other.interval, interval)) &&
            (identical(other.intervalExecutionDay, intervalExecutionDay) ||
                const DeepCollectionEquality().equals(
                    other.intervalExecutionDay, intervalExecutionDay)) &&
            (identical(other.startDate, startDate) ||
                const DeepCollectionEquality()
                    .equals(other.startDate, startDate)) &&
            (identical(other.endDate, endDate) ||
                const DeepCollectionEquality()
                    .equals(other.endDate, endDate)) &&
            (identical(other.adjustedStartDate, adjustedStartDate) ||
                const DeepCollectionEquality()
                    .equals(other.adjustedStartDate, adjustedStartDate)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(interval) ^
      const DeepCollectionEquality().hash(intervalExecutionDay) ^
      const DeepCollectionEquality().hash(startDate) ^
      const DeepCollectionEquality().hash(endDate) ^
      const DeepCollectionEquality().hash(adjustedStartDate) ^
      runtimeType.hashCode;
}

extension $ExternalPaymentScheduleBaseExtension on ExternalPaymentScheduleBase {
  ExternalPaymentScheduleBase copyWith(
      {enums.PaymentScheduleInterval? interval,
      int? intervalExecutionDay,
      DateTime? startDate,
      DateTime? endDate,
      DateTime? adjustedStartDate}) {
    return ExternalPaymentScheduleBase(
        interval: interval ?? this.interval,
        intervalExecutionDay: intervalExecutionDay ?? this.intervalExecutionDay,
        startDate: startDate ?? this.startDate,
        endDate: endDate ?? this.endDate,
        adjustedStartDate: adjustedStartDate ?? this.adjustedStartDate);
  }
}

@JsonSerializable(explicitToJson: true)
class ExternalPaymentScheduleRequest {
  ExternalPaymentScheduleRequest();

  factory ExternalPaymentScheduleRequest.fromJson(Map<String, dynamic> json) =>
      _$ExternalPaymentScheduleRequestFromJson(json);

  static const fromJsonFactory = _$ExternalPaymentScheduleRequestFromJson;
  static const toJsonFactory = _$ExternalPaymentScheduleRequestToJson;
  Map<String, dynamic> toJson() => _$ExternalPaymentScheduleRequestToJson(this);

  @override
  int get hashCode => runtimeType.hashCode;
}

@JsonSerializable(explicitToJson: true)
class ExternalPaymentOptions {
  ExternalPaymentOptions({
    this.requestRefundDetails,
    this.iban,
    this.bacs,
    this.walletId,
  });

  factory ExternalPaymentOptions.fromJson(Map<String, dynamic> json) =>
      _$ExternalPaymentOptionsFromJson(json);

  @JsonKey(name: 'request_refund_details')
  final bool? requestRefundDetails;
  @JsonKey(name: 'iban')
  final String? iban;
  @JsonKey(name: 'bacs')
  final PaymentInitiationOptionalRestrictionBacs? bacs;
  @JsonKey(name: 'wallet_id')
  final String? walletId;
  static const fromJsonFactory = _$ExternalPaymentOptionsFromJson;
  static const toJsonFactory = _$ExternalPaymentOptionsToJson;
  Map<String, dynamic> toJson() => _$ExternalPaymentOptionsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ExternalPaymentOptions &&
            (identical(other.requestRefundDetails, requestRefundDetails) ||
                const DeepCollectionEquality().equals(
                    other.requestRefundDetails, requestRefundDetails)) &&
            (identical(other.iban, iban) ||
                const DeepCollectionEquality().equals(other.iban, iban)) &&
            (identical(other.bacs, bacs) ||
                const DeepCollectionEquality().equals(other.bacs, bacs)) &&
            (identical(other.walletId, walletId) ||
                const DeepCollectionEquality()
                    .equals(other.walletId, walletId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(requestRefundDetails) ^
      const DeepCollectionEquality().hash(iban) ^
      const DeepCollectionEquality().hash(bacs) ^
      const DeepCollectionEquality().hash(walletId) ^
      runtimeType.hashCode;
}

extension $ExternalPaymentOptionsExtension on ExternalPaymentOptions {
  ExternalPaymentOptions copyWith(
      {bool? requestRefundDetails,
      String? iban,
      PaymentInitiationOptionalRestrictionBacs? bacs,
      String? walletId}) {
    return ExternalPaymentOptions(
        requestRefundDetails: requestRefundDetails ?? this.requestRefundDetails,
        iban: iban ?? this.iban,
        bacs: bacs ?? this.bacs,
        walletId: walletId ?? this.walletId);
  }
}

@JsonSerializable(explicitToJson: true)
class ExternalPaymentRefundDetails {
  ExternalPaymentRefundDetails({
    this.name,
    this.iban,
    this.bacs,
  });

  factory ExternalPaymentRefundDetails.fromJson(Map<String, dynamic> json) =>
      _$ExternalPaymentRefundDetailsFromJson(json);

  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'iban')
  final String? iban;
  @JsonKey(name: 'bacs')
  final RecipientBACSNullable? bacs;
  static const fromJsonFactory = _$ExternalPaymentRefundDetailsFromJson;
  static const toJsonFactory = _$ExternalPaymentRefundDetailsToJson;
  Map<String, dynamic> toJson() => _$ExternalPaymentRefundDetailsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ExternalPaymentRefundDetails &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.iban, iban) ||
                const DeepCollectionEquality().equals(other.iban, iban)) &&
            (identical(other.bacs, bacs) ||
                const DeepCollectionEquality().equals(other.bacs, bacs)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(iban) ^
      const DeepCollectionEquality().hash(bacs) ^
      runtimeType.hashCode;
}

extension $ExternalPaymentRefundDetailsExtension
    on ExternalPaymentRefundDetails {
  ExternalPaymentRefundDetails copyWith(
      {String? name, String? iban, RecipientBACSNullable? bacs}) {
    return ExternalPaymentRefundDetails(
        name: name ?? this.name,
        iban: iban ?? this.iban,
        bacs: bacs ?? this.bacs);
  }
}

@JsonSerializable(explicitToJson: true)
class ExternalPaymentScheduleGet {
  ExternalPaymentScheduleGet();

  factory ExternalPaymentScheduleGet.fromJson(Map<String, dynamic> json) =>
      _$ExternalPaymentScheduleGetFromJson(json);

  static const fromJsonFactory = _$ExternalPaymentScheduleGetFromJson;
  static const toJsonFactory = _$ExternalPaymentScheduleGetToJson;
  Map<String, dynamic> toJson() => _$ExternalPaymentScheduleGetToJson(this);

  @override
  int get hashCode => runtimeType.hashCode;
}

@JsonSerializable(explicitToJson: true)
class ProductStatus {
  ProductStatus({
    this.status,
    this.lastStatusChange,
    this.breakdown,
  });

  factory ProductStatus.fromJson(Map<String, dynamic> json) =>
      _$ProductStatusFromJson(json);

  @JsonKey(
      name: 'status',
      toJson: productStatusStatusToJson,
      fromJson: productStatusStatusFromJson)
  final enums.ProductStatusStatus? status;
  @JsonKey(name: 'last_status_change')
  final DateTime? lastStatusChange;
  @JsonKey(name: 'breakdown')
  final ProductStatusBreakdown? breakdown;
  static const fromJsonFactory = _$ProductStatusFromJson;
  static const toJsonFactory = _$ProductStatusToJson;
  Map<String, dynamic> toJson() => _$ProductStatusToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ProductStatus &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.lastStatusChange, lastStatusChange) ||
                const DeepCollectionEquality()
                    .equals(other.lastStatusChange, lastStatusChange)) &&
            (identical(other.breakdown, breakdown) ||
                const DeepCollectionEquality()
                    .equals(other.breakdown, breakdown)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(lastStatusChange) ^
      const DeepCollectionEquality().hash(breakdown) ^
      runtimeType.hashCode;
}

extension $ProductStatusExtension on ProductStatus {
  ProductStatus copyWith(
      {enums.ProductStatusStatus? status,
      DateTime? lastStatusChange,
      ProductStatusBreakdown? breakdown}) {
    return ProductStatus(
        status: status ?? this.status,
        lastStatusChange: lastStatusChange ?? this.lastStatusChange,
        breakdown: breakdown ?? this.breakdown);
  }
}

@JsonSerializable(explicitToJson: true)
class ProductStatusBreakdown {
  ProductStatusBreakdown({
    this.success,
    this.errorPlaid,
    this.errorInstitution,
    this.refreshInterval,
  });

  factory ProductStatusBreakdown.fromJson(Map<String, dynamic> json) =>
      _$ProductStatusBreakdownFromJson(json);

  @JsonKey(name: 'success')
  final double? success;
  @JsonKey(name: 'error_plaid')
  final double? errorPlaid;
  @JsonKey(name: 'error_institution')
  final double? errorInstitution;
  @JsonKey(
      name: 'refresh_interval',
      toJson: productStatusBreakdownRefreshIntervalToJson,
      fromJson: productStatusBreakdownRefreshIntervalFromJson)
  final enums.ProductStatusBreakdownRefreshInterval? refreshInterval;
  static const fromJsonFactory = _$ProductStatusBreakdownFromJson;
  static const toJsonFactory = _$ProductStatusBreakdownToJson;
  Map<String, dynamic> toJson() => _$ProductStatusBreakdownToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ProductStatusBreakdown &&
            (identical(other.success, success) ||
                const DeepCollectionEquality()
                    .equals(other.success, success)) &&
            (identical(other.errorPlaid, errorPlaid) ||
                const DeepCollectionEquality()
                    .equals(other.errorPlaid, errorPlaid)) &&
            (identical(other.errorInstitution, errorInstitution) ||
                const DeepCollectionEquality()
                    .equals(other.errorInstitution, errorInstitution)) &&
            (identical(other.refreshInterval, refreshInterval) ||
                const DeepCollectionEquality()
                    .equals(other.refreshInterval, refreshInterval)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(success) ^
      const DeepCollectionEquality().hash(errorPlaid) ^
      const DeepCollectionEquality().hash(errorInstitution) ^
      const DeepCollectionEquality().hash(refreshInterval) ^
      runtimeType.hashCode;
}

extension $ProductStatusBreakdownExtension on ProductStatusBreakdown {
  ProductStatusBreakdown copyWith(
      {double? success,
      double? errorPlaid,
      double? errorInstitution,
      enums.ProductStatusBreakdownRefreshInterval? refreshInterval}) {
    return ProductStatusBreakdown(
        success: success ?? this.success,
        errorPlaid: errorPlaid ?? this.errorPlaid,
        errorInstitution: errorInstitution ?? this.errorInstitution,
        refreshInterval: refreshInterval ?? this.refreshInterval);
  }
}

@JsonSerializable(explicitToJson: true)
class UserCustomPassword {
  UserCustomPassword({
    this.version,
    this.seed,
    this.overrideAccounts,
    this.mfa,
    this.recaptcha,
    this.forceError,
  });

  factory UserCustomPassword.fromJson(Map<String, dynamic> json) =>
      _$UserCustomPasswordFromJson(json);

  @JsonKey(name: 'version')
  final String? version;
  @JsonKey(name: 'seed')
  final String? seed;
  @JsonKey(name: 'override_accounts', defaultValue: <OverrideAccounts>[])
  final List<OverrideAccounts>? overrideAccounts;
  @JsonKey(name: 'mfa')
  final Mfa? mfa;
  @JsonKey(name: 'recaptcha')
  final String? recaptcha;
  @JsonKey(name: 'force_error')
  final String? forceError;
  static const fromJsonFactory = _$UserCustomPasswordFromJson;
  static const toJsonFactory = _$UserCustomPasswordToJson;
  Map<String, dynamic> toJson() => _$UserCustomPasswordToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is UserCustomPassword &&
            (identical(other.version, version) ||
                const DeepCollectionEquality()
                    .equals(other.version, version)) &&
            (identical(other.seed, seed) ||
                const DeepCollectionEquality().equals(other.seed, seed)) &&
            (identical(other.overrideAccounts, overrideAccounts) ||
                const DeepCollectionEquality()
                    .equals(other.overrideAccounts, overrideAccounts)) &&
            (identical(other.mfa, mfa) ||
                const DeepCollectionEquality().equals(other.mfa, mfa)) &&
            (identical(other.recaptcha, recaptcha) ||
                const DeepCollectionEquality()
                    .equals(other.recaptcha, recaptcha)) &&
            (identical(other.forceError, forceError) ||
                const DeepCollectionEquality()
                    .equals(other.forceError, forceError)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(version) ^
      const DeepCollectionEquality().hash(seed) ^
      const DeepCollectionEquality().hash(overrideAccounts) ^
      const DeepCollectionEquality().hash(mfa) ^
      const DeepCollectionEquality().hash(recaptcha) ^
      const DeepCollectionEquality().hash(forceError) ^
      runtimeType.hashCode;
}

extension $UserCustomPasswordExtension on UserCustomPassword {
  UserCustomPassword copyWith(
      {String? version,
      String? seed,
      List<OverrideAccounts>? overrideAccounts,
      Mfa? mfa,
      String? recaptcha,
      String? forceError}) {
    return UserCustomPassword(
        version: version ?? this.version,
        seed: seed ?? this.seed,
        overrideAccounts: overrideAccounts ?? this.overrideAccounts,
        mfa: mfa ?? this.mfa,
        recaptcha: recaptcha ?? this.recaptcha,
        forceError: forceError ?? this.forceError);
  }
}

@JsonSerializable(explicitToJson: true)
class Mfa {
  Mfa({
    this.type,
    this.questionRounds,
    this.questionsPerRound,
    this.selectionRounds,
    this.selectionsPerQuestion,
  });

  factory Mfa.fromJson(Map<String, dynamic> json) => _$MfaFromJson(json);

  @JsonKey(name: 'type')
  final String? type;
  @JsonKey(name: 'question_rounds')
  final double? questionRounds;
  @JsonKey(name: 'questions_per_round')
  final double? questionsPerRound;
  @JsonKey(name: 'selection_rounds')
  final double? selectionRounds;
  @JsonKey(name: 'selections_per_question')
  final double? selectionsPerQuestion;
  static const fromJsonFactory = _$MfaFromJson;
  static const toJsonFactory = _$MfaToJson;
  Map<String, dynamic> toJson() => _$MfaToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Mfa &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.questionRounds, questionRounds) ||
                const DeepCollectionEquality()
                    .equals(other.questionRounds, questionRounds)) &&
            (identical(other.questionsPerRound, questionsPerRound) ||
                const DeepCollectionEquality()
                    .equals(other.questionsPerRound, questionsPerRound)) &&
            (identical(other.selectionRounds, selectionRounds) ||
                const DeepCollectionEquality()
                    .equals(other.selectionRounds, selectionRounds)) &&
            (identical(other.selectionsPerQuestion, selectionsPerQuestion) ||
                const DeepCollectionEquality().equals(
                    other.selectionsPerQuestion, selectionsPerQuestion)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(questionRounds) ^
      const DeepCollectionEquality().hash(questionsPerRound) ^
      const DeepCollectionEquality().hash(selectionRounds) ^
      const DeepCollectionEquality().hash(selectionsPerQuestion) ^
      runtimeType.hashCode;
}

extension $MfaExtension on Mfa {
  Mfa copyWith(
      {String? type,
      double? questionRounds,
      double? questionsPerRound,
      double? selectionRounds,
      double? selectionsPerQuestion}) {
    return Mfa(
        type: type ?? this.type,
        questionRounds: questionRounds ?? this.questionRounds,
        questionsPerRound: questionsPerRound ?? this.questionsPerRound,
        selectionRounds: selectionRounds ?? this.selectionRounds,
        selectionsPerQuestion:
            selectionsPerQuestion ?? this.selectionsPerQuestion);
  }
}

@JsonSerializable(explicitToJson: true)
class OverrideAccounts {
  OverrideAccounts({
    this.type,
    this.subtype,
    this.startingBalance,
    this.forceAvailableBalance,
    this.currency,
    this.meta,
    this.numbers,
    this.transactions,
    this.holdings,
    this.investmentTransactions,
    this.identity,
    this.liability,
    this.inflowModel,
    this.income,
  });

  factory OverrideAccounts.fromJson(Map<String, dynamic> json) =>
      _$OverrideAccountsFromJson(json);

  @JsonKey(
      name: 'type',
      toJson: overrideAccountTypeToJson,
      fromJson: overrideAccountTypeFromJson)
  final enums.OverrideAccountType? type;
  @JsonKey(
      name: 'subtype',
      toJson: accountSubtypeToJson,
      fromJson: accountSubtypeFromJson)
  final enums.AccountSubtype? subtype;
  @JsonKey(name: 'starting_balance')
  final double? startingBalance;
  @JsonKey(name: 'force_available_balance')
  final double? forceAvailableBalance;
  @JsonKey(name: 'currency')
  final String? currency;
  @JsonKey(name: 'meta')
  final Meta? meta;
  @JsonKey(name: 'numbers')
  final Numbers? numbers;
  @JsonKey(name: 'transactions', defaultValue: <TransactionOverride>[])
  final List<TransactionOverride>? transactions;
  @JsonKey(name: 'holdings')
  final HoldingsOverride? holdings;
  @JsonKey(name: 'investment_transactions')
  final InvestmentsTransactionsOverride? investmentTransactions;
  @JsonKey(name: 'identity')
  final OwnerOverride? identity;
  @JsonKey(name: 'liability')
  final LiabilityOverride? liability;
  @JsonKey(name: 'inflow_model')
  final InflowModel? inflowModel;
  @JsonKey(name: 'income')
  final IncomeOverride? income;
  static const fromJsonFactory = _$OverrideAccountsFromJson;
  static const toJsonFactory = _$OverrideAccountsToJson;
  Map<String, dynamic> toJson() => _$OverrideAccountsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is OverrideAccounts &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.subtype, subtype) ||
                const DeepCollectionEquality()
                    .equals(other.subtype, subtype)) &&
            (identical(other.startingBalance, startingBalance) ||
                const DeepCollectionEquality()
                    .equals(other.startingBalance, startingBalance)) &&
            (identical(other.forceAvailableBalance, forceAvailableBalance) ||
                const DeepCollectionEquality().equals(
                    other.forceAvailableBalance, forceAvailableBalance)) &&
            (identical(other.currency, currency) ||
                const DeepCollectionEquality()
                    .equals(other.currency, currency)) &&
            (identical(other.meta, meta) ||
                const DeepCollectionEquality().equals(other.meta, meta)) &&
            (identical(other.numbers, numbers) ||
                const DeepCollectionEquality()
                    .equals(other.numbers, numbers)) &&
            (identical(other.transactions, transactions) ||
                const DeepCollectionEquality()
                    .equals(other.transactions, transactions)) &&
            (identical(other.holdings, holdings) ||
                const DeepCollectionEquality()
                    .equals(other.holdings, holdings)) &&
            (identical(other.investmentTransactions, investmentTransactions) ||
                const DeepCollectionEquality().equals(
                    other.investmentTransactions, investmentTransactions)) &&
            (identical(other.identity, identity) ||
                const DeepCollectionEquality()
                    .equals(other.identity, identity)) &&
            (identical(other.liability, liability) ||
                const DeepCollectionEquality()
                    .equals(other.liability, liability)) &&
            (identical(other.inflowModel, inflowModel) ||
                const DeepCollectionEquality()
                    .equals(other.inflowModel, inflowModel)) &&
            (identical(other.income, income) ||
                const DeepCollectionEquality().equals(other.income, income)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(subtype) ^
      const DeepCollectionEquality().hash(startingBalance) ^
      const DeepCollectionEquality().hash(forceAvailableBalance) ^
      const DeepCollectionEquality().hash(currency) ^
      const DeepCollectionEquality().hash(meta) ^
      const DeepCollectionEquality().hash(numbers) ^
      const DeepCollectionEquality().hash(transactions) ^
      const DeepCollectionEquality().hash(holdings) ^
      const DeepCollectionEquality().hash(investmentTransactions) ^
      const DeepCollectionEquality().hash(identity) ^
      const DeepCollectionEquality().hash(liability) ^
      const DeepCollectionEquality().hash(inflowModel) ^
      const DeepCollectionEquality().hash(income) ^
      runtimeType.hashCode;
}

extension $OverrideAccountsExtension on OverrideAccounts {
  OverrideAccounts copyWith(
      {enums.OverrideAccountType? type,
      enums.AccountSubtype? subtype,
      double? startingBalance,
      double? forceAvailableBalance,
      String? currency,
      Meta? meta,
      Numbers? numbers,
      List<TransactionOverride>? transactions,
      HoldingsOverride? holdings,
      InvestmentsTransactionsOverride? investmentTransactions,
      OwnerOverride? identity,
      LiabilityOverride? liability,
      InflowModel? inflowModel,
      IncomeOverride? income}) {
    return OverrideAccounts(
        type: type ?? this.type,
        subtype: subtype ?? this.subtype,
        startingBalance: startingBalance ?? this.startingBalance,
        forceAvailableBalance:
            forceAvailableBalance ?? this.forceAvailableBalance,
        currency: currency ?? this.currency,
        meta: meta ?? this.meta,
        numbers: numbers ?? this.numbers,
        transactions: transactions ?? this.transactions,
        holdings: holdings ?? this.holdings,
        investmentTransactions:
            investmentTransactions ?? this.investmentTransactions,
        identity: identity ?? this.identity,
        liability: liability ?? this.liability,
        inflowModel: inflowModel ?? this.inflowModel,
        income: income ?? this.income);
  }
}

@JsonSerializable(explicitToJson: true)
class Meta {
  Meta({
    this.name,
    this.officialName,
    this.limit,
  });

  factory Meta.fromJson(Map<String, dynamic> json) => _$MetaFromJson(json);

  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'official_name')
  final String? officialName;
  @JsonKey(name: 'limit')
  final double? limit;
  static const fromJsonFactory = _$MetaFromJson;
  static const toJsonFactory = _$MetaToJson;
  Map<String, dynamic> toJson() => _$MetaToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Meta &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.officialName, officialName) ||
                const DeepCollectionEquality()
                    .equals(other.officialName, officialName)) &&
            (identical(other.limit, limit) ||
                const DeepCollectionEquality().equals(other.limit, limit)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(officialName) ^
      const DeepCollectionEquality().hash(limit) ^
      runtimeType.hashCode;
}

extension $MetaExtension on Meta {
  Meta copyWith({String? name, String? officialName, double? limit}) {
    return Meta(
        name: name ?? this.name,
        officialName: officialName ?? this.officialName,
        limit: limit ?? this.limit);
  }
}

@JsonSerializable(explicitToJson: true)
class Numbers {
  Numbers({
    this.account,
    this.achRouting,
    this.achWireRouting,
    this.eftInstitution,
    this.eftBranch,
    this.internationalBic,
    this.internationalIban,
    this.bacsSortCode,
  });

  factory Numbers.fromJson(Map<String, dynamic> json) =>
      _$NumbersFromJson(json);

  @JsonKey(name: 'account')
  final String? account;
  @JsonKey(name: 'ach_routing')
  final String? achRouting;
  @JsonKey(name: 'ach_wire_routing')
  final String? achWireRouting;
  @JsonKey(name: 'eft_institution')
  final String? eftInstitution;
  @JsonKey(name: 'eft_branch')
  final String? eftBranch;
  @JsonKey(name: 'international_bic')
  final String? internationalBic;
  @JsonKey(name: 'international_iban')
  final String? internationalIban;
  @JsonKey(name: 'bacs_sort_code')
  final String? bacsSortCode;
  static const fromJsonFactory = _$NumbersFromJson;
  static const toJsonFactory = _$NumbersToJson;
  Map<String, dynamic> toJson() => _$NumbersToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Numbers &&
            (identical(other.account, account) ||
                const DeepCollectionEquality()
                    .equals(other.account, account)) &&
            (identical(other.achRouting, achRouting) ||
                const DeepCollectionEquality()
                    .equals(other.achRouting, achRouting)) &&
            (identical(other.achWireRouting, achWireRouting) ||
                const DeepCollectionEquality()
                    .equals(other.achWireRouting, achWireRouting)) &&
            (identical(other.eftInstitution, eftInstitution) ||
                const DeepCollectionEquality()
                    .equals(other.eftInstitution, eftInstitution)) &&
            (identical(other.eftBranch, eftBranch) ||
                const DeepCollectionEquality()
                    .equals(other.eftBranch, eftBranch)) &&
            (identical(other.internationalBic, internationalBic) ||
                const DeepCollectionEquality()
                    .equals(other.internationalBic, internationalBic)) &&
            (identical(other.internationalIban, internationalIban) ||
                const DeepCollectionEquality()
                    .equals(other.internationalIban, internationalIban)) &&
            (identical(other.bacsSortCode, bacsSortCode) ||
                const DeepCollectionEquality()
                    .equals(other.bacsSortCode, bacsSortCode)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(account) ^
      const DeepCollectionEquality().hash(achRouting) ^
      const DeepCollectionEquality().hash(achWireRouting) ^
      const DeepCollectionEquality().hash(eftInstitution) ^
      const DeepCollectionEquality().hash(eftBranch) ^
      const DeepCollectionEquality().hash(internationalBic) ^
      const DeepCollectionEquality().hash(internationalIban) ^
      const DeepCollectionEquality().hash(bacsSortCode) ^
      runtimeType.hashCode;
}

extension $NumbersExtension on Numbers {
  Numbers copyWith(
      {String? account,
      String? achRouting,
      String? achWireRouting,
      String? eftInstitution,
      String? eftBranch,
      String? internationalBic,
      String? internationalIban,
      String? bacsSortCode}) {
    return Numbers(
        account: account ?? this.account,
        achRouting: achRouting ?? this.achRouting,
        achWireRouting: achWireRouting ?? this.achWireRouting,
        eftInstitution: eftInstitution ?? this.eftInstitution,
        eftBranch: eftBranch ?? this.eftBranch,
        internationalBic: internationalBic ?? this.internationalBic,
        internationalIban: internationalIban ?? this.internationalIban,
        bacsSortCode: bacsSortCode ?? this.bacsSortCode);
  }
}

@JsonSerializable(explicitToJson: true)
class TransactionOverride {
  TransactionOverride({
    this.dateTransacted,
    this.datePosted,
    this.amount,
    this.description,
    this.currency,
  });

  factory TransactionOverride.fromJson(Map<String, dynamic> json) =>
      _$TransactionOverrideFromJson(json);

  @JsonKey(name: 'date_transacted', toJson: _dateToJson)
  final DateTime? dateTransacted;
  @JsonKey(name: 'date_posted', toJson: _dateToJson)
  final DateTime? datePosted;
  @JsonKey(name: 'amount')
  final double? amount;
  @JsonKey(name: 'description')
  final String? description;
  @JsonKey(name: 'currency')
  final String? currency;
  static const fromJsonFactory = _$TransactionOverrideFromJson;
  static const toJsonFactory = _$TransactionOverrideToJson;
  Map<String, dynamic> toJson() => _$TransactionOverrideToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransactionOverride &&
            (identical(other.dateTransacted, dateTransacted) ||
                const DeepCollectionEquality()
                    .equals(other.dateTransacted, dateTransacted)) &&
            (identical(other.datePosted, datePosted) ||
                const DeepCollectionEquality()
                    .equals(other.datePosted, datePosted)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.currency, currency) ||
                const DeepCollectionEquality()
                    .equals(other.currency, currency)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(dateTransacted) ^
      const DeepCollectionEquality().hash(datePosted) ^
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(currency) ^
      runtimeType.hashCode;
}

extension $TransactionOverrideExtension on TransactionOverride {
  TransactionOverride copyWith(
      {DateTime? dateTransacted,
      DateTime? datePosted,
      double? amount,
      String? description,
      String? currency}) {
    return TransactionOverride(
        dateTransacted: dateTransacted ?? this.dateTransacted,
        datePosted: datePosted ?? this.datePosted,
        amount: amount ?? this.amount,
        description: description ?? this.description,
        currency: currency ?? this.currency);
  }
}

@JsonSerializable(explicitToJson: true)
class SecurityOverride {
  SecurityOverride({
    this.isin,
    this.cusip,
    this.sedol,
    this.name,
    this.tickerSymbol,
    this.currency,
  });

  factory SecurityOverride.fromJson(Map<String, dynamic> json) =>
      _$SecurityOverrideFromJson(json);

  @JsonKey(name: 'isin')
  final String? isin;
  @JsonKey(name: 'cusip')
  final String? cusip;
  @JsonKey(name: 'sedol')
  final String? sedol;
  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'ticker_symbol')
  final String? tickerSymbol;
  @JsonKey(name: 'currency')
  final String? currency;
  static const fromJsonFactory = _$SecurityOverrideFromJson;
  static const toJsonFactory = _$SecurityOverrideToJson;
  Map<String, dynamic> toJson() => _$SecurityOverrideToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SecurityOverride &&
            (identical(other.isin, isin) ||
                const DeepCollectionEquality().equals(other.isin, isin)) &&
            (identical(other.cusip, cusip) ||
                const DeepCollectionEquality().equals(other.cusip, cusip)) &&
            (identical(other.sedol, sedol) ||
                const DeepCollectionEquality().equals(other.sedol, sedol)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.tickerSymbol, tickerSymbol) ||
                const DeepCollectionEquality()
                    .equals(other.tickerSymbol, tickerSymbol)) &&
            (identical(other.currency, currency) ||
                const DeepCollectionEquality()
                    .equals(other.currency, currency)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(isin) ^
      const DeepCollectionEquality().hash(cusip) ^
      const DeepCollectionEquality().hash(sedol) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(tickerSymbol) ^
      const DeepCollectionEquality().hash(currency) ^
      runtimeType.hashCode;
}

extension $SecurityOverrideExtension on SecurityOverride {
  SecurityOverride copyWith(
      {String? isin,
      String? cusip,
      String? sedol,
      String? name,
      String? tickerSymbol,
      String? currency}) {
    return SecurityOverride(
        isin: isin ?? this.isin,
        cusip: cusip ?? this.cusip,
        sedol: sedol ?? this.sedol,
        name: name ?? this.name,
        tickerSymbol: tickerSymbol ?? this.tickerSymbol,
        currency: currency ?? this.currency);
  }
}

@JsonSerializable(explicitToJson: true)
class HoldingsOverride {
  HoldingsOverride({
    this.institutionPrice,
    this.institutionPriceAsOf,
    this.costBasis,
    this.quantity,
    this.currency,
    this.security,
  });

  factory HoldingsOverride.fromJson(Map<String, dynamic> json) =>
      _$HoldingsOverrideFromJson(json);

  @JsonKey(name: 'institution_price')
  final double? institutionPrice;
  @JsonKey(name: 'institution_price_as_of', toJson: _dateToJson)
  final DateTime? institutionPriceAsOf;
  @JsonKey(name: 'cost_basis')
  final double? costBasis;
  @JsonKey(name: 'quantity')
  final double? quantity;
  @JsonKey(name: 'currency')
  final String? currency;
  @JsonKey(name: 'security')
  final SecurityOverride? security;
  static const fromJsonFactory = _$HoldingsOverrideFromJson;
  static const toJsonFactory = _$HoldingsOverrideToJson;
  Map<String, dynamic> toJson() => _$HoldingsOverrideToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is HoldingsOverride &&
            (identical(other.institutionPrice, institutionPrice) ||
                const DeepCollectionEquality()
                    .equals(other.institutionPrice, institutionPrice)) &&
            (identical(other.institutionPriceAsOf, institutionPriceAsOf) ||
                const DeepCollectionEquality().equals(
                    other.institutionPriceAsOf, institutionPriceAsOf)) &&
            (identical(other.costBasis, costBasis) ||
                const DeepCollectionEquality()
                    .equals(other.costBasis, costBasis)) &&
            (identical(other.quantity, quantity) ||
                const DeepCollectionEquality()
                    .equals(other.quantity, quantity)) &&
            (identical(other.currency, currency) ||
                const DeepCollectionEquality()
                    .equals(other.currency, currency)) &&
            (identical(other.security, security) ||
                const DeepCollectionEquality()
                    .equals(other.security, security)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(institutionPrice) ^
      const DeepCollectionEquality().hash(institutionPriceAsOf) ^
      const DeepCollectionEquality().hash(costBasis) ^
      const DeepCollectionEquality().hash(quantity) ^
      const DeepCollectionEquality().hash(currency) ^
      const DeepCollectionEquality().hash(security) ^
      runtimeType.hashCode;
}

extension $HoldingsOverrideExtension on HoldingsOverride {
  HoldingsOverride copyWith(
      {double? institutionPrice,
      DateTime? institutionPriceAsOf,
      double? costBasis,
      double? quantity,
      String? currency,
      SecurityOverride? security}) {
    return HoldingsOverride(
        institutionPrice: institutionPrice ?? this.institutionPrice,
        institutionPriceAsOf: institutionPriceAsOf ?? this.institutionPriceAsOf,
        costBasis: costBasis ?? this.costBasis,
        quantity: quantity ?? this.quantity,
        currency: currency ?? this.currency,
        security: security ?? this.security);
  }
}

@JsonSerializable(explicitToJson: true)
class InvestmentsTransactionsOverride {
  InvestmentsTransactionsOverride({
    this.date,
    this.name,
    this.quantity,
    this.price,
    this.fees,
    this.type,
    this.currency,
    this.security,
  });

  factory InvestmentsTransactionsOverride.fromJson(Map<String, dynamic> json) =>
      _$InvestmentsTransactionsOverrideFromJson(json);

  @JsonKey(name: 'date', toJson: _dateToJson)
  final DateTime? date;
  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'quantity')
  final double? quantity;
  @JsonKey(name: 'price')
  final double? price;
  @JsonKey(name: 'fees')
  final double? fees;
  @JsonKey(name: 'type')
  final String? type;
  @JsonKey(name: 'currency')
  final String? currency;
  @JsonKey(name: 'security')
  final SecurityOverride? security;
  static const fromJsonFactory = _$InvestmentsTransactionsOverrideFromJson;
  static const toJsonFactory = _$InvestmentsTransactionsOverrideToJson;
  Map<String, dynamic> toJson() =>
      _$InvestmentsTransactionsOverrideToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvestmentsTransactionsOverride &&
            (identical(other.date, date) ||
                const DeepCollectionEquality().equals(other.date, date)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.quantity, quantity) ||
                const DeepCollectionEquality()
                    .equals(other.quantity, quantity)) &&
            (identical(other.price, price) ||
                const DeepCollectionEquality().equals(other.price, price)) &&
            (identical(other.fees, fees) ||
                const DeepCollectionEquality().equals(other.fees, fees)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.currency, currency) ||
                const DeepCollectionEquality()
                    .equals(other.currency, currency)) &&
            (identical(other.security, security) ||
                const DeepCollectionEquality()
                    .equals(other.security, security)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(date) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(quantity) ^
      const DeepCollectionEquality().hash(price) ^
      const DeepCollectionEquality().hash(fees) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(currency) ^
      const DeepCollectionEquality().hash(security) ^
      runtimeType.hashCode;
}

extension $InvestmentsTransactionsOverrideExtension
    on InvestmentsTransactionsOverride {
  InvestmentsTransactionsOverride copyWith(
      {DateTime? date,
      String? name,
      double? quantity,
      double? price,
      double? fees,
      String? type,
      String? currency,
      SecurityOverride? security}) {
    return InvestmentsTransactionsOverride(
        date: date ?? this.date,
        name: name ?? this.name,
        quantity: quantity ?? this.quantity,
        price: price ?? this.price,
        fees: fees ?? this.fees,
        type: type ?? this.type,
        currency: currency ?? this.currency,
        security: security ?? this.security);
  }
}

@JsonSerializable(explicitToJson: true)
class LiabilityOverride {
  LiabilityOverride({
    this.type,
    this.purchaseApr,
    this.cashApr,
    this.balanceTransferApr,
    this.specialApr,
    this.lastPaymentAmount,
    this.minimumPaymentAmount,
    this.isOverdue,
    this.originationDate,
    this.principal,
    this.nominalApr,
    this.interestCapitalizationGracePeriodMonths,
    this.repaymentModel,
    this.expectedPayoffDate,
    this.guarantor,
    this.isFederal,
    this.loanName,
    this.loanStatus,
    this.paymentReferenceNumber,
    this.pslfStatus,
    this.repaymentPlanDescription,
    this.repaymentPlanType,
    this.sequenceNumber,
    this.servicerAddress,
  });

  factory LiabilityOverride.fromJson(Map<String, dynamic> json) =>
      _$LiabilityOverrideFromJson(json);

  @JsonKey(name: 'type')
  final String? type;
  @JsonKey(name: 'purchase_apr')
  final double? purchaseApr;
  @JsonKey(name: 'cash_apr')
  final double? cashApr;
  @JsonKey(name: 'balance_transfer_apr')
  final double? balanceTransferApr;
  @JsonKey(name: 'special_apr')
  final double? specialApr;
  @JsonKey(name: 'last_payment_amount')
  final double? lastPaymentAmount;
  @JsonKey(name: 'minimum_payment_amount')
  final double? minimumPaymentAmount;
  @JsonKey(name: 'is_overdue')
  final bool? isOverdue;
  @JsonKey(name: 'origination_date', toJson: _dateToJson)
  final DateTime? originationDate;
  @JsonKey(name: 'principal')
  final double? principal;
  @JsonKey(name: 'nominal_apr')
  final double? nominalApr;
  @JsonKey(name: 'interest_capitalization_grace_period_months')
  final double? interestCapitalizationGracePeriodMonths;
  @JsonKey(name: 'repayment_model')
  final StudentLoanRepaymentModel? repaymentModel;
  @JsonKey(name: 'expected_payoff_date', toJson: _dateToJson)
  final DateTime? expectedPayoffDate;
  @JsonKey(name: 'guarantor')
  final String? guarantor;
  @JsonKey(name: 'is_federal')
  final bool? isFederal;
  @JsonKey(name: 'loan_name')
  final String? loanName;
  @JsonKey(name: 'loan_status')
  final StudentLoanStatus? loanStatus;
  @JsonKey(name: 'payment_reference_number')
  final String? paymentReferenceNumber;
  @JsonKey(name: 'pslf_status')
  final PSLFStatus? pslfStatus;
  @JsonKey(name: 'repayment_plan_description')
  final String? repaymentPlanDescription;
  @JsonKey(name: 'repayment_plan_type')
  final String? repaymentPlanType;
  @JsonKey(name: 'sequence_number')
  final String? sequenceNumber;
  @JsonKey(name: 'servicer_address')
  final Address? servicerAddress;
  static const fromJsonFactory = _$LiabilityOverrideFromJson;
  static const toJsonFactory = _$LiabilityOverrideToJson;
  Map<String, dynamic> toJson() => _$LiabilityOverrideToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LiabilityOverride &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.purchaseApr, purchaseApr) ||
                const DeepCollectionEquality()
                    .equals(other.purchaseApr, purchaseApr)) &&
            (identical(other.cashApr, cashApr) ||
                const DeepCollectionEquality()
                    .equals(other.cashApr, cashApr)) &&
            (identical(other.balanceTransferApr, balanceTransferApr) ||
                const DeepCollectionEquality()
                    .equals(other.balanceTransferApr, balanceTransferApr)) &&
            (identical(other.specialApr, specialApr) ||
                const DeepCollectionEquality()
                    .equals(other.specialApr, specialApr)) &&
            (identical(other.lastPaymentAmount, lastPaymentAmount) ||
                const DeepCollectionEquality()
                    .equals(other.lastPaymentAmount, lastPaymentAmount)) &&
            (identical(other.minimumPaymentAmount, minimumPaymentAmount) ||
                const DeepCollectionEquality().equals(
                    other.minimumPaymentAmount, minimumPaymentAmount)) &&
            (identical(other.isOverdue, isOverdue) ||
                const DeepCollectionEquality()
                    .equals(other.isOverdue, isOverdue)) &&
            (identical(other.originationDate, originationDate) ||
                const DeepCollectionEquality()
                    .equals(other.originationDate, originationDate)) &&
            (identical(other.principal, principal) ||
                const DeepCollectionEquality()
                    .equals(other.principal, principal)) &&
            (identical(other.nominalApr, nominalApr) ||
                const DeepCollectionEquality()
                    .equals(other.nominalApr, nominalApr)) &&
            (identical(other.interestCapitalizationGracePeriodMonths, interestCapitalizationGracePeriodMonths) ||
                const DeepCollectionEquality().equals(
                    other.interestCapitalizationGracePeriodMonths,
                    interestCapitalizationGracePeriodMonths)) &&
            (identical(other.repaymentModel, repaymentModel) ||
                const DeepCollectionEquality()
                    .equals(other.repaymentModel, repaymentModel)) &&
            (identical(other.expectedPayoffDate, expectedPayoffDate) ||
                const DeepCollectionEquality()
                    .equals(other.expectedPayoffDate, expectedPayoffDate)) &&
            (identical(other.guarantor, guarantor) ||
                const DeepCollectionEquality()
                    .equals(other.guarantor, guarantor)) &&
            (identical(other.isFederal, isFederal) ||
                const DeepCollectionEquality()
                    .equals(other.isFederal, isFederal)) &&
            (identical(other.loanName, loanName) ||
                const DeepCollectionEquality()
                    .equals(other.loanName, loanName)) &&
            (identical(other.loanStatus, loanStatus) ||
                const DeepCollectionEquality()
                    .equals(other.loanStatus, loanStatus)) &&
            (identical(other.paymentReferenceNumber, paymentReferenceNumber) ||
                const DeepCollectionEquality().equals(
                    other.paymentReferenceNumber, paymentReferenceNumber)) &&
            (identical(other.pslfStatus, pslfStatus) ||
                const DeepCollectionEquality().equals(other.pslfStatus, pslfStatus)) &&
            (identical(other.repaymentPlanDescription, repaymentPlanDescription) || const DeepCollectionEquality().equals(other.repaymentPlanDescription, repaymentPlanDescription)) &&
            (identical(other.repaymentPlanType, repaymentPlanType) || const DeepCollectionEquality().equals(other.repaymentPlanType, repaymentPlanType)) &&
            (identical(other.sequenceNumber, sequenceNumber) || const DeepCollectionEquality().equals(other.sequenceNumber, sequenceNumber)) &&
            (identical(other.servicerAddress, servicerAddress) || const DeepCollectionEquality().equals(other.servicerAddress, servicerAddress)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(purchaseApr) ^
      const DeepCollectionEquality().hash(cashApr) ^
      const DeepCollectionEquality().hash(balanceTransferApr) ^
      const DeepCollectionEquality().hash(specialApr) ^
      const DeepCollectionEquality().hash(lastPaymentAmount) ^
      const DeepCollectionEquality().hash(minimumPaymentAmount) ^
      const DeepCollectionEquality().hash(isOverdue) ^
      const DeepCollectionEquality().hash(originationDate) ^
      const DeepCollectionEquality().hash(principal) ^
      const DeepCollectionEquality().hash(nominalApr) ^
      const DeepCollectionEquality()
          .hash(interestCapitalizationGracePeriodMonths) ^
      const DeepCollectionEquality().hash(repaymentModel) ^
      const DeepCollectionEquality().hash(expectedPayoffDate) ^
      const DeepCollectionEquality().hash(guarantor) ^
      const DeepCollectionEquality().hash(isFederal) ^
      const DeepCollectionEquality().hash(loanName) ^
      const DeepCollectionEquality().hash(loanStatus) ^
      const DeepCollectionEquality().hash(paymentReferenceNumber) ^
      const DeepCollectionEquality().hash(pslfStatus) ^
      const DeepCollectionEquality().hash(repaymentPlanDescription) ^
      const DeepCollectionEquality().hash(repaymentPlanType) ^
      const DeepCollectionEquality().hash(sequenceNumber) ^
      const DeepCollectionEquality().hash(servicerAddress) ^
      runtimeType.hashCode;
}

extension $LiabilityOverrideExtension on LiabilityOverride {
  LiabilityOverride copyWith(
      {String? type,
      double? purchaseApr,
      double? cashApr,
      double? balanceTransferApr,
      double? specialApr,
      double? lastPaymentAmount,
      double? minimumPaymentAmount,
      bool? isOverdue,
      DateTime? originationDate,
      double? principal,
      double? nominalApr,
      double? interestCapitalizationGracePeriodMonths,
      StudentLoanRepaymentModel? repaymentModel,
      DateTime? expectedPayoffDate,
      String? guarantor,
      bool? isFederal,
      String? loanName,
      StudentLoanStatus? loanStatus,
      String? paymentReferenceNumber,
      PSLFStatus? pslfStatus,
      String? repaymentPlanDescription,
      String? repaymentPlanType,
      String? sequenceNumber,
      Address? servicerAddress}) {
    return LiabilityOverride(
        type: type ?? this.type,
        purchaseApr: purchaseApr ?? this.purchaseApr,
        cashApr: cashApr ?? this.cashApr,
        balanceTransferApr: balanceTransferApr ?? this.balanceTransferApr,
        specialApr: specialApr ?? this.specialApr,
        lastPaymentAmount: lastPaymentAmount ?? this.lastPaymentAmount,
        minimumPaymentAmount: minimumPaymentAmount ?? this.minimumPaymentAmount,
        isOverdue: isOverdue ?? this.isOverdue,
        originationDate: originationDate ?? this.originationDate,
        principal: principal ?? this.principal,
        nominalApr: nominalApr ?? this.nominalApr,
        interestCapitalizationGracePeriodMonths:
            interestCapitalizationGracePeriodMonths ??
                this.interestCapitalizationGracePeriodMonths,
        repaymentModel: repaymentModel ?? this.repaymentModel,
        expectedPayoffDate: expectedPayoffDate ?? this.expectedPayoffDate,
        guarantor: guarantor ?? this.guarantor,
        isFederal: isFederal ?? this.isFederal,
        loanName: loanName ?? this.loanName,
        loanStatus: loanStatus ?? this.loanStatus,
        paymentReferenceNumber:
            paymentReferenceNumber ?? this.paymentReferenceNumber,
        pslfStatus: pslfStatus ?? this.pslfStatus,
        repaymentPlanDescription:
            repaymentPlanDescription ?? this.repaymentPlanDescription,
        repaymentPlanType: repaymentPlanType ?? this.repaymentPlanType,
        sequenceNumber: sequenceNumber ?? this.sequenceNumber,
        servicerAddress: servicerAddress ?? this.servicerAddress);
  }
}

@JsonSerializable(explicitToJson: true)
class StudentLoanRepaymentModel {
  StudentLoanRepaymentModel({
    this.type,
    this.nonRepaymentMonths,
    this.repaymentMonths,
  });

  factory StudentLoanRepaymentModel.fromJson(Map<String, dynamic> json) =>
      _$StudentLoanRepaymentModelFromJson(json);

  @JsonKey(name: 'type')
  final String? type;
  @JsonKey(name: 'non_repayment_months')
  final double? nonRepaymentMonths;
  @JsonKey(name: 'repayment_months')
  final double? repaymentMonths;
  static const fromJsonFactory = _$StudentLoanRepaymentModelFromJson;
  static const toJsonFactory = _$StudentLoanRepaymentModelToJson;
  Map<String, dynamic> toJson() => _$StudentLoanRepaymentModelToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is StudentLoanRepaymentModel &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.nonRepaymentMonths, nonRepaymentMonths) ||
                const DeepCollectionEquality()
                    .equals(other.nonRepaymentMonths, nonRepaymentMonths)) &&
            (identical(other.repaymentMonths, repaymentMonths) ||
                const DeepCollectionEquality()
                    .equals(other.repaymentMonths, repaymentMonths)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(nonRepaymentMonths) ^
      const DeepCollectionEquality().hash(repaymentMonths) ^
      runtimeType.hashCode;
}

extension $StudentLoanRepaymentModelExtension on StudentLoanRepaymentModel {
  StudentLoanRepaymentModel copyWith(
      {String? type, double? nonRepaymentMonths, double? repaymentMonths}) {
    return StudentLoanRepaymentModel(
        type: type ?? this.type,
        nonRepaymentMonths: nonRepaymentMonths ?? this.nonRepaymentMonths,
        repaymentMonths: repaymentMonths ?? this.repaymentMonths);
  }
}

@JsonSerializable(explicitToJson: true)
class InflowModel {
  InflowModel({
    this.type,
    this.incomeAmount,
    this.paymentDayOfMonth,
    this.transactionName,
    this.statementDayOfMonth,
  });

  factory InflowModel.fromJson(Map<String, dynamic> json) =>
      _$InflowModelFromJson(json);

  @JsonKey(name: 'type')
  final String? type;
  @JsonKey(name: 'income_amount')
  final double? incomeAmount;
  @JsonKey(name: 'payment_day_of_month')
  final double? paymentDayOfMonth;
  @JsonKey(name: 'transaction_name')
  final String? transactionName;
  @JsonKey(name: 'statement_day_of_month')
  final String? statementDayOfMonth;
  static const fromJsonFactory = _$InflowModelFromJson;
  static const toJsonFactory = _$InflowModelToJson;
  Map<String, dynamic> toJson() => _$InflowModelToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InflowModel &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.incomeAmount, incomeAmount) ||
                const DeepCollectionEquality()
                    .equals(other.incomeAmount, incomeAmount)) &&
            (identical(other.paymentDayOfMonth, paymentDayOfMonth) ||
                const DeepCollectionEquality()
                    .equals(other.paymentDayOfMonth, paymentDayOfMonth)) &&
            (identical(other.transactionName, transactionName) ||
                const DeepCollectionEquality()
                    .equals(other.transactionName, transactionName)) &&
            (identical(other.statementDayOfMonth, statementDayOfMonth) ||
                const DeepCollectionEquality()
                    .equals(other.statementDayOfMonth, statementDayOfMonth)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(incomeAmount) ^
      const DeepCollectionEquality().hash(paymentDayOfMonth) ^
      const DeepCollectionEquality().hash(transactionName) ^
      const DeepCollectionEquality().hash(statementDayOfMonth) ^
      runtimeType.hashCode;
}

extension $InflowModelExtension on InflowModel {
  InflowModel copyWith(
      {String? type,
      double? incomeAmount,
      double? paymentDayOfMonth,
      String? transactionName,
      String? statementDayOfMonth}) {
    return InflowModel(
        type: type ?? this.type,
        incomeAmount: incomeAmount ?? this.incomeAmount,
        paymentDayOfMonth: paymentDayOfMonth ?? this.paymentDayOfMonth,
        transactionName: transactionName ?? this.transactionName,
        statementDayOfMonth: statementDayOfMonth ?? this.statementDayOfMonth);
  }
}

@JsonSerializable(explicitToJson: true)
class IncomeOverride {
  IncomeOverride({
    this.paystubs,
  });

  factory IncomeOverride.fromJson(Map<String, dynamic> json) =>
      _$IncomeOverrideFromJson(json);

  @JsonKey(name: 'paystubs', defaultValue: <PaystubOverride>[])
  final List<PaystubOverride>? paystubs;
  static const fromJsonFactory = _$IncomeOverrideFromJson;
  static const toJsonFactory = _$IncomeOverrideToJson;
  Map<String, dynamic> toJson() => _$IncomeOverrideToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IncomeOverride &&
            (identical(other.paystubs, paystubs) ||
                const DeepCollectionEquality()
                    .equals(other.paystubs, paystubs)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(paystubs) ^ runtimeType.hashCode;
}

extension $IncomeOverrideExtension on IncomeOverride {
  IncomeOverride copyWith({List<PaystubOverride>? paystubs}) {
    return IncomeOverride(paystubs: paystubs ?? this.paystubs);
  }
}

@JsonSerializable(explicitToJson: true)
class PaystubOverride {
  PaystubOverride({
    this.employer,
    this.employee,
    this.incomeBreakdown,
    this.payPeriodDetails,
  });

  factory PaystubOverride.fromJson(Map<String, dynamic> json) =>
      _$PaystubOverrideFromJson(json);

  @JsonKey(name: 'employer')
  final PaystubOverride$Employer? employer;
  @JsonKey(name: 'employee')
  final PaystubOverride$Employee? employee;
  @JsonKey(name: 'income_breakdown', defaultValue: <IncomeBreakdown>[])
  final List<IncomeBreakdown>? incomeBreakdown;
  @JsonKey(name: 'pay_period_details')
  final PayPeriodDetails? payPeriodDetails;
  static const fromJsonFactory = _$PaystubOverrideFromJson;
  static const toJsonFactory = _$PaystubOverrideToJson;
  Map<String, dynamic> toJson() => _$PaystubOverrideToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaystubOverride &&
            (identical(other.employer, employer) ||
                const DeepCollectionEquality()
                    .equals(other.employer, employer)) &&
            (identical(other.employee, employee) ||
                const DeepCollectionEquality()
                    .equals(other.employee, employee)) &&
            (identical(other.incomeBreakdown, incomeBreakdown) ||
                const DeepCollectionEquality()
                    .equals(other.incomeBreakdown, incomeBreakdown)) &&
            (identical(other.payPeriodDetails, payPeriodDetails) ||
                const DeepCollectionEquality()
                    .equals(other.payPeriodDetails, payPeriodDetails)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(employer) ^
      const DeepCollectionEquality().hash(employee) ^
      const DeepCollectionEquality().hash(incomeBreakdown) ^
      const DeepCollectionEquality().hash(payPeriodDetails) ^
      runtimeType.hashCode;
}

extension $PaystubOverrideExtension on PaystubOverride {
  PaystubOverride copyWith(
      {PaystubOverride$Employer? employer,
      PaystubOverride$Employee? employee,
      List<IncomeBreakdown>? incomeBreakdown,
      PayPeriodDetails? payPeriodDetails}) {
    return PaystubOverride(
        employer: employer ?? this.employer,
        employee: employee ?? this.employee,
        incomeBreakdown: incomeBreakdown ?? this.incomeBreakdown,
        payPeriodDetails: payPeriodDetails ?? this.payPeriodDetails);
  }
}

@JsonSerializable(explicitToJson: true)
class AutomaticallyVerifiedWebhook {
  AutomaticallyVerifiedWebhook({
    this.webhookType,
    this.webhookCode,
    this.accountId,
    this.itemId,
  });

  factory AutomaticallyVerifiedWebhook.fromJson(Map<String, dynamic> json) =>
      _$AutomaticallyVerifiedWebhookFromJson(json);

  @JsonKey(name: 'webhook_type')
  final String? webhookType;
  @JsonKey(name: 'webhook_code')
  final String? webhookCode;
  @JsonKey(name: 'account_id')
  final String? accountId;
  @JsonKey(name: 'item_id')
  final String? itemId;
  static const fromJsonFactory = _$AutomaticallyVerifiedWebhookFromJson;
  static const toJsonFactory = _$AutomaticallyVerifiedWebhookToJson;
  Map<String, dynamic> toJson() => _$AutomaticallyVerifiedWebhookToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AutomaticallyVerifiedWebhook &&
            (identical(other.webhookType, webhookType) ||
                const DeepCollectionEquality()
                    .equals(other.webhookType, webhookType)) &&
            (identical(other.webhookCode, webhookCode) ||
                const DeepCollectionEquality()
                    .equals(other.webhookCode, webhookCode)) &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(webhookType) ^
      const DeepCollectionEquality().hash(webhookCode) ^
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(itemId) ^
      runtimeType.hashCode;
}

extension $AutomaticallyVerifiedWebhookExtension
    on AutomaticallyVerifiedWebhook {
  AutomaticallyVerifiedWebhook copyWith(
      {String? webhookType,
      String? webhookCode,
      String? accountId,
      String? itemId}) {
    return AutomaticallyVerifiedWebhook(
        webhookType: webhookType ?? this.webhookType,
        webhookCode: webhookCode ?? this.webhookCode,
        accountId: accountId ?? this.accountId,
        itemId: itemId ?? this.itemId);
  }
}

@JsonSerializable(explicitToJson: true)
class JWTHeader {
  JWTHeader({
    this.id,
  });

  factory JWTHeader.fromJson(Map<String, dynamic> json) =>
      _$JWTHeaderFromJson(json);

  @JsonKey(name: 'id')
  final String? id;
  static const fromJsonFactory = _$JWTHeaderFromJson;
  static const toJsonFactory = _$JWTHeaderToJson;
  Map<String, dynamic> toJson() => _$JWTHeaderToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is JWTHeader &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^ runtimeType.hashCode;
}

extension $JWTHeaderExtension on JWTHeader {
  JWTHeader copyWith({String? id}) {
    return JWTHeader(id: id ?? this.id);
  }
}

@JsonSerializable(explicitToJson: true)
class VerificationExpiredWebhook {
  VerificationExpiredWebhook({
    this.webhookType,
    this.webhookCode,
    this.itemId,
    this.accountId,
  });

  factory VerificationExpiredWebhook.fromJson(Map<String, dynamic> json) =>
      _$VerificationExpiredWebhookFromJson(json);

  @JsonKey(name: 'webhook_type')
  final String? webhookType;
  @JsonKey(name: 'webhook_code')
  final String? webhookCode;
  @JsonKey(name: 'item_id')
  final String? itemId;
  @JsonKey(name: 'account_id')
  final String? accountId;
  static const fromJsonFactory = _$VerificationExpiredWebhookFromJson;
  static const toJsonFactory = _$VerificationExpiredWebhookToJson;
  Map<String, dynamic> toJson() => _$VerificationExpiredWebhookToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is VerificationExpiredWebhook &&
            (identical(other.webhookType, webhookType) ||
                const DeepCollectionEquality()
                    .equals(other.webhookType, webhookType)) &&
            (identical(other.webhookCode, webhookCode) ||
                const DeepCollectionEquality()
                    .equals(other.webhookCode, webhookCode)) &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)) &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(webhookType) ^
      const DeepCollectionEquality().hash(webhookCode) ^
      const DeepCollectionEquality().hash(itemId) ^
      const DeepCollectionEquality().hash(accountId) ^
      runtimeType.hashCode;
}

extension $VerificationExpiredWebhookExtension on VerificationExpiredWebhook {
  VerificationExpiredWebhook copyWith(
      {String? webhookType,
      String? webhookCode,
      String? itemId,
      String? accountId}) {
    return VerificationExpiredWebhook(
        webhookType: webhookType ?? this.webhookType,
        webhookCode: webhookCode ?? this.webhookCode,
        itemId: itemId ?? this.itemId,
        accountId: accountId ?? this.accountId);
  }
}

@JsonSerializable(explicitToJson: true)
class WebhookUpdateAcknowledgedWebhook {
  WebhookUpdateAcknowledgedWebhook({
    this.webhookType,
    this.webhookCode,
    this.itemId,
    this.newWebhookUrl,
    this.error,
  });

  factory WebhookUpdateAcknowledgedWebhook.fromJson(
          Map<String, dynamic> json) =>
      _$WebhookUpdateAcknowledgedWebhookFromJson(json);

  @JsonKey(name: 'webhook_type')
  final String? webhookType;
  @JsonKey(name: 'webhook_code')
  final String? webhookCode;
  @JsonKey(name: 'item_id')
  final String? itemId;
  @JsonKey(name: 'new_webhook_url')
  final String? newWebhookUrl;
  @JsonKey(name: 'error')
  final Error? error;
  static const fromJsonFactory = _$WebhookUpdateAcknowledgedWebhookFromJson;
  static const toJsonFactory = _$WebhookUpdateAcknowledgedWebhookToJson;
  Map<String, dynamic> toJson() =>
      _$WebhookUpdateAcknowledgedWebhookToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WebhookUpdateAcknowledgedWebhook &&
            (identical(other.webhookType, webhookType) ||
                const DeepCollectionEquality()
                    .equals(other.webhookType, webhookType)) &&
            (identical(other.webhookCode, webhookCode) ||
                const DeepCollectionEquality()
                    .equals(other.webhookCode, webhookCode)) &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)) &&
            (identical(other.newWebhookUrl, newWebhookUrl) ||
                const DeepCollectionEquality()
                    .equals(other.newWebhookUrl, newWebhookUrl)) &&
            (identical(other.error, error) ||
                const DeepCollectionEquality().equals(other.error, error)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(webhookType) ^
      const DeepCollectionEquality().hash(webhookCode) ^
      const DeepCollectionEquality().hash(itemId) ^
      const DeepCollectionEquality().hash(newWebhookUrl) ^
      const DeepCollectionEquality().hash(error) ^
      runtimeType.hashCode;
}

extension $WebhookUpdateAcknowledgedWebhookExtension
    on WebhookUpdateAcknowledgedWebhook {
  WebhookUpdateAcknowledgedWebhook copyWith(
      {String? webhookType,
      String? webhookCode,
      String? itemId,
      String? newWebhookUrl,
      Error? error}) {
    return WebhookUpdateAcknowledgedWebhook(
        webhookType: webhookType ?? this.webhookType,
        webhookCode: webhookCode ?? this.webhookCode,
        itemId: itemId ?? this.itemId,
        newWebhookUrl: newWebhookUrl ?? this.newWebhookUrl,
        error: error ?? this.error);
  }
}

@JsonSerializable(explicitToJson: true)
class PendingExpirationWebhook {
  PendingExpirationWebhook({
    this.webhookType,
    this.webhookCode,
    this.itemId,
    this.consentExpirationTime,
  });

  factory PendingExpirationWebhook.fromJson(Map<String, dynamic> json) =>
      _$PendingExpirationWebhookFromJson(json);

  @JsonKey(name: 'webhook_type')
  final String? webhookType;
  @JsonKey(name: 'webhook_code')
  final String? webhookCode;
  @JsonKey(name: 'item_id')
  final String? itemId;
  @JsonKey(name: 'consent_expiration_time')
  final DateTime? consentExpirationTime;
  static const fromJsonFactory = _$PendingExpirationWebhookFromJson;
  static const toJsonFactory = _$PendingExpirationWebhookToJson;
  Map<String, dynamic> toJson() => _$PendingExpirationWebhookToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PendingExpirationWebhook &&
            (identical(other.webhookType, webhookType) ||
                const DeepCollectionEquality()
                    .equals(other.webhookType, webhookType)) &&
            (identical(other.webhookCode, webhookCode) ||
                const DeepCollectionEquality()
                    .equals(other.webhookCode, webhookCode)) &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)) &&
            (identical(other.consentExpirationTime, consentExpirationTime) ||
                const DeepCollectionEquality().equals(
                    other.consentExpirationTime, consentExpirationTime)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(webhookType) ^
      const DeepCollectionEquality().hash(webhookCode) ^
      const DeepCollectionEquality().hash(itemId) ^
      const DeepCollectionEquality().hash(consentExpirationTime) ^
      runtimeType.hashCode;
}

extension $PendingExpirationWebhookExtension on PendingExpirationWebhook {
  PendingExpirationWebhook copyWith(
      {String? webhookType,
      String? webhookCode,
      String? itemId,
      DateTime? consentExpirationTime}) {
    return PendingExpirationWebhook(
        webhookType: webhookType ?? this.webhookType,
        webhookCode: webhookCode ?? this.webhookCode,
        itemId: itemId ?? this.itemId,
        consentExpirationTime:
            consentExpirationTime ?? this.consentExpirationTime);
  }
}

@JsonSerializable(explicitToJson: true)
class ItemErrorWebhook {
  ItemErrorWebhook({
    this.webhookType,
    this.webhookCode,
    this.itemId,
    this.error,
  });

  factory ItemErrorWebhook.fromJson(Map<String, dynamic> json) =>
      _$ItemErrorWebhookFromJson(json);

  @JsonKey(name: 'webhook_type')
  final String? webhookType;
  @JsonKey(name: 'webhook_code')
  final String? webhookCode;
  @JsonKey(name: 'item_id')
  final String? itemId;
  @JsonKey(name: 'error')
  final Error? error;
  static const fromJsonFactory = _$ItemErrorWebhookFromJson;
  static const toJsonFactory = _$ItemErrorWebhookToJson;
  Map<String, dynamic> toJson() => _$ItemErrorWebhookToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ItemErrorWebhook &&
            (identical(other.webhookType, webhookType) ||
                const DeepCollectionEquality()
                    .equals(other.webhookType, webhookType)) &&
            (identical(other.webhookCode, webhookCode) ||
                const DeepCollectionEquality()
                    .equals(other.webhookCode, webhookCode)) &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)) &&
            (identical(other.error, error) ||
                const DeepCollectionEquality().equals(other.error, error)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(webhookType) ^
      const DeepCollectionEquality().hash(webhookCode) ^
      const DeepCollectionEquality().hash(itemId) ^
      const DeepCollectionEquality().hash(error) ^
      runtimeType.hashCode;
}

extension $ItemErrorWebhookExtension on ItemErrorWebhook {
  ItemErrorWebhook copyWith(
      {String? webhookType,
      String? webhookCode,
      String? itemId,
      Error? error}) {
    return ItemErrorWebhook(
        webhookType: webhookType ?? this.webhookType,
        webhookCode: webhookCode ?? this.webhookCode,
        itemId: itemId ?? this.itemId,
        error: error ?? this.error);
  }
}

@JsonSerializable(explicitToJson: true)
class ItemProductReadyWebhook {
  ItemProductReadyWebhook({
    this.webhookType,
    this.webhookCode,
    this.itemId,
    this.error,
  });

  factory ItemProductReadyWebhook.fromJson(Map<String, dynamic> json) =>
      _$ItemProductReadyWebhookFromJson(json);

  @JsonKey(name: 'webhook_type')
  final String? webhookType;
  @JsonKey(name: 'webhook_code')
  final String? webhookCode;
  @JsonKey(name: 'item_id')
  final String? itemId;
  @JsonKey(name: 'error')
  final Error? error;
  static const fromJsonFactory = _$ItemProductReadyWebhookFromJson;
  static const toJsonFactory = _$ItemProductReadyWebhookToJson;
  Map<String, dynamic> toJson() => _$ItemProductReadyWebhookToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ItemProductReadyWebhook &&
            (identical(other.webhookType, webhookType) ||
                const DeepCollectionEquality()
                    .equals(other.webhookType, webhookType)) &&
            (identical(other.webhookCode, webhookCode) ||
                const DeepCollectionEquality()
                    .equals(other.webhookCode, webhookCode)) &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)) &&
            (identical(other.error, error) ||
                const DeepCollectionEquality().equals(other.error, error)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(webhookType) ^
      const DeepCollectionEquality().hash(webhookCode) ^
      const DeepCollectionEquality().hash(itemId) ^
      const DeepCollectionEquality().hash(error) ^
      runtimeType.hashCode;
}

extension $ItemProductReadyWebhookExtension on ItemProductReadyWebhook {
  ItemProductReadyWebhook copyWith(
      {String? webhookType,
      String? webhookCode,
      String? itemId,
      Error? error}) {
    return ItemProductReadyWebhook(
        webhookType: webhookType ?? this.webhookType,
        webhookCode: webhookCode ?? this.webhookCode,
        itemId: itemId ?? this.itemId,
        error: error ?? this.error);
  }
}

@JsonSerializable(explicitToJson: true)
class RecaptchaRequiredError {
  RecaptchaRequiredError({
    this.errorType,
    this.errorCode,
    this.displayMessage,
    this.httpCode,
    this.linkUserExperience,
    this.commonCauses,
    this.troubleshootingSteps,
  });

  factory RecaptchaRequiredError.fromJson(Map<String, dynamic> json) =>
      _$RecaptchaRequiredErrorFromJson(json);

  @JsonKey(name: 'error_type')
  final String? errorType;
  @JsonKey(name: 'error_code')
  final String? errorCode;
  @JsonKey(name: 'display_message')
  final String? displayMessage;
  @JsonKey(name: 'http_code')
  final String? httpCode;
  @JsonKey(name: 'link_user_experience')
  final String? linkUserExperience;
  @JsonKey(name: 'common_causes')
  final String? commonCauses;
  @JsonKey(name: 'troubleshooting_steps')
  final String? troubleshootingSteps;
  static const fromJsonFactory = _$RecaptchaRequiredErrorFromJson;
  static const toJsonFactory = _$RecaptchaRequiredErrorToJson;
  Map<String, dynamic> toJson() => _$RecaptchaRequiredErrorToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is RecaptchaRequiredError &&
            (identical(other.errorType, errorType) ||
                const DeepCollectionEquality()
                    .equals(other.errorType, errorType)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.displayMessage, displayMessage) ||
                const DeepCollectionEquality()
                    .equals(other.displayMessage, displayMessage)) &&
            (identical(other.httpCode, httpCode) ||
                const DeepCollectionEquality()
                    .equals(other.httpCode, httpCode)) &&
            (identical(other.linkUserExperience, linkUserExperience) ||
                const DeepCollectionEquality()
                    .equals(other.linkUserExperience, linkUserExperience)) &&
            (identical(other.commonCauses, commonCauses) ||
                const DeepCollectionEquality()
                    .equals(other.commonCauses, commonCauses)) &&
            (identical(other.troubleshootingSteps, troubleshootingSteps) ||
                const DeepCollectionEquality()
                    .equals(other.troubleshootingSteps, troubleshootingSteps)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(errorType) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(displayMessage) ^
      const DeepCollectionEquality().hash(httpCode) ^
      const DeepCollectionEquality().hash(linkUserExperience) ^
      const DeepCollectionEquality().hash(commonCauses) ^
      const DeepCollectionEquality().hash(troubleshootingSteps) ^
      runtimeType.hashCode;
}

extension $RecaptchaRequiredErrorExtension on RecaptchaRequiredError {
  RecaptchaRequiredError copyWith(
      {String? errorType,
      String? errorCode,
      String? displayMessage,
      String? httpCode,
      String? linkUserExperience,
      String? commonCauses,
      String? troubleshootingSteps}) {
    return RecaptchaRequiredError(
        errorType: errorType ?? this.errorType,
        errorCode: errorCode ?? this.errorCode,
        displayMessage: displayMessage ?? this.displayMessage,
        httpCode: httpCode ?? this.httpCode,
        linkUserExperience: linkUserExperience ?? this.linkUserExperience,
        commonCauses: commonCauses ?? this.commonCauses,
        troubleshootingSteps:
            troubleshootingSteps ?? this.troubleshootingSteps);
  }
}

@JsonSerializable(explicitToJson: true)
class BankTransfersEventsUpdateWebhook {
  BankTransfersEventsUpdateWebhook({
    this.webhookType,
    this.webhookCode,
  });

  factory BankTransfersEventsUpdateWebhook.fromJson(
          Map<String, dynamic> json) =>
      _$BankTransfersEventsUpdateWebhookFromJson(json);

  @JsonKey(name: 'webhook_type')
  final String? webhookType;
  @JsonKey(name: 'webhook_code')
  final String? webhookCode;
  static const fromJsonFactory = _$BankTransfersEventsUpdateWebhookFromJson;
  static const toJsonFactory = _$BankTransfersEventsUpdateWebhookToJson;
  Map<String, dynamic> toJson() =>
      _$BankTransfersEventsUpdateWebhookToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BankTransfersEventsUpdateWebhook &&
            (identical(other.webhookType, webhookType) ||
                const DeepCollectionEquality()
                    .equals(other.webhookType, webhookType)) &&
            (identical(other.webhookCode, webhookCode) ||
                const DeepCollectionEquality()
                    .equals(other.webhookCode, webhookCode)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(webhookType) ^
      const DeepCollectionEquality().hash(webhookCode) ^
      runtimeType.hashCode;
}

extension $BankTransfersEventsUpdateWebhookExtension
    on BankTransfersEventsUpdateWebhook {
  BankTransfersEventsUpdateWebhook copyWith(
      {String? webhookType, String? webhookCode}) {
    return BankTransfersEventsUpdateWebhook(
        webhookType: webhookType ?? this.webhookType,
        webhookCode: webhookCode ?? this.webhookCode);
  }
}

@JsonSerializable(explicitToJson: true)
class InvestmentsDefaultUpdateWebhook {
  InvestmentsDefaultUpdateWebhook({
    this.webhookType,
    this.webhookCode,
    this.itemId,
    this.error,
    this.newInvestmentsTransactions,
    this.canceledInvestmentsTransactions,
  });

  factory InvestmentsDefaultUpdateWebhook.fromJson(Map<String, dynamic> json) =>
      _$InvestmentsDefaultUpdateWebhookFromJson(json);

  @JsonKey(name: 'webhook_type')
  final String? webhookType;
  @JsonKey(name: 'webhook_code')
  final String? webhookCode;
  @JsonKey(name: 'item_id')
  final String? itemId;
  @JsonKey(name: 'error')
  final Error? error;
  @JsonKey(name: 'new_investments_transactions')
  final double? newInvestmentsTransactions;
  @JsonKey(name: 'canceled_investments_transactions')
  final double? canceledInvestmentsTransactions;
  static const fromJsonFactory = _$InvestmentsDefaultUpdateWebhookFromJson;
  static const toJsonFactory = _$InvestmentsDefaultUpdateWebhookToJson;
  Map<String, dynamic> toJson() =>
      _$InvestmentsDefaultUpdateWebhookToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvestmentsDefaultUpdateWebhook &&
            (identical(other.webhookType, webhookType) ||
                const DeepCollectionEquality()
                    .equals(other.webhookType, webhookType)) &&
            (identical(other.webhookCode, webhookCode) ||
                const DeepCollectionEquality()
                    .equals(other.webhookCode, webhookCode)) &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)) &&
            (identical(other.error, error) ||
                const DeepCollectionEquality().equals(other.error, error)) &&
            (identical(other.newInvestmentsTransactions,
                    newInvestmentsTransactions) ||
                const DeepCollectionEquality().equals(
                    other.newInvestmentsTransactions,
                    newInvestmentsTransactions)) &&
            (identical(other.canceledInvestmentsTransactions,
                    canceledInvestmentsTransactions) ||
                const DeepCollectionEquality().equals(
                    other.canceledInvestmentsTransactions,
                    canceledInvestmentsTransactions)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(webhookType) ^
      const DeepCollectionEquality().hash(webhookCode) ^
      const DeepCollectionEquality().hash(itemId) ^
      const DeepCollectionEquality().hash(error) ^
      const DeepCollectionEquality().hash(newInvestmentsTransactions) ^
      const DeepCollectionEquality().hash(canceledInvestmentsTransactions) ^
      runtimeType.hashCode;
}

extension $InvestmentsDefaultUpdateWebhookExtension
    on InvestmentsDefaultUpdateWebhook {
  InvestmentsDefaultUpdateWebhook copyWith(
      {String? webhookType,
      String? webhookCode,
      String? itemId,
      Error? error,
      double? newInvestmentsTransactions,
      double? canceledInvestmentsTransactions}) {
    return InvestmentsDefaultUpdateWebhook(
        webhookType: webhookType ?? this.webhookType,
        webhookCode: webhookCode ?? this.webhookCode,
        itemId: itemId ?? this.itemId,
        error: error ?? this.error,
        newInvestmentsTransactions:
            newInvestmentsTransactions ?? this.newInvestmentsTransactions,
        canceledInvestmentsTransactions: canceledInvestmentsTransactions ??
            this.canceledInvestmentsTransactions);
  }
}

@JsonSerializable(explicitToJson: true)
class HoldingsDefaultUpdateWebhook {
  HoldingsDefaultUpdateWebhook({
    this.webhookType,
    this.webhookCode,
    this.itemId,
    this.error,
    this.newHoldings,
    this.updatedHoldings,
  });

  factory HoldingsDefaultUpdateWebhook.fromJson(Map<String, dynamic> json) =>
      _$HoldingsDefaultUpdateWebhookFromJson(json);

  @JsonKey(name: 'webhook_type')
  final String? webhookType;
  @JsonKey(name: 'webhook_code')
  final String? webhookCode;
  @JsonKey(name: 'item_id')
  final String? itemId;
  @JsonKey(name: 'error')
  final Error? error;
  @JsonKey(name: 'new_holdings')
  final double? newHoldings;
  @JsonKey(name: 'updated_holdings')
  final double? updatedHoldings;
  static const fromJsonFactory = _$HoldingsDefaultUpdateWebhookFromJson;
  static const toJsonFactory = _$HoldingsDefaultUpdateWebhookToJson;
  Map<String, dynamic> toJson() => _$HoldingsDefaultUpdateWebhookToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is HoldingsDefaultUpdateWebhook &&
            (identical(other.webhookType, webhookType) ||
                const DeepCollectionEquality()
                    .equals(other.webhookType, webhookType)) &&
            (identical(other.webhookCode, webhookCode) ||
                const DeepCollectionEquality()
                    .equals(other.webhookCode, webhookCode)) &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)) &&
            (identical(other.error, error) ||
                const DeepCollectionEquality().equals(other.error, error)) &&
            (identical(other.newHoldings, newHoldings) ||
                const DeepCollectionEquality()
                    .equals(other.newHoldings, newHoldings)) &&
            (identical(other.updatedHoldings, updatedHoldings) ||
                const DeepCollectionEquality()
                    .equals(other.updatedHoldings, updatedHoldings)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(webhookType) ^
      const DeepCollectionEquality().hash(webhookCode) ^
      const DeepCollectionEquality().hash(itemId) ^
      const DeepCollectionEquality().hash(error) ^
      const DeepCollectionEquality().hash(newHoldings) ^
      const DeepCollectionEquality().hash(updatedHoldings) ^
      runtimeType.hashCode;
}

extension $HoldingsDefaultUpdateWebhookExtension
    on HoldingsDefaultUpdateWebhook {
  HoldingsDefaultUpdateWebhook copyWith(
      {String? webhookType,
      String? webhookCode,
      String? itemId,
      Error? error,
      double? newHoldings,
      double? updatedHoldings}) {
    return HoldingsDefaultUpdateWebhook(
        webhookType: webhookType ?? this.webhookType,
        webhookCode: webhookCode ?? this.webhookCode,
        itemId: itemId ?? this.itemId,
        error: error ?? this.error,
        newHoldings: newHoldings ?? this.newHoldings,
        updatedHoldings: updatedHoldings ?? this.updatedHoldings);
  }
}

@JsonSerializable(explicitToJson: true)
class LiabilitiesDefaultUpdateWebhook {
  LiabilitiesDefaultUpdateWebhook({
    this.webhookType,
    this.webhookCode,
    this.itemId,
    this.error,
    this.accountIdsWithNewLiabilities,
    this.accountIdsWithUpdatedLiabilities,
  });

  factory LiabilitiesDefaultUpdateWebhook.fromJson(Map<String, dynamic> json) =>
      _$LiabilitiesDefaultUpdateWebhookFromJson(json);

  @JsonKey(name: 'webhook_type')
  final String? webhookType;
  @JsonKey(name: 'webhook_code')
  final String? webhookCode;
  @JsonKey(name: 'item_id')
  final String? itemId;
  @JsonKey(name: 'error')
  final Error? error;
  @JsonKey(name: 'account_ids_with_new_liabilities', defaultValue: <String>[])
  final List<String>? accountIdsWithNewLiabilities;
  @JsonKey(name: 'account_ids_with_updated_liabilities')
  final Map<String, dynamic>? accountIdsWithUpdatedLiabilities;
  static const fromJsonFactory = _$LiabilitiesDefaultUpdateWebhookFromJson;
  static const toJsonFactory = _$LiabilitiesDefaultUpdateWebhookToJson;
  Map<String, dynamic> toJson() =>
      _$LiabilitiesDefaultUpdateWebhookToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LiabilitiesDefaultUpdateWebhook &&
            (identical(other.webhookType, webhookType) ||
                const DeepCollectionEquality()
                    .equals(other.webhookType, webhookType)) &&
            (identical(other.webhookCode, webhookCode) ||
                const DeepCollectionEquality()
                    .equals(other.webhookCode, webhookCode)) &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)) &&
            (identical(other.error, error) ||
                const DeepCollectionEquality().equals(other.error, error)) &&
            (identical(other.accountIdsWithNewLiabilities,
                    accountIdsWithNewLiabilities) ||
                const DeepCollectionEquality().equals(
                    other.accountIdsWithNewLiabilities,
                    accountIdsWithNewLiabilities)) &&
            (identical(other.accountIdsWithUpdatedLiabilities,
                    accountIdsWithUpdatedLiabilities) ||
                const DeepCollectionEquality().equals(
                    other.accountIdsWithUpdatedLiabilities,
                    accountIdsWithUpdatedLiabilities)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(webhookType) ^
      const DeepCollectionEquality().hash(webhookCode) ^
      const DeepCollectionEquality().hash(itemId) ^
      const DeepCollectionEquality().hash(error) ^
      const DeepCollectionEquality().hash(accountIdsWithNewLiabilities) ^
      const DeepCollectionEquality().hash(accountIdsWithUpdatedLiabilities) ^
      runtimeType.hashCode;
}

extension $LiabilitiesDefaultUpdateWebhookExtension
    on LiabilitiesDefaultUpdateWebhook {
  LiabilitiesDefaultUpdateWebhook copyWith(
      {String? webhookType,
      String? webhookCode,
      String? itemId,
      Error? error,
      List<String>? accountIdsWithNewLiabilities,
      Map<String, dynamic>? accountIdsWithUpdatedLiabilities}) {
    return LiabilitiesDefaultUpdateWebhook(
        webhookType: webhookType ?? this.webhookType,
        webhookCode: webhookCode ?? this.webhookCode,
        itemId: itemId ?? this.itemId,
        error: error ?? this.error,
        accountIdsWithNewLiabilities:
            accountIdsWithNewLiabilities ?? this.accountIdsWithNewLiabilities,
        accountIdsWithUpdatedLiabilities: accountIdsWithUpdatedLiabilities ??
            this.accountIdsWithUpdatedLiabilities);
  }
}

@JsonSerializable(explicitToJson: true)
class AssetsProductReadyWebhook {
  AssetsProductReadyWebhook({
    this.webhookType,
    this.webhookCode,
    this.assetReportId,
  });

  factory AssetsProductReadyWebhook.fromJson(Map<String, dynamic> json) =>
      _$AssetsProductReadyWebhookFromJson(json);

  @JsonKey(name: 'webhook_type')
  final String? webhookType;
  @JsonKey(name: 'webhook_code')
  final String? webhookCode;
  @JsonKey(name: 'asset_report_id')
  final String? assetReportId;
  static const fromJsonFactory = _$AssetsProductReadyWebhookFromJson;
  static const toJsonFactory = _$AssetsProductReadyWebhookToJson;
  Map<String, dynamic> toJson() => _$AssetsProductReadyWebhookToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AssetsProductReadyWebhook &&
            (identical(other.webhookType, webhookType) ||
                const DeepCollectionEquality()
                    .equals(other.webhookType, webhookType)) &&
            (identical(other.webhookCode, webhookCode) ||
                const DeepCollectionEquality()
                    .equals(other.webhookCode, webhookCode)) &&
            (identical(other.assetReportId, assetReportId) ||
                const DeepCollectionEquality()
                    .equals(other.assetReportId, assetReportId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(webhookType) ^
      const DeepCollectionEquality().hash(webhookCode) ^
      const DeepCollectionEquality().hash(assetReportId) ^
      runtimeType.hashCode;
}

extension $AssetsProductReadyWebhookExtension on AssetsProductReadyWebhook {
  AssetsProductReadyWebhook copyWith(
      {String? webhookType, String? webhookCode, String? assetReportId}) {
    return AssetsProductReadyWebhook(
        webhookType: webhookType ?? this.webhookType,
        webhookCode: webhookCode ?? this.webhookCode,
        assetReportId: assetReportId ?? this.assetReportId);
  }
}

@JsonSerializable(explicitToJson: true)
class AssetsErrorWebhook {
  AssetsErrorWebhook({
    this.webhookType,
    this.webhookCode,
    this.error,
    this.assetReportId,
  });

  factory AssetsErrorWebhook.fromJson(Map<String, dynamic> json) =>
      _$AssetsErrorWebhookFromJson(json);

  @JsonKey(name: 'webhook_type')
  final String? webhookType;
  @JsonKey(name: 'webhook_code')
  final String? webhookCode;
  @JsonKey(name: 'error')
  final Error? error;
  @JsonKey(name: 'asset_report_id')
  final String? assetReportId;
  static const fromJsonFactory = _$AssetsErrorWebhookFromJson;
  static const toJsonFactory = _$AssetsErrorWebhookToJson;
  Map<String, dynamic> toJson() => _$AssetsErrorWebhookToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AssetsErrorWebhook &&
            (identical(other.webhookType, webhookType) ||
                const DeepCollectionEquality()
                    .equals(other.webhookType, webhookType)) &&
            (identical(other.webhookCode, webhookCode) ||
                const DeepCollectionEquality()
                    .equals(other.webhookCode, webhookCode)) &&
            (identical(other.error, error) ||
                const DeepCollectionEquality().equals(other.error, error)) &&
            (identical(other.assetReportId, assetReportId) ||
                const DeepCollectionEquality()
                    .equals(other.assetReportId, assetReportId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(webhookType) ^
      const DeepCollectionEquality().hash(webhookCode) ^
      const DeepCollectionEquality().hash(error) ^
      const DeepCollectionEquality().hash(assetReportId) ^
      runtimeType.hashCode;
}

extension $AssetsErrorWebhookExtension on AssetsErrorWebhook {
  AssetsErrorWebhook copyWith(
      {String? webhookType,
      String? webhookCode,
      Error? error,
      String? assetReportId}) {
    return AssetsErrorWebhook(
        webhookType: webhookType ?? this.webhookType,
        webhookCode: webhookCode ?? this.webhookCode,
        error: error ?? this.error,
        assetReportId: assetReportId ?? this.assetReportId);
  }
}

@JsonSerializable(explicitToJson: true)
class Cause {
  Cause({
    this.itemId,
    this.error,
  });

  factory Cause.fromJson(Map<String, dynamic> json) => _$CauseFromJson(json);

  @JsonKey(name: 'item_id')
  final String? itemId;
  @JsonKey(name: 'error')
  final Error? error;
  static const fromJsonFactory = _$CauseFromJson;
  static const toJsonFactory = _$CauseToJson;
  Map<String, dynamic> toJson() => _$CauseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Cause &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)) &&
            (identical(other.error, error) ||
                const DeepCollectionEquality().equals(other.error, error)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(itemId) ^
      const DeepCollectionEquality().hash(error) ^
      runtimeType.hashCode;
}

extension $CauseExtension on Cause {
  Cause copyWith({String? itemId, Error? error}) {
    return Cause(itemId: itemId ?? this.itemId, error: error ?? this.error);
  }
}

@JsonSerializable(explicitToJson: true)
class Warning {
  Warning({
    this.warningType,
    this.warningCode,
    this.cause,
  });

  factory Warning.fromJson(Map<String, dynamic> json) =>
      _$WarningFromJson(json);

  @JsonKey(name: 'warning_type')
  final String? warningType;
  @JsonKey(
      name: 'warning_code',
      toJson: warningWarningCodeToJson,
      fromJson: warningWarningCodeFromJson)
  final enums.WarningWarningCode? warningCode;
  @JsonKey(name: 'cause')
  final Cause? cause;
  static const fromJsonFactory = _$WarningFromJson;
  static const toJsonFactory = _$WarningToJson;
  Map<String, dynamic> toJson() => _$WarningToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Warning &&
            (identical(other.warningType, warningType) ||
                const DeepCollectionEquality()
                    .equals(other.warningType, warningType)) &&
            (identical(other.warningCode, warningCode) ||
                const DeepCollectionEquality()
                    .equals(other.warningCode, warningCode)) &&
            (identical(other.cause, cause) ||
                const DeepCollectionEquality().equals(other.cause, cause)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(warningType) ^
      const DeepCollectionEquality().hash(warningCode) ^
      const DeepCollectionEquality().hash(cause) ^
      runtimeType.hashCode;
}

extension $WarningExtension on Warning {
  Warning copyWith(
      {String? warningType,
      enums.WarningWarningCode? warningCode,
      Cause? cause}) {
    return Warning(
        warningType: warningType ?? this.warningType,
        warningCode: warningCode ?? this.warningCode,
        cause: cause ?? this.cause);
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentAmount {
  PaymentAmount({
    this.currency,
    this.value,
  });

  factory PaymentAmount.fromJson(Map<String, dynamic> json) =>
      _$PaymentAmountFromJson(json);

  @JsonKey(
      name: 'currency',
      toJson: paymentAmountCurrencyToJson,
      fromJson: paymentAmountCurrencyFromJson)
  final enums.PaymentAmountCurrency? currency;
  @JsonKey(name: 'value')
  final double? value;
  static const fromJsonFactory = _$PaymentAmountFromJson;
  static const toJsonFactory = _$PaymentAmountToJson;
  Map<String, dynamic> toJson() => _$PaymentAmountToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentAmount &&
            (identical(other.currency, currency) ||
                const DeepCollectionEquality()
                    .equals(other.currency, currency)) &&
            (identical(other.value, value) ||
                const DeepCollectionEquality().equals(other.value, value)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(currency) ^
      const DeepCollectionEquality().hash(value) ^
      runtimeType.hashCode;
}

extension $PaymentAmountExtension on PaymentAmount {
  PaymentAmount copyWith(
      {enums.PaymentAmountCurrency? currency, double? value}) {
    return PaymentAmount(
        currency: currency ?? this.currency, value: value ?? this.value);
  }
}

@JsonSerializable(explicitToJson: true)
class AssetReportUser {
  AssetReportUser({
    this.clientUserId,
    this.firstName,
    this.middleName,
    this.lastName,
    this.ssn,
    this.phoneNumber,
    this.email,
  });

  factory AssetReportUser.fromJson(Map<String, dynamic> json) =>
      _$AssetReportUserFromJson(json);

  @JsonKey(name: 'client_user_id')
  final String? clientUserId;
  @JsonKey(name: 'first_name')
  final String? firstName;
  @JsonKey(name: 'middle_name')
  final String? middleName;
  @JsonKey(name: 'last_name')
  final String? lastName;
  @JsonKey(name: 'ssn')
  final String? ssn;
  @JsonKey(name: 'phone_number')
  final String? phoneNumber;
  @JsonKey(name: 'email')
  final String? email;
  static const fromJsonFactory = _$AssetReportUserFromJson;
  static const toJsonFactory = _$AssetReportUserToJson;
  Map<String, dynamic> toJson() => _$AssetReportUserToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AssetReportUser &&
            (identical(other.clientUserId, clientUserId) ||
                const DeepCollectionEquality()
                    .equals(other.clientUserId, clientUserId)) &&
            (identical(other.firstName, firstName) ||
                const DeepCollectionEquality()
                    .equals(other.firstName, firstName)) &&
            (identical(other.middleName, middleName) ||
                const DeepCollectionEquality()
                    .equals(other.middleName, middleName)) &&
            (identical(other.lastName, lastName) ||
                const DeepCollectionEquality()
                    .equals(other.lastName, lastName)) &&
            (identical(other.ssn, ssn) ||
                const DeepCollectionEquality().equals(other.ssn, ssn)) &&
            (identical(other.phoneNumber, phoneNumber) ||
                const DeepCollectionEquality()
                    .equals(other.phoneNumber, phoneNumber)) &&
            (identical(other.email, email) ||
                const DeepCollectionEquality().equals(other.email, email)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientUserId) ^
      const DeepCollectionEquality().hash(firstName) ^
      const DeepCollectionEquality().hash(middleName) ^
      const DeepCollectionEquality().hash(lastName) ^
      const DeepCollectionEquality().hash(ssn) ^
      const DeepCollectionEquality().hash(phoneNumber) ^
      const DeepCollectionEquality().hash(email) ^
      runtimeType.hashCode;
}

extension $AssetReportUserExtension on AssetReportUser {
  AssetReportUser copyWith(
      {String? clientUserId,
      String? firstName,
      String? middleName,
      String? lastName,
      String? ssn,
      String? phoneNumber,
      String? email}) {
    return AssetReportUser(
        clientUserId: clientUserId ?? this.clientUserId,
        firstName: firstName ?? this.firstName,
        middleName: middleName ?? this.middleName,
        lastName: lastName ?? this.lastName,
        ssn: ssn ?? this.ssn,
        phoneNumber: phoneNumber ?? this.phoneNumber,
        email: email ?? this.email);
  }
}

@JsonSerializable(explicitToJson: true)
class StandaloneCurrencyCodeList {
  StandaloneCurrencyCodeList({
    this.isoCurrencyCode,
    this.unofficialCurrencyCode,
  });

  factory StandaloneCurrencyCodeList.fromJson(Map<String, dynamic> json) =>
      _$StandaloneCurrencyCodeListFromJson(json);

  @JsonKey(name: 'iso_currency_code')
  final String? isoCurrencyCode;
  @JsonKey(name: 'unofficial_currency_code')
  final String? unofficialCurrencyCode;
  static const fromJsonFactory = _$StandaloneCurrencyCodeListFromJson;
  static const toJsonFactory = _$StandaloneCurrencyCodeListToJson;
  Map<String, dynamic> toJson() => _$StandaloneCurrencyCodeListToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is StandaloneCurrencyCodeList &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)) &&
            (identical(other.unofficialCurrencyCode, unofficialCurrencyCode) ||
                const DeepCollectionEquality().equals(
                    other.unofficialCurrencyCode, unofficialCurrencyCode)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      const DeepCollectionEquality().hash(unofficialCurrencyCode) ^
      runtimeType.hashCode;
}

extension $StandaloneCurrencyCodeListExtension on StandaloneCurrencyCodeList {
  StandaloneCurrencyCodeList copyWith(
      {String? isoCurrencyCode, String? unofficialCurrencyCode}) {
    return StandaloneCurrencyCodeList(
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode,
        unofficialCurrencyCode:
            unofficialCurrencyCode ?? this.unofficialCurrencyCode);
  }
}

@JsonSerializable(explicitToJson: true)
class StandaloneAccountType {
  StandaloneAccountType({
    this.depository,
    this.credit,
    this.loan,
    this.investment,
    this.other,
  });

  factory StandaloneAccountType.fromJson(Map<String, dynamic> json) =>
      _$StandaloneAccountTypeFromJson(json);

  @JsonKey(name: 'depository')
  final String? depository;
  @JsonKey(name: 'credit')
  final String? credit;
  @JsonKey(name: 'loan')
  final String? loan;
  @JsonKey(name: 'investment')
  final String? investment;
  @JsonKey(name: 'other')
  final String? other;
  static const fromJsonFactory = _$StandaloneAccountTypeFromJson;
  static const toJsonFactory = _$StandaloneAccountTypeToJson;
  Map<String, dynamic> toJson() => _$StandaloneAccountTypeToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is StandaloneAccountType &&
            (identical(other.depository, depository) ||
                const DeepCollectionEquality()
                    .equals(other.depository, depository)) &&
            (identical(other.credit, credit) ||
                const DeepCollectionEquality().equals(other.credit, credit)) &&
            (identical(other.loan, loan) ||
                const DeepCollectionEquality().equals(other.loan, loan)) &&
            (identical(other.investment, investment) ||
                const DeepCollectionEquality()
                    .equals(other.investment, investment)) &&
            (identical(other.other, other) ||
                const DeepCollectionEquality().equals(other.other, other)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(depository) ^
      const DeepCollectionEquality().hash(credit) ^
      const DeepCollectionEquality().hash(loan) ^
      const DeepCollectionEquality().hash(investment) ^
      const DeepCollectionEquality().hash(other) ^
      runtimeType.hashCode;
}

extension $StandaloneAccountTypeExtension on StandaloneAccountType {
  StandaloneAccountType copyWith(
      {String? depository,
      String? credit,
      String? loan,
      String? investment,
      String? other}) {
    return StandaloneAccountType(
        depository: depository ?? this.depository,
        credit: credit ?? this.credit,
        loan: loan ?? this.loan,
        investment: investment ?? this.investment,
        other: other ?? this.other);
  }
}

@JsonSerializable(explicitToJson: true)
class AssetReport {
  AssetReport({
    this.assetReportId,
    this.clientReportId,
    this.dateGenerated,
    this.daysRequested,
    this.user,
    this.items,
  });

  factory AssetReport.fromJson(Map<String, dynamic> json) =>
      _$AssetReportFromJson(json);

  @JsonKey(name: 'asset_report_id')
  final String? assetReportId;
  @JsonKey(name: 'client_report_id')
  final String? clientReportId;
  @JsonKey(name: 'date_generated')
  final DateTime? dateGenerated;
  @JsonKey(name: 'days_requested')
  final double? daysRequested;
  @JsonKey(name: 'user')
  final AssetReportUser? user;
  @JsonKey(name: 'items', defaultValue: <AssetReportItem>[])
  final List<AssetReportItem>? items;
  static const fromJsonFactory = _$AssetReportFromJson;
  static const toJsonFactory = _$AssetReportToJson;
  Map<String, dynamic> toJson() => _$AssetReportToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AssetReport &&
            (identical(other.assetReportId, assetReportId) ||
                const DeepCollectionEquality()
                    .equals(other.assetReportId, assetReportId)) &&
            (identical(other.clientReportId, clientReportId) ||
                const DeepCollectionEquality()
                    .equals(other.clientReportId, clientReportId)) &&
            (identical(other.dateGenerated, dateGenerated) ||
                const DeepCollectionEquality()
                    .equals(other.dateGenerated, dateGenerated)) &&
            (identical(other.daysRequested, daysRequested) ||
                const DeepCollectionEquality()
                    .equals(other.daysRequested, daysRequested)) &&
            (identical(other.user, user) ||
                const DeepCollectionEquality().equals(other.user, user)) &&
            (identical(other.items, items) ||
                const DeepCollectionEquality().equals(other.items, items)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(assetReportId) ^
      const DeepCollectionEquality().hash(clientReportId) ^
      const DeepCollectionEquality().hash(dateGenerated) ^
      const DeepCollectionEquality().hash(daysRequested) ^
      const DeepCollectionEquality().hash(user) ^
      const DeepCollectionEquality().hash(items) ^
      runtimeType.hashCode;
}

extension $AssetReportExtension on AssetReport {
  AssetReport copyWith(
      {String? assetReportId,
      String? clientReportId,
      DateTime? dateGenerated,
      double? daysRequested,
      AssetReportUser? user,
      List<AssetReportItem>? items}) {
    return AssetReport(
        assetReportId: assetReportId ?? this.assetReportId,
        clientReportId: clientReportId ?? this.clientReportId,
        dateGenerated: dateGenerated ?? this.dateGenerated,
        daysRequested: daysRequested ?? this.daysRequested,
        user: user ?? this.user,
        items: items ?? this.items);
  }
}

@JsonSerializable(explicitToJson: true)
class AssetReportItem {
  AssetReportItem({
    this.itemId,
    this.institutionName,
    this.institutionId,
    this.dateLastUpdated,
    this.accounts,
  });

  factory AssetReportItem.fromJson(Map<String, dynamic> json) =>
      _$AssetReportItemFromJson(json);

  @JsonKey(name: 'item_id')
  final String? itemId;
  @JsonKey(name: 'institution_name')
  final String? institutionName;
  @JsonKey(name: 'institution_id')
  final String? institutionId;
  @JsonKey(name: 'date_last_updated')
  final DateTime? dateLastUpdated;
  @JsonKey(name: 'accounts', defaultValue: <AccountAssets>[])
  final List<AccountAssets>? accounts;
  static const fromJsonFactory = _$AssetReportItemFromJson;
  static const toJsonFactory = _$AssetReportItemToJson;
  Map<String, dynamic> toJson() => _$AssetReportItemToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AssetReportItem &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)) &&
            (identical(other.institutionName, institutionName) ||
                const DeepCollectionEquality()
                    .equals(other.institutionName, institutionName)) &&
            (identical(other.institutionId, institutionId) ||
                const DeepCollectionEquality()
                    .equals(other.institutionId, institutionId)) &&
            (identical(other.dateLastUpdated, dateLastUpdated) ||
                const DeepCollectionEquality()
                    .equals(other.dateLastUpdated, dateLastUpdated)) &&
            (identical(other.accounts, accounts) ||
                const DeepCollectionEquality()
                    .equals(other.accounts, accounts)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(itemId) ^
      const DeepCollectionEquality().hash(institutionName) ^
      const DeepCollectionEquality().hash(institutionId) ^
      const DeepCollectionEquality().hash(dateLastUpdated) ^
      const DeepCollectionEquality().hash(accounts) ^
      runtimeType.hashCode;
}

extension $AssetReportItemExtension on AssetReportItem {
  AssetReportItem copyWith(
      {String? itemId,
      String? institutionName,
      String? institutionId,
      DateTime? dateLastUpdated,
      List<AccountAssets>? accounts}) {
    return AssetReportItem(
        itemId: itemId ?? this.itemId,
        institutionName: institutionName ?? this.institutionName,
        institutionId: institutionId ?? this.institutionId,
        dateLastUpdated: dateLastUpdated ?? this.dateLastUpdated,
        accounts: accounts ?? this.accounts);
  }
}

@JsonSerializable(explicitToJson: true)
class PaymentStatusUpdateWebhook {
  PaymentStatusUpdateWebhook({
    this.webhookType,
    this.webhookCode,
    this.paymentId,
    this.newPaymentStatus,
    this.oldPaymentStatus,
    this.originalReference,
    this.adjustedReference,
    this.originalStartDate,
    this.adjustedStartDate,
    this.timestamp,
    this.error,
  });

  factory PaymentStatusUpdateWebhook.fromJson(Map<String, dynamic> json) =>
      _$PaymentStatusUpdateWebhookFromJson(json);

  @JsonKey(name: 'webhook_type')
  final String? webhookType;
  @JsonKey(name: 'webhook_code')
  final String? webhookCode;
  @JsonKey(name: 'payment_id')
  final String? paymentId;
  @JsonKey(
      name: 'new_payment_status',
      toJson: paymentStatusUpdateWebhookNewPaymentStatusToJson,
      fromJson: paymentStatusUpdateWebhookNewPaymentStatusFromJson)
  final enums.PaymentStatusUpdateWebhookNewPaymentStatus? newPaymentStatus;
  @JsonKey(
      name: 'old_payment_status',
      toJson: paymentStatusUpdateWebhookOldPaymentStatusToJson,
      fromJson: paymentStatusUpdateWebhookOldPaymentStatusFromJson)
  final enums.PaymentStatusUpdateWebhookOldPaymentStatus? oldPaymentStatus;
  @JsonKey(name: 'original_reference')
  final String? originalReference;
  @JsonKey(name: 'adjusted_reference')
  final String? adjustedReference;
  @JsonKey(name: 'original_start_date', toJson: _dateToJson)
  final DateTime? originalStartDate;
  @JsonKey(name: 'adjusted_start_date', toJson: _dateToJson)
  final DateTime? adjustedStartDate;
  @JsonKey(name: 'timestamp')
  final DateTime? timestamp;
  @JsonKey(name: 'error')
  final Error? error;
  static const fromJsonFactory = _$PaymentStatusUpdateWebhookFromJson;
  static const toJsonFactory = _$PaymentStatusUpdateWebhookToJson;
  Map<String, dynamic> toJson() => _$PaymentStatusUpdateWebhookToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaymentStatusUpdateWebhook &&
            (identical(other.webhookType, webhookType) ||
                const DeepCollectionEquality()
                    .equals(other.webhookType, webhookType)) &&
            (identical(other.webhookCode, webhookCode) ||
                const DeepCollectionEquality()
                    .equals(other.webhookCode, webhookCode)) &&
            (identical(other.paymentId, paymentId) ||
                const DeepCollectionEquality()
                    .equals(other.paymentId, paymentId)) &&
            (identical(other.newPaymentStatus, newPaymentStatus) ||
                const DeepCollectionEquality()
                    .equals(other.newPaymentStatus, newPaymentStatus)) &&
            (identical(other.oldPaymentStatus, oldPaymentStatus) ||
                const DeepCollectionEquality()
                    .equals(other.oldPaymentStatus, oldPaymentStatus)) &&
            (identical(other.originalReference, originalReference) ||
                const DeepCollectionEquality()
                    .equals(other.originalReference, originalReference)) &&
            (identical(other.adjustedReference, adjustedReference) ||
                const DeepCollectionEquality()
                    .equals(other.adjustedReference, adjustedReference)) &&
            (identical(other.originalStartDate, originalStartDate) ||
                const DeepCollectionEquality()
                    .equals(other.originalStartDate, originalStartDate)) &&
            (identical(other.adjustedStartDate, adjustedStartDate) ||
                const DeepCollectionEquality()
                    .equals(other.adjustedStartDate, adjustedStartDate)) &&
            (identical(other.timestamp, timestamp) ||
                const DeepCollectionEquality()
                    .equals(other.timestamp, timestamp)) &&
            (identical(other.error, error) ||
                const DeepCollectionEquality().equals(other.error, error)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(webhookType) ^
      const DeepCollectionEquality().hash(webhookCode) ^
      const DeepCollectionEquality().hash(paymentId) ^
      const DeepCollectionEquality().hash(newPaymentStatus) ^
      const DeepCollectionEquality().hash(oldPaymentStatus) ^
      const DeepCollectionEquality().hash(originalReference) ^
      const DeepCollectionEquality().hash(adjustedReference) ^
      const DeepCollectionEquality().hash(originalStartDate) ^
      const DeepCollectionEquality().hash(adjustedStartDate) ^
      const DeepCollectionEquality().hash(timestamp) ^
      const DeepCollectionEquality().hash(error) ^
      runtimeType.hashCode;
}

extension $PaymentStatusUpdateWebhookExtension on PaymentStatusUpdateWebhook {
  PaymentStatusUpdateWebhook copyWith(
      {String? webhookType,
      String? webhookCode,
      String? paymentId,
      enums.PaymentStatusUpdateWebhookNewPaymentStatus? newPaymentStatus,
      enums.PaymentStatusUpdateWebhookOldPaymentStatus? oldPaymentStatus,
      String? originalReference,
      String? adjustedReference,
      DateTime? originalStartDate,
      DateTime? adjustedStartDate,
      DateTime? timestamp,
      Error? error}) {
    return PaymentStatusUpdateWebhook(
        webhookType: webhookType ?? this.webhookType,
        webhookCode: webhookCode ?? this.webhookCode,
        paymentId: paymentId ?? this.paymentId,
        newPaymentStatus: newPaymentStatus ?? this.newPaymentStatus,
        oldPaymentStatus: oldPaymentStatus ?? this.oldPaymentStatus,
        originalReference: originalReference ?? this.originalReference,
        adjustedReference: adjustedReference ?? this.adjustedReference,
        originalStartDate: originalStartDate ?? this.originalStartDate,
        adjustedStartDate: adjustedStartDate ?? this.adjustedStartDate,
        timestamp: timestamp ?? this.timestamp,
        error: error ?? this.error);
  }
}

@JsonSerializable(explicitToJson: true)
class Holding {
  Holding({
    this.accountId,
    this.securityId,
    this.institutionPrice,
    this.institutionPriceAsOf,
    this.institutionValue,
    this.costBasis,
    this.quantity,
    this.isoCurrencyCode,
    this.unofficialCurrencyCode,
  });

  factory Holding.fromJson(Map<String, dynamic> json) =>
      _$HoldingFromJson(json);

  @JsonKey(name: 'account_id')
  final String? accountId;
  @JsonKey(name: 'security_id')
  final String? securityId;
  @JsonKey(name: 'institution_price')
  final double? institutionPrice;
  @JsonKey(name: 'institution_price_as_of', toJson: _dateToJson)
  final DateTime? institutionPriceAsOf;
  @JsonKey(name: 'institution_value')
  final double? institutionValue;
  @JsonKey(name: 'cost_basis')
  final double? costBasis;
  @JsonKey(name: 'quantity')
  final double? quantity;
  @JsonKey(name: 'iso_currency_code')
  final String? isoCurrencyCode;
  @JsonKey(name: 'unofficial_currency_code')
  final String? unofficialCurrencyCode;
  static const fromJsonFactory = _$HoldingFromJson;
  static const toJsonFactory = _$HoldingToJson;
  Map<String, dynamic> toJson() => _$HoldingToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Holding &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.securityId, securityId) ||
                const DeepCollectionEquality()
                    .equals(other.securityId, securityId)) &&
            (identical(other.institutionPrice, institutionPrice) ||
                const DeepCollectionEquality()
                    .equals(other.institutionPrice, institutionPrice)) &&
            (identical(other.institutionPriceAsOf, institutionPriceAsOf) ||
                const DeepCollectionEquality().equals(
                    other.institutionPriceAsOf, institutionPriceAsOf)) &&
            (identical(other.institutionValue, institutionValue) ||
                const DeepCollectionEquality()
                    .equals(other.institutionValue, institutionValue)) &&
            (identical(other.costBasis, costBasis) ||
                const DeepCollectionEquality()
                    .equals(other.costBasis, costBasis)) &&
            (identical(other.quantity, quantity) ||
                const DeepCollectionEquality()
                    .equals(other.quantity, quantity)) &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)) &&
            (identical(other.unofficialCurrencyCode, unofficialCurrencyCode) ||
                const DeepCollectionEquality().equals(
                    other.unofficialCurrencyCode, unofficialCurrencyCode)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(securityId) ^
      const DeepCollectionEquality().hash(institutionPrice) ^
      const DeepCollectionEquality().hash(institutionPriceAsOf) ^
      const DeepCollectionEquality().hash(institutionValue) ^
      const DeepCollectionEquality().hash(costBasis) ^
      const DeepCollectionEquality().hash(quantity) ^
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      const DeepCollectionEquality().hash(unofficialCurrencyCode) ^
      runtimeType.hashCode;
}

extension $HoldingExtension on Holding {
  Holding copyWith(
      {String? accountId,
      String? securityId,
      double? institutionPrice,
      DateTime? institutionPriceAsOf,
      double? institutionValue,
      double? costBasis,
      double? quantity,
      String? isoCurrencyCode,
      String? unofficialCurrencyCode}) {
    return Holding(
        accountId: accountId ?? this.accountId,
        securityId: securityId ?? this.securityId,
        institutionPrice: institutionPrice ?? this.institutionPrice,
        institutionPriceAsOf: institutionPriceAsOf ?? this.institutionPriceAsOf,
        institutionValue: institutionValue ?? this.institutionValue,
        costBasis: costBasis ?? this.costBasis,
        quantity: quantity ?? this.quantity,
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode,
        unofficialCurrencyCode:
            unofficialCurrencyCode ?? this.unofficialCurrencyCode);
  }
}

@JsonSerializable(explicitToJson: true)
class Security {
  Security({
    this.securityId,
    this.isin,
    this.cusip,
    this.sedol,
    this.institutionSecurityId,
    this.institutionId,
    this.proxySecurityId,
    this.name,
    this.tickerSymbol,
    this.isCashEquivalent,
    this.type,
    this.closePrice,
    this.closePriceAsOf,
    this.isoCurrencyCode,
    this.unofficialCurrencyCode,
  });

  factory Security.fromJson(Map<String, dynamic> json) =>
      _$SecurityFromJson(json);

  @JsonKey(name: 'security_id')
  final String? securityId;
  @JsonKey(name: 'isin')
  final String? isin;
  @JsonKey(name: 'cusip')
  final String? cusip;
  @JsonKey(name: 'sedol')
  final String? sedol;
  @JsonKey(name: 'institution_security_id')
  final String? institutionSecurityId;
  @JsonKey(name: 'institution_id')
  final String? institutionId;
  @JsonKey(name: 'proxy_security_id')
  final String? proxySecurityId;
  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'ticker_symbol')
  final String? tickerSymbol;
  @JsonKey(name: 'is_cash_equivalent')
  final bool? isCashEquivalent;
  @JsonKey(name: 'type')
  final String? type;
  @JsonKey(name: 'close_price')
  final double? closePrice;
  @JsonKey(name: 'close_price_as_of', toJson: _dateToJson)
  final DateTime? closePriceAsOf;
  @JsonKey(name: 'iso_currency_code')
  final String? isoCurrencyCode;
  @JsonKey(name: 'unofficial_currency_code')
  final String? unofficialCurrencyCode;
  static const fromJsonFactory = _$SecurityFromJson;
  static const toJsonFactory = _$SecurityToJson;
  Map<String, dynamic> toJson() => _$SecurityToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Security &&
            (identical(other.securityId, securityId) ||
                const DeepCollectionEquality()
                    .equals(other.securityId, securityId)) &&
            (identical(other.isin, isin) ||
                const DeepCollectionEquality().equals(other.isin, isin)) &&
            (identical(other.cusip, cusip) ||
                const DeepCollectionEquality().equals(other.cusip, cusip)) &&
            (identical(other.sedol, sedol) ||
                const DeepCollectionEquality().equals(other.sedol, sedol)) &&
            (identical(other.institutionSecurityId, institutionSecurityId) ||
                const DeepCollectionEquality().equals(
                    other.institutionSecurityId, institutionSecurityId)) &&
            (identical(other.institutionId, institutionId) ||
                const DeepCollectionEquality()
                    .equals(other.institutionId, institutionId)) &&
            (identical(other.proxySecurityId, proxySecurityId) ||
                const DeepCollectionEquality()
                    .equals(other.proxySecurityId, proxySecurityId)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.tickerSymbol, tickerSymbol) ||
                const DeepCollectionEquality()
                    .equals(other.tickerSymbol, tickerSymbol)) &&
            (identical(other.isCashEquivalent, isCashEquivalent) ||
                const DeepCollectionEquality()
                    .equals(other.isCashEquivalent, isCashEquivalent)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.closePrice, closePrice) ||
                const DeepCollectionEquality()
                    .equals(other.closePrice, closePrice)) &&
            (identical(other.closePriceAsOf, closePriceAsOf) ||
                const DeepCollectionEquality()
                    .equals(other.closePriceAsOf, closePriceAsOf)) &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)) &&
            (identical(other.unofficialCurrencyCode, unofficialCurrencyCode) ||
                const DeepCollectionEquality().equals(
                    other.unofficialCurrencyCode, unofficialCurrencyCode)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(securityId) ^
      const DeepCollectionEquality().hash(isin) ^
      const DeepCollectionEquality().hash(cusip) ^
      const DeepCollectionEquality().hash(sedol) ^
      const DeepCollectionEquality().hash(institutionSecurityId) ^
      const DeepCollectionEquality().hash(institutionId) ^
      const DeepCollectionEquality().hash(proxySecurityId) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(tickerSymbol) ^
      const DeepCollectionEquality().hash(isCashEquivalent) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(closePrice) ^
      const DeepCollectionEquality().hash(closePriceAsOf) ^
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      const DeepCollectionEquality().hash(unofficialCurrencyCode) ^
      runtimeType.hashCode;
}

extension $SecurityExtension on Security {
  Security copyWith(
      {String? securityId,
      String? isin,
      String? cusip,
      String? sedol,
      String? institutionSecurityId,
      String? institutionId,
      String? proxySecurityId,
      String? name,
      String? tickerSymbol,
      bool? isCashEquivalent,
      String? type,
      double? closePrice,
      DateTime? closePriceAsOf,
      String? isoCurrencyCode,
      String? unofficialCurrencyCode}) {
    return Security(
        securityId: securityId ?? this.securityId,
        isin: isin ?? this.isin,
        cusip: cusip ?? this.cusip,
        sedol: sedol ?? this.sedol,
        institutionSecurityId:
            institutionSecurityId ?? this.institutionSecurityId,
        institutionId: institutionId ?? this.institutionId,
        proxySecurityId: proxySecurityId ?? this.proxySecurityId,
        name: name ?? this.name,
        tickerSymbol: tickerSymbol ?? this.tickerSymbol,
        isCashEquivalent: isCashEquivalent ?? this.isCashEquivalent,
        type: type ?? this.type,
        closePrice: closePrice ?? this.closePrice,
        closePriceAsOf: closePriceAsOf ?? this.closePriceAsOf,
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode,
        unofficialCurrencyCode:
            unofficialCurrencyCode ?? this.unofficialCurrencyCode);
  }
}

@JsonSerializable(explicitToJson: true)
class InvestmentTransaction {
  InvestmentTransaction({
    this.investmentTransactionId,
    this.cancelTransactionId,
    this.accountId,
    this.securityId,
    this.date,
    this.name,
    this.quantity,
    this.amount,
    this.price,
    this.fees,
    this.type,
    this.subtype,
    this.isoCurrencyCode,
    this.unofficialCurrencyCode,
  });

  factory InvestmentTransaction.fromJson(Map<String, dynamic> json) =>
      _$InvestmentTransactionFromJson(json);

  @JsonKey(name: 'investment_transaction_id')
  final String? investmentTransactionId;
  @JsonKey(name: 'cancel_transaction_id')
  final String? cancelTransactionId;
  @JsonKey(name: 'account_id')
  final String? accountId;
  @JsonKey(name: 'security_id')
  final String? securityId;
  @JsonKey(name: 'date', toJson: _dateToJson)
  final DateTime? date;
  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'quantity')
  final double? quantity;
  @JsonKey(name: 'amount')
  final double? amount;
  @JsonKey(name: 'price')
  final double? price;
  @JsonKey(name: 'fees')
  final double? fees;
  @JsonKey(
      name: 'type',
      toJson: investmentTransactionType$ToJson,
      fromJson: investmentTransactionType$FromJson)
  final enums.InvestmentTransactionType$? type;
  @JsonKey(
      name: 'subtype',
      toJson: investmentTransactionSubtypeToJson,
      fromJson: investmentTransactionSubtypeFromJson)
  final enums.InvestmentTransactionSubtype? subtype;
  @JsonKey(name: 'iso_currency_code')
  final String? isoCurrencyCode;
  @JsonKey(name: 'unofficial_currency_code')
  final String? unofficialCurrencyCode;
  static const fromJsonFactory = _$InvestmentTransactionFromJson;
  static const toJsonFactory = _$InvestmentTransactionToJson;
  Map<String, dynamic> toJson() => _$InvestmentTransactionToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvestmentTransaction &&
            (identical(
                    other.investmentTransactionId, investmentTransactionId) ||
                const DeepCollectionEquality().equals(
                    other.investmentTransactionId, investmentTransactionId)) &&
            (identical(other.cancelTransactionId, cancelTransactionId) ||
                const DeepCollectionEquality()
                    .equals(other.cancelTransactionId, cancelTransactionId)) &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.securityId, securityId) ||
                const DeepCollectionEquality()
                    .equals(other.securityId, securityId)) &&
            (identical(other.date, date) ||
                const DeepCollectionEquality().equals(other.date, date)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.quantity, quantity) ||
                const DeepCollectionEquality()
                    .equals(other.quantity, quantity)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.price, price) ||
                const DeepCollectionEquality().equals(other.price, price)) &&
            (identical(other.fees, fees) ||
                const DeepCollectionEquality().equals(other.fees, fees)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.subtype, subtype) ||
                const DeepCollectionEquality()
                    .equals(other.subtype, subtype)) &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)) &&
            (identical(other.unofficialCurrencyCode, unofficialCurrencyCode) ||
                const DeepCollectionEquality().equals(
                    other.unofficialCurrencyCode, unofficialCurrencyCode)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(investmentTransactionId) ^
      const DeepCollectionEquality().hash(cancelTransactionId) ^
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(securityId) ^
      const DeepCollectionEquality().hash(date) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(quantity) ^
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(price) ^
      const DeepCollectionEquality().hash(fees) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(subtype) ^
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      const DeepCollectionEquality().hash(unofficialCurrencyCode) ^
      runtimeType.hashCode;
}

extension $InvestmentTransactionExtension on InvestmentTransaction {
  InvestmentTransaction copyWith(
      {String? investmentTransactionId,
      String? cancelTransactionId,
      String? accountId,
      String? securityId,
      DateTime? date,
      String? name,
      double? quantity,
      double? amount,
      double? price,
      double? fees,
      enums.InvestmentTransactionType$? type,
      enums.InvestmentTransactionSubtype? subtype,
      String? isoCurrencyCode,
      String? unofficialCurrencyCode}) {
    return InvestmentTransaction(
        investmentTransactionId:
            investmentTransactionId ?? this.investmentTransactionId,
        cancelTransactionId: cancelTransactionId ?? this.cancelTransactionId,
        accountId: accountId ?? this.accountId,
        securityId: securityId ?? this.securityId,
        date: date ?? this.date,
        name: name ?? this.name,
        quantity: quantity ?? this.quantity,
        amount: amount ?? this.amount,
        price: price ?? this.price,
        fees: fees ?? this.fees,
        type: type ?? this.type,
        subtype: subtype ?? this.subtype,
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode,
        unofficialCurrencyCode:
            unofficialCurrencyCode ?? this.unofficialCurrencyCode);
  }
}

@JsonSerializable(explicitToJson: true)
class StandaloneInvestmentTransactionType {
  StandaloneInvestmentTransactionType({
    this.buy,
    this.sell,
    this.cancel,
    this.cash,
    this.fee,
    this.transfer,
  });

  factory StandaloneInvestmentTransactionType.fromJson(
          Map<String, dynamic> json) =>
      _$StandaloneInvestmentTransactionTypeFromJson(json);

  @JsonKey(name: 'buy')
  final String? buy;
  @JsonKey(name: 'sell')
  final String? sell;
  @JsonKey(name: 'cancel')
  final String? cancel;
  @JsonKey(name: 'cash')
  final String? cash;
  @JsonKey(name: 'fee')
  final String? fee;
  @JsonKey(name: 'transfer')
  final String? transfer;
  static const fromJsonFactory = _$StandaloneInvestmentTransactionTypeFromJson;
  static const toJsonFactory = _$StandaloneInvestmentTransactionTypeToJson;
  Map<String, dynamic> toJson() =>
      _$StandaloneInvestmentTransactionTypeToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is StandaloneInvestmentTransactionType &&
            (identical(other.buy, buy) ||
                const DeepCollectionEquality().equals(other.buy, buy)) &&
            (identical(other.sell, sell) ||
                const DeepCollectionEquality().equals(other.sell, sell)) &&
            (identical(other.cancel, cancel) ||
                const DeepCollectionEquality().equals(other.cancel, cancel)) &&
            (identical(other.cash, cash) ||
                const DeepCollectionEquality().equals(other.cash, cash)) &&
            (identical(other.fee, fee) ||
                const DeepCollectionEquality().equals(other.fee, fee)) &&
            (identical(other.transfer, transfer) ||
                const DeepCollectionEquality()
                    .equals(other.transfer, transfer)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(buy) ^
      const DeepCollectionEquality().hash(sell) ^
      const DeepCollectionEquality().hash(cancel) ^
      const DeepCollectionEquality().hash(cash) ^
      const DeepCollectionEquality().hash(fee) ^
      const DeepCollectionEquality().hash(transfer) ^
      runtimeType.hashCode;
}

extension $StandaloneInvestmentTransactionTypeExtension
    on StandaloneInvestmentTransactionType {
  StandaloneInvestmentTransactionType copyWith(
      {String? buy,
      String? sell,
      String? cancel,
      String? cash,
      String? fee,
      String? transfer}) {
    return StandaloneInvestmentTransactionType(
        buy: buy ?? this.buy,
        sell: sell ?? this.sell,
        cancel: cancel ?? this.cancel,
        cash: cash ?? this.cash,
        fee: fee ?? this.fee,
        transfer: transfer ?? this.transfer);
  }
}

@JsonSerializable(explicitToJson: true)
class AccountSubtypes {
  AccountSubtypes();

  factory AccountSubtypes.fromJson(Map<String, dynamic> json) =>
      _$AccountSubtypesFromJson(json);

  static const fromJsonFactory = _$AccountSubtypesFromJson;
  static const toJsonFactory = _$AccountSubtypesToJson;
  Map<String, dynamic> toJson() => _$AccountSubtypesToJson(this);

  @override
  int get hashCode => runtimeType.hashCode;
}

@JsonSerializable(explicitToJson: true)
class UserPermissionRevokedWebhook {
  UserPermissionRevokedWebhook({
    this.webhookType,
    this.webhookCode,
    this.itemId,
    this.error,
  });

  factory UserPermissionRevokedWebhook.fromJson(Map<String, dynamic> json) =>
      _$UserPermissionRevokedWebhookFromJson(json);

  @JsonKey(name: 'webhook_type')
  final String? webhookType;
  @JsonKey(name: 'webhook_code')
  final String? webhookCode;
  @JsonKey(name: 'item_id')
  final String? itemId;
  @JsonKey(name: 'error')
  final Error? error;
  static const fromJsonFactory = _$UserPermissionRevokedWebhookFromJson;
  static const toJsonFactory = _$UserPermissionRevokedWebhookToJson;
  Map<String, dynamic> toJson() => _$UserPermissionRevokedWebhookToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is UserPermissionRevokedWebhook &&
            (identical(other.webhookType, webhookType) ||
                const DeepCollectionEquality()
                    .equals(other.webhookType, webhookType)) &&
            (identical(other.webhookCode, webhookCode) ||
                const DeepCollectionEquality()
                    .equals(other.webhookCode, webhookCode)) &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)) &&
            (identical(other.error, error) ||
                const DeepCollectionEquality().equals(other.error, error)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(webhookType) ^
      const DeepCollectionEquality().hash(webhookCode) ^
      const DeepCollectionEquality().hash(itemId) ^
      const DeepCollectionEquality().hash(error) ^
      runtimeType.hashCode;
}

extension $UserPermissionRevokedWebhookExtension
    on UserPermissionRevokedWebhook {
  UserPermissionRevokedWebhook copyWith(
      {String? webhookType,
      String? webhookCode,
      String? itemId,
      Error? error}) {
    return UserPermissionRevokedWebhook(
        webhookType: webhookType ?? this.webhookType,
        webhookCode: webhookCode ?? this.webhookCode,
        itemId: itemId ?? this.itemId,
        error: error ?? this.error);
  }
}

@JsonSerializable(explicitToJson: true)
class DepositSwitchGetRequest {
  DepositSwitchGetRequest({
    this.clientId,
    this.secret,
    this.depositSwitchId,
  });

  factory DepositSwitchGetRequest.fromJson(Map<String, dynamic> json) =>
      _$DepositSwitchGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'deposit_switch_id')
  final String? depositSwitchId;
  static const fromJsonFactory = _$DepositSwitchGetRequestFromJson;
  static const toJsonFactory = _$DepositSwitchGetRequestToJson;
  Map<String, dynamic> toJson() => _$DepositSwitchGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is DepositSwitchGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.depositSwitchId, depositSwitchId) ||
                const DeepCollectionEquality()
                    .equals(other.depositSwitchId, depositSwitchId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(depositSwitchId) ^
      runtimeType.hashCode;
}

extension $DepositSwitchGetRequestExtension on DepositSwitchGetRequest {
  DepositSwitchGetRequest copyWith(
      {String? clientId, String? secret, String? depositSwitchId}) {
    return DepositSwitchGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        depositSwitchId: depositSwitchId ?? this.depositSwitchId);
  }
}

@JsonSerializable(explicitToJson: true)
class DepositSwitchGetResponse {
  DepositSwitchGetResponse({
    this.depositSwitchId,
    this.targetAccountId,
    this.targetItemId,
    this.state,
    this.switchMethod,
    this.accountHasMultipleAllocations,
    this.isAllocatedRemainder,
    this.percentAllocated,
    this.amountAllocated,
    this.employerName,
    this.employerId,
    this.institutionName,
    this.institutionId,
    this.dateCreated,
    this.dateCompleted,
    this.requestId,
  });

  factory DepositSwitchGetResponse.fromJson(Map<String, dynamic> json) =>
      _$DepositSwitchGetResponseFromJson(json);

  @JsonKey(name: 'deposit_switch_id')
  final String? depositSwitchId;
  @JsonKey(name: 'target_account_id')
  final String? targetAccountId;
  @JsonKey(name: 'target_item_id')
  final String? targetItemId;
  @JsonKey(
      name: 'state',
      toJson: depositSwitchGetResponseStateToJson,
      fromJson: depositSwitchGetResponseStateFromJson)
  final enums.DepositSwitchGetResponseState? state;
  @JsonKey(
      name: 'switch_method',
      toJson: depositSwitchGetResponseSwitchMethodToJson,
      fromJson: depositSwitchGetResponseSwitchMethodFromJson)
  final enums.DepositSwitchGetResponseSwitchMethod? switchMethod;
  @JsonKey(name: 'account_has_multiple_allocations')
  final bool? accountHasMultipleAllocations;
  @JsonKey(name: 'is_allocated_remainder')
  final bool? isAllocatedRemainder;
  @JsonKey(name: 'percent_allocated')
  final double? percentAllocated;
  @JsonKey(name: 'amount_allocated')
  final double? amountAllocated;
  @JsonKey(name: 'employer_name')
  final String? employerName;
  @JsonKey(name: 'employer_id')
  final String? employerId;
  @JsonKey(name: 'institution_name')
  final String? institutionName;
  @JsonKey(name: 'institution_id')
  final String? institutionId;
  @JsonKey(name: 'date_created', toJson: _dateToJson)
  final DateTime? dateCreated;
  @JsonKey(name: 'date_completed', toJson: _dateToJson)
  final DateTime? dateCompleted;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$DepositSwitchGetResponseFromJson;
  static const toJsonFactory = _$DepositSwitchGetResponseToJson;
  Map<String, dynamic> toJson() => _$DepositSwitchGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is DepositSwitchGetResponse &&
            (identical(other.depositSwitchId, depositSwitchId) ||
                const DeepCollectionEquality()
                    .equals(other.depositSwitchId, depositSwitchId)) &&
            (identical(other.targetAccountId, targetAccountId) ||
                const DeepCollectionEquality()
                    .equals(other.targetAccountId, targetAccountId)) &&
            (identical(other.targetItemId, targetItemId) ||
                const DeepCollectionEquality()
                    .equals(other.targetItemId, targetItemId)) &&
            (identical(other.state, state) ||
                const DeepCollectionEquality().equals(other.state, state)) &&
            (identical(other.switchMethod, switchMethod) ||
                const DeepCollectionEquality()
                    .equals(other.switchMethod, switchMethod)) &&
            (identical(other.accountHasMultipleAllocations,
                    accountHasMultipleAllocations) ||
                const DeepCollectionEquality().equals(
                    other.accountHasMultipleAllocations,
                    accountHasMultipleAllocations)) &&
            (identical(other.isAllocatedRemainder, isAllocatedRemainder) ||
                const DeepCollectionEquality().equals(
                    other.isAllocatedRemainder, isAllocatedRemainder)) &&
            (identical(other.percentAllocated, percentAllocated) ||
                const DeepCollectionEquality()
                    .equals(other.percentAllocated, percentAllocated)) &&
            (identical(other.amountAllocated, amountAllocated) ||
                const DeepCollectionEquality()
                    .equals(other.amountAllocated, amountAllocated)) &&
            (identical(other.employerName, employerName) ||
                const DeepCollectionEquality()
                    .equals(other.employerName, employerName)) &&
            (identical(other.employerId, employerId) ||
                const DeepCollectionEquality()
                    .equals(other.employerId, employerId)) &&
            (identical(other.institutionName, institutionName) ||
                const DeepCollectionEquality()
                    .equals(other.institutionName, institutionName)) &&
            (identical(other.institutionId, institutionId) ||
                const DeepCollectionEquality()
                    .equals(other.institutionId, institutionId)) &&
            (identical(other.dateCreated, dateCreated) ||
                const DeepCollectionEquality()
                    .equals(other.dateCreated, dateCreated)) &&
            (identical(other.dateCompleted, dateCompleted) ||
                const DeepCollectionEquality()
                    .equals(other.dateCompleted, dateCompleted)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(depositSwitchId) ^
      const DeepCollectionEquality().hash(targetAccountId) ^
      const DeepCollectionEquality().hash(targetItemId) ^
      const DeepCollectionEquality().hash(state) ^
      const DeepCollectionEquality().hash(switchMethod) ^
      const DeepCollectionEquality().hash(accountHasMultipleAllocations) ^
      const DeepCollectionEquality().hash(isAllocatedRemainder) ^
      const DeepCollectionEquality().hash(percentAllocated) ^
      const DeepCollectionEquality().hash(amountAllocated) ^
      const DeepCollectionEquality().hash(employerName) ^
      const DeepCollectionEquality().hash(employerId) ^
      const DeepCollectionEquality().hash(institutionName) ^
      const DeepCollectionEquality().hash(institutionId) ^
      const DeepCollectionEquality().hash(dateCreated) ^
      const DeepCollectionEquality().hash(dateCompleted) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $DepositSwitchGetResponseExtension on DepositSwitchGetResponse {
  DepositSwitchGetResponse copyWith(
      {String? depositSwitchId,
      String? targetAccountId,
      String? targetItemId,
      enums.DepositSwitchGetResponseState? state,
      enums.DepositSwitchGetResponseSwitchMethod? switchMethod,
      bool? accountHasMultipleAllocations,
      bool? isAllocatedRemainder,
      double? percentAllocated,
      double? amountAllocated,
      String? employerName,
      String? employerId,
      String? institutionName,
      String? institutionId,
      DateTime? dateCreated,
      DateTime? dateCompleted,
      String? requestId}) {
    return DepositSwitchGetResponse(
        depositSwitchId: depositSwitchId ?? this.depositSwitchId,
        targetAccountId: targetAccountId ?? this.targetAccountId,
        targetItemId: targetItemId ?? this.targetItemId,
        state: state ?? this.state,
        switchMethod: switchMethod ?? this.switchMethod,
        accountHasMultipleAllocations:
            accountHasMultipleAllocations ?? this.accountHasMultipleAllocations,
        isAllocatedRemainder: isAllocatedRemainder ?? this.isAllocatedRemainder,
        percentAllocated: percentAllocated ?? this.percentAllocated,
        amountAllocated: amountAllocated ?? this.amountAllocated,
        employerName: employerName ?? this.employerName,
        employerId: employerId ?? this.employerId,
        institutionName: institutionName ?? this.institutionName,
        institutionId: institutionId ?? this.institutionId,
        dateCreated: dateCreated ?? this.dateCreated,
        dateCompleted: dateCompleted ?? this.dateCompleted,
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class DepositSwitchStateUpdateWebhook {
  DepositSwitchStateUpdateWebhook({
    this.webhookType,
    this.webhookCode,
    this.state,
    this.depositSwitchId,
  });

  factory DepositSwitchStateUpdateWebhook.fromJson(Map<String, dynamic> json) =>
      _$DepositSwitchStateUpdateWebhookFromJson(json);

  @JsonKey(name: 'webhook_type')
  final String? webhookType;
  @JsonKey(name: 'webhook_code')
  final String? webhookCode;
  @JsonKey(name: 'state')
  final String? state;
  @JsonKey(name: 'deposit_switch_id')
  final String? depositSwitchId;
  static const fromJsonFactory = _$DepositSwitchStateUpdateWebhookFromJson;
  static const toJsonFactory = _$DepositSwitchStateUpdateWebhookToJson;
  Map<String, dynamic> toJson() =>
      _$DepositSwitchStateUpdateWebhookToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is DepositSwitchStateUpdateWebhook &&
            (identical(other.webhookType, webhookType) ||
                const DeepCollectionEquality()
                    .equals(other.webhookType, webhookType)) &&
            (identical(other.webhookCode, webhookCode) ||
                const DeepCollectionEquality()
                    .equals(other.webhookCode, webhookCode)) &&
            (identical(other.state, state) ||
                const DeepCollectionEquality().equals(other.state, state)) &&
            (identical(other.depositSwitchId, depositSwitchId) ||
                const DeepCollectionEquality()
                    .equals(other.depositSwitchId, depositSwitchId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(webhookType) ^
      const DeepCollectionEquality().hash(webhookCode) ^
      const DeepCollectionEquality().hash(state) ^
      const DeepCollectionEquality().hash(depositSwitchId) ^
      runtimeType.hashCode;
}

extension $DepositSwitchStateUpdateWebhookExtension
    on DepositSwitchStateUpdateWebhook {
  DepositSwitchStateUpdateWebhook copyWith(
      {String? webhookType,
      String? webhookCode,
      String? state,
      String? depositSwitchId}) {
    return DepositSwitchStateUpdateWebhook(
        webhookType: webhookType ?? this.webhookType,
        webhookCode: webhookCode ?? this.webhookCode,
        state: state ?? this.state,
        depositSwitchId: depositSwitchId ?? this.depositSwitchId);
  }
}

@JsonSerializable(explicitToJson: true)
class AssetReportAuditCopyGetRequest {
  AssetReportAuditCopyGetRequest({
    this.clientId,
    this.secret,
    this.auditCopyToken,
  });

  factory AssetReportAuditCopyGetRequest.fromJson(Map<String, dynamic> json) =>
      _$AssetReportAuditCopyGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'audit_copy_token')
  final String? auditCopyToken;
  static const fromJsonFactory = _$AssetReportAuditCopyGetRequestFromJson;
  static const toJsonFactory = _$AssetReportAuditCopyGetRequestToJson;
  Map<String, dynamic> toJson() => _$AssetReportAuditCopyGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AssetReportAuditCopyGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.auditCopyToken, auditCopyToken) ||
                const DeepCollectionEquality()
                    .equals(other.auditCopyToken, auditCopyToken)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(auditCopyToken) ^
      runtimeType.hashCode;
}

extension $AssetReportAuditCopyGetRequestExtension
    on AssetReportAuditCopyGetRequest {
  AssetReportAuditCopyGetRequest copyWith(
      {String? clientId, String? secret, String? auditCopyToken}) {
    return AssetReportAuditCopyGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        auditCopyToken: auditCopyToken ?? this.auditCopyToken);
  }
}

@JsonSerializable(explicitToJson: true)
class TransferGetRequest {
  TransferGetRequest({
    this.clientId,
    this.secret,
    this.transferId,
  });

  factory TransferGetRequest.fromJson(Map<String, dynamic> json) =>
      _$TransferGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'transfer_id')
  final String? transferId;
  static const fromJsonFactory = _$TransferGetRequestFromJson;
  static const toJsonFactory = _$TransferGetRequestToJson;
  Map<String, dynamic> toJson() => _$TransferGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.transferId, transferId) ||
                const DeepCollectionEquality()
                    .equals(other.transferId, transferId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(transferId) ^
      runtimeType.hashCode;
}

extension $TransferGetRequestExtension on TransferGetRequest {
  TransferGetRequest copyWith(
      {String? clientId, String? secret, String? transferId}) {
    return TransferGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        transferId: transferId ?? this.transferId);
  }
}

@JsonSerializable(explicitToJson: true)
class BankTransferGetRequest {
  BankTransferGetRequest({
    this.clientId,
    this.secret,
    this.bankTransferId,
  });

  factory BankTransferGetRequest.fromJson(Map<String, dynamic> json) =>
      _$BankTransferGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'bank_transfer_id')
  final String? bankTransferId;
  static const fromJsonFactory = _$BankTransferGetRequestFromJson;
  static const toJsonFactory = _$BankTransferGetRequestToJson;
  Map<String, dynamic> toJson() => _$BankTransferGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BankTransferGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.bankTransferId, bankTransferId) ||
                const DeepCollectionEquality()
                    .equals(other.bankTransferId, bankTransferId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(bankTransferId) ^
      runtimeType.hashCode;
}

extension $BankTransferGetRequestExtension on BankTransferGetRequest {
  BankTransferGetRequest copyWith(
      {String? clientId, String? secret, String? bankTransferId}) {
    return BankTransferGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        bankTransferId: bankTransferId ?? this.bankTransferId);
  }
}

@JsonSerializable(explicitToJson: true)
class TransferGetResponse {
  TransferGetResponse({
    this.transfer,
    this.requestId,
  });

  factory TransferGetResponse.fromJson(Map<String, dynamic> json) =>
      _$TransferGetResponseFromJson(json);

  @JsonKey(name: 'transfer')
  final Transfer? transfer;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$TransferGetResponseFromJson;
  static const toJsonFactory = _$TransferGetResponseToJson;
  Map<String, dynamic> toJson() => _$TransferGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferGetResponse &&
            (identical(other.transfer, transfer) ||
                const DeepCollectionEquality()
                    .equals(other.transfer, transfer)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(transfer) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $TransferGetResponseExtension on TransferGetResponse {
  TransferGetResponse copyWith({Transfer? transfer, String? requestId}) {
    return TransferGetResponse(
        transfer: transfer ?? this.transfer,
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class BankTransferGetResponse {
  BankTransferGetResponse({
    this.bankTransfer,
    this.requestId,
  });

  factory BankTransferGetResponse.fromJson(Map<String, dynamic> json) =>
      _$BankTransferGetResponseFromJson(json);

  @JsonKey(name: 'bank_transfer')
  final BankTransfer? bankTransfer;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$BankTransferGetResponseFromJson;
  static const toJsonFactory = _$BankTransferGetResponseToJson;
  Map<String, dynamic> toJson() => _$BankTransferGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BankTransferGetResponse &&
            (identical(other.bankTransfer, bankTransfer) ||
                const DeepCollectionEquality()
                    .equals(other.bankTransfer, bankTransfer)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(bankTransfer) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $BankTransferGetResponseExtension on BankTransferGetResponse {
  BankTransferGetResponse copyWith(
      {BankTransfer? bankTransfer, String? requestId}) {
    return BankTransferGetResponse(
        bankTransfer: bankTransfer ?? this.bankTransfer,
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class Transfer {
  Transfer({
    this.id,
    this.achClass,
    this.accountId,
    this.type,
    this.user,
    this.amount,
    this.description,
    this.created,
    this.status,
    this.sweepStatus,
    this.network,
    this.cancellable,
    this.failureReason,
    this.metadata,
    this.originationAccountId,
  });

  factory Transfer.fromJson(Map<String, dynamic> json) =>
      _$TransferFromJson(json);

  @JsonKey(name: 'id')
  final String? id;
  @JsonKey(
      name: 'ach_class', toJson: aCHClassToJson, fromJson: aCHClassFromJson)
  final enums.ACHClass? achClass;
  @JsonKey(name: 'account_id')
  final String? accountId;
  @JsonKey(
      name: 'type', toJson: transferTypeToJson, fromJson: transferTypeFromJson)
  final enums.TransferType? type;
  @JsonKey(name: 'user')
  final TransferUserInResponse? user;
  @JsonKey(name: 'amount')
  final String? amount;
  @JsonKey(name: 'description')
  final String? description;
  @JsonKey(name: 'created')
  final DateTime? created;
  @JsonKey(
      name: 'status',
      toJson: transferStatusToJson,
      fromJson: transferStatusFromJson)
  final enums.TransferStatus? status;
  @JsonKey(
      name: 'sweep_status',
      toJson: transferSweepStatusToJson,
      fromJson: transferSweepStatusFromJson)
  final enums.TransferSweepStatus? sweepStatus;
  @JsonKey(
      name: 'network',
      toJson: transferNetworkToJson,
      fromJson: transferNetworkFromJson)
  final enums.TransferNetwork? network;
  @JsonKey(name: 'cancellable')
  final bool? cancellable;
  @JsonKey(name: 'failure_reason')
  final TransferFailure? failureReason;
  @JsonKey(name: 'metadata')
  final TransferMetadata? metadata;
  @JsonKey(name: 'origination_account_id')
  final String? originationAccountId;
  static const fromJsonFactory = _$TransferFromJson;
  static const toJsonFactory = _$TransferToJson;
  Map<String, dynamic> toJson() => _$TransferToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Transfer &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.achClass, achClass) ||
                const DeepCollectionEquality()
                    .equals(other.achClass, achClass)) &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.user, user) ||
                const DeepCollectionEquality().equals(other.user, user)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.created, created) ||
                const DeepCollectionEquality()
                    .equals(other.created, created)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.sweepStatus, sweepStatus) ||
                const DeepCollectionEquality()
                    .equals(other.sweepStatus, sweepStatus)) &&
            (identical(other.network, network) ||
                const DeepCollectionEquality()
                    .equals(other.network, network)) &&
            (identical(other.cancellable, cancellable) ||
                const DeepCollectionEquality()
                    .equals(other.cancellable, cancellable)) &&
            (identical(other.failureReason, failureReason) ||
                const DeepCollectionEquality()
                    .equals(other.failureReason, failureReason)) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality()
                    .equals(other.metadata, metadata)) &&
            (identical(other.originationAccountId, originationAccountId) ||
                const DeepCollectionEquality()
                    .equals(other.originationAccountId, originationAccountId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(achClass) ^
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(user) ^
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(created) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(sweepStatus) ^
      const DeepCollectionEquality().hash(network) ^
      const DeepCollectionEquality().hash(cancellable) ^
      const DeepCollectionEquality().hash(failureReason) ^
      const DeepCollectionEquality().hash(metadata) ^
      const DeepCollectionEquality().hash(originationAccountId) ^
      runtimeType.hashCode;
}

extension $TransferExtension on Transfer {
  Transfer copyWith(
      {String? id,
      enums.ACHClass? achClass,
      String? accountId,
      enums.TransferType? type,
      TransferUserInResponse? user,
      String? amount,
      String? description,
      DateTime? created,
      enums.TransferStatus? status,
      enums.TransferSweepStatus? sweepStatus,
      enums.TransferNetwork? network,
      bool? cancellable,
      TransferFailure? failureReason,
      TransferMetadata? metadata,
      String? originationAccountId}) {
    return Transfer(
        id: id ?? this.id,
        achClass: achClass ?? this.achClass,
        accountId: accountId ?? this.accountId,
        type: type ?? this.type,
        user: user ?? this.user,
        amount: amount ?? this.amount,
        description: description ?? this.description,
        created: created ?? this.created,
        status: status ?? this.status,
        sweepStatus: sweepStatus ?? this.sweepStatus,
        network: network ?? this.network,
        cancellable: cancellable ?? this.cancellable,
        failureReason: failureReason ?? this.failureReason,
        metadata: metadata ?? this.metadata,
        originationAccountId:
            originationAccountId ?? this.originationAccountId);
  }
}

@JsonSerializable(explicitToJson: true)
class BankTransfer {
  BankTransfer({
    this.id,
    this.achClass,
    this.accountId,
    this.type,
    this.user,
    this.amount,
    this.isoCurrencyCode,
    this.description,
    this.created,
    this.status,
    this.network,
    this.cancellable,
    this.failureReason,
    this.customTag,
    this.metadata,
    this.originationAccountId,
    this.direction,
  });

  factory BankTransfer.fromJson(Map<String, dynamic> json) =>
      _$BankTransferFromJson(json);

  @JsonKey(name: 'id')
  final String? id;
  @JsonKey(
      name: 'ach_class', toJson: aCHClassToJson, fromJson: aCHClassFromJson)
  final enums.ACHClass? achClass;
  @JsonKey(name: 'account_id')
  final String? accountId;
  @JsonKey(
      name: 'type',
      toJson: bankTransferTypeToJson,
      fromJson: bankTransferTypeFromJson)
  final enums.BankTransferType? type;
  @JsonKey(name: 'user')
  final BankTransferUser? user;
  @JsonKey(name: 'amount')
  final String? amount;
  @JsonKey(name: 'iso_currency_code')
  final String? isoCurrencyCode;
  @JsonKey(name: 'description')
  final String? description;
  @JsonKey(name: 'created')
  final DateTime? created;
  @JsonKey(
      name: 'status',
      toJson: bankTransferStatusToJson,
      fromJson: bankTransferStatusFromJson)
  final enums.BankTransferStatus? status;
  @JsonKey(
      name: 'network',
      toJson: bankTransferNetworkToJson,
      fromJson: bankTransferNetworkFromJson)
  final enums.BankTransferNetwork? network;
  @JsonKey(name: 'cancellable')
  final bool? cancellable;
  @JsonKey(name: 'failure_reason')
  final BankTransferFailure? failureReason;
  @JsonKey(name: 'custom_tag')
  final String? customTag;
  @JsonKey(name: 'metadata')
  final BankTransferMetadata? metadata;
  @JsonKey(name: 'origination_account_id')
  final String? originationAccountId;
  @JsonKey(
      name: 'direction',
      toJson: bankTransferDirectionToJson,
      fromJson: bankTransferDirectionFromJson)
  final enums.BankTransferDirection? direction;
  static const fromJsonFactory = _$BankTransferFromJson;
  static const toJsonFactory = _$BankTransferToJson;
  Map<String, dynamic> toJson() => _$BankTransferToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BankTransfer &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.achClass, achClass) ||
                const DeepCollectionEquality()
                    .equals(other.achClass, achClass)) &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.user, user) ||
                const DeepCollectionEquality().equals(other.user, user)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.created, created) ||
                const DeepCollectionEquality()
                    .equals(other.created, created)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.network, network) ||
                const DeepCollectionEquality()
                    .equals(other.network, network)) &&
            (identical(other.cancellable, cancellable) ||
                const DeepCollectionEquality()
                    .equals(other.cancellable, cancellable)) &&
            (identical(other.failureReason, failureReason) ||
                const DeepCollectionEquality()
                    .equals(other.failureReason, failureReason)) &&
            (identical(other.customTag, customTag) ||
                const DeepCollectionEquality()
                    .equals(other.customTag, customTag)) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality()
                    .equals(other.metadata, metadata)) &&
            (identical(other.originationAccountId, originationAccountId) ||
                const DeepCollectionEquality().equals(
                    other.originationAccountId, originationAccountId)) &&
            (identical(other.direction, direction) ||
                const DeepCollectionEquality()
                    .equals(other.direction, direction)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(achClass) ^
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(user) ^
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(created) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(network) ^
      const DeepCollectionEquality().hash(cancellable) ^
      const DeepCollectionEquality().hash(failureReason) ^
      const DeepCollectionEquality().hash(customTag) ^
      const DeepCollectionEquality().hash(metadata) ^
      const DeepCollectionEquality().hash(originationAccountId) ^
      const DeepCollectionEquality().hash(direction) ^
      runtimeType.hashCode;
}

extension $BankTransferExtension on BankTransfer {
  BankTransfer copyWith(
      {String? id,
      enums.ACHClass? achClass,
      String? accountId,
      enums.BankTransferType? type,
      BankTransferUser? user,
      String? amount,
      String? isoCurrencyCode,
      String? description,
      DateTime? created,
      enums.BankTransferStatus? status,
      enums.BankTransferNetwork? network,
      bool? cancellable,
      BankTransferFailure? failureReason,
      String? customTag,
      BankTransferMetadata? metadata,
      String? originationAccountId,
      enums.BankTransferDirection? direction}) {
    return BankTransfer(
        id: id ?? this.id,
        achClass: achClass ?? this.achClass,
        accountId: accountId ?? this.accountId,
        type: type ?? this.type,
        user: user ?? this.user,
        amount: amount ?? this.amount,
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode,
        description: description ?? this.description,
        created: created ?? this.created,
        status: status ?? this.status,
        network: network ?? this.network,
        cancellable: cancellable ?? this.cancellable,
        failureReason: failureReason ?? this.failureReason,
        customTag: customTag ?? this.customTag,
        metadata: metadata ?? this.metadata,
        originationAccountId: originationAccountId ?? this.originationAccountId,
        direction: direction ?? this.direction);
  }
}

@JsonSerializable(explicitToJson: true)
class TransferIntentGetFailureReason {
  TransferIntentGetFailureReason({
    this.errorType,
    this.errorCode,
    this.errorMessage,
  });

  factory TransferIntentGetFailureReason.fromJson(Map<String, dynamic> json) =>
      _$TransferIntentGetFailureReasonFromJson(json);

  @JsonKey(name: 'error_type')
  final String? errorType;
  @JsonKey(name: 'error_code')
  final String? errorCode;
  @JsonKey(name: 'error_message')
  final String? errorMessage;
  static const fromJsonFactory = _$TransferIntentGetFailureReasonFromJson;
  static const toJsonFactory = _$TransferIntentGetFailureReasonToJson;
  Map<String, dynamic> toJson() => _$TransferIntentGetFailureReasonToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferIntentGetFailureReason &&
            (identical(other.errorType, errorType) ||
                const DeepCollectionEquality()
                    .equals(other.errorType, errorType)) &&
            (identical(other.errorCode, errorCode) ||
                const DeepCollectionEquality()
                    .equals(other.errorCode, errorCode)) &&
            (identical(other.errorMessage, errorMessage) ||
                const DeepCollectionEquality()
                    .equals(other.errorMessage, errorMessage)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(errorType) ^
      const DeepCollectionEquality().hash(errorCode) ^
      const DeepCollectionEquality().hash(errorMessage) ^
      runtimeType.hashCode;
}

extension $TransferIntentGetFailureReasonExtension
    on TransferIntentGetFailureReason {
  TransferIntentGetFailureReason copyWith(
      {String? errorType, String? errorCode, String? errorMessage}) {
    return TransferIntentGetFailureReason(
        errorType: errorType ?? this.errorType,
        errorCode: errorCode ?? this.errorCode,
        errorMessage: errorMessage ?? this.errorMessage);
  }
}

@JsonSerializable(explicitToJson: true)
class TransferUserInRequest {
  TransferUserInRequest({
    this.legalName,
    this.phoneNumber,
    this.emailAddress,
    this.address,
  });

  factory TransferUserInRequest.fromJson(Map<String, dynamic> json) =>
      _$TransferUserInRequestFromJson(json);

  @JsonKey(name: 'legal_name')
  final String? legalName;
  @JsonKey(name: 'phone_number')
  final String? phoneNumber;
  @JsonKey(name: 'email_address')
  final String? emailAddress;
  @JsonKey(name: 'address')
  final TransferUserAddressInRequest? address;
  static const fromJsonFactory = _$TransferUserInRequestFromJson;
  static const toJsonFactory = _$TransferUserInRequestToJson;
  Map<String, dynamic> toJson() => _$TransferUserInRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferUserInRequest &&
            (identical(other.legalName, legalName) ||
                const DeepCollectionEquality()
                    .equals(other.legalName, legalName)) &&
            (identical(other.phoneNumber, phoneNumber) ||
                const DeepCollectionEquality()
                    .equals(other.phoneNumber, phoneNumber)) &&
            (identical(other.emailAddress, emailAddress) ||
                const DeepCollectionEquality()
                    .equals(other.emailAddress, emailAddress)) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality().equals(other.address, address)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(legalName) ^
      const DeepCollectionEquality().hash(phoneNumber) ^
      const DeepCollectionEquality().hash(emailAddress) ^
      const DeepCollectionEquality().hash(address) ^
      runtimeType.hashCode;
}

extension $TransferUserInRequestExtension on TransferUserInRequest {
  TransferUserInRequest copyWith(
      {String? legalName,
      String? phoneNumber,
      String? emailAddress,
      TransferUserAddressInRequest? address}) {
    return TransferUserInRequest(
        legalName: legalName ?? this.legalName,
        phoneNumber: phoneNumber ?? this.phoneNumber,
        emailAddress: emailAddress ?? this.emailAddress,
        address: address ?? this.address);
  }
}

@JsonSerializable(explicitToJson: true)
class TransferUserInResponse {
  TransferUserInResponse({
    this.legalName,
    this.phoneNumber,
    this.emailAddress,
    this.address,
  });

  factory TransferUserInResponse.fromJson(Map<String, dynamic> json) =>
      _$TransferUserInResponseFromJson(json);

  @JsonKey(name: 'legal_name')
  final String? legalName;
  @JsonKey(name: 'phone_number')
  final String? phoneNumber;
  @JsonKey(name: 'email_address')
  final String? emailAddress;
  @JsonKey(name: 'address')
  final TransferUserAddressInResponse? address;
  static const fromJsonFactory = _$TransferUserInResponseFromJson;
  static const toJsonFactory = _$TransferUserInResponseToJson;
  Map<String, dynamic> toJson() => _$TransferUserInResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferUserInResponse &&
            (identical(other.legalName, legalName) ||
                const DeepCollectionEquality()
                    .equals(other.legalName, legalName)) &&
            (identical(other.phoneNumber, phoneNumber) ||
                const DeepCollectionEquality()
                    .equals(other.phoneNumber, phoneNumber)) &&
            (identical(other.emailAddress, emailAddress) ||
                const DeepCollectionEquality()
                    .equals(other.emailAddress, emailAddress)) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality().equals(other.address, address)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(legalName) ^
      const DeepCollectionEquality().hash(phoneNumber) ^
      const DeepCollectionEquality().hash(emailAddress) ^
      const DeepCollectionEquality().hash(address) ^
      runtimeType.hashCode;
}

extension $TransferUserInResponseExtension on TransferUserInResponse {
  TransferUserInResponse copyWith(
      {String? legalName,
      String? phoneNumber,
      String? emailAddress,
      TransferUserAddressInResponse? address}) {
    return TransferUserInResponse(
        legalName: legalName ?? this.legalName,
        phoneNumber: phoneNumber ?? this.phoneNumber,
        emailAddress: emailAddress ?? this.emailAddress,
        address: address ?? this.address);
  }
}

@JsonSerializable(explicitToJson: true)
class TransferUserAddressInRequest {
  TransferUserAddressInRequest({
    this.street,
    this.city,
    this.region,
    this.postalCode,
    this.country,
  });

  factory TransferUserAddressInRequest.fromJson(Map<String, dynamic> json) =>
      _$TransferUserAddressInRequestFromJson(json);

  @JsonKey(name: 'street')
  final String? street;
  @JsonKey(name: 'city')
  final String? city;
  @JsonKey(name: 'region')
  final String? region;
  @JsonKey(name: 'postal_code')
  final String? postalCode;
  @JsonKey(name: 'country')
  final String? country;
  static const fromJsonFactory = _$TransferUserAddressInRequestFromJson;
  static const toJsonFactory = _$TransferUserAddressInRequestToJson;
  Map<String, dynamic> toJson() => _$TransferUserAddressInRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferUserAddressInRequest &&
            (identical(other.street, street) ||
                const DeepCollectionEquality().equals(other.street, street)) &&
            (identical(other.city, city) ||
                const DeepCollectionEquality().equals(other.city, city)) &&
            (identical(other.region, region) ||
                const DeepCollectionEquality().equals(other.region, region)) &&
            (identical(other.postalCode, postalCode) ||
                const DeepCollectionEquality()
                    .equals(other.postalCode, postalCode)) &&
            (identical(other.country, country) ||
                const DeepCollectionEquality().equals(other.country, country)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(street) ^
      const DeepCollectionEquality().hash(city) ^
      const DeepCollectionEquality().hash(region) ^
      const DeepCollectionEquality().hash(postalCode) ^
      const DeepCollectionEquality().hash(country) ^
      runtimeType.hashCode;
}

extension $TransferUserAddressInRequestExtension
    on TransferUserAddressInRequest {
  TransferUserAddressInRequest copyWith(
      {String? street,
      String? city,
      String? region,
      String? postalCode,
      String? country}) {
    return TransferUserAddressInRequest(
        street: street ?? this.street,
        city: city ?? this.city,
        region: region ?? this.region,
        postalCode: postalCode ?? this.postalCode,
        country: country ?? this.country);
  }
}

@JsonSerializable(explicitToJson: true)
class TransferUserAddressInResponse {
  TransferUserAddressInResponse({
    this.street,
    this.city,
    this.region,
    this.postalCode,
    this.country,
  });

  factory TransferUserAddressInResponse.fromJson(Map<String, dynamic> json) =>
      _$TransferUserAddressInResponseFromJson(json);

  @JsonKey(name: 'street')
  final String? street;
  @JsonKey(name: 'city')
  final String? city;
  @JsonKey(name: 'region')
  final String? region;
  @JsonKey(name: 'postal_code')
  final String? postalCode;
  @JsonKey(name: 'country')
  final String? country;
  static const fromJsonFactory = _$TransferUserAddressInResponseFromJson;
  static const toJsonFactory = _$TransferUserAddressInResponseToJson;
  Map<String, dynamic> toJson() => _$TransferUserAddressInResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferUserAddressInResponse &&
            (identical(other.street, street) ||
                const DeepCollectionEquality().equals(other.street, street)) &&
            (identical(other.city, city) ||
                const DeepCollectionEquality().equals(other.city, city)) &&
            (identical(other.region, region) ||
                const DeepCollectionEquality().equals(other.region, region)) &&
            (identical(other.postalCode, postalCode) ||
                const DeepCollectionEquality()
                    .equals(other.postalCode, postalCode)) &&
            (identical(other.country, country) ||
                const DeepCollectionEquality().equals(other.country, country)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(street) ^
      const DeepCollectionEquality().hash(city) ^
      const DeepCollectionEquality().hash(region) ^
      const DeepCollectionEquality().hash(postalCode) ^
      const DeepCollectionEquality().hash(country) ^
      runtimeType.hashCode;
}

extension $TransferUserAddressInResponseExtension
    on TransferUserAddressInResponse {
  TransferUserAddressInResponse copyWith(
      {String? street,
      String? city,
      String? region,
      String? postalCode,
      String? country}) {
    return TransferUserAddressInResponse(
        street: street ?? this.street,
        city: city ?? this.city,
        region: region ?? this.region,
        postalCode: postalCode ?? this.postalCode,
        country: country ?? this.country);
  }
}

@JsonSerializable(explicitToJson: true)
class BankTransferUser {
  BankTransferUser({
    this.legalName,
    this.emailAddress,
    this.routingNumber,
  });

  factory BankTransferUser.fromJson(Map<String, dynamic> json) =>
      _$BankTransferUserFromJson(json);

  @JsonKey(name: 'legal_name')
  final String? legalName;
  @JsonKey(name: 'email_address')
  final String? emailAddress;
  @JsonKey(name: 'routing_number')
  final String? routingNumber;
  static const fromJsonFactory = _$BankTransferUserFromJson;
  static const toJsonFactory = _$BankTransferUserToJson;
  Map<String, dynamic> toJson() => _$BankTransferUserToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BankTransferUser &&
            (identical(other.legalName, legalName) ||
                const DeepCollectionEquality()
                    .equals(other.legalName, legalName)) &&
            (identical(other.emailAddress, emailAddress) ||
                const DeepCollectionEquality()
                    .equals(other.emailAddress, emailAddress)) &&
            (identical(other.routingNumber, routingNumber) ||
                const DeepCollectionEquality()
                    .equals(other.routingNumber, routingNumber)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(legalName) ^
      const DeepCollectionEquality().hash(emailAddress) ^
      const DeepCollectionEquality().hash(routingNumber) ^
      runtimeType.hashCode;
}

extension $BankTransferUserExtension on BankTransferUser {
  BankTransferUser copyWith(
      {String? legalName, String? emailAddress, String? routingNumber}) {
    return BankTransferUser(
        legalName: legalName ?? this.legalName,
        emailAddress: emailAddress ?? this.emailAddress,
        routingNumber: routingNumber ?? this.routingNumber);
  }
}

@JsonSerializable(explicitToJson: true)
class TransferAuthorizationDecisionRationale {
  TransferAuthorizationDecisionRationale({
    this.code,
    this.description,
  });

  factory TransferAuthorizationDecisionRationale.fromJson(
          Map<String, dynamic> json) =>
      _$TransferAuthorizationDecisionRationaleFromJson(json);

  @JsonKey(
      name: 'code',
      toJson: transferAuthorizationDecisionRationaleCodeToJson,
      fromJson: transferAuthorizationDecisionRationaleCodeFromJson)
  final enums.TransferAuthorizationDecisionRationaleCode? code;
  @JsonKey(name: 'description')
  final String? description;
  static const fromJsonFactory =
      _$TransferAuthorizationDecisionRationaleFromJson;
  static const toJsonFactory = _$TransferAuthorizationDecisionRationaleToJson;
  Map<String, dynamic> toJson() =>
      _$TransferAuthorizationDecisionRationaleToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferAuthorizationDecisionRationale &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(description) ^
      runtimeType.hashCode;
}

extension $TransferAuthorizationDecisionRationaleExtension
    on TransferAuthorizationDecisionRationale {
  TransferAuthorizationDecisionRationale copyWith(
      {enums.TransferAuthorizationDecisionRationaleCode? code,
      String? description}) {
    return TransferAuthorizationDecisionRationale(
        code: code ?? this.code, description: description ?? this.description);
  }
}

@JsonSerializable(explicitToJson: true)
class TransferAuthorizationProposedTransfer {
  TransferAuthorizationProposedTransfer({
    this.achClass,
    this.accountId,
    this.type,
    this.user,
    this.amount,
    this.network,
    this.originationAccountId,
  });

  factory TransferAuthorizationProposedTransfer.fromJson(
          Map<String, dynamic> json) =>
      _$TransferAuthorizationProposedTransferFromJson(json);

  @JsonKey(
      name: 'ach_class', toJson: aCHClassToJson, fromJson: aCHClassFromJson)
  final enums.ACHClass? achClass;
  @JsonKey(name: 'account_id')
  final String? accountId;
  @JsonKey(
      name: 'type', toJson: transferTypeToJson, fromJson: transferTypeFromJson)
  final enums.TransferType? type;
  @JsonKey(name: 'user')
  final TransferUserInResponse? user;
  @JsonKey(name: 'amount')
  final String? amount;
  @JsonKey(name: 'network')
  final String? network;
  @JsonKey(name: 'origination_account_id')
  final String? originationAccountId;
  static const fromJsonFactory =
      _$TransferAuthorizationProposedTransferFromJson;
  static const toJsonFactory = _$TransferAuthorizationProposedTransferToJson;
  Map<String, dynamic> toJson() =>
      _$TransferAuthorizationProposedTransferToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferAuthorizationProposedTransfer &&
            (identical(other.achClass, achClass) ||
                const DeepCollectionEquality()
                    .equals(other.achClass, achClass)) &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.user, user) ||
                const DeepCollectionEquality().equals(other.user, user)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.network, network) ||
                const DeepCollectionEquality()
                    .equals(other.network, network)) &&
            (identical(other.originationAccountId, originationAccountId) ||
                const DeepCollectionEquality()
                    .equals(other.originationAccountId, originationAccountId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(achClass) ^
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(user) ^
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(network) ^
      const DeepCollectionEquality().hash(originationAccountId) ^
      runtimeType.hashCode;
}

extension $TransferAuthorizationProposedTransferExtension
    on TransferAuthorizationProposedTransfer {
  TransferAuthorizationProposedTransfer copyWith(
      {enums.ACHClass? achClass,
      String? accountId,
      enums.TransferType? type,
      TransferUserInResponse? user,
      String? amount,
      String? network,
      String? originationAccountId}) {
    return TransferAuthorizationProposedTransfer(
        achClass: achClass ?? this.achClass,
        accountId: accountId ?? this.accountId,
        type: type ?? this.type,
        user: user ?? this.user,
        amount: amount ?? this.amount,
        network: network ?? this.network,
        originationAccountId:
            originationAccountId ?? this.originationAccountId);
  }
}

@JsonSerializable(explicitToJson: true)
class TransferAuthorizationDevice {
  TransferAuthorizationDevice({
    this.ipAddress,
    this.userAgent,
  });

  factory TransferAuthorizationDevice.fromJson(Map<String, dynamic> json) =>
      _$TransferAuthorizationDeviceFromJson(json);

  @JsonKey(name: 'ip_address')
  final String? ipAddress;
  @JsonKey(name: 'user_agent')
  final String? userAgent;
  static const fromJsonFactory = _$TransferAuthorizationDeviceFromJson;
  static const toJsonFactory = _$TransferAuthorizationDeviceToJson;
  Map<String, dynamic> toJson() => _$TransferAuthorizationDeviceToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferAuthorizationDevice &&
            (identical(other.ipAddress, ipAddress) ||
                const DeepCollectionEquality()
                    .equals(other.ipAddress, ipAddress)) &&
            (identical(other.userAgent, userAgent) ||
                const DeepCollectionEquality()
                    .equals(other.userAgent, userAgent)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ipAddress) ^
      const DeepCollectionEquality().hash(userAgent) ^
      runtimeType.hashCode;
}

extension $TransferAuthorizationDeviceExtension on TransferAuthorizationDevice {
  TransferAuthorizationDevice copyWith({String? ipAddress, String? userAgent}) {
    return TransferAuthorizationDevice(
        ipAddress: ipAddress ?? this.ipAddress,
        userAgent: userAgent ?? this.userAgent);
  }
}

@JsonSerializable(explicitToJson: true)
class TransferMetadata {
  TransferMetadata();

  factory TransferMetadata.fromJson(Map<String, dynamic> json) =>
      _$TransferMetadataFromJson(json);

  static const fromJsonFactory = _$TransferMetadataFromJson;
  static const toJsonFactory = _$TransferMetadataToJson;
  Map<String, dynamic> toJson() => _$TransferMetadataToJson(this);

  @override
  int get hashCode => runtimeType.hashCode;
}

@JsonSerializable(explicitToJson: true)
class BankTransferMetadata {
  BankTransferMetadata();

  factory BankTransferMetadata.fromJson(Map<String, dynamic> json) =>
      _$BankTransferMetadataFromJson(json);

  static const fromJsonFactory = _$BankTransferMetadataFromJson;
  static const toJsonFactory = _$BankTransferMetadataToJson;
  Map<String, dynamic> toJson() => _$BankTransferMetadataToJson(this);

  @override
  int get hashCode => runtimeType.hashCode;
}

@JsonSerializable(explicitToJson: true)
class TransferFailure {
  TransferFailure({
    this.achReturnCode,
    this.description,
  });

  factory TransferFailure.fromJson(Map<String, dynamic> json) =>
      _$TransferFailureFromJson(json);

  @JsonKey(name: 'ach_return_code')
  final String? achReturnCode;
  @JsonKey(name: 'description')
  final String? description;
  static const fromJsonFactory = _$TransferFailureFromJson;
  static const toJsonFactory = _$TransferFailureToJson;
  Map<String, dynamic> toJson() => _$TransferFailureToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferFailure &&
            (identical(other.achReturnCode, achReturnCode) ||
                const DeepCollectionEquality()
                    .equals(other.achReturnCode, achReturnCode)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(achReturnCode) ^
      const DeepCollectionEquality().hash(description) ^
      runtimeType.hashCode;
}

extension $TransferFailureExtension on TransferFailure {
  TransferFailure copyWith({String? achReturnCode, String? description}) {
    return TransferFailure(
        achReturnCode: achReturnCode ?? this.achReturnCode,
        description: description ?? this.description);
  }
}

@JsonSerializable(explicitToJson: true)
class BankTransferFailure {
  BankTransferFailure({
    this.achReturnCode,
    this.description,
  });

  factory BankTransferFailure.fromJson(Map<String, dynamic> json) =>
      _$BankTransferFailureFromJson(json);

  @JsonKey(name: 'ach_return_code')
  final String? achReturnCode;
  @JsonKey(name: 'description')
  final String? description;
  static const fromJsonFactory = _$BankTransferFailureFromJson;
  static const toJsonFactory = _$BankTransferFailureToJson;
  Map<String, dynamic> toJson() => _$BankTransferFailureToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BankTransferFailure &&
            (identical(other.achReturnCode, achReturnCode) ||
                const DeepCollectionEquality()
                    .equals(other.achReturnCode, achReturnCode)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(achReturnCode) ^
      const DeepCollectionEquality().hash(description) ^
      runtimeType.hashCode;
}

extension $BankTransferFailureExtension on BankTransferFailure {
  BankTransferFailure copyWith({String? achReturnCode, String? description}) {
    return BankTransferFailure(
        achReturnCode: achReturnCode ?? this.achReturnCode,
        description: description ?? this.description);
  }
}

@JsonSerializable(explicitToJson: true)
class TransferAuthorizationCreateRequest {
  TransferAuthorizationCreateRequest({
    this.clientId,
    this.secret,
    this.accessToken,
    this.accountId,
    this.type,
    this.network,
    this.amount,
    this.achClass,
    this.user,
    this.device,
    this.originationAccountId,
  });

  factory TransferAuthorizationCreateRequest.fromJson(
          Map<String, dynamic> json) =>
      _$TransferAuthorizationCreateRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'access_token')
  final String? accessToken;
  @JsonKey(name: 'account_id')
  final String? accountId;
  @JsonKey(
      name: 'type', toJson: transferTypeToJson, fromJson: transferTypeFromJson)
  final enums.TransferType? type;
  @JsonKey(
      name: 'network',
      toJson: transferNetworkToJson,
      fromJson: transferNetworkFromJson)
  final enums.TransferNetwork? network;
  @JsonKey(name: 'amount')
  final String? amount;
  @JsonKey(
      name: 'ach_class', toJson: aCHClassToJson, fromJson: aCHClassFromJson)
  final enums.ACHClass? achClass;
  @JsonKey(name: 'user')
  final TransferUserInRequest? user;
  @JsonKey(name: 'device')
  final TransferAuthorizationDevice? device;
  @JsonKey(name: 'origination_account_id')
  final String? originationAccountId;
  static const fromJsonFactory = _$TransferAuthorizationCreateRequestFromJson;
  static const toJsonFactory = _$TransferAuthorizationCreateRequestToJson;
  Map<String, dynamic> toJson() =>
      _$TransferAuthorizationCreateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferAuthorizationCreateRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)) &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.network, network) ||
                const DeepCollectionEquality()
                    .equals(other.network, network)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.achClass, achClass) ||
                const DeepCollectionEquality()
                    .equals(other.achClass, achClass)) &&
            (identical(other.user, user) ||
                const DeepCollectionEquality().equals(other.user, user)) &&
            (identical(other.device, device) ||
                const DeepCollectionEquality().equals(other.device, device)) &&
            (identical(other.originationAccountId, originationAccountId) ||
                const DeepCollectionEquality()
                    .equals(other.originationAccountId, originationAccountId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(accessToken) ^
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(network) ^
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(achClass) ^
      const DeepCollectionEquality().hash(user) ^
      const DeepCollectionEquality().hash(device) ^
      const DeepCollectionEquality().hash(originationAccountId) ^
      runtimeType.hashCode;
}

extension $TransferAuthorizationCreateRequestExtension
    on TransferAuthorizationCreateRequest {
  TransferAuthorizationCreateRequest copyWith(
      {String? clientId,
      String? secret,
      String? accessToken,
      String? accountId,
      enums.TransferType? type,
      enums.TransferNetwork? network,
      String? amount,
      enums.ACHClass? achClass,
      TransferUserInRequest? user,
      TransferAuthorizationDevice? device,
      String? originationAccountId}) {
    return TransferAuthorizationCreateRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        accessToken: accessToken ?? this.accessToken,
        accountId: accountId ?? this.accountId,
        type: type ?? this.type,
        network: network ?? this.network,
        amount: amount ?? this.amount,
        achClass: achClass ?? this.achClass,
        user: user ?? this.user,
        device: device ?? this.device,
        originationAccountId:
            originationAccountId ?? this.originationAccountId);
  }
}

@JsonSerializable(explicitToJson: true)
class TransferCreateRequest {
  TransferCreateRequest({
    this.clientId,
    this.secret,
    this.idempotencyKey,
    this.accessToken,
    this.accountId,
    this.authorizationId,
    this.type,
    this.network,
    this.amount,
    this.description,
    this.achClass,
    this.user,
    this.metadata,
    this.originationAccountId,
  });

  factory TransferCreateRequest.fromJson(Map<String, dynamic> json) =>
      _$TransferCreateRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'idempotency_key')
  final String? idempotencyKey;
  @JsonKey(name: 'access_token')
  final String? accessToken;
  @JsonKey(name: 'account_id')
  final String? accountId;
  @JsonKey(name: 'authorization_id')
  final String? authorizationId;
  @JsonKey(
      name: 'type', toJson: transferTypeToJson, fromJson: transferTypeFromJson)
  final enums.TransferType? type;
  @JsonKey(
      name: 'network',
      toJson: transferNetworkToJson,
      fromJson: transferNetworkFromJson)
  final enums.TransferNetwork? network;
  @JsonKey(name: 'amount')
  final String? amount;
  @JsonKey(name: 'description')
  final String? description;
  @JsonKey(
      name: 'ach_class', toJson: aCHClassToJson, fromJson: aCHClassFromJson)
  final enums.ACHClass? achClass;
  @JsonKey(name: 'user')
  final TransferUserInRequest? user;
  @JsonKey(name: 'metadata')
  final TransferMetadata? metadata;
  @JsonKey(name: 'origination_account_id')
  final String? originationAccountId;
  static const fromJsonFactory = _$TransferCreateRequestFromJson;
  static const toJsonFactory = _$TransferCreateRequestToJson;
  Map<String, dynamic> toJson() => _$TransferCreateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferCreateRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.idempotencyKey, idempotencyKey) ||
                const DeepCollectionEquality()
                    .equals(other.idempotencyKey, idempotencyKey)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)) &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.authorizationId, authorizationId) ||
                const DeepCollectionEquality()
                    .equals(other.authorizationId, authorizationId)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.network, network) ||
                const DeepCollectionEquality()
                    .equals(other.network, network)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.achClass, achClass) ||
                const DeepCollectionEquality()
                    .equals(other.achClass, achClass)) &&
            (identical(other.user, user) ||
                const DeepCollectionEquality().equals(other.user, user)) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality()
                    .equals(other.metadata, metadata)) &&
            (identical(other.originationAccountId, originationAccountId) ||
                const DeepCollectionEquality()
                    .equals(other.originationAccountId, originationAccountId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(idempotencyKey) ^
      const DeepCollectionEquality().hash(accessToken) ^
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(authorizationId) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(network) ^
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(achClass) ^
      const DeepCollectionEquality().hash(user) ^
      const DeepCollectionEquality().hash(metadata) ^
      const DeepCollectionEquality().hash(originationAccountId) ^
      runtimeType.hashCode;
}

extension $TransferCreateRequestExtension on TransferCreateRequest {
  TransferCreateRequest copyWith(
      {String? clientId,
      String? secret,
      String? idempotencyKey,
      String? accessToken,
      String? accountId,
      String? authorizationId,
      enums.TransferType? type,
      enums.TransferNetwork? network,
      String? amount,
      String? description,
      enums.ACHClass? achClass,
      TransferUserInRequest? user,
      TransferMetadata? metadata,
      String? originationAccountId}) {
    return TransferCreateRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        idempotencyKey: idempotencyKey ?? this.idempotencyKey,
        accessToken: accessToken ?? this.accessToken,
        accountId: accountId ?? this.accountId,
        authorizationId: authorizationId ?? this.authorizationId,
        type: type ?? this.type,
        network: network ?? this.network,
        amount: amount ?? this.amount,
        description: description ?? this.description,
        achClass: achClass ?? this.achClass,
        user: user ?? this.user,
        metadata: metadata ?? this.metadata,
        originationAccountId:
            originationAccountId ?? this.originationAccountId);
  }
}

@JsonSerializable(explicitToJson: true)
class BankTransferCreateRequest {
  BankTransferCreateRequest({
    this.clientId,
    this.secret,
    this.idempotencyKey,
    this.accessToken,
    this.accountId,
    this.type,
    this.network,
    this.amount,
    this.isoCurrencyCode,
    this.description,
    this.achClass,
    this.user,
    this.customTag,
    this.metadata,
    this.originationAccountId,
  });

  factory BankTransferCreateRequest.fromJson(Map<String, dynamic> json) =>
      _$BankTransferCreateRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'idempotency_key')
  final String? idempotencyKey;
  @JsonKey(name: 'access_token')
  final String? accessToken;
  @JsonKey(name: 'account_id')
  final String? accountId;
  @JsonKey(
      name: 'type',
      toJson: bankTransferTypeToJson,
      fromJson: bankTransferTypeFromJson)
  final enums.BankTransferType? type;
  @JsonKey(
      name: 'network',
      toJson: bankTransferNetworkToJson,
      fromJson: bankTransferNetworkFromJson)
  final enums.BankTransferNetwork? network;
  @JsonKey(name: 'amount')
  final String? amount;
  @JsonKey(name: 'iso_currency_code')
  final String? isoCurrencyCode;
  @JsonKey(name: 'description')
  final String? description;
  @JsonKey(
      name: 'ach_class', toJson: aCHClassToJson, fromJson: aCHClassFromJson)
  final enums.ACHClass? achClass;
  @JsonKey(name: 'user')
  final BankTransferUser? user;
  @JsonKey(name: 'custom_tag')
  final String? customTag;
  @JsonKey(name: 'metadata')
  final BankTransferMetadata? metadata;
  @JsonKey(name: 'origination_account_id')
  final String? originationAccountId;
  static const fromJsonFactory = _$BankTransferCreateRequestFromJson;
  static const toJsonFactory = _$BankTransferCreateRequestToJson;
  Map<String, dynamic> toJson() => _$BankTransferCreateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BankTransferCreateRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.idempotencyKey, idempotencyKey) ||
                const DeepCollectionEquality()
                    .equals(other.idempotencyKey, idempotencyKey)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)) &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.network, network) ||
                const DeepCollectionEquality()
                    .equals(other.network, network)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.achClass, achClass) ||
                const DeepCollectionEquality()
                    .equals(other.achClass, achClass)) &&
            (identical(other.user, user) ||
                const DeepCollectionEquality().equals(other.user, user)) &&
            (identical(other.customTag, customTag) ||
                const DeepCollectionEquality()
                    .equals(other.customTag, customTag)) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality()
                    .equals(other.metadata, metadata)) &&
            (identical(other.originationAccountId, originationAccountId) ||
                const DeepCollectionEquality()
                    .equals(other.originationAccountId, originationAccountId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(idempotencyKey) ^
      const DeepCollectionEquality().hash(accessToken) ^
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(network) ^
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(achClass) ^
      const DeepCollectionEquality().hash(user) ^
      const DeepCollectionEquality().hash(customTag) ^
      const DeepCollectionEquality().hash(metadata) ^
      const DeepCollectionEquality().hash(originationAccountId) ^
      runtimeType.hashCode;
}

extension $BankTransferCreateRequestExtension on BankTransferCreateRequest {
  BankTransferCreateRequest copyWith(
      {String? clientId,
      String? secret,
      String? idempotencyKey,
      String? accessToken,
      String? accountId,
      enums.BankTransferType? type,
      enums.BankTransferNetwork? network,
      String? amount,
      String? isoCurrencyCode,
      String? description,
      enums.ACHClass? achClass,
      BankTransferUser? user,
      String? customTag,
      BankTransferMetadata? metadata,
      String? originationAccountId}) {
    return BankTransferCreateRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        idempotencyKey: idempotencyKey ?? this.idempotencyKey,
        accessToken: accessToken ?? this.accessToken,
        accountId: accountId ?? this.accountId,
        type: type ?? this.type,
        network: network ?? this.network,
        amount: amount ?? this.amount,
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode,
        description: description ?? this.description,
        achClass: achClass ?? this.achClass,
        user: user ?? this.user,
        customTag: customTag ?? this.customTag,
        metadata: metadata ?? this.metadata,
        originationAccountId:
            originationAccountId ?? this.originationAccountId);
  }
}

@JsonSerializable(explicitToJson: true)
class TransferAuthorizationCreateResponse {
  TransferAuthorizationCreateResponse({
    this.authorization,
    this.requestId,
  });

  factory TransferAuthorizationCreateResponse.fromJson(
          Map<String, dynamic> json) =>
      _$TransferAuthorizationCreateResponseFromJson(json);

  @JsonKey(name: 'authorization')
  final TransferAuthorization? authorization;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$TransferAuthorizationCreateResponseFromJson;
  static const toJsonFactory = _$TransferAuthorizationCreateResponseToJson;
  Map<String, dynamic> toJson() =>
      _$TransferAuthorizationCreateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferAuthorizationCreateResponse &&
            (identical(other.authorization, authorization) ||
                const DeepCollectionEquality()
                    .equals(other.authorization, authorization)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(authorization) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $TransferAuthorizationCreateResponseExtension
    on TransferAuthorizationCreateResponse {
  TransferAuthorizationCreateResponse copyWith(
      {TransferAuthorization? authorization, String? requestId}) {
    return TransferAuthorizationCreateResponse(
        authorization: authorization ?? this.authorization,
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class TransferAuthorization {
  TransferAuthorization({
    this.id,
    this.created,
    this.decision,
    this.decisionRationale,
    this.proposedTransfer,
  });

  factory TransferAuthorization.fromJson(Map<String, dynamic> json) =>
      _$TransferAuthorizationFromJson(json);

  @JsonKey(name: 'id')
  final String? id;
  @JsonKey(name: 'created')
  final String? created;
  @JsonKey(
      name: 'decision',
      toJson: transferAuthorizationDecisionToJson,
      fromJson: transferAuthorizationDecisionFromJson)
  final enums.TransferAuthorizationDecision? decision;
  @JsonKey(name: 'decision_rationale')
  final TransferAuthorizationDecisionRationale? decisionRationale;
  @JsonKey(name: 'proposed_transfer')
  final TransferAuthorizationProposedTransfer? proposedTransfer;
  static const fromJsonFactory = _$TransferAuthorizationFromJson;
  static const toJsonFactory = _$TransferAuthorizationToJson;
  Map<String, dynamic> toJson() => _$TransferAuthorizationToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferAuthorization &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.created, created) ||
                const DeepCollectionEquality()
                    .equals(other.created, created)) &&
            (identical(other.decision, decision) ||
                const DeepCollectionEquality()
                    .equals(other.decision, decision)) &&
            (identical(other.decisionRationale, decisionRationale) ||
                const DeepCollectionEquality()
                    .equals(other.decisionRationale, decisionRationale)) &&
            (identical(other.proposedTransfer, proposedTransfer) ||
                const DeepCollectionEquality()
                    .equals(other.proposedTransfer, proposedTransfer)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(created) ^
      const DeepCollectionEquality().hash(decision) ^
      const DeepCollectionEquality().hash(decisionRationale) ^
      const DeepCollectionEquality().hash(proposedTransfer) ^
      runtimeType.hashCode;
}

extension $TransferAuthorizationExtension on TransferAuthorization {
  TransferAuthorization copyWith(
      {String? id,
      String? created,
      enums.TransferAuthorizationDecision? decision,
      TransferAuthorizationDecisionRationale? decisionRationale,
      TransferAuthorizationProposedTransfer? proposedTransfer}) {
    return TransferAuthorization(
        id: id ?? this.id,
        created: created ?? this.created,
        decision: decision ?? this.decision,
        decisionRationale: decisionRationale ?? this.decisionRationale,
        proposedTransfer: proposedTransfer ?? this.proposedTransfer);
  }
}

@JsonSerializable(explicitToJson: true)
class TransferCreateResponse {
  TransferCreateResponse({
    this.transfer,
    this.requestId,
  });

  factory TransferCreateResponse.fromJson(Map<String, dynamic> json) =>
      _$TransferCreateResponseFromJson(json);

  @JsonKey(name: 'transfer')
  final Transfer? transfer;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$TransferCreateResponseFromJson;
  static const toJsonFactory = _$TransferCreateResponseToJson;
  Map<String, dynamic> toJson() => _$TransferCreateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferCreateResponse &&
            (identical(other.transfer, transfer) ||
                const DeepCollectionEquality()
                    .equals(other.transfer, transfer)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(transfer) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $TransferCreateResponseExtension on TransferCreateResponse {
  TransferCreateResponse copyWith({Transfer? transfer, String? requestId}) {
    return TransferCreateResponse(
        transfer: transfer ?? this.transfer,
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class BankTransferCreateResponse {
  BankTransferCreateResponse({
    this.bankTransfer,
    this.requestId,
  });

  factory BankTransferCreateResponse.fromJson(Map<String, dynamic> json) =>
      _$BankTransferCreateResponseFromJson(json);

  @JsonKey(name: 'bank_transfer')
  final BankTransfer? bankTransfer;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$BankTransferCreateResponseFromJson;
  static const toJsonFactory = _$BankTransferCreateResponseToJson;
  Map<String, dynamic> toJson() => _$BankTransferCreateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BankTransferCreateResponse &&
            (identical(other.bankTransfer, bankTransfer) ||
                const DeepCollectionEquality()
                    .equals(other.bankTransfer, bankTransfer)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(bankTransfer) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $BankTransferCreateResponseExtension on BankTransferCreateResponse {
  BankTransferCreateResponse copyWith(
      {BankTransfer? bankTransfer, String? requestId}) {
    return BankTransferCreateResponse(
        bankTransfer: bankTransfer ?? this.bankTransfer,
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class TransferListRequest {
  TransferListRequest({
    this.clientId,
    this.secret,
    this.startDate,
    this.endDate,
    this.count,
    this.offset,
    this.originationAccountId,
  });

  factory TransferListRequest.fromJson(Map<String, dynamic> json) =>
      _$TransferListRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'start_date')
  final DateTime? startDate;
  @JsonKey(name: 'end_date')
  final DateTime? endDate;
  @JsonKey(name: 'count')
  final int? count;
  @JsonKey(name: 'offset')
  final int? offset;
  @JsonKey(name: 'origination_account_id')
  final String? originationAccountId;
  static const fromJsonFactory = _$TransferListRequestFromJson;
  static const toJsonFactory = _$TransferListRequestToJson;
  Map<String, dynamic> toJson() => _$TransferListRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferListRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.startDate, startDate) ||
                const DeepCollectionEquality()
                    .equals(other.startDate, startDate)) &&
            (identical(other.endDate, endDate) ||
                const DeepCollectionEquality()
                    .equals(other.endDate, endDate)) &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)) &&
            (identical(other.offset, offset) ||
                const DeepCollectionEquality().equals(other.offset, offset)) &&
            (identical(other.originationAccountId, originationAccountId) ||
                const DeepCollectionEquality()
                    .equals(other.originationAccountId, originationAccountId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(startDate) ^
      const DeepCollectionEquality().hash(endDate) ^
      const DeepCollectionEquality().hash(count) ^
      const DeepCollectionEquality().hash(offset) ^
      const DeepCollectionEquality().hash(originationAccountId) ^
      runtimeType.hashCode;
}

extension $TransferListRequestExtension on TransferListRequest {
  TransferListRequest copyWith(
      {String? clientId,
      String? secret,
      DateTime? startDate,
      DateTime? endDate,
      int? count,
      int? offset,
      String? originationAccountId}) {
    return TransferListRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        startDate: startDate ?? this.startDate,
        endDate: endDate ?? this.endDate,
        count: count ?? this.count,
        offset: offset ?? this.offset,
        originationAccountId:
            originationAccountId ?? this.originationAccountId);
  }
}

@JsonSerializable(explicitToJson: true)
class BankTransferListRequest {
  BankTransferListRequest({
    this.clientId,
    this.secret,
    this.startDate,
    this.endDate,
    this.count,
    this.offset,
    this.originationAccountId,
    this.direction,
  });

  factory BankTransferListRequest.fromJson(Map<String, dynamic> json) =>
      _$BankTransferListRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'start_date')
  final DateTime? startDate;
  @JsonKey(name: 'end_date')
  final DateTime? endDate;
  @JsonKey(name: 'count')
  final int? count;
  @JsonKey(name: 'offset')
  final int? offset;
  @JsonKey(name: 'origination_account_id')
  final String? originationAccountId;
  @JsonKey(
      name: 'direction',
      toJson: bankTransferDirectionToJson,
      fromJson: bankTransferDirectionFromJson)
  final enums.BankTransferDirection? direction;
  static const fromJsonFactory = _$BankTransferListRequestFromJson;
  static const toJsonFactory = _$BankTransferListRequestToJson;
  Map<String, dynamic> toJson() => _$BankTransferListRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BankTransferListRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.startDate, startDate) ||
                const DeepCollectionEquality()
                    .equals(other.startDate, startDate)) &&
            (identical(other.endDate, endDate) ||
                const DeepCollectionEquality()
                    .equals(other.endDate, endDate)) &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)) &&
            (identical(other.offset, offset) ||
                const DeepCollectionEquality().equals(other.offset, offset)) &&
            (identical(other.originationAccountId, originationAccountId) ||
                const DeepCollectionEquality().equals(
                    other.originationAccountId, originationAccountId)) &&
            (identical(other.direction, direction) ||
                const DeepCollectionEquality()
                    .equals(other.direction, direction)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(startDate) ^
      const DeepCollectionEquality().hash(endDate) ^
      const DeepCollectionEquality().hash(count) ^
      const DeepCollectionEquality().hash(offset) ^
      const DeepCollectionEquality().hash(originationAccountId) ^
      const DeepCollectionEquality().hash(direction) ^
      runtimeType.hashCode;
}

extension $BankTransferListRequestExtension on BankTransferListRequest {
  BankTransferListRequest copyWith(
      {String? clientId,
      String? secret,
      DateTime? startDate,
      DateTime? endDate,
      int? count,
      int? offset,
      String? originationAccountId,
      enums.BankTransferDirection? direction}) {
    return BankTransferListRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        startDate: startDate ?? this.startDate,
        endDate: endDate ?? this.endDate,
        count: count ?? this.count,
        offset: offset ?? this.offset,
        originationAccountId: originationAccountId ?? this.originationAccountId,
        direction: direction ?? this.direction);
  }
}

@JsonSerializable(explicitToJson: true)
class TransferListResponse {
  TransferListResponse({
    this.transfers,
    this.requestId,
  });

  factory TransferListResponse.fromJson(Map<String, dynamic> json) =>
      _$TransferListResponseFromJson(json);

  @JsonKey(name: 'transfers', defaultValue: <Transfer>[])
  final List<Transfer>? transfers;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$TransferListResponseFromJson;
  static const toJsonFactory = _$TransferListResponseToJson;
  Map<String, dynamic> toJson() => _$TransferListResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferListResponse &&
            (identical(other.transfers, transfers) ||
                const DeepCollectionEquality()
                    .equals(other.transfers, transfers)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(transfers) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $TransferListResponseExtension on TransferListResponse {
  TransferListResponse copyWith(
      {List<Transfer>? transfers, String? requestId}) {
    return TransferListResponse(
        transfers: transfers ?? this.transfers,
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class BankTransferListResponse {
  BankTransferListResponse({
    this.bankTransfers,
    this.requestId,
  });

  factory BankTransferListResponse.fromJson(Map<String, dynamic> json) =>
      _$BankTransferListResponseFromJson(json);

  @JsonKey(name: 'bank_transfers', defaultValue: <BankTransfer>[])
  final List<BankTransfer>? bankTransfers;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$BankTransferListResponseFromJson;
  static const toJsonFactory = _$BankTransferListResponseToJson;
  Map<String, dynamic> toJson() => _$BankTransferListResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BankTransferListResponse &&
            (identical(other.bankTransfers, bankTransfers) ||
                const DeepCollectionEquality()
                    .equals(other.bankTransfers, bankTransfers)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(bankTransfers) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $BankTransferListResponseExtension on BankTransferListResponse {
  BankTransferListResponse copyWith(
      {List<BankTransfer>? bankTransfers, String? requestId}) {
    return BankTransferListResponse(
        bankTransfers: bankTransfers ?? this.bankTransfers,
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class TransferCancelRequest {
  TransferCancelRequest({
    this.clientId,
    this.secret,
    this.transferId,
  });

  factory TransferCancelRequest.fromJson(Map<String, dynamic> json) =>
      _$TransferCancelRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'transfer_id')
  final String? transferId;
  static const fromJsonFactory = _$TransferCancelRequestFromJson;
  static const toJsonFactory = _$TransferCancelRequestToJson;
  Map<String, dynamic> toJson() => _$TransferCancelRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferCancelRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.transferId, transferId) ||
                const DeepCollectionEquality()
                    .equals(other.transferId, transferId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(transferId) ^
      runtimeType.hashCode;
}

extension $TransferCancelRequestExtension on TransferCancelRequest {
  TransferCancelRequest copyWith(
      {String? clientId, String? secret, String? transferId}) {
    return TransferCancelRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        transferId: transferId ?? this.transferId);
  }
}

@JsonSerializable(explicitToJson: true)
class BankTransferCancelRequest {
  BankTransferCancelRequest({
    this.clientId,
    this.secret,
    this.bankTransferId,
  });

  factory BankTransferCancelRequest.fromJson(Map<String, dynamic> json) =>
      _$BankTransferCancelRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'bank_transfer_id')
  final String? bankTransferId;
  static const fromJsonFactory = _$BankTransferCancelRequestFromJson;
  static const toJsonFactory = _$BankTransferCancelRequestToJson;
  Map<String, dynamic> toJson() => _$BankTransferCancelRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BankTransferCancelRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.bankTransferId, bankTransferId) ||
                const DeepCollectionEquality()
                    .equals(other.bankTransferId, bankTransferId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(bankTransferId) ^
      runtimeType.hashCode;
}

extension $BankTransferCancelRequestExtension on BankTransferCancelRequest {
  BankTransferCancelRequest copyWith(
      {String? clientId, String? secret, String? bankTransferId}) {
    return BankTransferCancelRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        bankTransferId: bankTransferId ?? this.bankTransferId);
  }
}

@JsonSerializable(explicitToJson: true)
class TransferCancelResponse {
  TransferCancelResponse({
    this.requestId,
  });

  factory TransferCancelResponse.fromJson(Map<String, dynamic> json) =>
      _$TransferCancelResponseFromJson(json);

  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$TransferCancelResponseFromJson;
  static const toJsonFactory = _$TransferCancelResponseToJson;
  Map<String, dynamic> toJson() => _$TransferCancelResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferCancelResponse &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(requestId) ^ runtimeType.hashCode;
}

extension $TransferCancelResponseExtension on TransferCancelResponse {
  TransferCancelResponse copyWith({String? requestId}) {
    return TransferCancelResponse(requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class BankTransferCancelResponse {
  BankTransferCancelResponse({
    this.requestId,
  });

  factory BankTransferCancelResponse.fromJson(Map<String, dynamic> json) =>
      _$BankTransferCancelResponseFromJson(json);

  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$BankTransferCancelResponseFromJson;
  static const toJsonFactory = _$BankTransferCancelResponseToJson;
  Map<String, dynamic> toJson() => _$BankTransferCancelResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BankTransferCancelResponse &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(requestId) ^ runtimeType.hashCode;
}

extension $BankTransferCancelResponseExtension on BankTransferCancelResponse {
  BankTransferCancelResponse copyWith({String? requestId}) {
    return BankTransferCancelResponse(requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class TransferEventListRequest {
  TransferEventListRequest({
    this.clientId,
    this.secret,
    this.startDate,
    this.endDate,
    this.transferId,
    this.accountId,
    this.transferType,
    this.eventTypes,
    this.sweepId,
    this.count,
    this.offset,
    this.originationAccountId,
  });

  factory TransferEventListRequest.fromJson(Map<String, dynamic> json) =>
      _$TransferEventListRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'start_date')
  final DateTime? startDate;
  @JsonKey(name: 'end_date')
  final DateTime? endDate;
  @JsonKey(name: 'transfer_id')
  final String? transferId;
  @JsonKey(name: 'account_id')
  final String? accountId;
  @JsonKey(
      name: 'transfer_type',
      toJson: transferEventListRequestTransferTypeToJson,
      fromJson: transferEventListRequestTransferTypeFromJson)
  final enums.TransferEventListRequestTransferType? transferType;
  @JsonKey(
      name: 'event_types',
      toJson: transferEventTypeListToJson,
      fromJson: transferEventTypeListFromJson)
  final List<enums.TransferEventType>? eventTypes;
  @JsonKey(name: 'sweep_id')
  final String? sweepId;
  @JsonKey(name: 'count')
  final int? count;
  @JsonKey(name: 'offset')
  final int? offset;
  @JsonKey(name: 'origination_account_id')
  final String? originationAccountId;
  static const fromJsonFactory = _$TransferEventListRequestFromJson;
  static const toJsonFactory = _$TransferEventListRequestToJson;
  Map<String, dynamic> toJson() => _$TransferEventListRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferEventListRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.startDate, startDate) ||
                const DeepCollectionEquality()
                    .equals(other.startDate, startDate)) &&
            (identical(other.endDate, endDate) ||
                const DeepCollectionEquality()
                    .equals(other.endDate, endDate)) &&
            (identical(other.transferId, transferId) ||
                const DeepCollectionEquality()
                    .equals(other.transferId, transferId)) &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.transferType, transferType) ||
                const DeepCollectionEquality()
                    .equals(other.transferType, transferType)) &&
            (identical(other.eventTypes, eventTypes) ||
                const DeepCollectionEquality()
                    .equals(other.eventTypes, eventTypes)) &&
            (identical(other.sweepId, sweepId) ||
                const DeepCollectionEquality()
                    .equals(other.sweepId, sweepId)) &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)) &&
            (identical(other.offset, offset) ||
                const DeepCollectionEquality().equals(other.offset, offset)) &&
            (identical(other.originationAccountId, originationAccountId) ||
                const DeepCollectionEquality()
                    .equals(other.originationAccountId, originationAccountId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(startDate) ^
      const DeepCollectionEquality().hash(endDate) ^
      const DeepCollectionEquality().hash(transferId) ^
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(transferType) ^
      const DeepCollectionEquality().hash(eventTypes) ^
      const DeepCollectionEquality().hash(sweepId) ^
      const DeepCollectionEquality().hash(count) ^
      const DeepCollectionEquality().hash(offset) ^
      const DeepCollectionEquality().hash(originationAccountId) ^
      runtimeType.hashCode;
}

extension $TransferEventListRequestExtension on TransferEventListRequest {
  TransferEventListRequest copyWith(
      {String? clientId,
      String? secret,
      DateTime? startDate,
      DateTime? endDate,
      String? transferId,
      String? accountId,
      enums.TransferEventListRequestTransferType? transferType,
      List<enums.TransferEventType>? eventTypes,
      String? sweepId,
      int? count,
      int? offset,
      String? originationAccountId}) {
    return TransferEventListRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        startDate: startDate ?? this.startDate,
        endDate: endDate ?? this.endDate,
        transferId: transferId ?? this.transferId,
        accountId: accountId ?? this.accountId,
        transferType: transferType ?? this.transferType,
        eventTypes: eventTypes ?? this.eventTypes,
        sweepId: sweepId ?? this.sweepId,
        count: count ?? this.count,
        offset: offset ?? this.offset,
        originationAccountId:
            originationAccountId ?? this.originationAccountId);
  }
}

@JsonSerializable(explicitToJson: true)
class BankTransferEventListRequest {
  BankTransferEventListRequest({
    this.clientId,
    this.secret,
    this.startDate,
    this.endDate,
    this.bankTransferId,
    this.accountId,
    this.bankTransferType,
    this.eventTypes,
    this.count,
    this.offset,
    this.originationAccountId,
    this.direction,
  });

  factory BankTransferEventListRequest.fromJson(Map<String, dynamic> json) =>
      _$BankTransferEventListRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'start_date')
  final DateTime? startDate;
  @JsonKey(name: 'end_date')
  final DateTime? endDate;
  @JsonKey(name: 'bank_transfer_id')
  final String? bankTransferId;
  @JsonKey(name: 'account_id')
  final String? accountId;
  @JsonKey(
      name: 'bank_transfer_type',
      toJson: bankTransferEventListRequestBankTransferTypeToJson,
      fromJson: bankTransferEventListRequestBankTransferTypeFromJson)
  final enums.BankTransferEventListRequestBankTransferType? bankTransferType;
  @JsonKey(
      name: 'event_types',
      toJson: bankTransferEventTypeListToJson,
      fromJson: bankTransferEventTypeListFromJson)
  final List<enums.BankTransferEventType>? eventTypes;
  @JsonKey(name: 'count')
  final int? count;
  @JsonKey(name: 'offset')
  final int? offset;
  @JsonKey(name: 'origination_account_id')
  final String? originationAccountId;
  @JsonKey(
      name: 'direction',
      toJson: bankTransferEventListRequestDirectionToJson,
      fromJson: bankTransferEventListRequestDirectionFromJson)
  final enums.BankTransferEventListRequestDirection? direction;
  static const fromJsonFactory = _$BankTransferEventListRequestFromJson;
  static const toJsonFactory = _$BankTransferEventListRequestToJson;
  Map<String, dynamic> toJson() => _$BankTransferEventListRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BankTransferEventListRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.startDate, startDate) ||
                const DeepCollectionEquality()
                    .equals(other.startDate, startDate)) &&
            (identical(other.endDate, endDate) ||
                const DeepCollectionEquality()
                    .equals(other.endDate, endDate)) &&
            (identical(other.bankTransferId, bankTransferId) ||
                const DeepCollectionEquality()
                    .equals(other.bankTransferId, bankTransferId)) &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.bankTransferType, bankTransferType) ||
                const DeepCollectionEquality()
                    .equals(other.bankTransferType, bankTransferType)) &&
            (identical(other.eventTypes, eventTypes) ||
                const DeepCollectionEquality()
                    .equals(other.eventTypes, eventTypes)) &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)) &&
            (identical(other.offset, offset) ||
                const DeepCollectionEquality().equals(other.offset, offset)) &&
            (identical(other.originationAccountId, originationAccountId) ||
                const DeepCollectionEquality().equals(
                    other.originationAccountId, originationAccountId)) &&
            (identical(other.direction, direction) ||
                const DeepCollectionEquality()
                    .equals(other.direction, direction)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(startDate) ^
      const DeepCollectionEquality().hash(endDate) ^
      const DeepCollectionEquality().hash(bankTransferId) ^
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(bankTransferType) ^
      const DeepCollectionEquality().hash(eventTypes) ^
      const DeepCollectionEquality().hash(count) ^
      const DeepCollectionEquality().hash(offset) ^
      const DeepCollectionEquality().hash(originationAccountId) ^
      const DeepCollectionEquality().hash(direction) ^
      runtimeType.hashCode;
}

extension $BankTransferEventListRequestExtension
    on BankTransferEventListRequest {
  BankTransferEventListRequest copyWith(
      {String? clientId,
      String? secret,
      DateTime? startDate,
      DateTime? endDate,
      String? bankTransferId,
      String? accountId,
      enums.BankTransferEventListRequestBankTransferType? bankTransferType,
      List<enums.BankTransferEventType>? eventTypes,
      int? count,
      int? offset,
      String? originationAccountId,
      enums.BankTransferEventListRequestDirection? direction}) {
    return BankTransferEventListRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        startDate: startDate ?? this.startDate,
        endDate: endDate ?? this.endDate,
        bankTransferId: bankTransferId ?? this.bankTransferId,
        accountId: accountId ?? this.accountId,
        bankTransferType: bankTransferType ?? this.bankTransferType,
        eventTypes: eventTypes ?? this.eventTypes,
        count: count ?? this.count,
        offset: offset ?? this.offset,
        originationAccountId: originationAccountId ?? this.originationAccountId,
        direction: direction ?? this.direction);
  }
}

@JsonSerializable(explicitToJson: true)
class TransferEvent {
  TransferEvent({
    this.eventId,
    this.timestamp,
    this.eventType,
    this.accountId,
    this.transferId,
    this.originationAccountId,
    this.transferType,
    this.transferAmount,
    this.failureReason,
    this.sweepId,
    this.sweepAmount,
  });

  factory TransferEvent.fromJson(Map<String, dynamic> json) =>
      _$TransferEventFromJson(json);

  @JsonKey(name: 'event_id')
  final int? eventId;
  @JsonKey(name: 'timestamp')
  final DateTime? timestamp;
  @JsonKey(
      name: 'event_type',
      toJson: transferEventTypeToJson,
      fromJson: transferEventTypeFromJson)
  final enums.TransferEventType? eventType;
  @JsonKey(name: 'account_id')
  final String? accountId;
  @JsonKey(name: 'transfer_id')
  final String? transferId;
  @JsonKey(name: 'origination_account_id')
  final String? originationAccountId;
  @JsonKey(
      name: 'transfer_type',
      toJson: transferTypeToJson,
      fromJson: transferTypeFromJson)
  final enums.TransferType? transferType;
  @JsonKey(name: 'transfer_amount')
  final String? transferAmount;
  @JsonKey(name: 'failure_reason')
  final TransferFailure? failureReason;
  @JsonKey(name: 'sweep_id')
  final String? sweepId;
  @JsonKey(name: 'sweep_amount')
  final String? sweepAmount;
  static const fromJsonFactory = _$TransferEventFromJson;
  static const toJsonFactory = _$TransferEventToJson;
  Map<String, dynamic> toJson() => _$TransferEventToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferEvent &&
            (identical(other.eventId, eventId) ||
                const DeepCollectionEquality()
                    .equals(other.eventId, eventId)) &&
            (identical(other.timestamp, timestamp) ||
                const DeepCollectionEquality()
                    .equals(other.timestamp, timestamp)) &&
            (identical(other.eventType, eventType) ||
                const DeepCollectionEquality()
                    .equals(other.eventType, eventType)) &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.transferId, transferId) ||
                const DeepCollectionEquality()
                    .equals(other.transferId, transferId)) &&
            (identical(other.originationAccountId, originationAccountId) ||
                const DeepCollectionEquality().equals(
                    other.originationAccountId, originationAccountId)) &&
            (identical(other.transferType, transferType) ||
                const DeepCollectionEquality()
                    .equals(other.transferType, transferType)) &&
            (identical(other.transferAmount, transferAmount) ||
                const DeepCollectionEquality()
                    .equals(other.transferAmount, transferAmount)) &&
            (identical(other.failureReason, failureReason) ||
                const DeepCollectionEquality()
                    .equals(other.failureReason, failureReason)) &&
            (identical(other.sweepId, sweepId) ||
                const DeepCollectionEquality()
                    .equals(other.sweepId, sweepId)) &&
            (identical(other.sweepAmount, sweepAmount) ||
                const DeepCollectionEquality()
                    .equals(other.sweepAmount, sweepAmount)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(eventId) ^
      const DeepCollectionEquality().hash(timestamp) ^
      const DeepCollectionEquality().hash(eventType) ^
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(transferId) ^
      const DeepCollectionEquality().hash(originationAccountId) ^
      const DeepCollectionEquality().hash(transferType) ^
      const DeepCollectionEquality().hash(transferAmount) ^
      const DeepCollectionEquality().hash(failureReason) ^
      const DeepCollectionEquality().hash(sweepId) ^
      const DeepCollectionEquality().hash(sweepAmount) ^
      runtimeType.hashCode;
}

extension $TransferEventExtension on TransferEvent {
  TransferEvent copyWith(
      {int? eventId,
      DateTime? timestamp,
      enums.TransferEventType? eventType,
      String? accountId,
      String? transferId,
      String? originationAccountId,
      enums.TransferType? transferType,
      String? transferAmount,
      TransferFailure? failureReason,
      String? sweepId,
      String? sweepAmount}) {
    return TransferEvent(
        eventId: eventId ?? this.eventId,
        timestamp: timestamp ?? this.timestamp,
        eventType: eventType ?? this.eventType,
        accountId: accountId ?? this.accountId,
        transferId: transferId ?? this.transferId,
        originationAccountId: originationAccountId ?? this.originationAccountId,
        transferType: transferType ?? this.transferType,
        transferAmount: transferAmount ?? this.transferAmount,
        failureReason: failureReason ?? this.failureReason,
        sweepId: sweepId ?? this.sweepId,
        sweepAmount: sweepAmount ?? this.sweepAmount);
  }
}

@JsonSerializable(explicitToJson: true)
class BankTransferEvent {
  BankTransferEvent({
    this.eventId,
    this.timestamp,
    this.eventType,
    this.accountId,
    this.bankTransferId,
    this.originationAccountId,
    this.bankTransferType,
    this.bankTransferAmount,
    this.bankTransferIsoCurrencyCode,
    this.failureReason,
    this.direction,
    this.receiverDetails,
  });

  factory BankTransferEvent.fromJson(Map<String, dynamic> json) =>
      _$BankTransferEventFromJson(json);

  @JsonKey(name: 'event_id')
  final int? eventId;
  @JsonKey(name: 'timestamp')
  final DateTime? timestamp;
  @JsonKey(
      name: 'event_type',
      toJson: bankTransferEventTypeToJson,
      fromJson: bankTransferEventTypeFromJson)
  final enums.BankTransferEventType? eventType;
  @JsonKey(name: 'account_id')
  final String? accountId;
  @JsonKey(name: 'bank_transfer_id')
  final String? bankTransferId;
  @JsonKey(name: 'origination_account_id')
  final String? originationAccountId;
  @JsonKey(
      name: 'bank_transfer_type',
      toJson: bankTransferTypeToJson,
      fromJson: bankTransferTypeFromJson)
  final enums.BankTransferType? bankTransferType;
  @JsonKey(name: 'bank_transfer_amount')
  final String? bankTransferAmount;
  @JsonKey(name: 'bank_transfer_iso_currency_code')
  final String? bankTransferIsoCurrencyCode;
  @JsonKey(name: 'failure_reason')
  final BankTransferFailure? failureReason;
  @JsonKey(
      name: 'direction',
      toJson: bankTransferDirectionToJson,
      fromJson: bankTransferDirectionFromJson)
  final enums.BankTransferDirection? direction;
  @JsonKey(name: 'receiver_details')
  final BankTransferReceiverDetails? receiverDetails;
  static const fromJsonFactory = _$BankTransferEventFromJson;
  static const toJsonFactory = _$BankTransferEventToJson;
  Map<String, dynamic> toJson() => _$BankTransferEventToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BankTransferEvent &&
            (identical(other.eventId, eventId) ||
                const DeepCollectionEquality()
                    .equals(other.eventId, eventId)) &&
            (identical(other.timestamp, timestamp) ||
                const DeepCollectionEquality()
                    .equals(other.timestamp, timestamp)) &&
            (identical(other.eventType, eventType) ||
                const DeepCollectionEquality()
                    .equals(other.eventType, eventType)) &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.bankTransferId, bankTransferId) ||
                const DeepCollectionEquality()
                    .equals(other.bankTransferId, bankTransferId)) &&
            (identical(other.originationAccountId, originationAccountId) ||
                const DeepCollectionEquality().equals(
                    other.originationAccountId, originationAccountId)) &&
            (identical(other.bankTransferType, bankTransferType) ||
                const DeepCollectionEquality()
                    .equals(other.bankTransferType, bankTransferType)) &&
            (identical(other.bankTransferAmount, bankTransferAmount) ||
                const DeepCollectionEquality()
                    .equals(other.bankTransferAmount, bankTransferAmount)) &&
            (identical(other.bankTransferIsoCurrencyCode,
                    bankTransferIsoCurrencyCode) ||
                const DeepCollectionEquality().equals(
                    other.bankTransferIsoCurrencyCode,
                    bankTransferIsoCurrencyCode)) &&
            (identical(other.failureReason, failureReason) ||
                const DeepCollectionEquality()
                    .equals(other.failureReason, failureReason)) &&
            (identical(other.direction, direction) ||
                const DeepCollectionEquality()
                    .equals(other.direction, direction)) &&
            (identical(other.receiverDetails, receiverDetails) ||
                const DeepCollectionEquality()
                    .equals(other.receiverDetails, receiverDetails)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(eventId) ^
      const DeepCollectionEquality().hash(timestamp) ^
      const DeepCollectionEquality().hash(eventType) ^
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(bankTransferId) ^
      const DeepCollectionEquality().hash(originationAccountId) ^
      const DeepCollectionEquality().hash(bankTransferType) ^
      const DeepCollectionEquality().hash(bankTransferAmount) ^
      const DeepCollectionEquality().hash(bankTransferIsoCurrencyCode) ^
      const DeepCollectionEquality().hash(failureReason) ^
      const DeepCollectionEquality().hash(direction) ^
      const DeepCollectionEquality().hash(receiverDetails) ^
      runtimeType.hashCode;
}

extension $BankTransferEventExtension on BankTransferEvent {
  BankTransferEvent copyWith(
      {int? eventId,
      DateTime? timestamp,
      enums.BankTransferEventType? eventType,
      String? accountId,
      String? bankTransferId,
      String? originationAccountId,
      enums.BankTransferType? bankTransferType,
      String? bankTransferAmount,
      String? bankTransferIsoCurrencyCode,
      BankTransferFailure? failureReason,
      enums.BankTransferDirection? direction,
      BankTransferReceiverDetails? receiverDetails}) {
    return BankTransferEvent(
        eventId: eventId ?? this.eventId,
        timestamp: timestamp ?? this.timestamp,
        eventType: eventType ?? this.eventType,
        accountId: accountId ?? this.accountId,
        bankTransferId: bankTransferId ?? this.bankTransferId,
        originationAccountId: originationAccountId ?? this.originationAccountId,
        bankTransferType: bankTransferType ?? this.bankTransferType,
        bankTransferAmount: bankTransferAmount ?? this.bankTransferAmount,
        bankTransferIsoCurrencyCode:
            bankTransferIsoCurrencyCode ?? this.bankTransferIsoCurrencyCode,
        failureReason: failureReason ?? this.failureReason,
        direction: direction ?? this.direction,
        receiverDetails: receiverDetails ?? this.receiverDetails);
  }
}

@JsonSerializable(explicitToJson: true)
class TransferEventListResponse {
  TransferEventListResponse({
    this.transferEvents,
    this.requestId,
  });

  factory TransferEventListResponse.fromJson(Map<String, dynamic> json) =>
      _$TransferEventListResponseFromJson(json);

  @JsonKey(name: 'transfer_events', defaultValue: <TransferEvent>[])
  final List<TransferEvent>? transferEvents;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$TransferEventListResponseFromJson;
  static const toJsonFactory = _$TransferEventListResponseToJson;
  Map<String, dynamic> toJson() => _$TransferEventListResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferEventListResponse &&
            (identical(other.transferEvents, transferEvents) ||
                const DeepCollectionEquality()
                    .equals(other.transferEvents, transferEvents)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(transferEvents) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $TransferEventListResponseExtension on TransferEventListResponse {
  TransferEventListResponse copyWith(
      {List<TransferEvent>? transferEvents, String? requestId}) {
    return TransferEventListResponse(
        transferEvents: transferEvents ?? this.transferEvents,
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class BankTransferEventListResponse {
  BankTransferEventListResponse({
    this.bankTransferEvents,
    this.requestId,
  });

  factory BankTransferEventListResponse.fromJson(Map<String, dynamic> json) =>
      _$BankTransferEventListResponseFromJson(json);

  @JsonKey(name: 'bank_transfer_events', defaultValue: <BankTransferEvent>[])
  final List<BankTransferEvent>? bankTransferEvents;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$BankTransferEventListResponseFromJson;
  static const toJsonFactory = _$BankTransferEventListResponseToJson;
  Map<String, dynamic> toJson() => _$BankTransferEventListResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BankTransferEventListResponse &&
            (identical(other.bankTransferEvents, bankTransferEvents) ||
                const DeepCollectionEquality()
                    .equals(other.bankTransferEvents, bankTransferEvents)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(bankTransferEvents) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $BankTransferEventListResponseExtension
    on BankTransferEventListResponse {
  BankTransferEventListResponse copyWith(
      {List<BankTransferEvent>? bankTransferEvents, String? requestId}) {
    return BankTransferEventListResponse(
        bankTransferEvents: bankTransferEvents ?? this.bankTransferEvents,
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class BankTransferEventSyncRequest {
  BankTransferEventSyncRequest({
    this.clientId,
    this.secret,
    this.afterId,
    this.count,
  });

  factory BankTransferEventSyncRequest.fromJson(Map<String, dynamic> json) =>
      _$BankTransferEventSyncRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'after_id')
  final int? afterId;
  @JsonKey(name: 'count')
  final int? count;
  static const fromJsonFactory = _$BankTransferEventSyncRequestFromJson;
  static const toJsonFactory = _$BankTransferEventSyncRequestToJson;
  Map<String, dynamic> toJson() => _$BankTransferEventSyncRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BankTransferEventSyncRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.afterId, afterId) ||
                const DeepCollectionEquality()
                    .equals(other.afterId, afterId)) &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(afterId) ^
      const DeepCollectionEquality().hash(count) ^
      runtimeType.hashCode;
}

extension $BankTransferEventSyncRequestExtension
    on BankTransferEventSyncRequest {
  BankTransferEventSyncRequest copyWith(
      {String? clientId, String? secret, int? afterId, int? count}) {
    return BankTransferEventSyncRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        afterId: afterId ?? this.afterId,
        count: count ?? this.count);
  }
}

@JsonSerializable(explicitToJson: true)
class TransferEventSyncRequest {
  TransferEventSyncRequest({
    this.clientId,
    this.secret,
    this.afterId,
    this.count,
  });

  factory TransferEventSyncRequest.fromJson(Map<String, dynamic> json) =>
      _$TransferEventSyncRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'after_id')
  final int? afterId;
  @JsonKey(name: 'count')
  final int? count;
  static const fromJsonFactory = _$TransferEventSyncRequestFromJson;
  static const toJsonFactory = _$TransferEventSyncRequestToJson;
  Map<String, dynamic> toJson() => _$TransferEventSyncRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferEventSyncRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.afterId, afterId) ||
                const DeepCollectionEquality()
                    .equals(other.afterId, afterId)) &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(afterId) ^
      const DeepCollectionEquality().hash(count) ^
      runtimeType.hashCode;
}

extension $TransferEventSyncRequestExtension on TransferEventSyncRequest {
  TransferEventSyncRequest copyWith(
      {String? clientId, String? secret, int? afterId, int? count}) {
    return TransferEventSyncRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        afterId: afterId ?? this.afterId,
        count: count ?? this.count);
  }
}

@JsonSerializable(explicitToJson: true)
class BankTransferEventSyncResponse {
  BankTransferEventSyncResponse({
    this.bankTransferEvents,
    this.requestId,
  });

  factory BankTransferEventSyncResponse.fromJson(Map<String, dynamic> json) =>
      _$BankTransferEventSyncResponseFromJson(json);

  @JsonKey(name: 'bank_transfer_events', defaultValue: <BankTransferEvent>[])
  final List<BankTransferEvent>? bankTransferEvents;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$BankTransferEventSyncResponseFromJson;
  static const toJsonFactory = _$BankTransferEventSyncResponseToJson;
  Map<String, dynamic> toJson() => _$BankTransferEventSyncResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BankTransferEventSyncResponse &&
            (identical(other.bankTransferEvents, bankTransferEvents) ||
                const DeepCollectionEquality()
                    .equals(other.bankTransferEvents, bankTransferEvents)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(bankTransferEvents) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $BankTransferEventSyncResponseExtension
    on BankTransferEventSyncResponse {
  BankTransferEventSyncResponse copyWith(
      {List<BankTransferEvent>? bankTransferEvents, String? requestId}) {
    return BankTransferEventSyncResponse(
        bankTransferEvents: bankTransferEvents ?? this.bankTransferEvents,
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class TransferEventSyncResponse {
  TransferEventSyncResponse({
    this.transferEvents,
    this.requestId,
  });

  factory TransferEventSyncResponse.fromJson(Map<String, dynamic> json) =>
      _$TransferEventSyncResponseFromJson(json);

  @JsonKey(name: 'transfer_events', defaultValue: <TransferEvent>[])
  final List<TransferEvent>? transferEvents;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$TransferEventSyncResponseFromJson;
  static const toJsonFactory = _$TransferEventSyncResponseToJson;
  Map<String, dynamic> toJson() => _$TransferEventSyncResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferEventSyncResponse &&
            (identical(other.transferEvents, transferEvents) ||
                const DeepCollectionEquality()
                    .equals(other.transferEvents, transferEvents)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(transferEvents) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $TransferEventSyncResponseExtension on TransferEventSyncResponse {
  TransferEventSyncResponse copyWith(
      {List<TransferEvent>? transferEvents, String? requestId}) {
    return TransferEventSyncResponse(
        transferEvents: transferEvents ?? this.transferEvents,
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class BankTransferSweepGetRequest {
  BankTransferSweepGetRequest({
    this.clientId,
    this.secret,
    this.sweepId,
    this.originationAccountId,
  });

  factory BankTransferSweepGetRequest.fromJson(Map<String, dynamic> json) =>
      _$BankTransferSweepGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'sweep_id')
  final String? sweepId;
  @JsonKey(name: 'origination_account_id')
  final String? originationAccountId;
  static const fromJsonFactory = _$BankTransferSweepGetRequestFromJson;
  static const toJsonFactory = _$BankTransferSweepGetRequestToJson;
  Map<String, dynamic> toJson() => _$BankTransferSweepGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BankTransferSweepGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.sweepId, sweepId) ||
                const DeepCollectionEquality()
                    .equals(other.sweepId, sweepId)) &&
            (identical(other.originationAccountId, originationAccountId) ||
                const DeepCollectionEquality()
                    .equals(other.originationAccountId, originationAccountId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(sweepId) ^
      const DeepCollectionEquality().hash(originationAccountId) ^
      runtimeType.hashCode;
}

extension $BankTransferSweepGetRequestExtension on BankTransferSweepGetRequest {
  BankTransferSweepGetRequest copyWith(
      {String? clientId,
      String? secret,
      String? sweepId,
      String? originationAccountId}) {
    return BankTransferSweepGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        sweepId: sweepId ?? this.sweepId,
        originationAccountId:
            originationAccountId ?? this.originationAccountId);
  }
}

@JsonSerializable(explicitToJson: true)
class TransferSweepGetRequest {
  TransferSweepGetRequest({
    this.clientId,
    this.secret,
    this.sweepId,
  });

  factory TransferSweepGetRequest.fromJson(Map<String, dynamic> json) =>
      _$TransferSweepGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'sweep_id')
  final String? sweepId;
  static const fromJsonFactory = _$TransferSweepGetRequestFromJson;
  static const toJsonFactory = _$TransferSweepGetRequestToJson;
  Map<String, dynamic> toJson() => _$TransferSweepGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferSweepGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.sweepId, sweepId) ||
                const DeepCollectionEquality().equals(other.sweepId, sweepId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(sweepId) ^
      runtimeType.hashCode;
}

extension $TransferSweepGetRequestExtension on TransferSweepGetRequest {
  TransferSweepGetRequest copyWith(
      {String? clientId, String? secret, String? sweepId}) {
    return TransferSweepGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        sweepId: sweepId ?? this.sweepId);
  }
}

@JsonSerializable(explicitToJson: true)
class BankTransferSweepGetResponse {
  BankTransferSweepGetResponse({
    this.sweep,
    this.requestId,
  });

  factory BankTransferSweepGetResponse.fromJson(Map<String, dynamic> json) =>
      _$BankTransferSweepGetResponseFromJson(json);

  @JsonKey(name: 'sweep')
  final BankTransferSweep? sweep;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$BankTransferSweepGetResponseFromJson;
  static const toJsonFactory = _$BankTransferSweepGetResponseToJson;
  Map<String, dynamic> toJson() => _$BankTransferSweepGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BankTransferSweepGetResponse &&
            (identical(other.sweep, sweep) ||
                const DeepCollectionEquality().equals(other.sweep, sweep)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(sweep) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $BankTransferSweepGetResponseExtension
    on BankTransferSweepGetResponse {
  BankTransferSweepGetResponse copyWith(
      {BankTransferSweep? sweep, String? requestId}) {
    return BankTransferSweepGetResponse(
        sweep: sweep ?? this.sweep, requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class TransferSweepGetResponse {
  TransferSweepGetResponse({
    this.sweep,
    this.requestId,
  });

  factory TransferSweepGetResponse.fromJson(Map<String, dynamic> json) =>
      _$TransferSweepGetResponseFromJson(json);

  @JsonKey(name: 'sweep')
  final TransferSweep? sweep;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$TransferSweepGetResponseFromJson;
  static const toJsonFactory = _$TransferSweepGetResponseToJson;
  Map<String, dynamic> toJson() => _$TransferSweepGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferSweepGetResponse &&
            (identical(other.sweep, sweep) ||
                const DeepCollectionEquality().equals(other.sweep, sweep)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(sweep) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $TransferSweepGetResponseExtension on TransferSweepGetResponse {
  TransferSweepGetResponse copyWith({TransferSweep? sweep, String? requestId}) {
    return TransferSweepGetResponse(
        sweep: sweep ?? this.sweep, requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class BankTransferSweepListRequest {
  BankTransferSweepListRequest({
    this.clientId,
    this.secret,
    this.originationAccountId,
    this.startTime,
    this.endTime,
    this.count,
  });

  factory BankTransferSweepListRequest.fromJson(Map<String, dynamic> json) =>
      _$BankTransferSweepListRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'origination_account_id')
  final String? originationAccountId;
  @JsonKey(name: 'start_time')
  final DateTime? startTime;
  @JsonKey(name: 'end_time')
  final DateTime? endTime;
  @JsonKey(name: 'count')
  final int? count;
  static const fromJsonFactory = _$BankTransferSweepListRequestFromJson;
  static const toJsonFactory = _$BankTransferSweepListRequestToJson;
  Map<String, dynamic> toJson() => _$BankTransferSweepListRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BankTransferSweepListRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.originationAccountId, originationAccountId) ||
                const DeepCollectionEquality().equals(
                    other.originationAccountId, originationAccountId)) &&
            (identical(other.startTime, startTime) ||
                const DeepCollectionEquality()
                    .equals(other.startTime, startTime)) &&
            (identical(other.endTime, endTime) ||
                const DeepCollectionEquality()
                    .equals(other.endTime, endTime)) &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(originationAccountId) ^
      const DeepCollectionEquality().hash(startTime) ^
      const DeepCollectionEquality().hash(endTime) ^
      const DeepCollectionEquality().hash(count) ^
      runtimeType.hashCode;
}

extension $BankTransferSweepListRequestExtension
    on BankTransferSweepListRequest {
  BankTransferSweepListRequest copyWith(
      {String? clientId,
      String? secret,
      String? originationAccountId,
      DateTime? startTime,
      DateTime? endTime,
      int? count}) {
    return BankTransferSweepListRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        originationAccountId: originationAccountId ?? this.originationAccountId,
        startTime: startTime ?? this.startTime,
        endTime: endTime ?? this.endTime,
        count: count ?? this.count);
  }
}

@JsonSerializable(explicitToJson: true)
class TransferSweepListRequest {
  TransferSweepListRequest({
    this.clientId,
    this.secret,
    this.startTime,
    this.endTime,
    this.count,
    this.transferId,
    this.offset,
  });

  factory TransferSweepListRequest.fromJson(Map<String, dynamic> json) =>
      _$TransferSweepListRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'start_time')
  final DateTime? startTime;
  @JsonKey(name: 'end_time')
  final DateTime? endTime;
  @JsonKey(name: 'count')
  final int? count;
  @JsonKey(name: 'transfer_id')
  final String? transferId;
  @JsonKey(name: 'offset')
  final int? offset;
  static const fromJsonFactory = _$TransferSweepListRequestFromJson;
  static const toJsonFactory = _$TransferSweepListRequestToJson;
  Map<String, dynamic> toJson() => _$TransferSweepListRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferSweepListRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.startTime, startTime) ||
                const DeepCollectionEquality()
                    .equals(other.startTime, startTime)) &&
            (identical(other.endTime, endTime) ||
                const DeepCollectionEquality()
                    .equals(other.endTime, endTime)) &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)) &&
            (identical(other.transferId, transferId) ||
                const DeepCollectionEquality()
                    .equals(other.transferId, transferId)) &&
            (identical(other.offset, offset) ||
                const DeepCollectionEquality().equals(other.offset, offset)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(startTime) ^
      const DeepCollectionEquality().hash(endTime) ^
      const DeepCollectionEquality().hash(count) ^
      const DeepCollectionEquality().hash(transferId) ^
      const DeepCollectionEquality().hash(offset) ^
      runtimeType.hashCode;
}

extension $TransferSweepListRequestExtension on TransferSweepListRequest {
  TransferSweepListRequest copyWith(
      {String? clientId,
      String? secret,
      DateTime? startTime,
      DateTime? endTime,
      int? count,
      String? transferId,
      int? offset}) {
    return TransferSweepListRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        startTime: startTime ?? this.startTime,
        endTime: endTime ?? this.endTime,
        count: count ?? this.count,
        transferId: transferId ?? this.transferId,
        offset: offset ?? this.offset);
  }
}

@JsonSerializable(explicitToJson: true)
class TransferSweepListResponse {
  TransferSweepListResponse({
    this.sweeps,
    this.requestId,
  });

  factory TransferSweepListResponse.fromJson(Map<String, dynamic> json) =>
      _$TransferSweepListResponseFromJson(json);

  @JsonKey(name: 'sweeps', defaultValue: <TransferSweep>[])
  final List<TransferSweep>? sweeps;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$TransferSweepListResponseFromJson;
  static const toJsonFactory = _$TransferSweepListResponseToJson;
  Map<String, dynamic> toJson() => _$TransferSweepListResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferSweepListResponse &&
            (identical(other.sweeps, sweeps) ||
                const DeepCollectionEquality().equals(other.sweeps, sweeps)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(sweeps) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $TransferSweepListResponseExtension on TransferSweepListResponse {
  TransferSweepListResponse copyWith(
      {List<TransferSweep>? sweeps, String? requestId}) {
    return TransferSweepListResponse(
        sweeps: sweeps ?? this.sweeps, requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class BankTransferSweepListResponse {
  BankTransferSweepListResponse({
    this.sweeps,
    this.requestId,
  });

  factory BankTransferSweepListResponse.fromJson(Map<String, dynamic> json) =>
      _$BankTransferSweepListResponseFromJson(json);

  @JsonKey(name: 'sweeps', defaultValue: <BankTransferSweep>[])
  final List<BankTransferSweep>? sweeps;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$BankTransferSweepListResponseFromJson;
  static const toJsonFactory = _$BankTransferSweepListResponseToJson;
  Map<String, dynamic> toJson() => _$BankTransferSweepListResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BankTransferSweepListResponse &&
            (identical(other.sweeps, sweeps) ||
                const DeepCollectionEquality().equals(other.sweeps, sweeps)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(sweeps) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $BankTransferSweepListResponseExtension
    on BankTransferSweepListResponse {
  BankTransferSweepListResponse copyWith(
      {List<BankTransferSweep>? sweeps, String? requestId}) {
    return BankTransferSweepListResponse(
        sweeps: sweeps ?? this.sweeps, requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class BankTransferSweep {
  BankTransferSweep({
    this.id,
    this.transferId,
    this.createdAt,
    this.amount,
    this.isoCurrencyCode,
    this.sweepAccount,
  });

  factory BankTransferSweep.fromJson(Map<String, dynamic> json) =>
      _$BankTransferSweepFromJson(json);

  @JsonKey(name: 'id')
  final String? id;
  @JsonKey(name: 'transfer_id')
  final String? transferId;
  @JsonKey(name: 'created_at')
  final DateTime? createdAt;
  @JsonKey(name: 'amount')
  final String? amount;
  @JsonKey(name: 'iso_currency_code')
  final String? isoCurrencyCode;
  @JsonKey(name: 'sweep_account')
  final BankTransferSweepAccount? sweepAccount;
  static const fromJsonFactory = _$BankTransferSweepFromJson;
  static const toJsonFactory = _$BankTransferSweepToJson;
  Map<String, dynamic> toJson() => _$BankTransferSweepToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BankTransferSweep &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.transferId, transferId) ||
                const DeepCollectionEquality()
                    .equals(other.transferId, transferId)) &&
            (identical(other.createdAt, createdAt) ||
                const DeepCollectionEquality()
                    .equals(other.createdAt, createdAt)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)) &&
            (identical(other.sweepAccount, sweepAccount) ||
                const DeepCollectionEquality()
                    .equals(other.sweepAccount, sweepAccount)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(transferId) ^
      const DeepCollectionEquality().hash(createdAt) ^
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      const DeepCollectionEquality().hash(sweepAccount) ^
      runtimeType.hashCode;
}

extension $BankTransferSweepExtension on BankTransferSweep {
  BankTransferSweep copyWith(
      {String? id,
      String? transferId,
      DateTime? createdAt,
      String? amount,
      String? isoCurrencyCode,
      BankTransferSweepAccount? sweepAccount}) {
    return BankTransferSweep(
        id: id ?? this.id,
        transferId: transferId ?? this.transferId,
        createdAt: createdAt ?? this.createdAt,
        amount: amount ?? this.amount,
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode,
        sweepAccount: sweepAccount ?? this.sweepAccount);
  }
}

@JsonSerializable(explicitToJson: true)
class TransferSweep {
  TransferSweep({
    this.id,
    this.createdAt,
    this.amount,
  });

  factory TransferSweep.fromJson(Map<String, dynamic> json) =>
      _$TransferSweepFromJson(json);

  @JsonKey(name: 'id')
  final String? id;
  @JsonKey(name: 'created_at')
  final DateTime? createdAt;
  @JsonKey(name: 'amount')
  final String? amount;
  static const fromJsonFactory = _$TransferSweepFromJson;
  static const toJsonFactory = _$TransferSweepToJson;
  Map<String, dynamic> toJson() => _$TransferSweepToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferSweep &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.createdAt, createdAt) ||
                const DeepCollectionEquality()
                    .equals(other.createdAt, createdAt)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(createdAt) ^
      const DeepCollectionEquality().hash(amount) ^
      runtimeType.hashCode;
}

extension $TransferSweepExtension on TransferSweep {
  TransferSweep copyWith({String? id, DateTime? createdAt, String? amount}) {
    return TransferSweep(
        id: id ?? this.id,
        createdAt: createdAt ?? this.createdAt,
        amount: amount ?? this.amount);
  }
}

@JsonSerializable(explicitToJson: true)
class BankTransferSweepAccount {
  BankTransferSweepAccount({
    this.accountNumber,
    this.routingNumber,
  });

  factory BankTransferSweepAccount.fromJson(Map<String, dynamic> json) =>
      _$BankTransferSweepAccountFromJson(json);

  @JsonKey(name: 'account_number')
  final String? accountNumber;
  @JsonKey(name: 'routing_number')
  final String? routingNumber;
  static const fromJsonFactory = _$BankTransferSweepAccountFromJson;
  static const toJsonFactory = _$BankTransferSweepAccountToJson;
  Map<String, dynamic> toJson() => _$BankTransferSweepAccountToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BankTransferSweepAccount &&
            (identical(other.accountNumber, accountNumber) ||
                const DeepCollectionEquality()
                    .equals(other.accountNumber, accountNumber)) &&
            (identical(other.routingNumber, routingNumber) ||
                const DeepCollectionEquality()
                    .equals(other.routingNumber, routingNumber)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountNumber) ^
      const DeepCollectionEquality().hash(routingNumber) ^
      runtimeType.hashCode;
}

extension $BankTransferSweepAccountExtension on BankTransferSweepAccount {
  BankTransferSweepAccount copyWith(
      {String? accountNumber, String? routingNumber}) {
    return BankTransferSweepAccount(
        accountNumber: accountNumber ?? this.accountNumber,
        routingNumber: routingNumber ?? this.routingNumber);
  }
}

@JsonSerializable(explicitToJson: true)
class BankTransferBalanceGetRequest {
  BankTransferBalanceGetRequest({
    this.clientId,
    this.secret,
    this.originationAccountId,
  });

  factory BankTransferBalanceGetRequest.fromJson(Map<String, dynamic> json) =>
      _$BankTransferBalanceGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'origination_account_id')
  final String? originationAccountId;
  static const fromJsonFactory = _$BankTransferBalanceGetRequestFromJson;
  static const toJsonFactory = _$BankTransferBalanceGetRequestToJson;
  Map<String, dynamic> toJson() => _$BankTransferBalanceGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BankTransferBalanceGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.originationAccountId, originationAccountId) ||
                const DeepCollectionEquality()
                    .equals(other.originationAccountId, originationAccountId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(originationAccountId) ^
      runtimeType.hashCode;
}

extension $BankTransferBalanceGetRequestExtension
    on BankTransferBalanceGetRequest {
  BankTransferBalanceGetRequest copyWith(
      {String? clientId, String? secret, String? originationAccountId}) {
    return BankTransferBalanceGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        originationAccountId:
            originationAccountId ?? this.originationAccountId);
  }
}

@JsonSerializable(explicitToJson: true)
class BankTransferBalanceGetResponse {
  BankTransferBalanceGetResponse({
    this.balance,
    this.originationAccountId,
    this.requestId,
  });

  factory BankTransferBalanceGetResponse.fromJson(Map<String, dynamic> json) =>
      _$BankTransferBalanceGetResponseFromJson(json);

  @JsonKey(name: 'balance')
  final BankTransferBalance? balance;
  @JsonKey(name: 'origination_account_id')
  final String? originationAccountId;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$BankTransferBalanceGetResponseFromJson;
  static const toJsonFactory = _$BankTransferBalanceGetResponseToJson;
  Map<String, dynamic> toJson() => _$BankTransferBalanceGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BankTransferBalanceGetResponse &&
            (identical(other.balance, balance) ||
                const DeepCollectionEquality()
                    .equals(other.balance, balance)) &&
            (identical(other.originationAccountId, originationAccountId) ||
                const DeepCollectionEquality().equals(
                    other.originationAccountId, originationAccountId)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(balance) ^
      const DeepCollectionEquality().hash(originationAccountId) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $BankTransferBalanceGetResponseExtension
    on BankTransferBalanceGetResponse {
  BankTransferBalanceGetResponse copyWith(
      {BankTransferBalance? balance,
      String? originationAccountId,
      String? requestId}) {
    return BankTransferBalanceGetResponse(
        balance: balance ?? this.balance,
        originationAccountId: originationAccountId ?? this.originationAccountId,
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class BankTransferBalance {
  BankTransferBalance({
    this.available,
    this.transactable,
  });

  factory BankTransferBalance.fromJson(Map<String, dynamic> json) =>
      _$BankTransferBalanceFromJson(json);

  @JsonKey(name: 'available')
  final String? available;
  @JsonKey(name: 'transactable')
  final String? transactable;
  static const fromJsonFactory = _$BankTransferBalanceFromJson;
  static const toJsonFactory = _$BankTransferBalanceToJson;
  Map<String, dynamic> toJson() => _$BankTransferBalanceToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BankTransferBalance &&
            (identical(other.available, available) ||
                const DeepCollectionEquality()
                    .equals(other.available, available)) &&
            (identical(other.transactable, transactable) ||
                const DeepCollectionEquality()
                    .equals(other.transactable, transactable)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(available) ^
      const DeepCollectionEquality().hash(transactable) ^
      runtimeType.hashCode;
}

extension $BankTransferBalanceExtension on BankTransferBalance {
  BankTransferBalance copyWith({String? available, String? transactable}) {
    return BankTransferBalance(
        available: available ?? this.available,
        transactable: transactable ?? this.transactable);
  }
}

@JsonSerializable(explicitToJson: true)
class BankTransferMigrateAccountRequest {
  BankTransferMigrateAccountRequest({
    this.clientId,
    this.secret,
    this.accountNumber,
    this.routingNumber,
    this.accountType,
  });

  factory BankTransferMigrateAccountRequest.fromJson(
          Map<String, dynamic> json) =>
      _$BankTransferMigrateAccountRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'account_number')
  final String? accountNumber;
  @JsonKey(name: 'routing_number')
  final String? routingNumber;
  @JsonKey(name: 'account_type')
  final String? accountType;
  static const fromJsonFactory = _$BankTransferMigrateAccountRequestFromJson;
  static const toJsonFactory = _$BankTransferMigrateAccountRequestToJson;
  Map<String, dynamic> toJson() =>
      _$BankTransferMigrateAccountRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BankTransferMigrateAccountRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.accountNumber, accountNumber) ||
                const DeepCollectionEquality()
                    .equals(other.accountNumber, accountNumber)) &&
            (identical(other.routingNumber, routingNumber) ||
                const DeepCollectionEquality()
                    .equals(other.routingNumber, routingNumber)) &&
            (identical(other.accountType, accountType) ||
                const DeepCollectionEquality()
                    .equals(other.accountType, accountType)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(accountNumber) ^
      const DeepCollectionEquality().hash(routingNumber) ^
      const DeepCollectionEquality().hash(accountType) ^
      runtimeType.hashCode;
}

extension $BankTransferMigrateAccountRequestExtension
    on BankTransferMigrateAccountRequest {
  BankTransferMigrateAccountRequest copyWith(
      {String? clientId,
      String? secret,
      String? accountNumber,
      String? routingNumber,
      String? accountType}) {
    return BankTransferMigrateAccountRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        accountNumber: accountNumber ?? this.accountNumber,
        routingNumber: routingNumber ?? this.routingNumber,
        accountType: accountType ?? this.accountType);
  }
}

@JsonSerializable(explicitToJson: true)
class BankTransferMigrateAccountResponse {
  BankTransferMigrateAccountResponse({
    this.accessToken,
    this.accountId,
    this.requestId,
  });

  factory BankTransferMigrateAccountResponse.fromJson(
          Map<String, dynamic> json) =>
      _$BankTransferMigrateAccountResponseFromJson(json);

  @JsonKey(name: 'access_token')
  final String? accessToken;
  @JsonKey(name: 'account_id')
  final String? accountId;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$BankTransferMigrateAccountResponseFromJson;
  static const toJsonFactory = _$BankTransferMigrateAccountResponseToJson;
  Map<String, dynamic> toJson() =>
      _$BankTransferMigrateAccountResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BankTransferMigrateAccountResponse &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)) &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accessToken) ^
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $BankTransferMigrateAccountResponseExtension
    on BankTransferMigrateAccountResponse {
  BankTransferMigrateAccountResponse copyWith(
      {String? accessToken, String? accountId, String? requestId}) {
    return BankTransferMigrateAccountResponse(
        accessToken: accessToken ?? this.accessToken,
        accountId: accountId ?? this.accountId,
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class TransferIntentCreateRequest {
  TransferIntentCreateRequest({
    this.clientId,
    this.secret,
    this.accountId,
    this.mode,
    this.amount,
    this.description,
    this.achClass,
    this.originationAccountId,
    this.user,
    this.metadata,
  });

  factory TransferIntentCreateRequest.fromJson(Map<String, dynamic> json) =>
      _$TransferIntentCreateRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'account_id')
  final String? accountId;
  @JsonKey(
      name: 'mode',
      toJson: transferIntentCreateModeToJson,
      fromJson: transferIntentCreateModeFromJson)
  final enums.TransferIntentCreateMode? mode;
  @JsonKey(name: 'amount')
  final String? amount;
  @JsonKey(name: 'description')
  final String? description;
  @JsonKey(
      name: 'ach_class', toJson: aCHClassToJson, fromJson: aCHClassFromJson)
  final enums.ACHClass? achClass;
  @JsonKey(name: 'origination_account_id')
  final String? originationAccountId;
  @JsonKey(name: 'user')
  final TransferUserInRequest? user;
  @JsonKey(name: 'metadata')
  final TransferMetadata? metadata;
  static const fromJsonFactory = _$TransferIntentCreateRequestFromJson;
  static const toJsonFactory = _$TransferIntentCreateRequestToJson;
  Map<String, dynamic> toJson() => _$TransferIntentCreateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferIntentCreateRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.mode, mode) ||
                const DeepCollectionEquality().equals(other.mode, mode)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.achClass, achClass) ||
                const DeepCollectionEquality()
                    .equals(other.achClass, achClass)) &&
            (identical(other.originationAccountId, originationAccountId) ||
                const DeepCollectionEquality().equals(
                    other.originationAccountId, originationAccountId)) &&
            (identical(other.user, user) ||
                const DeepCollectionEquality().equals(other.user, user)) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality()
                    .equals(other.metadata, metadata)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(mode) ^
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(achClass) ^
      const DeepCollectionEquality().hash(originationAccountId) ^
      const DeepCollectionEquality().hash(user) ^
      const DeepCollectionEquality().hash(metadata) ^
      runtimeType.hashCode;
}

extension $TransferIntentCreateRequestExtension on TransferIntentCreateRequest {
  TransferIntentCreateRequest copyWith(
      {String? clientId,
      String? secret,
      String? accountId,
      enums.TransferIntentCreateMode? mode,
      String? amount,
      String? description,
      enums.ACHClass? achClass,
      String? originationAccountId,
      TransferUserInRequest? user,
      TransferMetadata? metadata}) {
    return TransferIntentCreateRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        accountId: accountId ?? this.accountId,
        mode: mode ?? this.mode,
        amount: amount ?? this.amount,
        description: description ?? this.description,
        achClass: achClass ?? this.achClass,
        originationAccountId: originationAccountId ?? this.originationAccountId,
        user: user ?? this.user,
        metadata: metadata ?? this.metadata);
  }
}

@JsonSerializable(explicitToJson: true)
class TransferIntentCreate {
  TransferIntentCreate({
    this.id,
    this.created,
    this.status,
    this.accountId,
    this.originationAccountId,
    this.amount,
    this.mode,
    this.achClass,
    this.user,
    this.description,
    this.metadata,
  });

  factory TransferIntentCreate.fromJson(Map<String, dynamic> json) =>
      _$TransferIntentCreateFromJson(json);

  @JsonKey(name: 'id')
  final String? id;
  @JsonKey(name: 'created')
  final DateTime? created;
  @JsonKey(
      name: 'status',
      toJson: transferIntentCreateStatusToJson,
      fromJson: transferIntentCreateStatusFromJson)
  final enums.TransferIntentCreateStatus? status;
  @JsonKey(name: 'account_id')
  final String? accountId;
  @JsonKey(name: 'origination_account_id')
  final String? originationAccountId;
  @JsonKey(name: 'amount')
  final String? amount;
  @JsonKey(
      name: 'mode',
      toJson: transferIntentCreateModeToJson,
      fromJson: transferIntentCreateModeFromJson)
  final enums.TransferIntentCreateMode? mode;
  @JsonKey(
      name: 'ach_class', toJson: aCHClassToJson, fromJson: aCHClassFromJson)
  final enums.ACHClass? achClass;
  @JsonKey(name: 'user')
  final TransferUserInResponse? user;
  @JsonKey(name: 'description')
  final String? description;
  @JsonKey(name: 'metadata')
  final TransferMetadata? metadata;
  static const fromJsonFactory = _$TransferIntentCreateFromJson;
  static const toJsonFactory = _$TransferIntentCreateToJson;
  Map<String, dynamic> toJson() => _$TransferIntentCreateToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferIntentCreate &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.created, created) ||
                const DeepCollectionEquality()
                    .equals(other.created, created)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.originationAccountId, originationAccountId) ||
                const DeepCollectionEquality().equals(
                    other.originationAccountId, originationAccountId)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.mode, mode) ||
                const DeepCollectionEquality().equals(other.mode, mode)) &&
            (identical(other.achClass, achClass) ||
                const DeepCollectionEquality()
                    .equals(other.achClass, achClass)) &&
            (identical(other.user, user) ||
                const DeepCollectionEquality().equals(other.user, user)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality()
                    .equals(other.metadata, metadata)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(created) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(originationAccountId) ^
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(mode) ^
      const DeepCollectionEquality().hash(achClass) ^
      const DeepCollectionEquality().hash(user) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(metadata) ^
      runtimeType.hashCode;
}

extension $TransferIntentCreateExtension on TransferIntentCreate {
  TransferIntentCreate copyWith(
      {String? id,
      DateTime? created,
      enums.TransferIntentCreateStatus? status,
      String? accountId,
      String? originationAccountId,
      String? amount,
      enums.TransferIntentCreateMode? mode,
      enums.ACHClass? achClass,
      TransferUserInResponse? user,
      String? description,
      TransferMetadata? metadata}) {
    return TransferIntentCreate(
        id: id ?? this.id,
        created: created ?? this.created,
        status: status ?? this.status,
        accountId: accountId ?? this.accountId,
        originationAccountId: originationAccountId ?? this.originationAccountId,
        amount: amount ?? this.amount,
        mode: mode ?? this.mode,
        achClass: achClass ?? this.achClass,
        user: user ?? this.user,
        description: description ?? this.description,
        metadata: metadata ?? this.metadata);
  }
}

@JsonSerializable(explicitToJson: true)
class TransferIntentCreateResponse {
  TransferIntentCreateResponse({
    this.transferIntent,
    this.requestId,
  });

  factory TransferIntentCreateResponse.fromJson(Map<String, dynamic> json) =>
      _$TransferIntentCreateResponseFromJson(json);

  @JsonKey(name: 'transfer_intent')
  final TransferIntentCreate? transferIntent;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$TransferIntentCreateResponseFromJson;
  static const toJsonFactory = _$TransferIntentCreateResponseToJson;
  Map<String, dynamic> toJson() => _$TransferIntentCreateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferIntentCreateResponse &&
            (identical(other.transferIntent, transferIntent) ||
                const DeepCollectionEquality()
                    .equals(other.transferIntent, transferIntent)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(transferIntent) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $TransferIntentCreateResponseExtension
    on TransferIntentCreateResponse {
  TransferIntentCreateResponse copyWith(
      {TransferIntentCreate? transferIntent, String? requestId}) {
    return TransferIntentCreateResponse(
        transferIntent: transferIntent ?? this.transferIntent,
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class TransferIntentGetRequest {
  TransferIntentGetRequest({
    this.clientId,
    this.secret,
    this.transferIntentId,
  });

  factory TransferIntentGetRequest.fromJson(Map<String, dynamic> json) =>
      _$TransferIntentGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'transfer_intent_id')
  final String? transferIntentId;
  static const fromJsonFactory = _$TransferIntentGetRequestFromJson;
  static const toJsonFactory = _$TransferIntentGetRequestToJson;
  Map<String, dynamic> toJson() => _$TransferIntentGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferIntentGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.transferIntentId, transferIntentId) ||
                const DeepCollectionEquality()
                    .equals(other.transferIntentId, transferIntentId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(transferIntentId) ^
      runtimeType.hashCode;
}

extension $TransferIntentGetRequestExtension on TransferIntentGetRequest {
  TransferIntentGetRequest copyWith(
      {String? clientId, String? secret, String? transferIntentId}) {
    return TransferIntentGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        transferIntentId: transferIntentId ?? this.transferIntentId);
  }
}

@JsonSerializable(explicitToJson: true)
class TransferIntentGet {
  TransferIntentGet({
    this.id,
    this.created,
    this.status,
    this.transferId,
    this.failureReason,
    this.authorizationDecision,
    this.authorizationDecisionRationale,
    this.accountId,
    this.originationAccountId,
    this.amount,
    this.mode,
    this.achClass,
    this.user,
    this.description,
    this.metadata,
  });

  factory TransferIntentGet.fromJson(Map<String, dynamic> json) =>
      _$TransferIntentGetFromJson(json);

  @JsonKey(name: 'id')
  final String? id;
  @JsonKey(name: 'created')
  final DateTime? created;
  @JsonKey(
      name: 'status',
      toJson: transferIntentGetStatusToJson,
      fromJson: transferIntentGetStatusFromJson)
  final enums.TransferIntentGetStatus? status;
  @JsonKey(name: 'transfer_id')
  final String? transferId;
  @JsonKey(name: 'failure_reason')
  final TransferIntentGetFailureReason? failureReason;
  @JsonKey(
      name: 'authorization_decision',
      toJson: transferIntentGetAuthorizationDecisionToJson,
      fromJson: transferIntentGetAuthorizationDecisionFromJson)
  final enums.TransferIntentGetAuthorizationDecision? authorizationDecision;
  @JsonKey(name: 'authorization_decision_rationale')
  final TransferAuthorizationDecisionRationale? authorizationDecisionRationale;
  @JsonKey(name: 'account_id')
  final String? accountId;
  @JsonKey(name: 'origination_account_id')
  final String? originationAccountId;
  @JsonKey(name: 'amount')
  final String? amount;
  @JsonKey(
      name: 'mode',
      toJson: transferIntentCreateModeToJson,
      fromJson: transferIntentCreateModeFromJson)
  final enums.TransferIntentCreateMode? mode;
  @JsonKey(
      name: 'ach_class', toJson: aCHClassToJson, fromJson: aCHClassFromJson)
  final enums.ACHClass? achClass;
  @JsonKey(name: 'user')
  final TransferUserInResponse? user;
  @JsonKey(name: 'description')
  final String? description;
  @JsonKey(name: 'metadata')
  final TransferMetadata? metadata;
  static const fromJsonFactory = _$TransferIntentGetFromJson;
  static const toJsonFactory = _$TransferIntentGetToJson;
  Map<String, dynamic> toJson() => _$TransferIntentGetToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferIntentGet &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.created, created) ||
                const DeepCollectionEquality()
                    .equals(other.created, created)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.transferId, transferId) ||
                const DeepCollectionEquality()
                    .equals(other.transferId, transferId)) &&
            (identical(other.failureReason, failureReason) ||
                const DeepCollectionEquality()
                    .equals(other.failureReason, failureReason)) &&
            (identical(other.authorizationDecision, authorizationDecision) ||
                const DeepCollectionEquality().equals(
                    other.authorizationDecision, authorizationDecision)) &&
            (identical(other.authorizationDecisionRationale,
                    authorizationDecisionRationale) ||
                const DeepCollectionEquality().equals(
                    other.authorizationDecisionRationale,
                    authorizationDecisionRationale)) &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.originationAccountId, originationAccountId) ||
                const DeepCollectionEquality().equals(
                    other.originationAccountId, originationAccountId)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.mode, mode) ||
                const DeepCollectionEquality().equals(other.mode, mode)) &&
            (identical(other.achClass, achClass) ||
                const DeepCollectionEquality()
                    .equals(other.achClass, achClass)) &&
            (identical(other.user, user) ||
                const DeepCollectionEquality().equals(other.user, user)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality()
                    .equals(other.metadata, metadata)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(created) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(transferId) ^
      const DeepCollectionEquality().hash(failureReason) ^
      const DeepCollectionEquality().hash(authorizationDecision) ^
      const DeepCollectionEquality().hash(authorizationDecisionRationale) ^
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(originationAccountId) ^
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(mode) ^
      const DeepCollectionEquality().hash(achClass) ^
      const DeepCollectionEquality().hash(user) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(metadata) ^
      runtimeType.hashCode;
}

extension $TransferIntentGetExtension on TransferIntentGet {
  TransferIntentGet copyWith(
      {String? id,
      DateTime? created,
      enums.TransferIntentGetStatus? status,
      String? transferId,
      TransferIntentGetFailureReason? failureReason,
      enums.TransferIntentGetAuthorizationDecision? authorizationDecision,
      TransferAuthorizationDecisionRationale? authorizationDecisionRationale,
      String? accountId,
      String? originationAccountId,
      String? amount,
      enums.TransferIntentCreateMode? mode,
      enums.ACHClass? achClass,
      TransferUserInResponse? user,
      String? description,
      TransferMetadata? metadata}) {
    return TransferIntentGet(
        id: id ?? this.id,
        created: created ?? this.created,
        status: status ?? this.status,
        transferId: transferId ?? this.transferId,
        failureReason: failureReason ?? this.failureReason,
        authorizationDecision:
            authorizationDecision ?? this.authorizationDecision,
        authorizationDecisionRationale: authorizationDecisionRationale ??
            this.authorizationDecisionRationale,
        accountId: accountId ?? this.accountId,
        originationAccountId: originationAccountId ?? this.originationAccountId,
        amount: amount ?? this.amount,
        mode: mode ?? this.mode,
        achClass: achClass ?? this.achClass,
        user: user ?? this.user,
        description: description ?? this.description,
        metadata: metadata ?? this.metadata);
  }
}

@JsonSerializable(explicitToJson: true)
class TransferIntentGetResponse {
  TransferIntentGetResponse({
    this.transferIntent,
    this.requestId,
  });

  factory TransferIntentGetResponse.fromJson(Map<String, dynamic> json) =>
      _$TransferIntentGetResponseFromJson(json);

  @JsonKey(name: 'transfer_intent')
  final TransferIntentGet? transferIntent;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$TransferIntentGetResponseFromJson;
  static const toJsonFactory = _$TransferIntentGetResponseToJson;
  Map<String, dynamic> toJson() => _$TransferIntentGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransferIntentGetResponse &&
            (identical(other.transferIntent, transferIntent) ||
                const DeepCollectionEquality()
                    .equals(other.transferIntent, transferIntent)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(transferIntent) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $TransferIntentGetResponseExtension on TransferIntentGetResponse {
  TransferIntentGetResponse copyWith(
      {TransferIntentGet? transferIntent, String? requestId}) {
    return TransferIntentGetResponse(
        transferIntent: transferIntent ?? this.transferIntent,
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class SandboxBankTransferSimulateRequest {
  SandboxBankTransferSimulateRequest({
    this.clientId,
    this.secret,
    this.bankTransferId,
    this.eventType,
    this.failureReason,
  });

  factory SandboxBankTransferSimulateRequest.fromJson(
          Map<String, dynamic> json) =>
      _$SandboxBankTransferSimulateRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'bank_transfer_id')
  final String? bankTransferId;
  @JsonKey(name: 'event_type')
  final String? eventType;
  @JsonKey(name: 'failure_reason')
  final BankTransferFailure? failureReason;
  static const fromJsonFactory = _$SandboxBankTransferSimulateRequestFromJson;
  static const toJsonFactory = _$SandboxBankTransferSimulateRequestToJson;
  Map<String, dynamic> toJson() =>
      _$SandboxBankTransferSimulateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SandboxBankTransferSimulateRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.bankTransferId, bankTransferId) ||
                const DeepCollectionEquality()
                    .equals(other.bankTransferId, bankTransferId)) &&
            (identical(other.eventType, eventType) ||
                const DeepCollectionEquality()
                    .equals(other.eventType, eventType)) &&
            (identical(other.failureReason, failureReason) ||
                const DeepCollectionEquality()
                    .equals(other.failureReason, failureReason)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(bankTransferId) ^
      const DeepCollectionEquality().hash(eventType) ^
      const DeepCollectionEquality().hash(failureReason) ^
      runtimeType.hashCode;
}

extension $SandboxBankTransferSimulateRequestExtension
    on SandboxBankTransferSimulateRequest {
  SandboxBankTransferSimulateRequest copyWith(
      {String? clientId,
      String? secret,
      String? bankTransferId,
      String? eventType,
      BankTransferFailure? failureReason}) {
    return SandboxBankTransferSimulateRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        bankTransferId: bankTransferId ?? this.bankTransferId,
        eventType: eventType ?? this.eventType,
        failureReason: failureReason ?? this.failureReason);
  }
}

@JsonSerializable(explicitToJson: true)
class SandboxTransferSimulateRequest {
  SandboxTransferSimulateRequest({
    this.clientId,
    this.secret,
    this.transferId,
    this.eventType,
    this.failureReason,
  });

  factory SandboxTransferSimulateRequest.fromJson(Map<String, dynamic> json) =>
      _$SandboxTransferSimulateRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'transfer_id')
  final String? transferId;
  @JsonKey(name: 'event_type')
  final String? eventType;
  @JsonKey(name: 'failure_reason')
  final TransferFailure? failureReason;
  static const fromJsonFactory = _$SandboxTransferSimulateRequestFromJson;
  static const toJsonFactory = _$SandboxTransferSimulateRequestToJson;
  Map<String, dynamic> toJson() => _$SandboxTransferSimulateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SandboxTransferSimulateRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.transferId, transferId) ||
                const DeepCollectionEquality()
                    .equals(other.transferId, transferId)) &&
            (identical(other.eventType, eventType) ||
                const DeepCollectionEquality()
                    .equals(other.eventType, eventType)) &&
            (identical(other.failureReason, failureReason) ||
                const DeepCollectionEquality()
                    .equals(other.failureReason, failureReason)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(transferId) ^
      const DeepCollectionEquality().hash(eventType) ^
      const DeepCollectionEquality().hash(failureReason) ^
      runtimeType.hashCode;
}

extension $SandboxTransferSimulateRequestExtension
    on SandboxTransferSimulateRequest {
  SandboxTransferSimulateRequest copyWith(
      {String? clientId,
      String? secret,
      String? transferId,
      String? eventType,
      TransferFailure? failureReason}) {
    return SandboxTransferSimulateRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        transferId: transferId ?? this.transferId,
        eventType: eventType ?? this.eventType,
        failureReason: failureReason ?? this.failureReason);
  }
}

@JsonSerializable(explicitToJson: true)
class SandboxTransferSweepSimulateRequest {
  SandboxTransferSweepSimulateRequest({
    this.clientId,
    this.secret,
    this.swept,
    this.reverseSwept,
  });

  factory SandboxTransferSweepSimulateRequest.fromJson(
          Map<String, dynamic> json) =>
      _$SandboxTransferSweepSimulateRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'swept', defaultValue: <String>[])
  final List<String>? swept;
  @JsonKey(name: 'reverse_swept', defaultValue: <String>[])
  final List<String>? reverseSwept;
  static const fromJsonFactory = _$SandboxTransferSweepSimulateRequestFromJson;
  static const toJsonFactory = _$SandboxTransferSweepSimulateRequestToJson;
  Map<String, dynamic> toJson() =>
      _$SandboxTransferSweepSimulateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SandboxTransferSweepSimulateRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.swept, swept) ||
                const DeepCollectionEquality().equals(other.swept, swept)) &&
            (identical(other.reverseSwept, reverseSwept) ||
                const DeepCollectionEquality()
                    .equals(other.reverseSwept, reverseSwept)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(swept) ^
      const DeepCollectionEquality().hash(reverseSwept) ^
      runtimeType.hashCode;
}

extension $SandboxTransferSweepSimulateRequestExtension
    on SandboxTransferSweepSimulateRequest {
  SandboxTransferSweepSimulateRequest copyWith(
      {String? clientId,
      String? secret,
      List<String>? swept,
      List<String>? reverseSwept}) {
    return SandboxTransferSweepSimulateRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        swept: swept ?? this.swept,
        reverseSwept: reverseSwept ?? this.reverseSwept);
  }
}

@JsonSerializable(explicitToJson: true)
class SandboxBankTransferSimulateResponse {
  SandboxBankTransferSimulateResponse({
    this.requestId,
  });

  factory SandboxBankTransferSimulateResponse.fromJson(
          Map<String, dynamic> json) =>
      _$SandboxBankTransferSimulateResponseFromJson(json);

  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$SandboxBankTransferSimulateResponseFromJson;
  static const toJsonFactory = _$SandboxBankTransferSimulateResponseToJson;
  Map<String, dynamic> toJson() =>
      _$SandboxBankTransferSimulateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SandboxBankTransferSimulateResponse &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(requestId) ^ runtimeType.hashCode;
}

extension $SandboxBankTransferSimulateResponseExtension
    on SandboxBankTransferSimulateResponse {
  SandboxBankTransferSimulateResponse copyWith({String? requestId}) {
    return SandboxBankTransferSimulateResponse(
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class SandboxTransferSimulateResponse {
  SandboxTransferSimulateResponse({
    this.requestId,
  });

  factory SandboxTransferSimulateResponse.fromJson(Map<String, dynamic> json) =>
      _$SandboxTransferSimulateResponseFromJson(json);

  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$SandboxTransferSimulateResponseFromJson;
  static const toJsonFactory = _$SandboxTransferSimulateResponseToJson;
  Map<String, dynamic> toJson() =>
      _$SandboxTransferSimulateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SandboxTransferSimulateResponse &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(requestId) ^ runtimeType.hashCode;
}

extension $SandboxTransferSimulateResponseExtension
    on SandboxTransferSimulateResponse {
  SandboxTransferSimulateResponse copyWith({String? requestId}) {
    return SandboxTransferSimulateResponse(
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class SandboxTransferSweepSimulateResponse {
  SandboxTransferSweepSimulateResponse({
    this.sweep,
    this.requestId,
  });

  factory SandboxTransferSweepSimulateResponse.fromJson(
          Map<String, dynamic> json) =>
      _$SandboxTransferSweepSimulateResponseFromJson(json);

  @JsonKey(name: 'sweep')
  final TransferSweep? sweep;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$SandboxTransferSweepSimulateResponseFromJson;
  static const toJsonFactory = _$SandboxTransferSweepSimulateResponseToJson;
  Map<String, dynamic> toJson() =>
      _$SandboxTransferSweepSimulateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SandboxTransferSweepSimulateResponse &&
            (identical(other.sweep, sweep) ||
                const DeepCollectionEquality().equals(other.sweep, sweep)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(sweep) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $SandboxTransferSweepSimulateResponseExtension
    on SandboxTransferSweepSimulateResponse {
  SandboxTransferSweepSimulateResponse copyWith(
      {TransferSweep? sweep, String? requestId}) {
    return SandboxTransferSweepSimulateResponse(
        sweep: sweep ?? this.sweep, requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class BankTransferReceiverDetails {
  BankTransferReceiverDetails({
    this.availableBalance,
  });

  factory BankTransferReceiverDetails.fromJson(Map<String, dynamic> json) =>
      _$BankTransferReceiverDetailsFromJson(json);

  @JsonKey(
      name: 'available_balance',
      toJson: bankTransferReceiverDetailsAvailableBalanceToJson,
      fromJson: bankTransferReceiverDetailsAvailableBalanceFromJson)
  final enums.BankTransferReceiverDetailsAvailableBalance? availableBalance;
  static const fromJsonFactory = _$BankTransferReceiverDetailsFromJson;
  static const toJsonFactory = _$BankTransferReceiverDetailsToJson;
  Map<String, dynamic> toJson() => _$BankTransferReceiverDetailsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BankTransferReceiverDetails &&
            (identical(other.availableBalance, availableBalance) ||
                const DeepCollectionEquality()
                    .equals(other.availableBalance, availableBalance)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(availableBalance) ^
      runtimeType.hashCode;
}

extension $BankTransferReceiverDetailsExtension on BankTransferReceiverDetails {
  BankTransferReceiverDetails copyWith(
      {enums.BankTransferReceiverDetailsAvailableBalance? availableBalance}) {
    return BankTransferReceiverDetails(
        availableBalance: availableBalance ?? this.availableBalance);
  }
}

@JsonSerializable(explicitToJson: true)
class AccountFiltersResponse {
  AccountFiltersResponse({
    this.depository,
    this.credit,
    this.loan,
    this.investment,
  });

  factory AccountFiltersResponse.fromJson(Map<String, dynamic> json) =>
      _$AccountFiltersResponseFromJson(json);

  @JsonKey(name: 'depository')
  final DepositoryFilter? depository;
  @JsonKey(name: 'credit')
  final CreditFilter? credit;
  @JsonKey(name: 'loan')
  final LoanFilter? loan;
  @JsonKey(name: 'investment')
  final InvestmentFilter? investment;
  static const fromJsonFactory = _$AccountFiltersResponseFromJson;
  static const toJsonFactory = _$AccountFiltersResponseToJson;
  Map<String, dynamic> toJson() => _$AccountFiltersResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AccountFiltersResponse &&
            (identical(other.depository, depository) ||
                const DeepCollectionEquality()
                    .equals(other.depository, depository)) &&
            (identical(other.credit, credit) ||
                const DeepCollectionEquality().equals(other.credit, credit)) &&
            (identical(other.loan, loan) ||
                const DeepCollectionEquality().equals(other.loan, loan)) &&
            (identical(other.investment, investment) ||
                const DeepCollectionEquality()
                    .equals(other.investment, investment)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(depository) ^
      const DeepCollectionEquality().hash(credit) ^
      const DeepCollectionEquality().hash(loan) ^
      const DeepCollectionEquality().hash(investment) ^
      runtimeType.hashCode;
}

extension $AccountFiltersResponseExtension on AccountFiltersResponse {
  AccountFiltersResponse copyWith(
      {DepositoryFilter? depository,
      CreditFilter? credit,
      LoanFilter? loan,
      InvestmentFilter? investment}) {
    return AccountFiltersResponse(
        depository: depository ?? this.depository,
        credit: credit ?? this.credit,
        loan: loan ?? this.loan,
        investment: investment ?? this.investment);
  }
}

@JsonSerializable(explicitToJson: true)
class InstitutionsSearchAccountFilter {
  InstitutionsSearchAccountFilter({
    this.loan,
    this.depository,
    this.credit,
    this.investment,
  });

  factory InstitutionsSearchAccountFilter.fromJson(Map<String, dynamic> json) =>
      _$InstitutionsSearchAccountFilterFromJson(json);

  @JsonKey(
      name: 'loan',
      toJson: accountSubtypeListToJson,
      fromJson: accountSubtypeListFromJson)
  final List<enums.AccountSubtype>? loan;
  @JsonKey(
      name: 'depository',
      toJson: accountSubtypeListToJson,
      fromJson: accountSubtypeListFromJson)
  final List<enums.AccountSubtype>? depository;
  @JsonKey(
      name: 'credit',
      toJson: accountSubtypeListToJson,
      fromJson: accountSubtypeListFromJson)
  final List<enums.AccountSubtype>? credit;
  @JsonKey(
      name: 'investment',
      toJson: accountSubtypeListToJson,
      fromJson: accountSubtypeListFromJson)
  final List<enums.AccountSubtype>? investment;
  static const fromJsonFactory = _$InstitutionsSearchAccountFilterFromJson;
  static const toJsonFactory = _$InstitutionsSearchAccountFilterToJson;
  Map<String, dynamic> toJson() =>
      _$InstitutionsSearchAccountFilterToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InstitutionsSearchAccountFilter &&
            (identical(other.loan, loan) ||
                const DeepCollectionEquality().equals(other.loan, loan)) &&
            (identical(other.depository, depository) ||
                const DeepCollectionEquality()
                    .equals(other.depository, depository)) &&
            (identical(other.credit, credit) ||
                const DeepCollectionEquality().equals(other.credit, credit)) &&
            (identical(other.investment, investment) ||
                const DeepCollectionEquality()
                    .equals(other.investment, investment)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(loan) ^
      const DeepCollectionEquality().hash(depository) ^
      const DeepCollectionEquality().hash(credit) ^
      const DeepCollectionEquality().hash(investment) ^
      runtimeType.hashCode;
}

extension $InstitutionsSearchAccountFilterExtension
    on InstitutionsSearchAccountFilter {
  InstitutionsSearchAccountFilter copyWith(
      {List<enums.AccountSubtype>? loan,
      List<enums.AccountSubtype>? depository,
      List<enums.AccountSubtype>? credit,
      List<enums.AccountSubtype>? investment}) {
    return InstitutionsSearchAccountFilter(
        loan: loan ?? this.loan,
        depository: depository ?? this.depository,
        credit: credit ?? this.credit,
        investment: investment ?? this.investment);
  }
}

@JsonSerializable(explicitToJson: true)
class AccountIdentity {
  AccountIdentity({
    this.owners,
    this.accountId,
    this.balances,
    this.mask,
    this.name,
    this.officialName,
    this.type,
    this.subtype,
    this.verificationStatus,
  });

  factory AccountIdentity.fromJson(Map<String, dynamic> json) =>
      _$AccountIdentityFromJson(json);

  @JsonKey(name: 'owners', defaultValue: <Owner>[])
  final List<Owner>? owners;
  @JsonKey(name: 'account_id')
  final String? accountId;
  @JsonKey(name: 'balances')
  final AccountBalance? balances;
  @JsonKey(name: 'mask')
  final String? mask;
  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'official_name')
  final String? officialName;
  @JsonKey(
      name: 'type', toJson: accountTypeToJson, fromJson: accountTypeFromJson)
  final enums.AccountType? type;
  @JsonKey(
      name: 'subtype',
      toJson: accountSubtypeToJson,
      fromJson: accountSubtypeFromJson)
  final enums.AccountSubtype? subtype;
  @JsonKey(
      name: 'verification_status',
      toJson: accountIdentityVerificationStatusToJson,
      fromJson: accountIdentityVerificationStatusFromJson)
  final enums.AccountIdentityVerificationStatus? verificationStatus;
  static const fromJsonFactory = _$AccountIdentityFromJson;
  static const toJsonFactory = _$AccountIdentityToJson;
  Map<String, dynamic> toJson() => _$AccountIdentityToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AccountIdentity &&
            (identical(other.owners, owners) ||
                const DeepCollectionEquality().equals(other.owners, owners)) &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.balances, balances) ||
                const DeepCollectionEquality()
                    .equals(other.balances, balances)) &&
            (identical(other.mask, mask) ||
                const DeepCollectionEquality().equals(other.mask, mask)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.officialName, officialName) ||
                const DeepCollectionEquality()
                    .equals(other.officialName, officialName)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.subtype, subtype) ||
                const DeepCollectionEquality()
                    .equals(other.subtype, subtype)) &&
            (identical(other.verificationStatus, verificationStatus) ||
                const DeepCollectionEquality()
                    .equals(other.verificationStatus, verificationStatus)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(owners) ^
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(balances) ^
      const DeepCollectionEquality().hash(mask) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(officialName) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(subtype) ^
      const DeepCollectionEquality().hash(verificationStatus) ^
      runtimeType.hashCode;
}

extension $AccountIdentityExtension on AccountIdentity {
  AccountIdentity copyWith(
      {List<Owner>? owners,
      String? accountId,
      AccountBalance? balances,
      String? mask,
      String? name,
      String? officialName,
      enums.AccountType? type,
      enums.AccountSubtype? subtype,
      enums.AccountIdentityVerificationStatus? verificationStatus}) {
    return AccountIdentity(
        owners: owners ?? this.owners,
        accountId: accountId ?? this.accountId,
        balances: balances ?? this.balances,
        mask: mask ?? this.mask,
        name: name ?? this.name,
        officialName: officialName ?? this.officialName,
        type: type ?? this.type,
        subtype: subtype ?? this.subtype,
        verificationStatus: verificationStatus ?? this.verificationStatus);
  }
}

@JsonSerializable(explicitToJson: true)
class AccountAssets {
  AccountAssets({
    this.daysAvailable,
    this.transactions,
    this.owners,
    this.historicalBalances,
    this.accountId,
    this.balances,
    this.mask,
    this.name,
    this.officialName,
    this.type,
    this.subtype,
    this.verificationStatus,
  });

  factory AccountAssets.fromJson(Map<String, dynamic> json) =>
      _$AccountAssetsFromJson(json);

  @JsonKey(name: 'days_available')
  final double? daysAvailable;
  @JsonKey(name: 'transactions', defaultValue: <AssetReportTransaction>[])
  final List<AssetReportTransaction>? transactions;
  @JsonKey(name: 'owners', defaultValue: <Owner>[])
  final List<Owner>? owners;
  @JsonKey(name: 'historical_balances', defaultValue: <HistoricalBalance>[])
  final List<HistoricalBalance>? historicalBalances;
  @JsonKey(name: 'account_id')
  final String? accountId;
  @JsonKey(name: 'balances')
  final AccountBalance? balances;
  @JsonKey(name: 'mask')
  final String? mask;
  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'official_name')
  final String? officialName;
  @JsonKey(
      name: 'type', toJson: accountTypeToJson, fromJson: accountTypeFromJson)
  final enums.AccountType? type;
  @JsonKey(
      name: 'subtype',
      toJson: accountSubtypeToJson,
      fromJson: accountSubtypeFromJson)
  final enums.AccountSubtype? subtype;
  @JsonKey(
      name: 'verification_status',
      toJson: accountAssetsVerificationStatusToJson,
      fromJson: accountAssetsVerificationStatusFromJson)
  final enums.AccountAssetsVerificationStatus? verificationStatus;
  static const fromJsonFactory = _$AccountAssetsFromJson;
  static const toJsonFactory = _$AccountAssetsToJson;
  Map<String, dynamic> toJson() => _$AccountAssetsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AccountAssets &&
            (identical(other.daysAvailable, daysAvailable) ||
                const DeepCollectionEquality()
                    .equals(other.daysAvailable, daysAvailable)) &&
            (identical(other.transactions, transactions) ||
                const DeepCollectionEquality()
                    .equals(other.transactions, transactions)) &&
            (identical(other.owners, owners) ||
                const DeepCollectionEquality().equals(other.owners, owners)) &&
            (identical(other.historicalBalances, historicalBalances) ||
                const DeepCollectionEquality()
                    .equals(other.historicalBalances, historicalBalances)) &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.balances, balances) ||
                const DeepCollectionEquality()
                    .equals(other.balances, balances)) &&
            (identical(other.mask, mask) ||
                const DeepCollectionEquality().equals(other.mask, mask)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.officialName, officialName) ||
                const DeepCollectionEquality()
                    .equals(other.officialName, officialName)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.subtype, subtype) ||
                const DeepCollectionEquality()
                    .equals(other.subtype, subtype)) &&
            (identical(other.verificationStatus, verificationStatus) ||
                const DeepCollectionEquality()
                    .equals(other.verificationStatus, verificationStatus)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(daysAvailable) ^
      const DeepCollectionEquality().hash(transactions) ^
      const DeepCollectionEquality().hash(owners) ^
      const DeepCollectionEquality().hash(historicalBalances) ^
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(balances) ^
      const DeepCollectionEquality().hash(mask) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(officialName) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(subtype) ^
      const DeepCollectionEquality().hash(verificationStatus) ^
      runtimeType.hashCode;
}

extension $AccountAssetsExtension on AccountAssets {
  AccountAssets copyWith(
      {double? daysAvailable,
      List<AssetReportTransaction>? transactions,
      List<Owner>? owners,
      List<HistoricalBalance>? historicalBalances,
      String? accountId,
      AccountBalance? balances,
      String? mask,
      String? name,
      String? officialName,
      enums.AccountType? type,
      enums.AccountSubtype? subtype,
      enums.AccountAssetsVerificationStatus? verificationStatus}) {
    return AccountAssets(
        daysAvailable: daysAvailable ?? this.daysAvailable,
        transactions: transactions ?? this.transactions,
        owners: owners ?? this.owners,
        historicalBalances: historicalBalances ?? this.historicalBalances,
        accountId: accountId ?? this.accountId,
        balances: balances ?? this.balances,
        mask: mask ?? this.mask,
        name: name ?? this.name,
        officialName: officialName ?? this.officialName,
        type: type ?? this.type,
        subtype: subtype ?? this.subtype,
        verificationStatus: verificationStatus ?? this.verificationStatus);
  }
}

@JsonSerializable(explicitToJson: true)
class DepositoryFilter {
  DepositoryFilter({
    this.accountSubtypes,
  });

  factory DepositoryFilter.fromJson(Map<String, dynamic> json) =>
      _$DepositoryFilterFromJson(json);

  @JsonKey(name: 'account_subtypes')
  final List<AccountSubtype>? accountSubtypes;
  static const fromJsonFactory = _$DepositoryFilterFromJson;
  static const toJsonFactory = _$DepositoryFilterToJson;
  Map<String, dynamic> toJson() => _$DepositoryFilterToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is DepositoryFilter &&
            (identical(other.accountSubtypes, accountSubtypes) ||
                const DeepCollectionEquality()
                    .equals(other.accountSubtypes, accountSubtypes)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountSubtypes) ^
      runtimeType.hashCode;
}

extension $DepositoryFilterExtension on DepositoryFilter {
  DepositoryFilter copyWith({List<AccountSubtype>? accountSubtypes}) {
    return DepositoryFilter(
        accountSubtypes: accountSubtypes ?? this.accountSubtypes);
  }
}

@JsonSerializable(explicitToJson: true)
class CreditFilter {
  CreditFilter({
    this.accountSubtypes,
  });

  factory CreditFilter.fromJson(Map<String, dynamic> json) =>
      _$CreditFilterFromJson(json);

  @JsonKey(name: 'account_subtypes')
  final List<AccountSubtype>? accountSubtypes;
  static const fromJsonFactory = _$CreditFilterFromJson;
  static const toJsonFactory = _$CreditFilterToJson;
  Map<String, dynamic> toJson() => _$CreditFilterToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CreditFilter &&
            (identical(other.accountSubtypes, accountSubtypes) ||
                const DeepCollectionEquality()
                    .equals(other.accountSubtypes, accountSubtypes)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountSubtypes) ^
      runtimeType.hashCode;
}

extension $CreditFilterExtension on CreditFilter {
  CreditFilter copyWith({List<AccountSubtype>? accountSubtypes}) {
    return CreditFilter(
        accountSubtypes: accountSubtypes ?? this.accountSubtypes);
  }
}

@JsonSerializable(explicitToJson: true)
class LoanFilter {
  LoanFilter({
    this.accountSubtypes,
  });

  factory LoanFilter.fromJson(Map<String, dynamic> json) =>
      _$LoanFilterFromJson(json);

  @JsonKey(name: 'account_subtypes')
  final List<AccountSubtype>? accountSubtypes;
  static const fromJsonFactory = _$LoanFilterFromJson;
  static const toJsonFactory = _$LoanFilterToJson;
  Map<String, dynamic> toJson() => _$LoanFilterToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LoanFilter &&
            (identical(other.accountSubtypes, accountSubtypes) ||
                const DeepCollectionEquality()
                    .equals(other.accountSubtypes, accountSubtypes)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountSubtypes) ^
      runtimeType.hashCode;
}

extension $LoanFilterExtension on LoanFilter {
  LoanFilter copyWith({List<AccountSubtype>? accountSubtypes}) {
    return LoanFilter(accountSubtypes: accountSubtypes ?? this.accountSubtypes);
  }
}

@JsonSerializable(explicitToJson: true)
class InvestmentFilter {
  InvestmentFilter({
    this.accountSubtypes,
  });

  factory InvestmentFilter.fromJson(Map<String, dynamic> json) =>
      _$InvestmentFilterFromJson(json);

  @JsonKey(name: 'account_subtypes')
  final List<AccountSubtype>? accountSubtypes;
  static const fromJsonFactory = _$InvestmentFilterFromJson;
  static const toJsonFactory = _$InvestmentFilterToJson;
  Map<String, dynamic> toJson() => _$InvestmentFilterToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is InvestmentFilter &&
            (identical(other.accountSubtypes, accountSubtypes) ||
                const DeepCollectionEquality()
                    .equals(other.accountSubtypes, accountSubtypes)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountSubtypes) ^
      runtimeType.hashCode;
}

extension $InvestmentFilterExtension on InvestmentFilter {
  InvestmentFilter copyWith({List<AccountSubtype>? accountSubtypes}) {
    return InvestmentFilter(
        accountSubtypes: accountSubtypes ?? this.accountSubtypes);
  }
}

@JsonSerializable(explicitToJson: true)
class EmployersSearchRequest {
  EmployersSearchRequest({
    this.clientId,
    this.secret,
    this.query,
    this.products,
  });

  factory EmployersSearchRequest.fromJson(Map<String, dynamic> json) =>
      _$EmployersSearchRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'query')
  final String? query;
  @JsonKey(name: 'products', defaultValue: <String>[])
  final List<String>? products;
  static const fromJsonFactory = _$EmployersSearchRequestFromJson;
  static const toJsonFactory = _$EmployersSearchRequestToJson;
  Map<String, dynamic> toJson() => _$EmployersSearchRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is EmployersSearchRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.query, query) ||
                const DeepCollectionEquality().equals(other.query, query)) &&
            (identical(other.products, products) ||
                const DeepCollectionEquality()
                    .equals(other.products, products)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(query) ^
      const DeepCollectionEquality().hash(products) ^
      runtimeType.hashCode;
}

extension $EmployersSearchRequestExtension on EmployersSearchRequest {
  EmployersSearchRequest copyWith(
      {String? clientId,
      String? secret,
      String? query,
      List<String>? products}) {
    return EmployersSearchRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        query: query ?? this.query,
        products: products ?? this.products);
  }
}

@JsonSerializable(explicitToJson: true)
class EmployersSearchResponse {
  EmployersSearchResponse({
    this.employers,
    this.requestId,
  });

  factory EmployersSearchResponse.fromJson(Map<String, dynamic> json) =>
      _$EmployersSearchResponseFromJson(json);

  @JsonKey(name: 'employers', defaultValue: <Employer>[])
  final List<Employer>? employers;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$EmployersSearchResponseFromJson;
  static const toJsonFactory = _$EmployersSearchResponseToJson;
  Map<String, dynamic> toJson() => _$EmployersSearchResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is EmployersSearchResponse &&
            (identical(other.employers, employers) ||
                const DeepCollectionEquality()
                    .equals(other.employers, employers)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(employers) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $EmployersSearchResponseExtension on EmployersSearchResponse {
  EmployersSearchResponse copyWith(
      {List<Employer>? employers, String? requestId}) {
    return EmployersSearchResponse(
        employers: employers ?? this.employers,
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class Employer {
  Employer({
    this.employerId,
    this.name,
    this.address,
    this.confidenceScore,
  });

  factory Employer.fromJson(Map<String, dynamic> json) =>
      _$EmployerFromJson(json);

  @JsonKey(name: 'employer_id')
  final String? employerId;
  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'address')
  final AddressDataNullable? address;
  @JsonKey(name: 'confidence_score')
  final double? confidenceScore;
  static const fromJsonFactory = _$EmployerFromJson;
  static const toJsonFactory = _$EmployerToJson;
  Map<String, dynamic> toJson() => _$EmployerToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Employer &&
            (identical(other.employerId, employerId) ||
                const DeepCollectionEquality()
                    .equals(other.employerId, employerId)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality()
                    .equals(other.address, address)) &&
            (identical(other.confidenceScore, confidenceScore) ||
                const DeepCollectionEquality()
                    .equals(other.confidenceScore, confidenceScore)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(employerId) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(confidenceScore) ^
      runtimeType.hashCode;
}

extension $EmployerExtension on Employer {
  Employer copyWith(
      {String? employerId,
      String? name,
      AddressDataNullable? address,
      double? confidenceScore}) {
    return Employer(
        employerId: employerId ?? this.employerId,
        name: name ?? this.name,
        address: address ?? this.address,
        confidenceScore: confidenceScore ?? this.confidenceScore);
  }
}

@JsonSerializable(explicitToJson: true)
class IncomeVerificationCreateRequest {
  IncomeVerificationCreateRequest({
    this.clientId,
    this.secret,
    this.webhook,
    this.precheckId,
    this.options,
  });

  factory IncomeVerificationCreateRequest.fromJson(Map<String, dynamic> json) =>
      _$IncomeVerificationCreateRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'webhook')
  final String? webhook;
  @JsonKey(name: 'precheck_id')
  final String? precheckId;
  @JsonKey(name: 'options')
  final IncomeVerificationCreateRequestOptions? options;
  static const fromJsonFactory = _$IncomeVerificationCreateRequestFromJson;
  static const toJsonFactory = _$IncomeVerificationCreateRequestToJson;
  Map<String, dynamic> toJson() =>
      _$IncomeVerificationCreateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IncomeVerificationCreateRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.webhook, webhook) ||
                const DeepCollectionEquality()
                    .equals(other.webhook, webhook)) &&
            (identical(other.precheckId, precheckId) ||
                const DeepCollectionEquality()
                    .equals(other.precheckId, precheckId)) &&
            (identical(other.options, options) ||
                const DeepCollectionEquality().equals(other.options, options)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(webhook) ^
      const DeepCollectionEquality().hash(precheckId) ^
      const DeepCollectionEquality().hash(options) ^
      runtimeType.hashCode;
}

extension $IncomeVerificationCreateRequestExtension
    on IncomeVerificationCreateRequest {
  IncomeVerificationCreateRequest copyWith(
      {String? clientId,
      String? secret,
      String? webhook,
      String? precheckId,
      IncomeVerificationCreateRequestOptions? options}) {
    return IncomeVerificationCreateRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        webhook: webhook ?? this.webhook,
        precheckId: precheckId ?? this.precheckId,
        options: options ?? this.options);
  }
}

@JsonSerializable(explicitToJson: true)
class IncomeVerificationCreateRequestOptions {
  IncomeVerificationCreateRequestOptions({
    this.accessTokens,
  });

  factory IncomeVerificationCreateRequestOptions.fromJson(
          Map<String, dynamic> json) =>
      _$IncomeVerificationCreateRequestOptionsFromJson(json);

  @JsonKey(name: 'access_tokens', defaultValue: <String>[])
  final List<String>? accessTokens;
  static const fromJsonFactory =
      _$IncomeVerificationCreateRequestOptionsFromJson;
  static const toJsonFactory = _$IncomeVerificationCreateRequestOptionsToJson;
  Map<String, dynamic> toJson() =>
      _$IncomeVerificationCreateRequestOptionsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IncomeVerificationCreateRequestOptions &&
            (identical(other.accessTokens, accessTokens) ||
                const DeepCollectionEquality()
                    .equals(other.accessTokens, accessTokens)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accessTokens) ^ runtimeType.hashCode;
}

extension $IncomeVerificationCreateRequestOptionsExtension
    on IncomeVerificationCreateRequestOptions {
  IncomeVerificationCreateRequestOptions copyWith(
      {List<String>? accessTokens}) {
    return IncomeVerificationCreateRequestOptions(
        accessTokens: accessTokens ?? this.accessTokens);
  }
}

@JsonSerializable(explicitToJson: true)
class IncomeVerificationCreateResponse {
  IncomeVerificationCreateResponse({
    this.incomeVerificationId,
    this.requestId,
  });

  factory IncomeVerificationCreateResponse.fromJson(
          Map<String, dynamic> json) =>
      _$IncomeVerificationCreateResponseFromJson(json);

  @JsonKey(name: 'income_verification_id')
  final String? incomeVerificationId;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$IncomeVerificationCreateResponseFromJson;
  static const toJsonFactory = _$IncomeVerificationCreateResponseToJson;
  Map<String, dynamic> toJson() =>
      _$IncomeVerificationCreateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IncomeVerificationCreateResponse &&
            (identical(other.incomeVerificationId, incomeVerificationId) ||
                const DeepCollectionEquality().equals(
                    other.incomeVerificationId, incomeVerificationId)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(incomeVerificationId) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $IncomeVerificationCreateResponseExtension
    on IncomeVerificationCreateResponse {
  IncomeVerificationCreateResponse copyWith(
      {String? incomeVerificationId, String? requestId}) {
    return IncomeVerificationCreateResponse(
        incomeVerificationId: incomeVerificationId ?? this.incomeVerificationId,
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class IncomeVerificationPrecheckRequest {
  IncomeVerificationPrecheckRequest({
    this.clientId,
    this.secret,
    this.user,
    this.employer,
    this.transactionsAccessToken,
    this.transactionsAccessTokens,
    this.usMilitaryInfo,
  });

  factory IncomeVerificationPrecheckRequest.fromJson(
          Map<String, dynamic> json) =>
      _$IncomeVerificationPrecheckRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'user')
  final IncomeVerificationPrecheckUser? user;
  @JsonKey(name: 'employer')
  final IncomeVerificationPrecheckEmployer? employer;
  @JsonKey(name: 'transactions_access_token')
  final String? transactionsAccessToken;
  @JsonKey(name: 'transactions_access_tokens', defaultValue: <String>[])
  final List<String>? transactionsAccessTokens;
  @JsonKey(name: 'us_military_info')
  final IncomeVerificationPrecheckMilitaryInfo? usMilitaryInfo;
  static const fromJsonFactory = _$IncomeVerificationPrecheckRequestFromJson;
  static const toJsonFactory = _$IncomeVerificationPrecheckRequestToJson;
  Map<String, dynamic> toJson() =>
      _$IncomeVerificationPrecheckRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IncomeVerificationPrecheckRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.user, user) ||
                const DeepCollectionEquality().equals(other.user, user)) &&
            (identical(other.employer, employer) ||
                const DeepCollectionEquality()
                    .equals(other.employer, employer)) &&
            (identical(
                    other.transactionsAccessToken, transactionsAccessToken) ||
                const DeepCollectionEquality().equals(
                    other.transactionsAccessToken, transactionsAccessToken)) &&
            (identical(
                    other.transactionsAccessTokens, transactionsAccessTokens) ||
                const DeepCollectionEquality().equals(
                    other.transactionsAccessTokens,
                    transactionsAccessTokens)) &&
            (identical(other.usMilitaryInfo, usMilitaryInfo) ||
                const DeepCollectionEquality()
                    .equals(other.usMilitaryInfo, usMilitaryInfo)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(user) ^
      const DeepCollectionEquality().hash(employer) ^
      const DeepCollectionEquality().hash(transactionsAccessToken) ^
      const DeepCollectionEquality().hash(transactionsAccessTokens) ^
      const DeepCollectionEquality().hash(usMilitaryInfo) ^
      runtimeType.hashCode;
}

extension $IncomeVerificationPrecheckRequestExtension
    on IncomeVerificationPrecheckRequest {
  IncomeVerificationPrecheckRequest copyWith(
      {String? clientId,
      String? secret,
      IncomeVerificationPrecheckUser? user,
      IncomeVerificationPrecheckEmployer? employer,
      String? transactionsAccessToken,
      List<String>? transactionsAccessTokens,
      IncomeVerificationPrecheckMilitaryInfo? usMilitaryInfo}) {
    return IncomeVerificationPrecheckRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        user: user ?? this.user,
        employer: employer ?? this.employer,
        transactionsAccessToken:
            transactionsAccessToken ?? this.transactionsAccessToken,
        transactionsAccessTokens:
            transactionsAccessTokens ?? this.transactionsAccessTokens,
        usMilitaryInfo: usMilitaryInfo ?? this.usMilitaryInfo);
  }
}

@JsonSerializable(explicitToJson: true)
class IncomeVerificationPrecheckEmployer {
  IncomeVerificationPrecheckEmployer({
    this.name,
    this.address,
    this.taxId,
    this.url,
  });

  factory IncomeVerificationPrecheckEmployer.fromJson(
          Map<String, dynamic> json) =>
      _$IncomeVerificationPrecheckEmployerFromJson(json);

  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'address')
  final IncomeVerificationPrecheckEmployerAddress? address;
  @JsonKey(name: 'tax_id')
  final String? taxId;
  @JsonKey(name: 'url')
  final String? url;
  static const fromJsonFactory = _$IncomeVerificationPrecheckEmployerFromJson;
  static const toJsonFactory = _$IncomeVerificationPrecheckEmployerToJson;
  Map<String, dynamic> toJson() =>
      _$IncomeVerificationPrecheckEmployerToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IncomeVerificationPrecheckEmployer &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality()
                    .equals(other.address, address)) &&
            (identical(other.taxId, taxId) ||
                const DeepCollectionEquality().equals(other.taxId, taxId)) &&
            (identical(other.url, url) ||
                const DeepCollectionEquality().equals(other.url, url)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(taxId) ^
      const DeepCollectionEquality().hash(url) ^
      runtimeType.hashCode;
}

extension $IncomeVerificationPrecheckEmployerExtension
    on IncomeVerificationPrecheckEmployer {
  IncomeVerificationPrecheckEmployer copyWith(
      {String? name,
      IncomeVerificationPrecheckEmployerAddress? address,
      String? taxId,
      String? url}) {
    return IncomeVerificationPrecheckEmployer(
        name: name ?? this.name,
        address: address ?? this.address,
        taxId: taxId ?? this.taxId,
        url: url ?? this.url);
  }
}

@JsonSerializable(explicitToJson: true)
class IncomeVerificationPrecheckEmployerAddress {
  IncomeVerificationPrecheckEmployerAddress();

  factory IncomeVerificationPrecheckEmployerAddress.fromJson(
          Map<String, dynamic> json) =>
      _$IncomeVerificationPrecheckEmployerAddressFromJson(json);

  static const fromJsonFactory =
      _$IncomeVerificationPrecheckEmployerAddressFromJson;
  static const toJsonFactory =
      _$IncomeVerificationPrecheckEmployerAddressToJson;
  Map<String, dynamic> toJson() =>
      _$IncomeVerificationPrecheckEmployerAddressToJson(this);

  @override
  int get hashCode => runtimeType.hashCode;
}

@JsonSerializable(explicitToJson: true)
class IncomeVerificationPrecheckMilitaryInfo {
  IncomeVerificationPrecheckMilitaryInfo({
    this.isActiveDuty,
    this.branch,
  });

  factory IncomeVerificationPrecheckMilitaryInfo.fromJson(
          Map<String, dynamic> json) =>
      _$IncomeVerificationPrecheckMilitaryInfoFromJson(json);

  @JsonKey(name: 'is_active_duty')
  final bool? isActiveDuty;
  @JsonKey(
      name: 'branch',
      toJson: incomeVerificationPrecheckMilitaryInfoBranchToJson,
      fromJson: incomeVerificationPrecheckMilitaryInfoBranchFromJson)
  final enums.IncomeVerificationPrecheckMilitaryInfoBranch? branch;
  static const fromJsonFactory =
      _$IncomeVerificationPrecheckMilitaryInfoFromJson;
  static const toJsonFactory = _$IncomeVerificationPrecheckMilitaryInfoToJson;
  Map<String, dynamic> toJson() =>
      _$IncomeVerificationPrecheckMilitaryInfoToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IncomeVerificationPrecheckMilitaryInfo &&
            (identical(other.isActiveDuty, isActiveDuty) ||
                const DeepCollectionEquality()
                    .equals(other.isActiveDuty, isActiveDuty)) &&
            (identical(other.branch, branch) ||
                const DeepCollectionEquality().equals(other.branch, branch)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(isActiveDuty) ^
      const DeepCollectionEquality().hash(branch) ^
      runtimeType.hashCode;
}

extension $IncomeVerificationPrecheckMilitaryInfoExtension
    on IncomeVerificationPrecheckMilitaryInfo {
  IncomeVerificationPrecheckMilitaryInfo copyWith(
      {bool? isActiveDuty,
      enums.IncomeVerificationPrecheckMilitaryInfoBranch? branch}) {
    return IncomeVerificationPrecheckMilitaryInfo(
        isActiveDuty: isActiveDuty ?? this.isActiveDuty,
        branch: branch ?? this.branch);
  }
}

@JsonSerializable(explicitToJson: true)
class IncomeVerificationPrecheckUser {
  IncomeVerificationPrecheckUser({
    this.firstName,
    this.lastName,
    this.emailAddress,
    this.homeAddress,
  });

  factory IncomeVerificationPrecheckUser.fromJson(Map<String, dynamic> json) =>
      _$IncomeVerificationPrecheckUserFromJson(json);

  @JsonKey(name: 'first_name')
  final String? firstName;
  @JsonKey(name: 'last_name')
  final String? lastName;
  @JsonKey(name: 'email_address')
  final String? emailAddress;
  @JsonKey(name: 'home_address')
  final SignalAddressData? homeAddress;
  static const fromJsonFactory = _$IncomeVerificationPrecheckUserFromJson;
  static const toJsonFactory = _$IncomeVerificationPrecheckUserToJson;
  Map<String, dynamic> toJson() => _$IncomeVerificationPrecheckUserToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IncomeVerificationPrecheckUser &&
            (identical(other.firstName, firstName) ||
                const DeepCollectionEquality()
                    .equals(other.firstName, firstName)) &&
            (identical(other.lastName, lastName) ||
                const DeepCollectionEquality()
                    .equals(other.lastName, lastName)) &&
            (identical(other.emailAddress, emailAddress) ||
                const DeepCollectionEquality()
                    .equals(other.emailAddress, emailAddress)) &&
            (identical(other.homeAddress, homeAddress) ||
                const DeepCollectionEquality()
                    .equals(other.homeAddress, homeAddress)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(firstName) ^
      const DeepCollectionEquality().hash(lastName) ^
      const DeepCollectionEquality().hash(emailAddress) ^
      const DeepCollectionEquality().hash(homeAddress) ^
      runtimeType.hashCode;
}

extension $IncomeVerificationPrecheckUserExtension
    on IncomeVerificationPrecheckUser {
  IncomeVerificationPrecheckUser copyWith(
      {String? firstName,
      String? lastName,
      String? emailAddress,
      SignalAddressData? homeAddress}) {
    return IncomeVerificationPrecheckUser(
        firstName: firstName ?? this.firstName,
        lastName: lastName ?? this.lastName,
        emailAddress: emailAddress ?? this.emailAddress,
        homeAddress: homeAddress ?? this.homeAddress);
  }
}

@JsonSerializable(explicitToJson: true)
class IncomeVerificationPrecheckResponse {
  IncomeVerificationPrecheckResponse({
    this.precheckId,
    this.requestId,
    this.confidence,
  });

  factory IncomeVerificationPrecheckResponse.fromJson(
          Map<String, dynamic> json) =>
      _$IncomeVerificationPrecheckResponseFromJson(json);

  @JsonKey(name: 'precheck_id')
  final String? precheckId;
  @JsonKey(name: 'request_id')
  final String? requestId;
  @JsonKey(
      name: 'confidence',
      toJson: incomeVerificationPrecheckConfidenceToJson,
      fromJson: incomeVerificationPrecheckConfidenceFromJson)
  final enums.IncomeVerificationPrecheckConfidence? confidence;
  static const fromJsonFactory = _$IncomeVerificationPrecheckResponseFromJson;
  static const toJsonFactory = _$IncomeVerificationPrecheckResponseToJson;
  Map<String, dynamic> toJson() =>
      _$IncomeVerificationPrecheckResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IncomeVerificationPrecheckResponse &&
            (identical(other.precheckId, precheckId) ||
                const DeepCollectionEquality()
                    .equals(other.precheckId, precheckId)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)) &&
            (identical(other.confidence, confidence) ||
                const DeepCollectionEquality()
                    .equals(other.confidence, confidence)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(precheckId) ^
      const DeepCollectionEquality().hash(requestId) ^
      const DeepCollectionEquality().hash(confidence) ^
      runtimeType.hashCode;
}

extension $IncomeVerificationPrecheckResponseExtension
    on IncomeVerificationPrecheckResponse {
  IncomeVerificationPrecheckResponse copyWith(
      {String? precheckId,
      String? requestId,
      enums.IncomeVerificationPrecheckConfidence? confidence}) {
    return IncomeVerificationPrecheckResponse(
        precheckId: precheckId ?? this.precheckId,
        requestId: requestId ?? this.requestId,
        confidence: confidence ?? this.confidence);
  }
}

@JsonSerializable(explicitToJson: true)
class LinkTokenCreateRequestIncomeVerification {
  LinkTokenCreateRequestIncomeVerification({
    this.incomeVerificationId,
    this.assetReportId,
    this.precheckId,
    this.accessTokens,
  });

  factory LinkTokenCreateRequestIncomeVerification.fromJson(
          Map<String, dynamic> json) =>
      _$LinkTokenCreateRequestIncomeVerificationFromJson(json);

  @JsonKey(name: 'income_verification_id')
  final String? incomeVerificationId;
  @JsonKey(name: 'asset_report_id')
  final String? assetReportId;
  @JsonKey(name: 'precheck_id')
  final String? precheckId;
  @JsonKey(name: 'access_tokens', defaultValue: <String>[])
  final List<String>? accessTokens;
  static const fromJsonFactory =
      _$LinkTokenCreateRequestIncomeVerificationFromJson;
  static const toJsonFactory = _$LinkTokenCreateRequestIncomeVerificationToJson;
  Map<String, dynamic> toJson() =>
      _$LinkTokenCreateRequestIncomeVerificationToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LinkTokenCreateRequestIncomeVerification &&
            (identical(other.incomeVerificationId, incomeVerificationId) ||
                const DeepCollectionEquality().equals(
                    other.incomeVerificationId, incomeVerificationId)) &&
            (identical(other.assetReportId, assetReportId) ||
                const DeepCollectionEquality()
                    .equals(other.assetReportId, assetReportId)) &&
            (identical(other.precheckId, precheckId) ||
                const DeepCollectionEquality()
                    .equals(other.precheckId, precheckId)) &&
            (identical(other.accessTokens, accessTokens) ||
                const DeepCollectionEquality()
                    .equals(other.accessTokens, accessTokens)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(incomeVerificationId) ^
      const DeepCollectionEquality().hash(assetReportId) ^
      const DeepCollectionEquality().hash(precheckId) ^
      const DeepCollectionEquality().hash(accessTokens) ^
      runtimeType.hashCode;
}

extension $LinkTokenCreateRequestIncomeVerificationExtension
    on LinkTokenCreateRequestIncomeVerification {
  LinkTokenCreateRequestIncomeVerification copyWith(
      {String? incomeVerificationId,
      String? assetReportId,
      String? precheckId,
      List<String>? accessTokens}) {
    return LinkTokenCreateRequestIncomeVerification(
        incomeVerificationId: incomeVerificationId ?? this.incomeVerificationId,
        assetReportId: assetReportId ?? this.assetReportId,
        precheckId: precheckId ?? this.precheckId,
        accessTokens: accessTokens ?? this.accessTokens);
  }
}

@JsonSerializable(explicitToJson: true)
class IncomeVerificationStatusWebhook {
  IncomeVerificationStatusWebhook({
    this.webhookType,
    this.webhookCode,
    this.incomeVerificationId,
    this.itemId,
    this.verificationStatus,
  });

  factory IncomeVerificationStatusWebhook.fromJson(Map<String, dynamic> json) =>
      _$IncomeVerificationStatusWebhookFromJson(json);

  @JsonKey(name: 'webhook_type')
  final String? webhookType;
  @JsonKey(name: 'webhook_code')
  final String? webhookCode;
  @JsonKey(name: 'income_verification_id')
  final String? incomeVerificationId;
  @JsonKey(name: 'item_id')
  final String? itemId;
  @JsonKey(name: 'verification_status')
  final String? verificationStatus;
  static const fromJsonFactory = _$IncomeVerificationStatusWebhookFromJson;
  static const toJsonFactory = _$IncomeVerificationStatusWebhookToJson;
  Map<String, dynamic> toJson() =>
      _$IncomeVerificationStatusWebhookToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IncomeVerificationStatusWebhook &&
            (identical(other.webhookType, webhookType) ||
                const DeepCollectionEquality()
                    .equals(other.webhookType, webhookType)) &&
            (identical(other.webhookCode, webhookCode) ||
                const DeepCollectionEquality()
                    .equals(other.webhookCode, webhookCode)) &&
            (identical(other.incomeVerificationId, incomeVerificationId) ||
                const DeepCollectionEquality().equals(
                    other.incomeVerificationId, incomeVerificationId)) &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)) &&
            (identical(other.verificationStatus, verificationStatus) ||
                const DeepCollectionEquality()
                    .equals(other.verificationStatus, verificationStatus)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(webhookType) ^
      const DeepCollectionEquality().hash(webhookCode) ^
      const DeepCollectionEquality().hash(incomeVerificationId) ^
      const DeepCollectionEquality().hash(itemId) ^
      const DeepCollectionEquality().hash(verificationStatus) ^
      runtimeType.hashCode;
}

extension $IncomeVerificationStatusWebhookExtension
    on IncomeVerificationStatusWebhook {
  IncomeVerificationStatusWebhook copyWith(
      {String? webhookType,
      String? webhookCode,
      String? incomeVerificationId,
      String? itemId,
      String? verificationStatus}) {
    return IncomeVerificationStatusWebhook(
        webhookType: webhookType ?? this.webhookType,
        webhookCode: webhookCode ?? this.webhookCode,
        incomeVerificationId: incomeVerificationId ?? this.incomeVerificationId,
        itemId: itemId ?? this.itemId,
        verificationStatus: verificationStatus ?? this.verificationStatus);
  }
}

@JsonSerializable(explicitToJson: true)
class IncomeVerificationSummaryGetRequest {
  IncomeVerificationSummaryGetRequest({
    this.clientId,
    this.secret,
    this.incomeVerificationId,
    this.accessToken,
  });

  factory IncomeVerificationSummaryGetRequest.fromJson(
          Map<String, dynamic> json) =>
      _$IncomeVerificationSummaryGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'income_verification_id')
  final String? incomeVerificationId;
  @JsonKey(name: 'access_token')
  final String? accessToken;
  static const fromJsonFactory = _$IncomeVerificationSummaryGetRequestFromJson;
  static const toJsonFactory = _$IncomeVerificationSummaryGetRequestToJson;
  Map<String, dynamic> toJson() =>
      _$IncomeVerificationSummaryGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IncomeVerificationSummaryGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.incomeVerificationId, incomeVerificationId) ||
                const DeepCollectionEquality().equals(
                    other.incomeVerificationId, incomeVerificationId)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(incomeVerificationId) ^
      const DeepCollectionEquality().hash(accessToken) ^
      runtimeType.hashCode;
}

extension $IncomeVerificationSummaryGetRequestExtension
    on IncomeVerificationSummaryGetRequest {
  IncomeVerificationSummaryGetRequest copyWith(
      {String? clientId,
      String? secret,
      String? incomeVerificationId,
      String? accessToken}) {
    return IncomeVerificationSummaryGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        incomeVerificationId: incomeVerificationId ?? this.incomeVerificationId,
        accessToken: accessToken ?? this.accessToken);
  }
}

@JsonSerializable(explicitToJson: true)
class IncomeVerificationSummaryGetResponse {
  IncomeVerificationSummaryGetResponse({
    this.incomeSummaries,
    this.error,
    this.requestId,
  });

  factory IncomeVerificationSummaryGetResponse.fromJson(
          Map<String, dynamic> json) =>
      _$IncomeVerificationSummaryGetResponseFromJson(json);

  @JsonKey(name: 'income_summaries', defaultValue: <IncomeSummary>[])
  final List<IncomeSummary>? incomeSummaries;
  @JsonKey(name: 'error')
  final Error? error;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$IncomeVerificationSummaryGetResponseFromJson;
  static const toJsonFactory = _$IncomeVerificationSummaryGetResponseToJson;
  Map<String, dynamic> toJson() =>
      _$IncomeVerificationSummaryGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IncomeVerificationSummaryGetResponse &&
            (identical(other.incomeSummaries, incomeSummaries) ||
                const DeepCollectionEquality()
                    .equals(other.incomeSummaries, incomeSummaries)) &&
            (identical(other.error, error) ||
                const DeepCollectionEquality().equals(other.error, error)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(incomeSummaries) ^
      const DeepCollectionEquality().hash(error) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $IncomeVerificationSummaryGetResponseExtension
    on IncomeVerificationSummaryGetResponse {
  IncomeVerificationSummaryGetResponse copyWith(
      {List<IncomeSummary>? incomeSummaries, Error? error, String? requestId}) {
    return IncomeVerificationSummaryGetResponse(
        incomeSummaries: incomeSummaries ?? this.incomeSummaries,
        error: error ?? this.error,
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class IncomeVerificationRefreshRequest {
  IncomeVerificationRefreshRequest({
    this.clientId,
    this.secret,
    this.incomeVerificationId,
    this.accessToken,
  });

  factory IncomeVerificationRefreshRequest.fromJson(
          Map<String, dynamic> json) =>
      _$IncomeVerificationRefreshRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'income_verification_id')
  final String? incomeVerificationId;
  @JsonKey(name: 'access_token')
  final String? accessToken;
  static const fromJsonFactory = _$IncomeVerificationRefreshRequestFromJson;
  static const toJsonFactory = _$IncomeVerificationRefreshRequestToJson;
  Map<String, dynamic> toJson() =>
      _$IncomeVerificationRefreshRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IncomeVerificationRefreshRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.incomeVerificationId, incomeVerificationId) ||
                const DeepCollectionEquality().equals(
                    other.incomeVerificationId, incomeVerificationId)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(incomeVerificationId) ^
      const DeepCollectionEquality().hash(accessToken) ^
      runtimeType.hashCode;
}

extension $IncomeVerificationRefreshRequestExtension
    on IncomeVerificationRefreshRequest {
  IncomeVerificationRefreshRequest copyWith(
      {String? clientId,
      String? secret,
      String? incomeVerificationId,
      String? accessToken}) {
    return IncomeVerificationRefreshRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        incomeVerificationId: incomeVerificationId ?? this.incomeVerificationId,
        accessToken: accessToken ?? this.accessToken);
  }
}

@JsonSerializable(explicitToJson: true)
class IncomeVerificationRefreshResponse {
  IncomeVerificationRefreshResponse({
    this.requestId,
    this.verificationRefreshStatus,
  });

  factory IncomeVerificationRefreshResponse.fromJson(
          Map<String, dynamic> json) =>
      _$IncomeVerificationRefreshResponseFromJson(json);

  @JsonKey(name: 'request_id')
  final String? requestId;
  @JsonKey(
      name: 'verification_refresh_status',
      toJson: verificationRefreshStatusToJson,
      fromJson: verificationRefreshStatusFromJson)
  final enums.VerificationRefreshStatus? verificationRefreshStatus;
  static const fromJsonFactory = _$IncomeVerificationRefreshResponseFromJson;
  static const toJsonFactory = _$IncomeVerificationRefreshResponseToJson;
  Map<String, dynamic> toJson() =>
      _$IncomeVerificationRefreshResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IncomeVerificationRefreshResponse &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)) &&
            (identical(other.verificationRefreshStatus,
                    verificationRefreshStatus) ||
                const DeepCollectionEquality().equals(
                    other.verificationRefreshStatus,
                    verificationRefreshStatus)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(requestId) ^
      const DeepCollectionEquality().hash(verificationRefreshStatus) ^
      runtimeType.hashCode;
}

extension $IncomeVerificationRefreshResponseExtension
    on IncomeVerificationRefreshResponse {
  IncomeVerificationRefreshResponse copyWith(
      {String? requestId,
      enums.VerificationRefreshStatus? verificationRefreshStatus}) {
    return IncomeVerificationRefreshResponse(
        requestId: requestId ?? this.requestId,
        verificationRefreshStatus:
            verificationRefreshStatus ?? this.verificationRefreshStatus);
  }
}

@JsonSerializable(explicitToJson: true)
class IncomeSummary {
  IncomeSummary({
    this.employerName,
    this.employeeName,
    this.ytdGrossIncome,
    this.ytdNetIncome,
    this.payFrequency,
    this.projectedWage,
    this.verifiedTransaction,
  });

  factory IncomeSummary.fromJson(Map<String, dynamic> json) =>
      _$IncomeSummaryFromJson(json);

  @JsonKey(name: 'employer_name')
  final EmployerIncomeSummaryFieldString? employerName;
  @JsonKey(name: 'employee_name')
  final EmployeeIncomeSummaryFieldString? employeeName;
  @JsonKey(name: 'ytd_gross_income')
  final YTDGrossIncomeSummaryFieldNumber? ytdGrossIncome;
  @JsonKey(name: 'ytd_net_income')
  final YTDNetIncomeSummaryFieldNumber? ytdNetIncome;
  @JsonKey(name: 'pay_frequency')
  final PayFrequency? payFrequency;
  @JsonKey(name: 'projected_wage')
  final ProjectedIncomeSummaryFieldNumber? projectedWage;
  @JsonKey(name: 'verified_transaction')
  final TransactionData? verifiedTransaction;
  static const fromJsonFactory = _$IncomeSummaryFromJson;
  static const toJsonFactory = _$IncomeSummaryToJson;
  Map<String, dynamic> toJson() => _$IncomeSummaryToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IncomeSummary &&
            (identical(other.employerName, employerName) ||
                const DeepCollectionEquality()
                    .equals(other.employerName, employerName)) &&
            (identical(other.employeeName, employeeName) ||
                const DeepCollectionEquality()
                    .equals(other.employeeName, employeeName)) &&
            (identical(other.ytdGrossIncome, ytdGrossIncome) ||
                const DeepCollectionEquality()
                    .equals(other.ytdGrossIncome, ytdGrossIncome)) &&
            (identical(other.ytdNetIncome, ytdNetIncome) ||
                const DeepCollectionEquality()
                    .equals(other.ytdNetIncome, ytdNetIncome)) &&
            (identical(other.payFrequency, payFrequency) ||
                const DeepCollectionEquality()
                    .equals(other.payFrequency, payFrequency)) &&
            (identical(other.projectedWage, projectedWage) ||
                const DeepCollectionEquality()
                    .equals(other.projectedWage, projectedWage)) &&
            (identical(other.verifiedTransaction, verifiedTransaction) ||
                const DeepCollectionEquality()
                    .equals(other.verifiedTransaction, verifiedTransaction)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(employerName) ^
      const DeepCollectionEquality().hash(employeeName) ^
      const DeepCollectionEquality().hash(ytdGrossIncome) ^
      const DeepCollectionEquality().hash(ytdNetIncome) ^
      const DeepCollectionEquality().hash(payFrequency) ^
      const DeepCollectionEquality().hash(projectedWage) ^
      const DeepCollectionEquality().hash(verifiedTransaction) ^
      runtimeType.hashCode;
}

extension $IncomeSummaryExtension on IncomeSummary {
  IncomeSummary copyWith(
      {EmployerIncomeSummaryFieldString? employerName,
      EmployeeIncomeSummaryFieldString? employeeName,
      YTDGrossIncomeSummaryFieldNumber? ytdGrossIncome,
      YTDNetIncomeSummaryFieldNumber? ytdNetIncome,
      PayFrequency? payFrequency,
      ProjectedIncomeSummaryFieldNumber? projectedWage,
      TransactionData? verifiedTransaction}) {
    return IncomeSummary(
        employerName: employerName ?? this.employerName,
        employeeName: employeeName ?? this.employeeName,
        ytdGrossIncome: ytdGrossIncome ?? this.ytdGrossIncome,
        ytdNetIncome: ytdNetIncome ?? this.ytdNetIncome,
        payFrequency: payFrequency ?? this.payFrequency,
        projectedWage: projectedWage ?? this.projectedWage,
        verifiedTransaction: verifiedTransaction ?? this.verifiedTransaction);
  }
}

@JsonSerializable(explicitToJson: true)
class TransactionData {
  TransactionData({
    this.description,
    this.amount,
    this.date,
    this.accountId,
    this.transactionId,
  });

  factory TransactionData.fromJson(Map<String, dynamic> json) =>
      _$TransactionDataFromJson(json);

  @JsonKey(name: 'description')
  final String? description;
  @JsonKey(name: 'amount')
  final double? amount;
  @JsonKey(name: 'date', toJson: _dateToJson)
  final DateTime? date;
  @JsonKey(name: 'account_id')
  final String? accountId;
  @JsonKey(name: 'transaction_id')
  final String? transactionId;
  static const fromJsonFactory = _$TransactionDataFromJson;
  static const toJsonFactory = _$TransactionDataToJson;
  Map<String, dynamic> toJson() => _$TransactionDataToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TransactionData &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.date, date) ||
                const DeepCollectionEquality().equals(other.date, date)) &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.transactionId, transactionId) ||
                const DeepCollectionEquality()
                    .equals(other.transactionId, transactionId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(date) ^
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(transactionId) ^
      runtimeType.hashCode;
}

extension $TransactionDataExtension on TransactionData {
  TransactionData copyWith(
      {String? description,
      double? amount,
      DateTime? date,
      String? accountId,
      String? transactionId}) {
    return TransactionData(
        description: description ?? this.description,
        amount: amount ?? this.amount,
        date: date ?? this.date,
        accountId: accountId ?? this.accountId,
        transactionId: transactionId ?? this.transactionId);
  }
}

@JsonSerializable(explicitToJson: true)
class IncomeSummaryFieldString {
  IncomeSummaryFieldString({
    this.value,
    this.verificationStatus,
  });

  factory IncomeSummaryFieldString.fromJson(Map<String, dynamic> json) =>
      _$IncomeSummaryFieldStringFromJson(json);

  @JsonKey(name: 'value')
  final String? value;
  @JsonKey(
      name: 'verification_status',
      toJson: verificationStatusToJson,
      fromJson: verificationStatusFromJson)
  final enums.VerificationStatus? verificationStatus;
  static const fromJsonFactory = _$IncomeSummaryFieldStringFromJson;
  static const toJsonFactory = _$IncomeSummaryFieldStringToJson;
  Map<String, dynamic> toJson() => _$IncomeSummaryFieldStringToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IncomeSummaryFieldString &&
            (identical(other.value, value) ||
                const DeepCollectionEquality().equals(other.value, value)) &&
            (identical(other.verificationStatus, verificationStatus) ||
                const DeepCollectionEquality()
                    .equals(other.verificationStatus, verificationStatus)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(value) ^
      const DeepCollectionEquality().hash(verificationStatus) ^
      runtimeType.hashCode;
}

extension $IncomeSummaryFieldStringExtension on IncomeSummaryFieldString {
  IncomeSummaryFieldString copyWith(
      {String? value, enums.VerificationStatus? verificationStatus}) {
    return IncomeSummaryFieldString(
        value: value ?? this.value,
        verificationStatus: verificationStatus ?? this.verificationStatus);
  }
}

@JsonSerializable(explicitToJson: true)
class EmployerIncomeSummaryFieldString {
  EmployerIncomeSummaryFieldString();

  factory EmployerIncomeSummaryFieldString.fromJson(
          Map<String, dynamic> json) =>
      _$EmployerIncomeSummaryFieldStringFromJson(json);

  static const fromJsonFactory = _$EmployerIncomeSummaryFieldStringFromJson;
  static const toJsonFactory = _$EmployerIncomeSummaryFieldStringToJson;
  Map<String, dynamic> toJson() =>
      _$EmployerIncomeSummaryFieldStringToJson(this);

  @override
  int get hashCode => runtimeType.hashCode;
}

@JsonSerializable(explicitToJson: true)
class EmployeeIncomeSummaryFieldString {
  EmployeeIncomeSummaryFieldString();

  factory EmployeeIncomeSummaryFieldString.fromJson(
          Map<String, dynamic> json) =>
      _$EmployeeIncomeSummaryFieldStringFromJson(json);

  static const fromJsonFactory = _$EmployeeIncomeSummaryFieldStringFromJson;
  static const toJsonFactory = _$EmployeeIncomeSummaryFieldStringToJson;
  Map<String, dynamic> toJson() =>
      _$EmployeeIncomeSummaryFieldStringToJson(this);

  @override
  int get hashCode => runtimeType.hashCode;
}

@JsonSerializable(explicitToJson: true)
class IncomeSummaryFieldNumber {
  IncomeSummaryFieldNumber({
    this.value,
    this.verificationStatus,
  });

  factory IncomeSummaryFieldNumber.fromJson(Map<String, dynamic> json) =>
      _$IncomeSummaryFieldNumberFromJson(json);

  @JsonKey(name: 'value')
  final double? value;
  @JsonKey(
      name: 'verification_status',
      toJson: verificationStatusToJson,
      fromJson: verificationStatusFromJson)
  final enums.VerificationStatus? verificationStatus;
  static const fromJsonFactory = _$IncomeSummaryFieldNumberFromJson;
  static const toJsonFactory = _$IncomeSummaryFieldNumberToJson;
  Map<String, dynamic> toJson() => _$IncomeSummaryFieldNumberToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IncomeSummaryFieldNumber &&
            (identical(other.value, value) ||
                const DeepCollectionEquality().equals(other.value, value)) &&
            (identical(other.verificationStatus, verificationStatus) ||
                const DeepCollectionEquality()
                    .equals(other.verificationStatus, verificationStatus)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(value) ^
      const DeepCollectionEquality().hash(verificationStatus) ^
      runtimeType.hashCode;
}

extension $IncomeSummaryFieldNumberExtension on IncomeSummaryFieldNumber {
  IncomeSummaryFieldNumber copyWith(
      {double? value, enums.VerificationStatus? verificationStatus}) {
    return IncomeSummaryFieldNumber(
        value: value ?? this.value,
        verificationStatus: verificationStatus ?? this.verificationStatus);
  }
}

@JsonSerializable(explicitToJson: true)
class YTDGrossIncomeSummaryFieldNumber {
  YTDGrossIncomeSummaryFieldNumber();

  factory YTDGrossIncomeSummaryFieldNumber.fromJson(
          Map<String, dynamic> json) =>
      _$YTDGrossIncomeSummaryFieldNumberFromJson(json);

  static const fromJsonFactory = _$YTDGrossIncomeSummaryFieldNumberFromJson;
  static const toJsonFactory = _$YTDGrossIncomeSummaryFieldNumberToJson;
  Map<String, dynamic> toJson() =>
      _$YTDGrossIncomeSummaryFieldNumberToJson(this);

  @override
  int get hashCode => runtimeType.hashCode;
}

@JsonSerializable(explicitToJson: true)
class YTDNetIncomeSummaryFieldNumber {
  YTDNetIncomeSummaryFieldNumber();

  factory YTDNetIncomeSummaryFieldNumber.fromJson(Map<String, dynamic> json) =>
      _$YTDNetIncomeSummaryFieldNumberFromJson(json);

  static const fromJsonFactory = _$YTDNetIncomeSummaryFieldNumberFromJson;
  static const toJsonFactory = _$YTDNetIncomeSummaryFieldNumberToJson;
  Map<String, dynamic> toJson() => _$YTDNetIncomeSummaryFieldNumberToJson(this);

  @override
  int get hashCode => runtimeType.hashCode;
}

@JsonSerializable(explicitToJson: true)
class ProjectedIncomeSummaryFieldNumber {
  ProjectedIncomeSummaryFieldNumber();

  factory ProjectedIncomeSummaryFieldNumber.fromJson(
          Map<String, dynamic> json) =>
      _$ProjectedIncomeSummaryFieldNumberFromJson(json);

  static const fromJsonFactory = _$ProjectedIncomeSummaryFieldNumberFromJson;
  static const toJsonFactory = _$ProjectedIncomeSummaryFieldNumberToJson;
  Map<String, dynamic> toJson() =>
      _$ProjectedIncomeSummaryFieldNumberToJson(this);

  @override
  int get hashCode => runtimeType.hashCode;
}

@JsonSerializable(explicitToJson: true)
class PayFrequency {
  PayFrequency({
    this.value,
    this.verificationStatus,
  });

  factory PayFrequency.fromJson(Map<String, dynamic> json) =>
      _$PayFrequencyFromJson(json);

  @JsonKey(
      name: 'value',
      toJson: payFrequencyValueToJson,
      fromJson: payFrequencyValueFromJson)
  final enums.PayFrequencyValue? value;
  @JsonKey(
      name: 'verification_status',
      toJson: verificationStatusToJson,
      fromJson: verificationStatusFromJson)
  final enums.VerificationStatus? verificationStatus;
  static const fromJsonFactory = _$PayFrequencyFromJson;
  static const toJsonFactory = _$PayFrequencyToJson;
  Map<String, dynamic> toJson() => _$PayFrequencyToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PayFrequency &&
            (identical(other.value, value) ||
                const DeepCollectionEquality().equals(other.value, value)) &&
            (identical(other.verificationStatus, verificationStatus) ||
                const DeepCollectionEquality()
                    .equals(other.verificationStatus, verificationStatus)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(value) ^
      const DeepCollectionEquality().hash(verificationStatus) ^
      runtimeType.hashCode;
}

extension $PayFrequencyExtension on PayFrequency {
  PayFrequency copyWith(
      {enums.PayFrequencyValue? value,
      enums.VerificationStatus? verificationStatus}) {
    return PayFrequency(
        value: value ?? this.value,
        verificationStatus: verificationStatus ?? this.verificationStatus);
  }
}

@JsonSerializable(explicitToJson: true)
class IncomeVerificationPaystubGetRequest {
  IncomeVerificationPaystubGetRequest({
    this.clientId,
    this.secret,
    this.incomeVerificationId,
    this.accessToken,
  });

  factory IncomeVerificationPaystubGetRequest.fromJson(
          Map<String, dynamic> json) =>
      _$IncomeVerificationPaystubGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'income_verification_id')
  final String? incomeVerificationId;
  @JsonKey(name: 'access_token')
  final String? accessToken;
  static const fromJsonFactory = _$IncomeVerificationPaystubGetRequestFromJson;
  static const toJsonFactory = _$IncomeVerificationPaystubGetRequestToJson;
  Map<String, dynamic> toJson() =>
      _$IncomeVerificationPaystubGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IncomeVerificationPaystubGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.incomeVerificationId, incomeVerificationId) ||
                const DeepCollectionEquality().equals(
                    other.incomeVerificationId, incomeVerificationId)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(incomeVerificationId) ^
      const DeepCollectionEquality().hash(accessToken) ^
      runtimeType.hashCode;
}

extension $IncomeVerificationPaystubGetRequestExtension
    on IncomeVerificationPaystubGetRequest {
  IncomeVerificationPaystubGetRequest copyWith(
      {String? clientId,
      String? secret,
      String? incomeVerificationId,
      String? accessToken}) {
    return IncomeVerificationPaystubGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        incomeVerificationId: incomeVerificationId ?? this.incomeVerificationId,
        accessToken: accessToken ?? this.accessToken);
  }
}

@JsonSerializable(explicitToJson: true)
class IncomeVerificationPaystubGetResponse {
  IncomeVerificationPaystubGetResponse({
    this.paystub,
    this.error,
    this.requestId,
  });

  factory IncomeVerificationPaystubGetResponse.fromJson(
          Map<String, dynamic> json) =>
      _$IncomeVerificationPaystubGetResponseFromJson(json);

  @JsonKey(name: 'paystub')
  final Paystub? paystub;
  @JsonKey(name: 'error')
  final Error? error;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$IncomeVerificationPaystubGetResponseFromJson;
  static const toJsonFactory = _$IncomeVerificationPaystubGetResponseToJson;
  Map<String, dynamic> toJson() =>
      _$IncomeVerificationPaystubGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IncomeVerificationPaystubGetResponse &&
            (identical(other.paystub, paystub) ||
                const DeepCollectionEquality()
                    .equals(other.paystub, paystub)) &&
            (identical(other.error, error) ||
                const DeepCollectionEquality().equals(other.error, error)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(paystub) ^
      const DeepCollectionEquality().hash(error) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $IncomeVerificationPaystubGetResponseExtension
    on IncomeVerificationPaystubGetResponse {
  IncomeVerificationPaystubGetResponse copyWith(
      {Paystub? paystub, Error? error, String? requestId}) {
    return IncomeVerificationPaystubGetResponse(
        paystub: paystub ?? this.paystub,
        error: error ?? this.error,
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class IncomeVerificationPaystubsGetRequest {
  IncomeVerificationPaystubsGetRequest({
    this.clientId,
    this.secret,
    this.incomeVerificationId,
    this.accessToken,
  });

  factory IncomeVerificationPaystubsGetRequest.fromJson(
          Map<String, dynamic> json) =>
      _$IncomeVerificationPaystubsGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'income_verification_id')
  final String? incomeVerificationId;
  @JsonKey(name: 'access_token')
  final String? accessToken;
  static const fromJsonFactory = _$IncomeVerificationPaystubsGetRequestFromJson;
  static const toJsonFactory = _$IncomeVerificationPaystubsGetRequestToJson;
  Map<String, dynamic> toJson() =>
      _$IncomeVerificationPaystubsGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IncomeVerificationPaystubsGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.incomeVerificationId, incomeVerificationId) ||
                const DeepCollectionEquality().equals(
                    other.incomeVerificationId, incomeVerificationId)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(incomeVerificationId) ^
      const DeepCollectionEquality().hash(accessToken) ^
      runtimeType.hashCode;
}

extension $IncomeVerificationPaystubsGetRequestExtension
    on IncomeVerificationPaystubsGetRequest {
  IncomeVerificationPaystubsGetRequest copyWith(
      {String? clientId,
      String? secret,
      String? incomeVerificationId,
      String? accessToken}) {
    return IncomeVerificationPaystubsGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        incomeVerificationId: incomeVerificationId ?? this.incomeVerificationId,
        accessToken: accessToken ?? this.accessToken);
  }
}

@JsonSerializable(explicitToJson: true)
class IncomeVerificationPaystubsGetResponse {
  IncomeVerificationPaystubsGetResponse({
    this.documentMetadata,
    this.paystubs,
    this.error,
    this.requestId,
  });

  factory IncomeVerificationPaystubsGetResponse.fromJson(
          Map<String, dynamic> json) =>
      _$IncomeVerificationPaystubsGetResponseFromJson(json);

  @JsonKey(name: 'document_metadata', defaultValue: <DocumentMetadata>[])
  final List<DocumentMetadata>? documentMetadata;
  @JsonKey(name: 'paystubs', defaultValue: <Paystub>[])
  final List<Paystub>? paystubs;
  @JsonKey(name: 'error')
  final Error? error;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory =
      _$IncomeVerificationPaystubsGetResponseFromJson;
  static const toJsonFactory = _$IncomeVerificationPaystubsGetResponseToJson;
  Map<String, dynamic> toJson() =>
      _$IncomeVerificationPaystubsGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IncomeVerificationPaystubsGetResponse &&
            (identical(other.documentMetadata, documentMetadata) ||
                const DeepCollectionEquality()
                    .equals(other.documentMetadata, documentMetadata)) &&
            (identical(other.paystubs, paystubs) ||
                const DeepCollectionEquality()
                    .equals(other.paystubs, paystubs)) &&
            (identical(other.error, error) ||
                const DeepCollectionEquality().equals(other.error, error)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(documentMetadata) ^
      const DeepCollectionEquality().hash(paystubs) ^
      const DeepCollectionEquality().hash(error) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $IncomeVerificationPaystubsGetResponseExtension
    on IncomeVerificationPaystubsGetResponse {
  IncomeVerificationPaystubsGetResponse copyWith(
      {List<DocumentMetadata>? documentMetadata,
      List<Paystub>? paystubs,
      Error? error,
      String? requestId}) {
    return IncomeVerificationPaystubsGetResponse(
        documentMetadata: documentMetadata ?? this.documentMetadata,
        paystubs: paystubs ?? this.paystubs,
        error: error ?? this.error,
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class DocumentMetadata {
  DocumentMetadata({
    this.name,
    this.status,
    this.docId,
    this.docType,
  });

  factory DocumentMetadata.fromJson(Map<String, dynamic> json) =>
      _$DocumentMetadataFromJson(json);

  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'status')
  final String? status;
  @JsonKey(name: 'doc_id')
  final String? docId;
  @JsonKey(name: 'doc_type', toJson: docTypeToJson, fromJson: docTypeFromJson)
  final enums.DocType? docType;
  static const fromJsonFactory = _$DocumentMetadataFromJson;
  static const toJsonFactory = _$DocumentMetadataToJson;
  Map<String, dynamic> toJson() => _$DocumentMetadataToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is DocumentMetadata &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.docId, docId) ||
                const DeepCollectionEquality().equals(other.docId, docId)) &&
            (identical(other.docType, docType) ||
                const DeepCollectionEquality().equals(other.docType, docType)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(docId) ^
      const DeepCollectionEquality().hash(docType) ^
      runtimeType.hashCode;
}

extension $DocumentMetadataExtension on DocumentMetadata {
  DocumentMetadata copyWith(
      {String? name, String? status, String? docId, enums.DocType? docType}) {
    return DocumentMetadata(
        name: name ?? this.name,
        status: status ?? this.status,
        docId: docId ?? this.docId,
        docType: docType ?? this.docType);
  }
}

@JsonSerializable(explicitToJson: true)
class Paystub {
  Paystub({
    this.deductions,
    this.docId,
    this.earnings,
    this.employee,
    this.employer,
    this.employmentDetails,
    this.netPay,
    this.payPeriodDetails,
    this.paystubDetails,
    this.incomeBreakdown,
    this.ytdEarnings,
    this.verification,
  });

  factory Paystub.fromJson(Map<String, dynamic> json) =>
      _$PaystubFromJson(json);

  @JsonKey(name: 'deductions')
  final Deductions? deductions;
  @JsonKey(name: 'doc_id')
  final String? docId;
  @JsonKey(name: 'earnings')
  final Earnings? earnings;
  @JsonKey(name: 'employee')
  final Employee? employee;
  @JsonKey(name: 'employer')
  final PaystubEmployer? employer;
  @JsonKey(name: 'employment_details')
  final EmploymentDetails? employmentDetails;
  @JsonKey(name: 'net_pay')
  final NetPay? netPay;
  @JsonKey(name: 'pay_period_details')
  final PayPeriodDetails? payPeriodDetails;
  @JsonKey(name: 'paystub_details')
  final PaystubDetails? paystubDetails;
  @JsonKey(name: 'income_breakdown', defaultValue: <IncomeBreakdown>[])
  final List<IncomeBreakdown>? incomeBreakdown;
  @JsonKey(name: 'ytd_earnings')
  final PaystubYTDDetails? ytdEarnings;
  @JsonKey(name: 'verification')
  final PaystubVerification? verification;
  static const fromJsonFactory = _$PaystubFromJson;
  static const toJsonFactory = _$PaystubToJson;
  Map<String, dynamic> toJson() => _$PaystubToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Paystub &&
            (identical(other.deductions, deductions) ||
                const DeepCollectionEquality()
                    .equals(other.deductions, deductions)) &&
            (identical(other.docId, docId) ||
                const DeepCollectionEquality().equals(other.docId, docId)) &&
            (identical(other.earnings, earnings) ||
                const DeepCollectionEquality()
                    .equals(other.earnings, earnings)) &&
            (identical(other.employee, employee) ||
                const DeepCollectionEquality()
                    .equals(other.employee, employee)) &&
            (identical(other.employer, employer) ||
                const DeepCollectionEquality()
                    .equals(other.employer, employer)) &&
            (identical(other.employmentDetails, employmentDetails) ||
                const DeepCollectionEquality()
                    .equals(other.employmentDetails, employmentDetails)) &&
            (identical(other.netPay, netPay) ||
                const DeepCollectionEquality().equals(other.netPay, netPay)) &&
            (identical(other.payPeriodDetails, payPeriodDetails) ||
                const DeepCollectionEquality()
                    .equals(other.payPeriodDetails, payPeriodDetails)) &&
            (identical(other.paystubDetails, paystubDetails) ||
                const DeepCollectionEquality()
                    .equals(other.paystubDetails, paystubDetails)) &&
            (identical(other.incomeBreakdown, incomeBreakdown) ||
                const DeepCollectionEquality()
                    .equals(other.incomeBreakdown, incomeBreakdown)) &&
            (identical(other.ytdEarnings, ytdEarnings) ||
                const DeepCollectionEquality()
                    .equals(other.ytdEarnings, ytdEarnings)) &&
            (identical(other.verification, verification) ||
                const DeepCollectionEquality()
                    .equals(other.verification, verification)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(deductions) ^
      const DeepCollectionEquality().hash(docId) ^
      const DeepCollectionEquality().hash(earnings) ^
      const DeepCollectionEquality().hash(employee) ^
      const DeepCollectionEquality().hash(employer) ^
      const DeepCollectionEquality().hash(employmentDetails) ^
      const DeepCollectionEquality().hash(netPay) ^
      const DeepCollectionEquality().hash(payPeriodDetails) ^
      const DeepCollectionEquality().hash(paystubDetails) ^
      const DeepCollectionEquality().hash(incomeBreakdown) ^
      const DeepCollectionEquality().hash(ytdEarnings) ^
      const DeepCollectionEquality().hash(verification) ^
      runtimeType.hashCode;
}

extension $PaystubExtension on Paystub {
  Paystub copyWith(
      {Deductions? deductions,
      String? docId,
      Earnings? earnings,
      Employee? employee,
      PaystubEmployer? employer,
      EmploymentDetails? employmentDetails,
      NetPay? netPay,
      PayPeriodDetails? payPeriodDetails,
      PaystubDetails? paystubDetails,
      List<IncomeBreakdown>? incomeBreakdown,
      PaystubYTDDetails? ytdEarnings,
      PaystubVerification? verification}) {
    return Paystub(
        deductions: deductions ?? this.deductions,
        docId: docId ?? this.docId,
        earnings: earnings ?? this.earnings,
        employee: employee ?? this.employee,
        employer: employer ?? this.employer,
        employmentDetails: employmentDetails ?? this.employmentDetails,
        netPay: netPay ?? this.netPay,
        payPeriodDetails: payPeriodDetails ?? this.payPeriodDetails,
        paystubDetails: paystubDetails ?? this.paystubDetails,
        incomeBreakdown: incomeBreakdown ?? this.incomeBreakdown,
        ytdEarnings: ytdEarnings ?? this.ytdEarnings,
        verification: verification ?? this.verification);
  }
}

@JsonSerializable(explicitToJson: true)
class Deductions {
  Deductions({
    this.subtotals,
    this.breakdown,
    this.totals,
    this.total,
  });

  factory Deductions.fromJson(Map<String, dynamic> json) =>
      _$DeductionsFromJson(json);

  @JsonKey(name: 'subtotals', defaultValue: <Total>[])
  final List<Total>? subtotals;
  @JsonKey(name: 'breakdown', defaultValue: <DeductionsBreakdown>[])
  final List<DeductionsBreakdown>? breakdown;
  @JsonKey(name: 'totals', defaultValue: <Total>[])
  final List<Total>? totals;
  @JsonKey(name: 'total')
  final DeductionsTotal? total;
  static const fromJsonFactory = _$DeductionsFromJson;
  static const toJsonFactory = _$DeductionsToJson;
  Map<String, dynamic> toJson() => _$DeductionsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Deductions &&
            (identical(other.subtotals, subtotals) ||
                const DeepCollectionEquality()
                    .equals(other.subtotals, subtotals)) &&
            (identical(other.breakdown, breakdown) ||
                const DeepCollectionEquality()
                    .equals(other.breakdown, breakdown)) &&
            (identical(other.totals, totals) ||
                const DeepCollectionEquality().equals(other.totals, totals)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(subtotals) ^
      const DeepCollectionEquality().hash(breakdown) ^
      const DeepCollectionEquality().hash(totals) ^
      const DeepCollectionEquality().hash(total) ^
      runtimeType.hashCode;
}

extension $DeductionsExtension on Deductions {
  Deductions copyWith(
      {List<Total>? subtotals,
      List<DeductionsBreakdown>? breakdown,
      List<Total>? totals,
      DeductionsTotal? total}) {
    return Deductions(
        subtotals: subtotals ?? this.subtotals,
        breakdown: breakdown ?? this.breakdown,
        totals: totals ?? this.totals,
        total: total ?? this.total);
  }
}

@JsonSerializable(explicitToJson: true)
class DeductionsBreakdown {
  DeductionsBreakdown({
    this.currentAmount,
    this.description,
    this.isoCurrencyCode,
    this.unofficialCurrencyCode,
    this.ytdAmount,
  });

  factory DeductionsBreakdown.fromJson(Map<String, dynamic> json) =>
      _$DeductionsBreakdownFromJson(json);

  @JsonKey(name: 'current_amount')
  final double? currentAmount;
  @JsonKey(name: 'description')
  final String? description;
  @JsonKey(name: 'iso_currency_code')
  final String? isoCurrencyCode;
  @JsonKey(name: 'unofficial_currency_code')
  final String? unofficialCurrencyCode;
  @JsonKey(name: 'ytd_amount')
  final double? ytdAmount;
  static const fromJsonFactory = _$DeductionsBreakdownFromJson;
  static const toJsonFactory = _$DeductionsBreakdownToJson;
  Map<String, dynamic> toJson() => _$DeductionsBreakdownToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is DeductionsBreakdown &&
            (identical(other.currentAmount, currentAmount) ||
                const DeepCollectionEquality()
                    .equals(other.currentAmount, currentAmount)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)) &&
            (identical(other.unofficialCurrencyCode, unofficialCurrencyCode) ||
                const DeepCollectionEquality().equals(
                    other.unofficialCurrencyCode, unofficialCurrencyCode)) &&
            (identical(other.ytdAmount, ytdAmount) ||
                const DeepCollectionEquality()
                    .equals(other.ytdAmount, ytdAmount)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(currentAmount) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      const DeepCollectionEquality().hash(unofficialCurrencyCode) ^
      const DeepCollectionEquality().hash(ytdAmount) ^
      runtimeType.hashCode;
}

extension $DeductionsBreakdownExtension on DeductionsBreakdown {
  DeductionsBreakdown copyWith(
      {double? currentAmount,
      String? description,
      String? isoCurrencyCode,
      String? unofficialCurrencyCode,
      double? ytdAmount}) {
    return DeductionsBreakdown(
        currentAmount: currentAmount ?? this.currentAmount,
        description: description ?? this.description,
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode,
        unofficialCurrencyCode:
            unofficialCurrencyCode ?? this.unofficialCurrencyCode,
        ytdAmount: ytdAmount ?? this.ytdAmount);
  }
}

@JsonSerializable(explicitToJson: true)
class DeductionsTotal {
  DeductionsTotal({
    this.currentAmount,
    this.isoCurrencyCode,
    this.unofficialCurrencyCode,
    this.ytdAmount,
  });

  factory DeductionsTotal.fromJson(Map<String, dynamic> json) =>
      _$DeductionsTotalFromJson(json);

  @JsonKey(name: 'current_amount')
  final double? currentAmount;
  @JsonKey(name: 'iso_currency_code')
  final String? isoCurrencyCode;
  @JsonKey(name: 'unofficial_currency_code')
  final String? unofficialCurrencyCode;
  @JsonKey(name: 'ytd_amount')
  final double? ytdAmount;
  static const fromJsonFactory = _$DeductionsTotalFromJson;
  static const toJsonFactory = _$DeductionsTotalToJson;
  Map<String, dynamic> toJson() => _$DeductionsTotalToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is DeductionsTotal &&
            (identical(other.currentAmount, currentAmount) ||
                const DeepCollectionEquality()
                    .equals(other.currentAmount, currentAmount)) &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)) &&
            (identical(other.unofficialCurrencyCode, unofficialCurrencyCode) ||
                const DeepCollectionEquality().equals(
                    other.unofficialCurrencyCode, unofficialCurrencyCode)) &&
            (identical(other.ytdAmount, ytdAmount) ||
                const DeepCollectionEquality()
                    .equals(other.ytdAmount, ytdAmount)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(currentAmount) ^
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      const DeepCollectionEquality().hash(unofficialCurrencyCode) ^
      const DeepCollectionEquality().hash(ytdAmount) ^
      runtimeType.hashCode;
}

extension $DeductionsTotalExtension on DeductionsTotal {
  DeductionsTotal copyWith(
      {double? currentAmount,
      String? isoCurrencyCode,
      String? unofficialCurrencyCode,
      double? ytdAmount}) {
    return DeductionsTotal(
        currentAmount: currentAmount ?? this.currentAmount,
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode,
        unofficialCurrencyCode:
            unofficialCurrencyCode ?? this.unofficialCurrencyCode,
        ytdAmount: ytdAmount ?? this.ytdAmount);
  }
}

@JsonSerializable(explicitToJson: true)
class Total {
  Total({
    this.canonicalDescription,
    this.description,
    this.currentPay,
    this.ytdPay,
  });

  factory Total.fromJson(Map<String, dynamic> json) => _$TotalFromJson(json);

  @JsonKey(
      name: 'canonical_description',
      toJson: totalCanonicalDescriptionToJson,
      fromJson: totalCanonicalDescriptionFromJson)
  final enums.TotalCanonicalDescription? canonicalDescription;
  @JsonKey(name: 'description')
  final String? description;
  @JsonKey(name: 'current_pay')
  final Pay? currentPay;
  @JsonKey(name: 'ytd_pay')
  final Pay? ytdPay;
  static const fromJsonFactory = _$TotalFromJson;
  static const toJsonFactory = _$TotalToJson;
  Map<String, dynamic> toJson() => _$TotalToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Total &&
            (identical(other.canonicalDescription, canonicalDescription) ||
                const DeepCollectionEquality().equals(
                    other.canonicalDescription, canonicalDescription)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.currentPay, currentPay) ||
                const DeepCollectionEquality()
                    .equals(other.currentPay, currentPay)) &&
            (identical(other.ytdPay, ytdPay) ||
                const DeepCollectionEquality().equals(other.ytdPay, ytdPay)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(canonicalDescription) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(currentPay) ^
      const DeepCollectionEquality().hash(ytdPay) ^
      runtimeType.hashCode;
}

extension $TotalExtension on Total {
  Total copyWith(
      {enums.TotalCanonicalDescription? canonicalDescription,
      String? description,
      Pay? currentPay,
      Pay? ytdPay}) {
    return Total(
        canonicalDescription: canonicalDescription ?? this.canonicalDescription,
        description: description ?? this.description,
        currentPay: currentPay ?? this.currentPay,
        ytdPay: ytdPay ?? this.ytdPay);
  }
}

@JsonSerializable(explicitToJson: true)
class Pay {
  Pay({
    this.amount,
    this.currency,
  });

  factory Pay.fromJson(Map<String, dynamic> json) => _$PayFromJson(json);

  @JsonKey(name: 'amount')
  final double? amount;
  @JsonKey(name: 'currency')
  final String? currency;
  static const fromJsonFactory = _$PayFromJson;
  static const toJsonFactory = _$PayToJson;
  Map<String, dynamic> toJson() => _$PayToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Pay &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.currency, currency) ||
                const DeepCollectionEquality()
                    .equals(other.currency, currency)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(currency) ^
      runtimeType.hashCode;
}

extension $PayExtension on Pay {
  Pay copyWith({double? amount, String? currency}) {
    return Pay(
        amount: amount ?? this.amount, currency: currency ?? this.currency);
  }
}

@JsonSerializable(explicitToJson: true)
class Earnings {
  Earnings({
    this.subtotals,
    this.totals,
    this.breakdown,
    this.total,
  });

  factory Earnings.fromJson(Map<String, dynamic> json) =>
      _$EarningsFromJson(json);

  @JsonKey(name: 'subtotals', defaultValue: <EarningsTotal>[])
  final List<EarningsTotal>? subtotals;
  @JsonKey(name: 'totals', defaultValue: <EarningsTotal>[])
  final List<EarningsTotal>? totals;
  @JsonKey(name: 'breakdown', defaultValue: <EarningsBreakdown>[])
  final List<EarningsBreakdown>? breakdown;
  @JsonKey(name: 'total')
  final EarningsTotal? total;
  static const fromJsonFactory = _$EarningsFromJson;
  static const toJsonFactory = _$EarningsToJson;
  Map<String, dynamic> toJson() => _$EarningsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Earnings &&
            (identical(other.subtotals, subtotals) ||
                const DeepCollectionEquality()
                    .equals(other.subtotals, subtotals)) &&
            (identical(other.totals, totals) ||
                const DeepCollectionEquality().equals(other.totals, totals)) &&
            (identical(other.breakdown, breakdown) ||
                const DeepCollectionEquality()
                    .equals(other.breakdown, breakdown)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(subtotals) ^
      const DeepCollectionEquality().hash(totals) ^
      const DeepCollectionEquality().hash(breakdown) ^
      const DeepCollectionEquality().hash(total) ^
      runtimeType.hashCode;
}

extension $EarningsExtension on Earnings {
  Earnings copyWith(
      {List<EarningsTotal>? subtotals,
      List<EarningsTotal>? totals,
      List<EarningsBreakdown>? breakdown,
      EarningsTotal? total}) {
    return Earnings(
        subtotals: subtotals ?? this.subtotals,
        totals: totals ?? this.totals,
        breakdown: breakdown ?? this.breakdown,
        total: total ?? this.total);
  }
}

@JsonSerializable(explicitToJson: true)
class EarningsBreakdown {
  EarningsBreakdown({
    this.canonicalDescription,
    this.currentAmount,
    this.description,
    this.hours,
    this.isoCurrencyCode,
    this.rate,
    this.unofficialCurrencyCode,
    this.ytdAmount,
  });

  factory EarningsBreakdown.fromJson(Map<String, dynamic> json) =>
      _$EarningsBreakdownFromJson(json);

  @JsonKey(
      name: 'canonical_description',
      toJson: earningsBreakdownCanonicalDescriptionToJson,
      fromJson: earningsBreakdownCanonicalDescriptionFromJson)
  final enums.EarningsBreakdownCanonicalDescription? canonicalDescription;
  @JsonKey(name: 'current_amount')
  final double? currentAmount;
  @JsonKey(name: 'description')
  final String? description;
  @JsonKey(name: 'hours')
  final double? hours;
  @JsonKey(name: 'iso_currency_code')
  final String? isoCurrencyCode;
  @JsonKey(name: 'rate')
  final double? rate;
  @JsonKey(name: 'unofficial_currency_code')
  final String? unofficialCurrencyCode;
  @JsonKey(name: 'ytd_amount')
  final double? ytdAmount;
  static const fromJsonFactory = _$EarningsBreakdownFromJson;
  static const toJsonFactory = _$EarningsBreakdownToJson;
  Map<String, dynamic> toJson() => _$EarningsBreakdownToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is EarningsBreakdown &&
            (identical(other.canonicalDescription, canonicalDescription) ||
                const DeepCollectionEquality().equals(
                    other.canonicalDescription, canonicalDescription)) &&
            (identical(other.currentAmount, currentAmount) ||
                const DeepCollectionEquality()
                    .equals(other.currentAmount, currentAmount)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.hours, hours) ||
                const DeepCollectionEquality().equals(other.hours, hours)) &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)) &&
            (identical(other.rate, rate) ||
                const DeepCollectionEquality().equals(other.rate, rate)) &&
            (identical(other.unofficialCurrencyCode, unofficialCurrencyCode) ||
                const DeepCollectionEquality().equals(
                    other.unofficialCurrencyCode, unofficialCurrencyCode)) &&
            (identical(other.ytdAmount, ytdAmount) ||
                const DeepCollectionEquality()
                    .equals(other.ytdAmount, ytdAmount)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(canonicalDescription) ^
      const DeepCollectionEquality().hash(currentAmount) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(hours) ^
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      const DeepCollectionEquality().hash(rate) ^
      const DeepCollectionEquality().hash(unofficialCurrencyCode) ^
      const DeepCollectionEquality().hash(ytdAmount) ^
      runtimeType.hashCode;
}

extension $EarningsBreakdownExtension on EarningsBreakdown {
  EarningsBreakdown copyWith(
      {enums.EarningsBreakdownCanonicalDescription? canonicalDescription,
      double? currentAmount,
      String? description,
      double? hours,
      String? isoCurrencyCode,
      double? rate,
      String? unofficialCurrencyCode,
      double? ytdAmount}) {
    return EarningsBreakdown(
        canonicalDescription: canonicalDescription ?? this.canonicalDescription,
        currentAmount: currentAmount ?? this.currentAmount,
        description: description ?? this.description,
        hours: hours ?? this.hours,
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode,
        rate: rate ?? this.rate,
        unofficialCurrencyCode:
            unofficialCurrencyCode ?? this.unofficialCurrencyCode,
        ytdAmount: ytdAmount ?? this.ytdAmount);
  }
}

@JsonSerializable(explicitToJson: true)
class EarningsTotal {
  EarningsTotal({
    this.currentAmount,
    this.currentPay,
    this.ytdPay,
    this.hours,
    this.isoCurrencyCode,
    this.unofficialCurrencyCode,
    this.ytdAmount,
  });

  factory EarningsTotal.fromJson(Map<String, dynamic> json) =>
      _$EarningsTotalFromJson(json);

  @JsonKey(name: 'current_amount')
  final double? currentAmount;
  @JsonKey(name: 'current_pay')
  final Pay? currentPay;
  @JsonKey(name: 'ytd_pay')
  final Pay? ytdPay;
  @JsonKey(name: 'hours')
  final double? hours;
  @JsonKey(name: 'iso_currency_code')
  final String? isoCurrencyCode;
  @JsonKey(name: 'unofficial_currency_code')
  final String? unofficialCurrencyCode;
  @JsonKey(name: 'ytd_amount')
  final double? ytdAmount;
  static const fromJsonFactory = _$EarningsTotalFromJson;
  static const toJsonFactory = _$EarningsTotalToJson;
  Map<String, dynamic> toJson() => _$EarningsTotalToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is EarningsTotal &&
            (identical(other.currentAmount, currentAmount) ||
                const DeepCollectionEquality()
                    .equals(other.currentAmount, currentAmount)) &&
            (identical(other.currentPay, currentPay) ||
                const DeepCollectionEquality()
                    .equals(other.currentPay, currentPay)) &&
            (identical(other.ytdPay, ytdPay) ||
                const DeepCollectionEquality().equals(other.ytdPay, ytdPay)) &&
            (identical(other.hours, hours) ||
                const DeepCollectionEquality().equals(other.hours, hours)) &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)) &&
            (identical(other.unofficialCurrencyCode, unofficialCurrencyCode) ||
                const DeepCollectionEquality().equals(
                    other.unofficialCurrencyCode, unofficialCurrencyCode)) &&
            (identical(other.ytdAmount, ytdAmount) ||
                const DeepCollectionEquality()
                    .equals(other.ytdAmount, ytdAmount)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(currentAmount) ^
      const DeepCollectionEquality().hash(currentPay) ^
      const DeepCollectionEquality().hash(ytdPay) ^
      const DeepCollectionEquality().hash(hours) ^
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      const DeepCollectionEquality().hash(unofficialCurrencyCode) ^
      const DeepCollectionEquality().hash(ytdAmount) ^
      runtimeType.hashCode;
}

extension $EarningsTotalExtension on EarningsTotal {
  EarningsTotal copyWith(
      {double? currentAmount,
      Pay? currentPay,
      Pay? ytdPay,
      double? hours,
      String? isoCurrencyCode,
      String? unofficialCurrencyCode,
      double? ytdAmount}) {
    return EarningsTotal(
        currentAmount: currentAmount ?? this.currentAmount,
        currentPay: currentPay ?? this.currentPay,
        ytdPay: ytdPay ?? this.ytdPay,
        hours: hours ?? this.hours,
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode,
        unofficialCurrencyCode:
            unofficialCurrencyCode ?? this.unofficialCurrencyCode,
        ytdAmount: ytdAmount ?? this.ytdAmount);
  }
}

@JsonSerializable(explicitToJson: true)
class EmploymentDetails {
  EmploymentDetails({
    this.annualSalary,
    this.hireDate,
  });

  factory EmploymentDetails.fromJson(Map<String, dynamic> json) =>
      _$EmploymentDetailsFromJson(json);

  @JsonKey(name: 'annual_salary')
  final Pay? annualSalary;
  @JsonKey(name: 'hire_date', toJson: _dateToJson)
  final DateTime? hireDate;
  static const fromJsonFactory = _$EmploymentDetailsFromJson;
  static const toJsonFactory = _$EmploymentDetailsToJson;
  Map<String, dynamic> toJson() => _$EmploymentDetailsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is EmploymentDetails &&
            (identical(other.annualSalary, annualSalary) ||
                const DeepCollectionEquality()
                    .equals(other.annualSalary, annualSalary)) &&
            (identical(other.hireDate, hireDate) ||
                const DeepCollectionEquality()
                    .equals(other.hireDate, hireDate)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(annualSalary) ^
      const DeepCollectionEquality().hash(hireDate) ^
      runtimeType.hashCode;
}

extension $EmploymentDetailsExtension on EmploymentDetails {
  EmploymentDetails copyWith({Pay? annualSalary, DateTime? hireDate}) {
    return EmploymentDetails(
        annualSalary: annualSalary ?? this.annualSalary,
        hireDate: hireDate ?? this.hireDate);
  }
}

@JsonSerializable(explicitToJson: true)
class NetPay {
  NetPay({
    this.currentAmount,
    this.description,
    this.isoCurrencyCode,
    this.unofficialCurrencyCode,
    this.ytdAmount,
    this.total,
  });

  factory NetPay.fromJson(Map<String, dynamic> json) => _$NetPayFromJson(json);

  @JsonKey(name: 'current_amount')
  final double? currentAmount;
  @JsonKey(name: 'description')
  final String? description;
  @JsonKey(name: 'iso_currency_code')
  final String? isoCurrencyCode;
  @JsonKey(name: 'unofficial_currency_code')
  final String? unofficialCurrencyCode;
  @JsonKey(name: 'ytd_amount')
  final double? ytdAmount;
  @JsonKey(name: 'total')
  final Total? total;
  static const fromJsonFactory = _$NetPayFromJson;
  static const toJsonFactory = _$NetPayToJson;
  Map<String, dynamic> toJson() => _$NetPayToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is NetPay &&
            (identical(other.currentAmount, currentAmount) ||
                const DeepCollectionEquality()
                    .equals(other.currentAmount, currentAmount)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)) &&
            (identical(other.unofficialCurrencyCode, unofficialCurrencyCode) ||
                const DeepCollectionEquality().equals(
                    other.unofficialCurrencyCode, unofficialCurrencyCode)) &&
            (identical(other.ytdAmount, ytdAmount) ||
                const DeepCollectionEquality()
                    .equals(other.ytdAmount, ytdAmount)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(currentAmount) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      const DeepCollectionEquality().hash(unofficialCurrencyCode) ^
      const DeepCollectionEquality().hash(ytdAmount) ^
      const DeepCollectionEquality().hash(total) ^
      runtimeType.hashCode;
}

extension $NetPayExtension on NetPay {
  NetPay copyWith(
      {double? currentAmount,
      String? description,
      String? isoCurrencyCode,
      String? unofficialCurrencyCode,
      double? ytdAmount,
      Total? total}) {
    return NetPay(
        currentAmount: currentAmount ?? this.currentAmount,
        description: description ?? this.description,
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode,
        unofficialCurrencyCode:
            unofficialCurrencyCode ?? this.unofficialCurrencyCode,
        ytdAmount: ytdAmount ?? this.ytdAmount,
        total: total ?? this.total);
  }
}

@JsonSerializable(explicitToJson: true)
class PaystubDetails {
  PaystubDetails({
    this.payPeriodStartDate,
    this.payPeriodEndDate,
    this.payDate,
    this.paystubProvider,
    this.payFrequency,
  });

  factory PaystubDetails.fromJson(Map<String, dynamic> json) =>
      _$PaystubDetailsFromJson(json);

  @JsonKey(name: 'pay_period_start_date', toJson: _dateToJson)
  final DateTime? payPeriodStartDate;
  @JsonKey(name: 'pay_period_end_date', toJson: _dateToJson)
  final DateTime? payPeriodEndDate;
  @JsonKey(name: 'pay_date', toJson: _dateToJson)
  final DateTime? payDate;
  @JsonKey(name: 'paystub_provider')
  final String? paystubProvider;
  @JsonKey(
      name: 'pay_frequency',
      toJson: paystubPayFrequencyToJson,
      fromJson: paystubPayFrequencyFromJson)
  final enums.PaystubPayFrequency? payFrequency;
  static const fromJsonFactory = _$PaystubDetailsFromJson;
  static const toJsonFactory = _$PaystubDetailsToJson;
  Map<String, dynamic> toJson() => _$PaystubDetailsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaystubDetails &&
            (identical(other.payPeriodStartDate, payPeriodStartDate) ||
                const DeepCollectionEquality()
                    .equals(other.payPeriodStartDate, payPeriodStartDate)) &&
            (identical(other.payPeriodEndDate, payPeriodEndDate) ||
                const DeepCollectionEquality()
                    .equals(other.payPeriodEndDate, payPeriodEndDate)) &&
            (identical(other.payDate, payDate) ||
                const DeepCollectionEquality()
                    .equals(other.payDate, payDate)) &&
            (identical(other.paystubProvider, paystubProvider) ||
                const DeepCollectionEquality()
                    .equals(other.paystubProvider, paystubProvider)) &&
            (identical(other.payFrequency, payFrequency) ||
                const DeepCollectionEquality()
                    .equals(other.payFrequency, payFrequency)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(payPeriodStartDate) ^
      const DeepCollectionEquality().hash(payPeriodEndDate) ^
      const DeepCollectionEquality().hash(payDate) ^
      const DeepCollectionEquality().hash(paystubProvider) ^
      const DeepCollectionEquality().hash(payFrequency) ^
      runtimeType.hashCode;
}

extension $PaystubDetailsExtension on PaystubDetails {
  PaystubDetails copyWith(
      {DateTime? payPeriodStartDate,
      DateTime? payPeriodEndDate,
      DateTime? payDate,
      String? paystubProvider,
      enums.PaystubPayFrequency? payFrequency}) {
    return PaystubDetails(
        payPeriodStartDate: payPeriodStartDate ?? this.payPeriodStartDate,
        payPeriodEndDate: payPeriodEndDate ?? this.payPeriodEndDate,
        payDate: payDate ?? this.payDate,
        paystubProvider: paystubProvider ?? this.paystubProvider,
        payFrequency: payFrequency ?? this.payFrequency);
  }
}

@JsonSerializable(explicitToJson: true)
class IncomeBreakdown {
  IncomeBreakdown({
    this.type,
    this.rate,
    this.hours,
    this.total,
  });

  factory IncomeBreakdown.fromJson(Map<String, dynamic> json) =>
      _$IncomeBreakdownFromJson(json);

  @JsonKey(
      name: 'type',
      toJson: incomeBreakdownTypeToJson,
      fromJson: incomeBreakdownTypeFromJson)
  final enums.IncomeBreakdownType? type;
  @JsonKey(name: 'rate')
  final double? rate;
  @JsonKey(name: 'hours')
  final double? hours;
  @JsonKey(name: 'total')
  final double? total;
  static const fromJsonFactory = _$IncomeBreakdownFromJson;
  static const toJsonFactory = _$IncomeBreakdownToJson;
  Map<String, dynamic> toJson() => _$IncomeBreakdownToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IncomeBreakdown &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.rate, rate) ||
                const DeepCollectionEquality().equals(other.rate, rate)) &&
            (identical(other.hours, hours) ||
                const DeepCollectionEquality().equals(other.hours, hours)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(rate) ^
      const DeepCollectionEquality().hash(hours) ^
      const DeepCollectionEquality().hash(total) ^
      runtimeType.hashCode;
}

extension $IncomeBreakdownExtension on IncomeBreakdown {
  IncomeBreakdown copyWith(
      {enums.IncomeBreakdownType? type,
      double? rate,
      double? hours,
      double? total}) {
    return IncomeBreakdown(
        type: type ?? this.type,
        rate: rate ?? this.rate,
        hours: hours ?? this.hours,
        total: total ?? this.total);
  }
}

@JsonSerializable(explicitToJson: true)
class Employee {
  Employee({
    this.address,
    this.name,
    this.maritalStatus,
    this.taxpayerId,
  });

  factory Employee.fromJson(Map<String, dynamic> json) =>
      _$EmployeeFromJson(json);

  @JsonKey(name: 'address')
  final PaystubAddress? address;
  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'marital_status')
  final String? maritalStatus;
  @JsonKey(name: 'taxpayer_id')
  final TaxpayerID? taxpayerId;
  static const fromJsonFactory = _$EmployeeFromJson;
  static const toJsonFactory = _$EmployeeToJson;
  Map<String, dynamic> toJson() => _$EmployeeToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Employee &&
            (identical(other.address, address) ||
                const DeepCollectionEquality()
                    .equals(other.address, address)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.maritalStatus, maritalStatus) ||
                const DeepCollectionEquality()
                    .equals(other.maritalStatus, maritalStatus)) &&
            (identical(other.taxpayerId, taxpayerId) ||
                const DeepCollectionEquality()
                    .equals(other.taxpayerId, taxpayerId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(maritalStatus) ^
      const DeepCollectionEquality().hash(taxpayerId) ^
      runtimeType.hashCode;
}

extension $EmployeeExtension on Employee {
  Employee copyWith(
      {PaystubAddress? address,
      String? name,
      String? maritalStatus,
      TaxpayerID? taxpayerId}) {
    return Employee(
        address: address ?? this.address,
        name: name ?? this.name,
        maritalStatus: maritalStatus ?? this.maritalStatus,
        taxpayerId: taxpayerId ?? this.taxpayerId);
  }
}

@JsonSerializable(explicitToJson: true)
class TaxpayerID {
  TaxpayerID({
    this.idType,
    this.idMask,
    this.last4Digits,
  });

  factory TaxpayerID.fromJson(Map<String, dynamic> json) =>
      _$TaxpayerIDFromJson(json);

  @JsonKey(name: 'id_type')
  final String? idType;
  @JsonKey(name: 'id_mask')
  final String? idMask;
  @JsonKey(name: 'last_4_digits')
  final String? last4Digits;
  static const fromJsonFactory = _$TaxpayerIDFromJson;
  static const toJsonFactory = _$TaxpayerIDToJson;
  Map<String, dynamic> toJson() => _$TaxpayerIDToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TaxpayerID &&
            (identical(other.idType, idType) ||
                const DeepCollectionEquality().equals(other.idType, idType)) &&
            (identical(other.idMask, idMask) ||
                const DeepCollectionEquality().equals(other.idMask, idMask)) &&
            (identical(other.last4Digits, last4Digits) ||
                const DeepCollectionEquality()
                    .equals(other.last4Digits, last4Digits)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(idType) ^
      const DeepCollectionEquality().hash(idMask) ^
      const DeepCollectionEquality().hash(last4Digits) ^
      runtimeType.hashCode;
}

extension $TaxpayerIDExtension on TaxpayerID {
  TaxpayerID copyWith({String? idType, String? idMask, String? last4Digits}) {
    return TaxpayerID(
        idType: idType ?? this.idType,
        idMask: idMask ?? this.idMask,
        last4Digits: last4Digits ?? this.last4Digits);
  }
}

@JsonSerializable(explicitToJson: true)
class PaystubEmployer {
  PaystubEmployer({
    this.address,
    this.name,
  });

  factory PaystubEmployer.fromJson(Map<String, dynamic> json) =>
      _$PaystubEmployerFromJson(json);

  @JsonKey(name: 'address')
  final PaystubAddress? address;
  @JsonKey(name: 'name')
  final String? name;
  static const fromJsonFactory = _$PaystubEmployerFromJson;
  static const toJsonFactory = _$PaystubEmployerToJson;
  Map<String, dynamic> toJson() => _$PaystubEmployerToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaystubEmployer &&
            (identical(other.address, address) ||
                const DeepCollectionEquality()
                    .equals(other.address, address)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(name) ^
      runtimeType.hashCode;
}

extension $PaystubEmployerExtension on PaystubEmployer {
  PaystubEmployer copyWith({PaystubAddress? address, String? name}) {
    return PaystubEmployer(
        address: address ?? this.address, name: name ?? this.name);
  }
}

@JsonSerializable(explicitToJson: true)
class PaystubAddress {
  PaystubAddress({
    this.city,
    this.country,
    this.postalCode,
    this.region,
    this.street,
    this.line1,
    this.line2,
    this.stateCode,
  });

  factory PaystubAddress.fromJson(Map<String, dynamic> json) =>
      _$PaystubAddressFromJson(json);

  @JsonKey(name: 'city')
  final String? city;
  @JsonKey(name: 'country')
  final String? country;
  @JsonKey(name: 'postal_code')
  final String? postalCode;
  @JsonKey(name: 'region')
  final String? region;
  @JsonKey(name: 'street')
  final String? street;
  @JsonKey(name: 'line1')
  final String? line1;
  @JsonKey(name: 'line2')
  final String? line2;
  @JsonKey(name: 'state_code')
  final String? stateCode;
  static const fromJsonFactory = _$PaystubAddressFromJson;
  static const toJsonFactory = _$PaystubAddressToJson;
  Map<String, dynamic> toJson() => _$PaystubAddressToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaystubAddress &&
            (identical(other.city, city) ||
                const DeepCollectionEquality().equals(other.city, city)) &&
            (identical(other.country, country) ||
                const DeepCollectionEquality()
                    .equals(other.country, country)) &&
            (identical(other.postalCode, postalCode) ||
                const DeepCollectionEquality()
                    .equals(other.postalCode, postalCode)) &&
            (identical(other.region, region) ||
                const DeepCollectionEquality().equals(other.region, region)) &&
            (identical(other.street, street) ||
                const DeepCollectionEquality().equals(other.street, street)) &&
            (identical(other.line1, line1) ||
                const DeepCollectionEquality().equals(other.line1, line1)) &&
            (identical(other.line2, line2) ||
                const DeepCollectionEquality().equals(other.line2, line2)) &&
            (identical(other.stateCode, stateCode) ||
                const DeepCollectionEquality()
                    .equals(other.stateCode, stateCode)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(city) ^
      const DeepCollectionEquality().hash(country) ^
      const DeepCollectionEquality().hash(postalCode) ^
      const DeepCollectionEquality().hash(region) ^
      const DeepCollectionEquality().hash(street) ^
      const DeepCollectionEquality().hash(line1) ^
      const DeepCollectionEquality().hash(line2) ^
      const DeepCollectionEquality().hash(stateCode) ^
      runtimeType.hashCode;
}

extension $PaystubAddressExtension on PaystubAddress {
  PaystubAddress copyWith(
      {String? city,
      String? country,
      String? postalCode,
      String? region,
      String? street,
      String? line1,
      String? line2,
      String? stateCode}) {
    return PaystubAddress(
        city: city ?? this.city,
        country: country ?? this.country,
        postalCode: postalCode ?? this.postalCode,
        region: region ?? this.region,
        street: street ?? this.street,
        line1: line1 ?? this.line1,
        line2: line2 ?? this.line2,
        stateCode: stateCode ?? this.stateCode);
  }
}

@JsonSerializable(explicitToJson: true)
class PayPeriodDetails {
  PayPeriodDetails({
    this.checkAmount,
    this.distributionBreakdown,
    this.endDate,
    this.grossEarnings,
    this.payDate,
    this.payFrequency,
    this.payDay,
    this.startDate,
  });

  factory PayPeriodDetails.fromJson(Map<String, dynamic> json) =>
      _$PayPeriodDetailsFromJson(json);

  @JsonKey(name: 'check_amount')
  final double? checkAmount;
  @JsonKey(
      name: 'distribution_breakdown', defaultValue: <DistributionBreakdown>[])
  final List<DistributionBreakdown>? distributionBreakdown;
  @JsonKey(name: 'end_date', toJson: _dateToJson)
  final DateTime? endDate;
  @JsonKey(name: 'gross_earnings')
  final double? grossEarnings;
  @JsonKey(name: 'pay_date', toJson: _dateToJson)
  final DateTime? payDate;
  @JsonKey(
      name: 'pay_frequency',
      toJson: payPeriodDetailsPayFrequencyToJson,
      fromJson: payPeriodDetailsPayFrequencyFromJson)
  final enums.PayPeriodDetailsPayFrequency? payFrequency;
  @JsonKey(name: 'pay_day', toJson: _dateToJson)
  final DateTime? payDay;
  @JsonKey(name: 'start_date', toJson: _dateToJson)
  final DateTime? startDate;
  static const fromJsonFactory = _$PayPeriodDetailsFromJson;
  static const toJsonFactory = _$PayPeriodDetailsToJson;
  Map<String, dynamic> toJson() => _$PayPeriodDetailsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PayPeriodDetails &&
            (identical(other.checkAmount, checkAmount) ||
                const DeepCollectionEquality()
                    .equals(other.checkAmount, checkAmount)) &&
            (identical(other.distributionBreakdown, distributionBreakdown) ||
                const DeepCollectionEquality().equals(
                    other.distributionBreakdown, distributionBreakdown)) &&
            (identical(other.endDate, endDate) ||
                const DeepCollectionEquality()
                    .equals(other.endDate, endDate)) &&
            (identical(other.grossEarnings, grossEarnings) ||
                const DeepCollectionEquality()
                    .equals(other.grossEarnings, grossEarnings)) &&
            (identical(other.payDate, payDate) ||
                const DeepCollectionEquality()
                    .equals(other.payDate, payDate)) &&
            (identical(other.payFrequency, payFrequency) ||
                const DeepCollectionEquality()
                    .equals(other.payFrequency, payFrequency)) &&
            (identical(other.payDay, payDay) ||
                const DeepCollectionEquality().equals(other.payDay, payDay)) &&
            (identical(other.startDate, startDate) ||
                const DeepCollectionEquality()
                    .equals(other.startDate, startDate)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(checkAmount) ^
      const DeepCollectionEquality().hash(distributionBreakdown) ^
      const DeepCollectionEquality().hash(endDate) ^
      const DeepCollectionEquality().hash(grossEarnings) ^
      const DeepCollectionEquality().hash(payDate) ^
      const DeepCollectionEquality().hash(payFrequency) ^
      const DeepCollectionEquality().hash(payDay) ^
      const DeepCollectionEquality().hash(startDate) ^
      runtimeType.hashCode;
}

extension $PayPeriodDetailsExtension on PayPeriodDetails {
  PayPeriodDetails copyWith(
      {double? checkAmount,
      List<DistributionBreakdown>? distributionBreakdown,
      DateTime? endDate,
      double? grossEarnings,
      DateTime? payDate,
      enums.PayPeriodDetailsPayFrequency? payFrequency,
      DateTime? payDay,
      DateTime? startDate}) {
    return PayPeriodDetails(
        checkAmount: checkAmount ?? this.checkAmount,
        distributionBreakdown:
            distributionBreakdown ?? this.distributionBreakdown,
        endDate: endDate ?? this.endDate,
        grossEarnings: grossEarnings ?? this.grossEarnings,
        payDate: payDate ?? this.payDate,
        payFrequency: payFrequency ?? this.payFrequency,
        payDay: payDay ?? this.payDay,
        startDate: startDate ?? this.startDate);
  }
}

@JsonSerializable(explicitToJson: true)
class DistributionBreakdown {
  DistributionBreakdown({
    this.accountName,
    this.bankName,
    this.currentAmount,
    this.isoCurrencyCode,
    this.mask,
    this.type,
    this.unofficialCurrencyCode,
    this.currentPay,
  });

  factory DistributionBreakdown.fromJson(Map<String, dynamic> json) =>
      _$DistributionBreakdownFromJson(json);

  @JsonKey(name: 'account_name')
  final String? accountName;
  @JsonKey(name: 'bank_name')
  final String? bankName;
  @JsonKey(name: 'current_amount')
  final double? currentAmount;
  @JsonKey(name: 'iso_currency_code')
  final String? isoCurrencyCode;
  @JsonKey(name: 'mask')
  final String? mask;
  @JsonKey(name: 'type')
  final String? type;
  @JsonKey(name: 'unofficial_currency_code')
  final String? unofficialCurrencyCode;
  @JsonKey(name: 'current_pay')
  final Pay? currentPay;
  static const fromJsonFactory = _$DistributionBreakdownFromJson;
  static const toJsonFactory = _$DistributionBreakdownToJson;
  Map<String, dynamic> toJson() => _$DistributionBreakdownToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is DistributionBreakdown &&
            (identical(other.accountName, accountName) ||
                const DeepCollectionEquality()
                    .equals(other.accountName, accountName)) &&
            (identical(other.bankName, bankName) ||
                const DeepCollectionEquality()
                    .equals(other.bankName, bankName)) &&
            (identical(other.currentAmount, currentAmount) ||
                const DeepCollectionEquality()
                    .equals(other.currentAmount, currentAmount)) &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)) &&
            (identical(other.mask, mask) ||
                const DeepCollectionEquality().equals(other.mask, mask)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.unofficialCurrencyCode, unofficialCurrencyCode) ||
                const DeepCollectionEquality().equals(
                    other.unofficialCurrencyCode, unofficialCurrencyCode)) &&
            (identical(other.currentPay, currentPay) ||
                const DeepCollectionEquality()
                    .equals(other.currentPay, currentPay)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountName) ^
      const DeepCollectionEquality().hash(bankName) ^
      const DeepCollectionEquality().hash(currentAmount) ^
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      const DeepCollectionEquality().hash(mask) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(unofficialCurrencyCode) ^
      const DeepCollectionEquality().hash(currentPay) ^
      runtimeType.hashCode;
}

extension $DistributionBreakdownExtension on DistributionBreakdown {
  DistributionBreakdown copyWith(
      {String? accountName,
      String? bankName,
      double? currentAmount,
      String? isoCurrencyCode,
      String? mask,
      String? type,
      String? unofficialCurrencyCode,
      Pay? currentPay}) {
    return DistributionBreakdown(
        accountName: accountName ?? this.accountName,
        bankName: bankName ?? this.bankName,
        currentAmount: currentAmount ?? this.currentAmount,
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode,
        mask: mask ?? this.mask,
        type: type ?? this.type,
        unofficialCurrencyCode:
            unofficialCurrencyCode ?? this.unofficialCurrencyCode,
        currentPay: currentPay ?? this.currentPay);
  }
}

@JsonSerializable(explicitToJson: true)
class PaystubDeduction {
  PaystubDeduction({
    this.type,
    this.isPretax,
    this.total,
  });

  factory PaystubDeduction.fromJson(Map<String, dynamic> json) =>
      _$PaystubDeductionFromJson(json);

  @JsonKey(name: 'type')
  final String? type;
  @JsonKey(name: 'is_pretax')
  final bool? isPretax;
  @JsonKey(name: 'total')
  final double? total;
  static const fromJsonFactory = _$PaystubDeductionFromJson;
  static const toJsonFactory = _$PaystubDeductionToJson;
  Map<String, dynamic> toJson() => _$PaystubDeductionToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaystubDeduction &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.isPretax, isPretax) ||
                const DeepCollectionEquality()
                    .equals(other.isPretax, isPretax)) &&
            (identical(other.total, total) ||
                const DeepCollectionEquality().equals(other.total, total)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(isPretax) ^
      const DeepCollectionEquality().hash(total) ^
      runtimeType.hashCode;
}

extension $PaystubDeductionExtension on PaystubDeduction {
  PaystubDeduction copyWith({String? type, bool? isPretax, double? total}) {
    return PaystubDeduction(
        type: type ?? this.type,
        isPretax: isPretax ?? this.isPretax,
        total: total ?? this.total);
  }
}

@JsonSerializable(explicitToJson: true)
class PaystubYTDDetails {
  PaystubYTDDetails({
    this.grossEarnings,
    this.netEarnings,
  });

  factory PaystubYTDDetails.fromJson(Map<String, dynamic> json) =>
      _$PaystubYTDDetailsFromJson(json);

  @JsonKey(name: 'gross_earnings')
  final double? grossEarnings;
  @JsonKey(name: 'net_earnings')
  final double? netEarnings;
  static const fromJsonFactory = _$PaystubYTDDetailsFromJson;
  static const toJsonFactory = _$PaystubYTDDetailsToJson;
  Map<String, dynamic> toJson() => _$PaystubYTDDetailsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaystubYTDDetails &&
            (identical(other.grossEarnings, grossEarnings) ||
                const DeepCollectionEquality()
                    .equals(other.grossEarnings, grossEarnings)) &&
            (identical(other.netEarnings, netEarnings) ||
                const DeepCollectionEquality()
                    .equals(other.netEarnings, netEarnings)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(grossEarnings) ^
      const DeepCollectionEquality().hash(netEarnings) ^
      runtimeType.hashCode;
}

extension $PaystubYTDDetailsExtension on PaystubYTDDetails {
  PaystubYTDDetails copyWith({double? grossEarnings, double? netEarnings}) {
    return PaystubYTDDetails(
        grossEarnings: grossEarnings ?? this.grossEarnings,
        netEarnings: netEarnings ?? this.netEarnings);
  }
}

@JsonSerializable(explicitToJson: true)
class PaystubVerification {
  PaystubVerification({
    this.verificationStatus,
    this.verificationAttributes,
  });

  factory PaystubVerification.fromJson(Map<String, dynamic> json) =>
      _$PaystubVerificationFromJson(json);

  @JsonKey(
      name: 'verification_status',
      toJson: paystubVerificationStatusToJson,
      fromJson: paystubVerificationStatusFromJson)
  final enums.PaystubVerificationStatus? verificationStatus;
  @JsonKey(
      name: 'verification_attributes', defaultValue: <VerificationAttribute>[])
  final List<VerificationAttribute>? verificationAttributes;
  static const fromJsonFactory = _$PaystubVerificationFromJson;
  static const toJsonFactory = _$PaystubVerificationToJson;
  Map<String, dynamic> toJson() => _$PaystubVerificationToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaystubVerification &&
            (identical(other.verificationStatus, verificationStatus) ||
                const DeepCollectionEquality()
                    .equals(other.verificationStatus, verificationStatus)) &&
            (identical(other.verificationAttributes, verificationAttributes) ||
                const DeepCollectionEquality().equals(
                    other.verificationAttributes, verificationAttributes)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(verificationStatus) ^
      const DeepCollectionEquality().hash(verificationAttributes) ^
      runtimeType.hashCode;
}

extension $PaystubVerificationExtension on PaystubVerification {
  PaystubVerification copyWith(
      {enums.PaystubVerificationStatus? verificationStatus,
      List<VerificationAttribute>? verificationAttributes}) {
    return PaystubVerification(
        verificationStatus: verificationStatus ?? this.verificationStatus,
        verificationAttributes:
            verificationAttributes ?? this.verificationAttributes);
  }
}

@JsonSerializable(explicitToJson: true)
class VerificationAttribute {
  VerificationAttribute({
    this.type,
  });

  factory VerificationAttribute.fromJson(Map<String, dynamic> json) =>
      _$VerificationAttributeFromJson(json);

  @JsonKey(
      name: 'type',
      toJson: verificationAttributeType$ToJson,
      fromJson: verificationAttributeType$FromJson)
  final enums.VerificationAttributeType$? type;
  static const fromJsonFactory = _$VerificationAttributeFromJson;
  static const toJsonFactory = _$VerificationAttributeToJson;
  Map<String, dynamic> toJson() => _$VerificationAttributeToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is VerificationAttribute &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^ runtimeType.hashCode;
}

extension $VerificationAttributeExtension on VerificationAttribute {
  VerificationAttribute copyWith({enums.VerificationAttributeType$? type}) {
    return VerificationAttribute(type: type ?? this.type);
  }
}

@JsonSerializable(explicitToJson: true)
class IncomeVerificationDocumentsDownloadRequest {
  IncomeVerificationDocumentsDownloadRequest({
    this.clientId,
    this.secret,
    this.incomeVerificationId,
    this.accessToken,
    this.documentId,
  });

  factory IncomeVerificationDocumentsDownloadRequest.fromJson(
          Map<String, dynamic> json) =>
      _$IncomeVerificationDocumentsDownloadRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'income_verification_id')
  final String? incomeVerificationId;
  @JsonKey(name: 'access_token')
  final String? accessToken;
  @JsonKey(name: 'document_id')
  final String? documentId;
  static const fromJsonFactory =
      _$IncomeVerificationDocumentsDownloadRequestFromJson;
  static const toJsonFactory =
      _$IncomeVerificationDocumentsDownloadRequestToJson;
  Map<String, dynamic> toJson() =>
      _$IncomeVerificationDocumentsDownloadRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IncomeVerificationDocumentsDownloadRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.incomeVerificationId, incomeVerificationId) ||
                const DeepCollectionEquality().equals(
                    other.incomeVerificationId, incomeVerificationId)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)) &&
            (identical(other.documentId, documentId) ||
                const DeepCollectionEquality()
                    .equals(other.documentId, documentId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(incomeVerificationId) ^
      const DeepCollectionEquality().hash(accessToken) ^
      const DeepCollectionEquality().hash(documentId) ^
      runtimeType.hashCode;
}

extension $IncomeVerificationDocumentsDownloadRequestExtension
    on IncomeVerificationDocumentsDownloadRequest {
  IncomeVerificationDocumentsDownloadRequest copyWith(
      {String? clientId,
      String? secret,
      String? incomeVerificationId,
      String? accessToken,
      String? documentId}) {
    return IncomeVerificationDocumentsDownloadRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        incomeVerificationId: incomeVerificationId ?? this.incomeVerificationId,
        accessToken: accessToken ?? this.accessToken,
        documentId: documentId ?? this.documentId);
  }
}

@JsonSerializable(explicitToJson: true)
class IncomeVerificationTaxformsGetRequest {
  IncomeVerificationTaxformsGetRequest({
    this.clientId,
    this.secret,
    this.incomeVerificationId,
    this.accessToken,
  });

  factory IncomeVerificationTaxformsGetRequest.fromJson(
          Map<String, dynamic> json) =>
      _$IncomeVerificationTaxformsGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'income_verification_id')
  final String? incomeVerificationId;
  @JsonKey(name: 'access_token')
  final String? accessToken;
  static const fromJsonFactory = _$IncomeVerificationTaxformsGetRequestFromJson;
  static const toJsonFactory = _$IncomeVerificationTaxformsGetRequestToJson;
  Map<String, dynamic> toJson() =>
      _$IncomeVerificationTaxformsGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IncomeVerificationTaxformsGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.incomeVerificationId, incomeVerificationId) ||
                const DeepCollectionEquality().equals(
                    other.incomeVerificationId, incomeVerificationId)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(incomeVerificationId) ^
      const DeepCollectionEquality().hash(accessToken) ^
      runtimeType.hashCode;
}

extension $IncomeVerificationTaxformsGetRequestExtension
    on IncomeVerificationTaxformsGetRequest {
  IncomeVerificationTaxformsGetRequest copyWith(
      {String? clientId,
      String? secret,
      String? incomeVerificationId,
      String? accessToken}) {
    return IncomeVerificationTaxformsGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        incomeVerificationId: incomeVerificationId ?? this.incomeVerificationId,
        accessToken: accessToken ?? this.accessToken);
  }
}

@JsonSerializable(explicitToJson: true)
class IncomeVerificationTaxformsGetResponse {
  IncomeVerificationTaxformsGetResponse({
    this.requestId,
    this.documentMetadata,
    this.taxforms,
    this.error,
  });

  factory IncomeVerificationTaxformsGetResponse.fromJson(
          Map<String, dynamic> json) =>
      _$IncomeVerificationTaxformsGetResponseFromJson(json);

  @JsonKey(name: 'request_id')
  final String? requestId;
  @JsonKey(name: 'document_metadata', defaultValue: <DocumentMetadata>[])
  final List<DocumentMetadata>? documentMetadata;
  @JsonKey(name: 'taxforms', defaultValue: <Taxform>[])
  final List<Taxform>? taxforms;
  @JsonKey(name: 'error')
  final Error? error;
  static const fromJsonFactory =
      _$IncomeVerificationTaxformsGetResponseFromJson;
  static const toJsonFactory = _$IncomeVerificationTaxformsGetResponseToJson;
  Map<String, dynamic> toJson() =>
      _$IncomeVerificationTaxformsGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IncomeVerificationTaxformsGetResponse &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)) &&
            (identical(other.documentMetadata, documentMetadata) ||
                const DeepCollectionEquality()
                    .equals(other.documentMetadata, documentMetadata)) &&
            (identical(other.taxforms, taxforms) ||
                const DeepCollectionEquality()
                    .equals(other.taxforms, taxforms)) &&
            (identical(other.error, error) ||
                const DeepCollectionEquality().equals(other.error, error)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(requestId) ^
      const DeepCollectionEquality().hash(documentMetadata) ^
      const DeepCollectionEquality().hash(taxforms) ^
      const DeepCollectionEquality().hash(error) ^
      runtimeType.hashCode;
}

extension $IncomeVerificationTaxformsGetResponseExtension
    on IncomeVerificationTaxformsGetResponse {
  IncomeVerificationTaxformsGetResponse copyWith(
      {String? requestId,
      List<DocumentMetadata>? documentMetadata,
      List<Taxform>? taxforms,
      Error? error}) {
    return IncomeVerificationTaxformsGetResponse(
        requestId: requestId ?? this.requestId,
        documentMetadata: documentMetadata ?? this.documentMetadata,
        taxforms: taxforms ?? this.taxforms,
        error: error ?? this.error);
  }
}

@JsonSerializable(explicitToJson: true)
class Taxform {
  Taxform({
    this.docId,
    this.documentType,
    this.w2,
  });

  factory Taxform.fromJson(Map<String, dynamic> json) =>
      _$TaxformFromJson(json);

  @JsonKey(name: 'doc_id')
  final String? docId;
  @JsonKey(name: 'document_type')
  final String? documentType;
  @JsonKey(name: 'w2')
  final W2? w2;
  static const fromJsonFactory = _$TaxformFromJson;
  static const toJsonFactory = _$TaxformToJson;
  Map<String, dynamic> toJson() => _$TaxformToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Taxform &&
            (identical(other.docId, docId) ||
                const DeepCollectionEquality().equals(other.docId, docId)) &&
            (identical(other.documentType, documentType) ||
                const DeepCollectionEquality()
                    .equals(other.documentType, documentType)) &&
            (identical(other.w2, w2) ||
                const DeepCollectionEquality().equals(other.w2, w2)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(docId) ^
      const DeepCollectionEquality().hash(documentType) ^
      const DeepCollectionEquality().hash(w2) ^
      runtimeType.hashCode;
}

extension $TaxformExtension on Taxform {
  Taxform copyWith({String? docId, String? documentType, W2? w2}) {
    return Taxform(
        docId: docId ?? this.docId,
        documentType: documentType ?? this.documentType,
        w2: w2 ?? this.w2);
  }
}

@JsonSerializable(explicitToJson: true)
class W2 {
  W2({
    this.employer,
    this.employee,
    this.taxYear,
    this.employerIdNumber,
    this.wagesTipsOtherComp,
    this.federalIncomeTaxWithheld,
    this.socialSecurityWages,
    this.socialSecurityTaxWithheld,
    this.medicareWagesAndTips,
    this.medicareTaxWithheld,
    this.socialSecurityTips,
    this.allocatedTips,
    this.box9,
    this.dependentCareBenefits,
    this.nonqualifiedPlans,
    this.box12,
    this.statutoryEmployee,
    this.retirementPlan,
    this.thirdPartySickPay,
    this.other,
    this.stateAndLocalWages,
  });

  factory W2.fromJson(Map<String, dynamic> json) => _$W2FromJson(json);

  @JsonKey(name: 'employer')
  final PaystubEmployer? employer;
  @JsonKey(name: 'employee')
  final Employee? employee;
  @JsonKey(name: 'tax_year')
  final String? taxYear;
  @JsonKey(name: 'employer_id_number')
  final String? employerIdNumber;
  @JsonKey(name: 'wages_tips_other_comp')
  final String? wagesTipsOtherComp;
  @JsonKey(name: 'federal_income_tax_withheld')
  final String? federalIncomeTaxWithheld;
  @JsonKey(name: 'social_security_wages')
  final String? socialSecurityWages;
  @JsonKey(name: 'social_security_tax_withheld')
  final String? socialSecurityTaxWithheld;
  @JsonKey(name: 'medicare_wages_and_tips')
  final String? medicareWagesAndTips;
  @JsonKey(name: 'medicare_tax_withheld')
  final String? medicareTaxWithheld;
  @JsonKey(name: 'social_security_tips')
  final String? socialSecurityTips;
  @JsonKey(name: 'allocated_tips')
  final String? allocatedTips;
  @JsonKey(name: 'box_9')
  final String? box9;
  @JsonKey(name: 'dependent_care_benefits')
  final String? dependentCareBenefits;
  @JsonKey(name: 'nonqualified_plans')
  final String? nonqualifiedPlans;
  @JsonKey(name: 'box_12', defaultValue: <W2Box12>[])
  final List<W2Box12>? box12;
  @JsonKey(name: 'statutory_employee')
  final String? statutoryEmployee;
  @JsonKey(name: 'retirement_plan')
  final String? retirementPlan;
  @JsonKey(name: 'third_party_sick_pay')
  final String? thirdPartySickPay;
  @JsonKey(name: 'other')
  final String? other;
  @JsonKey(
      name: 'state_and_local_wages', defaultValue: <W2StateAndLocalWages>[])
  final List<W2StateAndLocalWages>? stateAndLocalWages;
  static const fromJsonFactory = _$W2FromJson;
  static const toJsonFactory = _$W2ToJson;
  Map<String, dynamic> toJson() => _$W2ToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is W2 &&
            (identical(other.employer, employer) ||
                const DeepCollectionEquality()
                    .equals(other.employer, employer)) &&
            (identical(other.employee, employee) ||
                const DeepCollectionEquality()
                    .equals(other.employee, employee)) &&
            (identical(other.taxYear, taxYear) ||
                const DeepCollectionEquality()
                    .equals(other.taxYear, taxYear)) &&
            (identical(other.employerIdNumber, employerIdNumber) ||
                const DeepCollectionEquality()
                    .equals(other.employerIdNumber, employerIdNumber)) &&
            (identical(other.wagesTipsOtherComp, wagesTipsOtherComp) ||
                const DeepCollectionEquality()
                    .equals(other.wagesTipsOtherComp, wagesTipsOtherComp)) &&
            (identical(other.federalIncomeTaxWithheld, federalIncomeTaxWithheld) ||
                const DeepCollectionEquality().equals(
                    other.federalIncomeTaxWithheld,
                    federalIncomeTaxWithheld)) &&
            (identical(other.socialSecurityWages, socialSecurityWages) ||
                const DeepCollectionEquality()
                    .equals(other.socialSecurityWages, socialSecurityWages)) &&
            (identical(other.socialSecurityTaxWithheld, socialSecurityTaxWithheld) ||
                const DeepCollectionEquality().equals(
                    other.socialSecurityTaxWithheld,
                    socialSecurityTaxWithheld)) &&
            (identical(other.medicareWagesAndTips, medicareWagesAndTips) ||
                const DeepCollectionEquality().equals(
                    other.medicareWagesAndTips, medicareWagesAndTips)) &&
            (identical(other.medicareTaxWithheld, medicareTaxWithheld) ||
                const DeepCollectionEquality()
                    .equals(other.medicareTaxWithheld, medicareTaxWithheld)) &&
            (identical(other.socialSecurityTips, socialSecurityTips) ||
                const DeepCollectionEquality()
                    .equals(other.socialSecurityTips, socialSecurityTips)) &&
            (identical(other.allocatedTips, allocatedTips) ||
                const DeepCollectionEquality()
                    .equals(other.allocatedTips, allocatedTips)) &&
            (identical(other.box9, box9) ||
                const DeepCollectionEquality().equals(other.box9, box9)) &&
            (identical(other.dependentCareBenefits, dependentCareBenefits) ||
                const DeepCollectionEquality().equals(
                    other.dependentCareBenefits, dependentCareBenefits)) &&
            (identical(other.nonqualifiedPlans, nonqualifiedPlans) ||
                const DeepCollectionEquality()
                    .equals(other.nonqualifiedPlans, nonqualifiedPlans)) &&
            (identical(other.box12, box12) || const DeepCollectionEquality().equals(other.box12, box12)) &&
            (identical(other.statutoryEmployee, statutoryEmployee) || const DeepCollectionEquality().equals(other.statutoryEmployee, statutoryEmployee)) &&
            (identical(other.retirementPlan, retirementPlan) || const DeepCollectionEquality().equals(other.retirementPlan, retirementPlan)) &&
            (identical(other.thirdPartySickPay, thirdPartySickPay) || const DeepCollectionEquality().equals(other.thirdPartySickPay, thirdPartySickPay)) &&
            (identical(other.other, other) || const DeepCollectionEquality().equals(other.other, other)) &&
            (identical(other.stateAndLocalWages, stateAndLocalWages) || const DeepCollectionEquality().equals(other.stateAndLocalWages, stateAndLocalWages)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(employer) ^
      const DeepCollectionEquality().hash(employee) ^
      const DeepCollectionEquality().hash(taxYear) ^
      const DeepCollectionEquality().hash(employerIdNumber) ^
      const DeepCollectionEquality().hash(wagesTipsOtherComp) ^
      const DeepCollectionEquality().hash(federalIncomeTaxWithheld) ^
      const DeepCollectionEquality().hash(socialSecurityWages) ^
      const DeepCollectionEquality().hash(socialSecurityTaxWithheld) ^
      const DeepCollectionEquality().hash(medicareWagesAndTips) ^
      const DeepCollectionEquality().hash(medicareTaxWithheld) ^
      const DeepCollectionEquality().hash(socialSecurityTips) ^
      const DeepCollectionEquality().hash(allocatedTips) ^
      const DeepCollectionEquality().hash(box9) ^
      const DeepCollectionEquality().hash(dependentCareBenefits) ^
      const DeepCollectionEquality().hash(nonqualifiedPlans) ^
      const DeepCollectionEquality().hash(box12) ^
      const DeepCollectionEquality().hash(statutoryEmployee) ^
      const DeepCollectionEquality().hash(retirementPlan) ^
      const DeepCollectionEquality().hash(thirdPartySickPay) ^
      const DeepCollectionEquality().hash(other) ^
      const DeepCollectionEquality().hash(stateAndLocalWages) ^
      runtimeType.hashCode;
}

extension $W2Extension on W2 {
  W2 copyWith(
      {PaystubEmployer? employer,
      Employee? employee,
      String? taxYear,
      String? employerIdNumber,
      String? wagesTipsOtherComp,
      String? federalIncomeTaxWithheld,
      String? socialSecurityWages,
      String? socialSecurityTaxWithheld,
      String? medicareWagesAndTips,
      String? medicareTaxWithheld,
      String? socialSecurityTips,
      String? allocatedTips,
      String? box9,
      String? dependentCareBenefits,
      String? nonqualifiedPlans,
      List<W2Box12>? box12,
      String? statutoryEmployee,
      String? retirementPlan,
      String? thirdPartySickPay,
      String? other,
      List<W2StateAndLocalWages>? stateAndLocalWages}) {
    return W2(
        employer: employer ?? this.employer,
        employee: employee ?? this.employee,
        taxYear: taxYear ?? this.taxYear,
        employerIdNumber: employerIdNumber ?? this.employerIdNumber,
        wagesTipsOtherComp: wagesTipsOtherComp ?? this.wagesTipsOtherComp,
        federalIncomeTaxWithheld:
            federalIncomeTaxWithheld ?? this.federalIncomeTaxWithheld,
        socialSecurityWages: socialSecurityWages ?? this.socialSecurityWages,
        socialSecurityTaxWithheld:
            socialSecurityTaxWithheld ?? this.socialSecurityTaxWithheld,
        medicareWagesAndTips: medicareWagesAndTips ?? this.medicareWagesAndTips,
        medicareTaxWithheld: medicareTaxWithheld ?? this.medicareTaxWithheld,
        socialSecurityTips: socialSecurityTips ?? this.socialSecurityTips,
        allocatedTips: allocatedTips ?? this.allocatedTips,
        box9: box9 ?? this.box9,
        dependentCareBenefits:
            dependentCareBenefits ?? this.dependentCareBenefits,
        nonqualifiedPlans: nonqualifiedPlans ?? this.nonqualifiedPlans,
        box12: box12 ?? this.box12,
        statutoryEmployee: statutoryEmployee ?? this.statutoryEmployee,
        retirementPlan: retirementPlan ?? this.retirementPlan,
        thirdPartySickPay: thirdPartySickPay ?? this.thirdPartySickPay,
        other: other ?? this.other,
        stateAndLocalWages: stateAndLocalWages ?? this.stateAndLocalWages);
  }
}

@JsonSerializable(explicitToJson: true)
class W2Box12 {
  W2Box12({
    this.code,
    this.amount,
  });

  factory W2Box12.fromJson(Map<String, dynamic> json) =>
      _$W2Box12FromJson(json);

  @JsonKey(name: 'code')
  final String? code;
  @JsonKey(name: 'amount')
  final String? amount;
  static const fromJsonFactory = _$W2Box12FromJson;
  static const toJsonFactory = _$W2Box12ToJson;
  Map<String, dynamic> toJson() => _$W2Box12ToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is W2Box12 &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(amount) ^
      runtimeType.hashCode;
}

extension $W2Box12Extension on W2Box12 {
  W2Box12 copyWith({String? code, String? amount}) {
    return W2Box12(code: code ?? this.code, amount: amount ?? this.amount);
  }
}

@JsonSerializable(explicitToJson: true)
class W2StateAndLocalWages {
  W2StateAndLocalWages({
    this.state,
    this.employerStateIdNumber,
    this.stateWagesTips,
    this.stateIncomeTax,
    this.localWagesTips,
    this.localIncomeTax,
    this.localityName,
  });

  factory W2StateAndLocalWages.fromJson(Map<String, dynamic> json) =>
      _$W2StateAndLocalWagesFromJson(json);

  @JsonKey(name: 'state')
  final String? state;
  @JsonKey(name: 'employer_state_id_number')
  final String? employerStateIdNumber;
  @JsonKey(name: 'state_wages_tips')
  final String? stateWagesTips;
  @JsonKey(name: 'state_income_tax')
  final String? stateIncomeTax;
  @JsonKey(name: 'local_wages_tips')
  final String? localWagesTips;
  @JsonKey(name: 'local_income_tax')
  final String? localIncomeTax;
  @JsonKey(name: 'locality_name')
  final String? localityName;
  static const fromJsonFactory = _$W2StateAndLocalWagesFromJson;
  static const toJsonFactory = _$W2StateAndLocalWagesToJson;
  Map<String, dynamic> toJson() => _$W2StateAndLocalWagesToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is W2StateAndLocalWages &&
            (identical(other.state, state) ||
                const DeepCollectionEquality().equals(other.state, state)) &&
            (identical(other.employerStateIdNumber, employerStateIdNumber) ||
                const DeepCollectionEquality().equals(
                    other.employerStateIdNumber, employerStateIdNumber)) &&
            (identical(other.stateWagesTips, stateWagesTips) ||
                const DeepCollectionEquality()
                    .equals(other.stateWagesTips, stateWagesTips)) &&
            (identical(other.stateIncomeTax, stateIncomeTax) ||
                const DeepCollectionEquality()
                    .equals(other.stateIncomeTax, stateIncomeTax)) &&
            (identical(other.localWagesTips, localWagesTips) ||
                const DeepCollectionEquality()
                    .equals(other.localWagesTips, localWagesTips)) &&
            (identical(other.localIncomeTax, localIncomeTax) ||
                const DeepCollectionEquality()
                    .equals(other.localIncomeTax, localIncomeTax)) &&
            (identical(other.localityName, localityName) ||
                const DeepCollectionEquality()
                    .equals(other.localityName, localityName)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(state) ^
      const DeepCollectionEquality().hash(employerStateIdNumber) ^
      const DeepCollectionEquality().hash(stateWagesTips) ^
      const DeepCollectionEquality().hash(stateIncomeTax) ^
      const DeepCollectionEquality().hash(localWagesTips) ^
      const DeepCollectionEquality().hash(localIncomeTax) ^
      const DeepCollectionEquality().hash(localityName) ^
      runtimeType.hashCode;
}

extension $W2StateAndLocalWagesExtension on W2StateAndLocalWages {
  W2StateAndLocalWages copyWith(
      {String? state,
      String? employerStateIdNumber,
      String? stateWagesTips,
      String? stateIncomeTax,
      String? localWagesTips,
      String? localIncomeTax,
      String? localityName}) {
    return W2StateAndLocalWages(
        state: state ?? this.state,
        employerStateIdNumber:
            employerStateIdNumber ?? this.employerStateIdNumber,
        stateWagesTips: stateWagesTips ?? this.stateWagesTips,
        stateIncomeTax: stateIncomeTax ?? this.stateIncomeTax,
        localWagesTips: localWagesTips ?? this.localWagesTips,
        localIncomeTax: localIncomeTax ?? this.localIncomeTax,
        localityName: localityName ?? this.localityName);
  }
}

@JsonSerializable(explicitToJson: true)
class IncomeVerificationWebhookStatus {
  IncomeVerificationWebhookStatus({
    this.id,
  });

  factory IncomeVerificationWebhookStatus.fromJson(Map<String, dynamic> json) =>
      _$IncomeVerificationWebhookStatusFromJson(json);

  @JsonKey(name: 'id')
  final String? id;
  static const fromJsonFactory = _$IncomeVerificationWebhookStatusFromJson;
  static const toJsonFactory = _$IncomeVerificationWebhookStatusToJson;
  Map<String, dynamic> toJson() =>
      _$IncomeVerificationWebhookStatusToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IncomeVerificationWebhookStatus &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^ runtimeType.hashCode;
}

extension $IncomeVerificationWebhookStatusExtension
    on IncomeVerificationWebhookStatus {
  IncomeVerificationWebhookStatus copyWith({String? id}) {
    return IncomeVerificationWebhookStatus(id: id ?? this.id);
  }
}

@JsonSerializable(explicitToJson: true)
class EmploymentVerificationGetRequest {
  EmploymentVerificationGetRequest({
    this.clientId,
    this.secret,
    this.accessToken,
  });

  factory EmploymentVerificationGetRequest.fromJson(
          Map<String, dynamic> json) =>
      _$EmploymentVerificationGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'access_token')
  final String? accessToken;
  static const fromJsonFactory = _$EmploymentVerificationGetRequestFromJson;
  static const toJsonFactory = _$EmploymentVerificationGetRequestToJson;
  Map<String, dynamic> toJson() =>
      _$EmploymentVerificationGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is EmploymentVerificationGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(accessToken) ^
      runtimeType.hashCode;
}

extension $EmploymentVerificationGetRequestExtension
    on EmploymentVerificationGetRequest {
  EmploymentVerificationGetRequest copyWith(
      {String? clientId, String? secret, String? accessToken}) {
    return EmploymentVerificationGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        accessToken: accessToken ?? this.accessToken);
  }
}

@JsonSerializable(explicitToJson: true)
class EmploymentVerificationGetResponse {
  EmploymentVerificationGetResponse({
    this.employments,
    this.error,
    this.requestId,
  });

  factory EmploymentVerificationGetResponse.fromJson(
          Map<String, dynamic> json) =>
      _$EmploymentVerificationGetResponseFromJson(json);

  @JsonKey(name: 'employments', defaultValue: <EmploymentVerification>[])
  final List<EmploymentVerification>? employments;
  @JsonKey(name: 'error')
  final Error? error;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$EmploymentVerificationGetResponseFromJson;
  static const toJsonFactory = _$EmploymentVerificationGetResponseToJson;
  Map<String, dynamic> toJson() =>
      _$EmploymentVerificationGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is EmploymentVerificationGetResponse &&
            (identical(other.employments, employments) ||
                const DeepCollectionEquality()
                    .equals(other.employments, employments)) &&
            (identical(other.error, error) ||
                const DeepCollectionEquality().equals(other.error, error)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(employments) ^
      const DeepCollectionEquality().hash(error) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $EmploymentVerificationGetResponseExtension
    on EmploymentVerificationGetResponse {
  EmploymentVerificationGetResponse copyWith(
      {List<EmploymentVerification>? employments,
      Error? error,
      String? requestId}) {
    return EmploymentVerificationGetResponse(
        employments: employments ?? this.employments,
        error: error ?? this.error,
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class EmploymentVerification {
  EmploymentVerification({
    this.status,
    this.startDate,
    this.endDate,
    this.employer,
    this.title,
    this.platformIds,
  });

  factory EmploymentVerification.fromJson(Map<String, dynamic> json) =>
      _$EmploymentVerificationFromJson(json);

  @JsonKey(
      name: 'status',
      toJson: employmentVerificationStatusToJson,
      fromJson: employmentVerificationStatusFromJson)
  final enums.EmploymentVerificationStatus? status;
  @JsonKey(name: 'start_date', toJson: _dateToJson)
  final DateTime? startDate;
  @JsonKey(name: 'end_date', toJson: _dateToJson)
  final DateTime? endDate;
  @JsonKey(name: 'employer')
  final EmployerVerification? employer;
  @JsonKey(name: 'title')
  final String? title;
  @JsonKey(name: 'platform_ids')
  final PlatformIds? platformIds;
  static const fromJsonFactory = _$EmploymentVerificationFromJson;
  static const toJsonFactory = _$EmploymentVerificationToJson;
  Map<String, dynamic> toJson() => _$EmploymentVerificationToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is EmploymentVerification &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.startDate, startDate) ||
                const DeepCollectionEquality()
                    .equals(other.startDate, startDate)) &&
            (identical(other.endDate, endDate) ||
                const DeepCollectionEquality()
                    .equals(other.endDate, endDate)) &&
            (identical(other.employer, employer) ||
                const DeepCollectionEquality()
                    .equals(other.employer, employer)) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.platformIds, platformIds) ||
                const DeepCollectionEquality()
                    .equals(other.platformIds, platformIds)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(startDate) ^
      const DeepCollectionEquality().hash(endDate) ^
      const DeepCollectionEquality().hash(employer) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(platformIds) ^
      runtimeType.hashCode;
}

extension $EmploymentVerificationExtension on EmploymentVerification {
  EmploymentVerification copyWith(
      {enums.EmploymentVerificationStatus? status,
      DateTime? startDate,
      DateTime? endDate,
      EmployerVerification? employer,
      String? title,
      PlatformIds? platformIds}) {
    return EmploymentVerification(
        status: status ?? this.status,
        startDate: startDate ?? this.startDate,
        endDate: endDate ?? this.endDate,
        employer: employer ?? this.employer,
        title: title ?? this.title,
        platformIds: platformIds ?? this.platformIds);
  }
}

@JsonSerializable(explicitToJson: true)
class EmployerVerification {
  EmployerVerification({
    this.name,
  });

  factory EmployerVerification.fromJson(Map<String, dynamic> json) =>
      _$EmployerVerificationFromJson(json);

  @JsonKey(name: 'name')
  final String? name;
  static const fromJsonFactory = _$EmployerVerificationFromJson;
  static const toJsonFactory = _$EmployerVerificationToJson;
  Map<String, dynamic> toJson() => _$EmployerVerificationToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is EmployerVerification &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^ runtimeType.hashCode;
}

extension $EmployerVerificationExtension on EmployerVerification {
  EmployerVerification copyWith({String? name}) {
    return EmployerVerification(name: name ?? this.name);
  }
}

@JsonSerializable(explicitToJson: true)
class PlatformIds {
  PlatformIds({
    this.employeeId,
    this.payrollId,
    this.positionId,
  });

  factory PlatformIds.fromJson(Map<String, dynamic> json) =>
      _$PlatformIdsFromJson(json);

  @JsonKey(name: 'employee_id')
  final String? employeeId;
  @JsonKey(name: 'payroll_id')
  final String? payrollId;
  @JsonKey(name: 'position_id')
  final String? positionId;
  static const fromJsonFactory = _$PlatformIdsFromJson;
  static const toJsonFactory = _$PlatformIdsToJson;
  Map<String, dynamic> toJson() => _$PlatformIdsToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PlatformIds &&
            (identical(other.employeeId, employeeId) ||
                const DeepCollectionEquality()
                    .equals(other.employeeId, employeeId)) &&
            (identical(other.payrollId, payrollId) ||
                const DeepCollectionEquality()
                    .equals(other.payrollId, payrollId)) &&
            (identical(other.positionId, positionId) ||
                const DeepCollectionEquality()
                    .equals(other.positionId, positionId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(employeeId) ^
      const DeepCollectionEquality().hash(payrollId) ^
      const DeepCollectionEquality().hash(positionId) ^
      runtimeType.hashCode;
}

extension $PlatformIdsExtension on PlatformIds {
  PlatformIds copyWith(
      {String? employeeId, String? payrollId, String? positionId}) {
    return PlatformIds(
        employeeId: employeeId ?? this.employeeId,
        payrollId: payrollId ?? this.payrollId,
        positionId: positionId ?? this.positionId);
  }
}

@JsonSerializable(explicitToJson: true)
class AssetReportTransaction {
  AssetReportTransaction({
    this.dateTransacted,
    this.transactionType,
    this.pendingTransactionId,
    this.categoryId,
    this.category,
    this.location,
    this.paymentMeta,
    this.accountOwner,
    this.name,
    this.originalDescription,
    this.accountId,
    this.amount,
    this.isoCurrencyCode,
    this.unofficialCurrencyCode,
    this.date,
    this.pending,
    this.transactionId,
    this.merchantName,
    this.checkNumber,
  });

  factory AssetReportTransaction.fromJson(Map<String, dynamic> json) =>
      _$AssetReportTransactionFromJson(json);

  @JsonKey(name: 'date_transacted')
  final String? dateTransacted;
  @JsonKey(
      name: 'transaction_type',
      toJson: assetReportTransactionTransactionTypeToJson,
      fromJson: assetReportTransactionTransactionTypeFromJson)
  final enums.AssetReportTransactionTransactionType? transactionType;
  @JsonKey(name: 'pending_transaction_id')
  final String? pendingTransactionId;
  @JsonKey(name: 'category_id')
  final String? categoryId;
  @JsonKey(name: 'category', defaultValue: <String>[])
  final List<String>? category;
  @JsonKey(name: 'location')
  final Location? location;
  @JsonKey(name: 'payment_meta')
  final PaymentMeta? paymentMeta;
  @JsonKey(name: 'account_owner')
  final String? accountOwner;
  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'original_description')
  final String? originalDescription;
  @JsonKey(name: 'account_id')
  final String? accountId;
  @JsonKey(name: 'amount')
  final double? amount;
  @JsonKey(name: 'iso_currency_code')
  final String? isoCurrencyCode;
  @JsonKey(name: 'unofficial_currency_code')
  final String? unofficialCurrencyCode;
  @JsonKey(name: 'date', toJson: _dateToJson)
  final DateTime? date;
  @JsonKey(name: 'pending')
  final bool? pending;
  @JsonKey(name: 'transaction_id')
  final String? transactionId;
  @JsonKey(name: 'merchant_name')
  final String? merchantName;
  @JsonKey(name: 'check_number')
  final String? checkNumber;
  static const fromJsonFactory = _$AssetReportTransactionFromJson;
  static const toJsonFactory = _$AssetReportTransactionToJson;
  Map<String, dynamic> toJson() => _$AssetReportTransactionToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AssetReportTransaction &&
            (identical(other.dateTransacted, dateTransacted) ||
                const DeepCollectionEquality()
                    .equals(other.dateTransacted, dateTransacted)) &&
            (identical(other.transactionType, transactionType) ||
                const DeepCollectionEquality()
                    .equals(other.transactionType, transactionType)) &&
            (identical(other.pendingTransactionId, pendingTransactionId) ||
                const DeepCollectionEquality().equals(
                    other.pendingTransactionId, pendingTransactionId)) &&
            (identical(other.categoryId, categoryId) ||
                const DeepCollectionEquality()
                    .equals(other.categoryId, categoryId)) &&
            (identical(other.category, category) ||
                const DeepCollectionEquality()
                    .equals(other.category, category)) &&
            (identical(other.location, location) ||
                const DeepCollectionEquality()
                    .equals(other.location, location)) &&
            (identical(other.paymentMeta, paymentMeta) ||
                const DeepCollectionEquality()
                    .equals(other.paymentMeta, paymentMeta)) &&
            (identical(other.accountOwner, accountOwner) ||
                const DeepCollectionEquality()
                    .equals(other.accountOwner, accountOwner)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.originalDescription, originalDescription) ||
                const DeepCollectionEquality()
                    .equals(other.originalDescription, originalDescription)) &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)) &&
            (identical(other.unofficialCurrencyCode, unofficialCurrencyCode) ||
                const DeepCollectionEquality().equals(
                    other.unofficialCurrencyCode, unofficialCurrencyCode)) &&
            (identical(other.date, date) ||
                const DeepCollectionEquality().equals(other.date, date)) &&
            (identical(other.pending, pending) ||
                const DeepCollectionEquality()
                    .equals(other.pending, pending)) &&
            (identical(other.transactionId, transactionId) ||
                const DeepCollectionEquality()
                    .equals(other.transactionId, transactionId)) &&
            (identical(other.merchantName, merchantName) ||
                const DeepCollectionEquality()
                    .equals(other.merchantName, merchantName)) &&
            (identical(other.checkNumber, checkNumber) ||
                const DeepCollectionEquality()
                    .equals(other.checkNumber, checkNumber)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(dateTransacted) ^
      const DeepCollectionEquality().hash(transactionType) ^
      const DeepCollectionEquality().hash(pendingTransactionId) ^
      const DeepCollectionEquality().hash(categoryId) ^
      const DeepCollectionEquality().hash(category) ^
      const DeepCollectionEquality().hash(location) ^
      const DeepCollectionEquality().hash(paymentMeta) ^
      const DeepCollectionEquality().hash(accountOwner) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(originalDescription) ^
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      const DeepCollectionEquality().hash(unofficialCurrencyCode) ^
      const DeepCollectionEquality().hash(date) ^
      const DeepCollectionEquality().hash(pending) ^
      const DeepCollectionEquality().hash(transactionId) ^
      const DeepCollectionEquality().hash(merchantName) ^
      const DeepCollectionEquality().hash(checkNumber) ^
      runtimeType.hashCode;
}

extension $AssetReportTransactionExtension on AssetReportTransaction {
  AssetReportTransaction copyWith(
      {String? dateTransacted,
      enums.AssetReportTransactionTransactionType? transactionType,
      String? pendingTransactionId,
      String? categoryId,
      List<String>? category,
      Location? location,
      PaymentMeta? paymentMeta,
      String? accountOwner,
      String? name,
      String? originalDescription,
      String? accountId,
      double? amount,
      String? isoCurrencyCode,
      String? unofficialCurrencyCode,
      DateTime? date,
      bool? pending,
      String? transactionId,
      String? merchantName,
      String? checkNumber}) {
    return AssetReportTransaction(
        dateTransacted: dateTransacted ?? this.dateTransacted,
        transactionType: transactionType ?? this.transactionType,
        pendingTransactionId: pendingTransactionId ?? this.pendingTransactionId,
        categoryId: categoryId ?? this.categoryId,
        category: category ?? this.category,
        location: location ?? this.location,
        paymentMeta: paymentMeta ?? this.paymentMeta,
        accountOwner: accountOwner ?? this.accountOwner,
        name: name ?? this.name,
        originalDescription: originalDescription ?? this.originalDescription,
        accountId: accountId ?? this.accountId,
        amount: amount ?? this.amount,
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode,
        unofficialCurrencyCode:
            unofficialCurrencyCode ?? this.unofficialCurrencyCode,
        date: date ?? this.date,
        pending: pending ?? this.pending,
        transactionId: transactionId ?? this.transactionId,
        merchantName: merchantName ?? this.merchantName,
        checkNumber: checkNumber ?? this.checkNumber);
  }
}

@JsonSerializable(explicitToJson: true)
class HealthIncident {
  HealthIncident({
    this.startDate,
    this.endDate,
    this.title,
    this.incidentUpdates,
  });

  factory HealthIncident.fromJson(Map<String, dynamic> json) =>
      _$HealthIncidentFromJson(json);

  @JsonKey(name: 'start_date')
  final DateTime? startDate;
  @JsonKey(name: 'end_date')
  final DateTime? endDate;
  @JsonKey(name: 'title')
  final String? title;
  @JsonKey(name: 'incident_updates', defaultValue: <IncidentUpdate>[])
  final List<IncidentUpdate>? incidentUpdates;
  static const fromJsonFactory = _$HealthIncidentFromJson;
  static const toJsonFactory = _$HealthIncidentToJson;
  Map<String, dynamic> toJson() => _$HealthIncidentToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is HealthIncident &&
            (identical(other.startDate, startDate) ||
                const DeepCollectionEquality()
                    .equals(other.startDate, startDate)) &&
            (identical(other.endDate, endDate) ||
                const DeepCollectionEquality()
                    .equals(other.endDate, endDate)) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.incidentUpdates, incidentUpdates) ||
                const DeepCollectionEquality()
                    .equals(other.incidentUpdates, incidentUpdates)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(startDate) ^
      const DeepCollectionEquality().hash(endDate) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(incidentUpdates) ^
      runtimeType.hashCode;
}

extension $HealthIncidentExtension on HealthIncident {
  HealthIncident copyWith(
      {DateTime? startDate,
      DateTime? endDate,
      String? title,
      List<IncidentUpdate>? incidentUpdates}) {
    return HealthIncident(
        startDate: startDate ?? this.startDate,
        endDate: endDate ?? this.endDate,
        title: title ?? this.title,
        incidentUpdates: incidentUpdates ?? this.incidentUpdates);
  }
}

@JsonSerializable(explicitToJson: true)
class IncidentUpdate {
  IncidentUpdate({
    this.description,
    this.status,
    this.updatedDate,
  });

  factory IncidentUpdate.fromJson(Map<String, dynamic> json) =>
      _$IncidentUpdateFromJson(json);

  @JsonKey(name: 'description')
  final String? description;
  @JsonKey(
      name: 'status',
      toJson: incidentUpdateStatusToJson,
      fromJson: incidentUpdateStatusFromJson)
  final enums.IncidentUpdateStatus? status;
  @JsonKey(name: 'updated_date')
  final DateTime? updatedDate;
  static const fromJsonFactory = _$IncidentUpdateFromJson;
  static const toJsonFactory = _$IncidentUpdateToJson;
  Map<String, dynamic> toJson() => _$IncidentUpdateToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is IncidentUpdate &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.updatedDate, updatedDate) ||
                const DeepCollectionEquality()
                    .equals(other.updatedDate, updatedDate)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(updatedDate) ^
      runtimeType.hashCode;
}

extension $IncidentUpdateExtension on IncidentUpdate {
  IncidentUpdate copyWith(
      {String? description,
      enums.IncidentUpdateStatus? status,
      DateTime? updatedDate}) {
    return IncidentUpdate(
        description: description ?? this.description,
        status: status ?? this.status,
        updatedDate: updatedDate ?? this.updatedDate);
  }
}

@JsonSerializable(explicitToJson: true)
class DepositSwitchAltCreateRequest {
  DepositSwitchAltCreateRequest({
    this.clientId,
    this.secret,
    this.targetAccount,
    this.targetUser,
    this.options,
    this.countryCode,
  });

  factory DepositSwitchAltCreateRequest.fromJson(Map<String, dynamic> json) =>
      _$DepositSwitchAltCreateRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'target_account')
  final DepositSwitchTargetAccount? targetAccount;
  @JsonKey(name: 'target_user')
  final DepositSwitchTargetUser? targetUser;
  @JsonKey(name: 'options')
  final DepositSwitchCreateRequestOptions? options;
  @JsonKey(
      name: 'country_code',
      toJson: depositSwitchAltCreateRequestCountryCodeToJson,
      fromJson: depositSwitchAltCreateRequestCountryCodeFromJson)
  final enums.DepositSwitchAltCreateRequestCountryCode? countryCode;
  static const fromJsonFactory = _$DepositSwitchAltCreateRequestFromJson;
  static const toJsonFactory = _$DepositSwitchAltCreateRequestToJson;
  Map<String, dynamic> toJson() => _$DepositSwitchAltCreateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is DepositSwitchAltCreateRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.targetAccount, targetAccount) ||
                const DeepCollectionEquality()
                    .equals(other.targetAccount, targetAccount)) &&
            (identical(other.targetUser, targetUser) ||
                const DeepCollectionEquality()
                    .equals(other.targetUser, targetUser)) &&
            (identical(other.options, options) ||
                const DeepCollectionEquality()
                    .equals(other.options, options)) &&
            (identical(other.countryCode, countryCode) ||
                const DeepCollectionEquality()
                    .equals(other.countryCode, countryCode)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(targetAccount) ^
      const DeepCollectionEquality().hash(targetUser) ^
      const DeepCollectionEquality().hash(options) ^
      const DeepCollectionEquality().hash(countryCode) ^
      runtimeType.hashCode;
}

extension $DepositSwitchAltCreateRequestExtension
    on DepositSwitchAltCreateRequest {
  DepositSwitchAltCreateRequest copyWith(
      {String? clientId,
      String? secret,
      DepositSwitchTargetAccount? targetAccount,
      DepositSwitchTargetUser? targetUser,
      DepositSwitchCreateRequestOptions? options,
      enums.DepositSwitchAltCreateRequestCountryCode? countryCode}) {
    return DepositSwitchAltCreateRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        targetAccount: targetAccount ?? this.targetAccount,
        targetUser: targetUser ?? this.targetUser,
        options: options ?? this.options,
        countryCode: countryCode ?? this.countryCode);
  }
}

@JsonSerializable(explicitToJson: true)
class DepositSwitchAltCreateResponse {
  DepositSwitchAltCreateResponse({
    this.depositSwitchId,
    this.requestId,
  });

  factory DepositSwitchAltCreateResponse.fromJson(Map<String, dynamic> json) =>
      _$DepositSwitchAltCreateResponseFromJson(json);

  @JsonKey(name: 'deposit_switch_id')
  final String? depositSwitchId;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$DepositSwitchAltCreateResponseFromJson;
  static const toJsonFactory = _$DepositSwitchAltCreateResponseToJson;
  Map<String, dynamic> toJson() => _$DepositSwitchAltCreateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is DepositSwitchAltCreateResponse &&
            (identical(other.depositSwitchId, depositSwitchId) ||
                const DeepCollectionEquality()
                    .equals(other.depositSwitchId, depositSwitchId)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(depositSwitchId) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $DepositSwitchAltCreateResponseExtension
    on DepositSwitchAltCreateResponse {
  DepositSwitchAltCreateResponse copyWith(
      {String? depositSwitchId, String? requestId}) {
    return DepositSwitchAltCreateResponse(
        depositSwitchId: depositSwitchId ?? this.depositSwitchId,
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class DepositSwitchTargetAccount {
  DepositSwitchTargetAccount({
    this.accountNumber,
    this.routingNumber,
    this.accountName,
    this.accountSubtype,
  });

  factory DepositSwitchTargetAccount.fromJson(Map<String, dynamic> json) =>
      _$DepositSwitchTargetAccountFromJson(json);

  @JsonKey(name: 'account_number')
  final String? accountNumber;
  @JsonKey(name: 'routing_number')
  final String? routingNumber;
  @JsonKey(name: 'account_name')
  final String? accountName;
  @JsonKey(
      name: 'account_subtype',
      toJson: depositSwitchTargetAccountAccountSubtypeToJson,
      fromJson: depositSwitchTargetAccountAccountSubtypeFromJson)
  final enums.DepositSwitchTargetAccountAccountSubtype? accountSubtype;
  static const fromJsonFactory = _$DepositSwitchTargetAccountFromJson;
  static const toJsonFactory = _$DepositSwitchTargetAccountToJson;
  Map<String, dynamic> toJson() => _$DepositSwitchTargetAccountToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is DepositSwitchTargetAccount &&
            (identical(other.accountNumber, accountNumber) ||
                const DeepCollectionEquality()
                    .equals(other.accountNumber, accountNumber)) &&
            (identical(other.routingNumber, routingNumber) ||
                const DeepCollectionEquality()
                    .equals(other.routingNumber, routingNumber)) &&
            (identical(other.accountName, accountName) ||
                const DeepCollectionEquality()
                    .equals(other.accountName, accountName)) &&
            (identical(other.accountSubtype, accountSubtype) ||
                const DeepCollectionEquality()
                    .equals(other.accountSubtype, accountSubtype)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountNumber) ^
      const DeepCollectionEquality().hash(routingNumber) ^
      const DeepCollectionEquality().hash(accountName) ^
      const DeepCollectionEquality().hash(accountSubtype) ^
      runtimeType.hashCode;
}

extension $DepositSwitchTargetAccountExtension on DepositSwitchTargetAccount {
  DepositSwitchTargetAccount copyWith(
      {String? accountNumber,
      String? routingNumber,
      String? accountName,
      enums.DepositSwitchTargetAccountAccountSubtype? accountSubtype}) {
    return DepositSwitchTargetAccount(
        accountNumber: accountNumber ?? this.accountNumber,
        routingNumber: routingNumber ?? this.routingNumber,
        accountName: accountName ?? this.accountName,
        accountSubtype: accountSubtype ?? this.accountSubtype);
  }
}

@JsonSerializable(explicitToJson: true)
class DepositSwitchTargetUser {
  DepositSwitchTargetUser({
    this.givenName,
    this.familyName,
    this.phone,
    this.email,
    this.address,
    this.taxPayerId,
  });

  factory DepositSwitchTargetUser.fromJson(Map<String, dynamic> json) =>
      _$DepositSwitchTargetUserFromJson(json);

  @JsonKey(name: 'given_name')
  final String? givenName;
  @JsonKey(name: 'family_name')
  final String? familyName;
  @JsonKey(name: 'phone')
  final String? phone;
  @JsonKey(name: 'email')
  final String? email;
  @JsonKey(name: 'address')
  final DepositSwitchAddressData? address;
  @JsonKey(name: 'tax_payer_id')
  final String? taxPayerId;
  static const fromJsonFactory = _$DepositSwitchTargetUserFromJson;
  static const toJsonFactory = _$DepositSwitchTargetUserToJson;
  Map<String, dynamic> toJson() => _$DepositSwitchTargetUserToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is DepositSwitchTargetUser &&
            (identical(other.givenName, givenName) ||
                const DeepCollectionEquality()
                    .equals(other.givenName, givenName)) &&
            (identical(other.familyName, familyName) ||
                const DeepCollectionEquality()
                    .equals(other.familyName, familyName)) &&
            (identical(other.phone, phone) ||
                const DeepCollectionEquality().equals(other.phone, phone)) &&
            (identical(other.email, email) ||
                const DeepCollectionEquality().equals(other.email, email)) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality()
                    .equals(other.address, address)) &&
            (identical(other.taxPayerId, taxPayerId) ||
                const DeepCollectionEquality()
                    .equals(other.taxPayerId, taxPayerId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(givenName) ^
      const DeepCollectionEquality().hash(familyName) ^
      const DeepCollectionEquality().hash(phone) ^
      const DeepCollectionEquality().hash(email) ^
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(taxPayerId) ^
      runtimeType.hashCode;
}

extension $DepositSwitchTargetUserExtension on DepositSwitchTargetUser {
  DepositSwitchTargetUser copyWith(
      {String? givenName,
      String? familyName,
      String? phone,
      String? email,
      DepositSwitchAddressData? address,
      String? taxPayerId}) {
    return DepositSwitchTargetUser(
        givenName: givenName ?? this.givenName,
        familyName: familyName ?? this.familyName,
        phone: phone ?? this.phone,
        email: email ?? this.email,
        address: address ?? this.address,
        taxPayerId: taxPayerId ?? this.taxPayerId);
  }
}

@JsonSerializable(explicitToJson: true)
class DepositSwitchAddressData {
  DepositSwitchAddressData({
    this.city,
    this.region,
    this.street,
    this.postalCode,
    this.country,
  });

  factory DepositSwitchAddressData.fromJson(Map<String, dynamic> json) =>
      _$DepositSwitchAddressDataFromJson(json);

  @JsonKey(name: 'city')
  final String? city;
  @JsonKey(name: 'region')
  final String? region;
  @JsonKey(name: 'street')
  final String? street;
  @JsonKey(name: 'postal_code')
  final String? postalCode;
  @JsonKey(name: 'country')
  final String? country;
  static const fromJsonFactory = _$DepositSwitchAddressDataFromJson;
  static const toJsonFactory = _$DepositSwitchAddressDataToJson;
  Map<String, dynamic> toJson() => _$DepositSwitchAddressDataToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is DepositSwitchAddressData &&
            (identical(other.city, city) ||
                const DeepCollectionEquality().equals(other.city, city)) &&
            (identical(other.region, region) ||
                const DeepCollectionEquality().equals(other.region, region)) &&
            (identical(other.street, street) ||
                const DeepCollectionEquality().equals(other.street, street)) &&
            (identical(other.postalCode, postalCode) ||
                const DeepCollectionEquality()
                    .equals(other.postalCode, postalCode)) &&
            (identical(other.country, country) ||
                const DeepCollectionEquality().equals(other.country, country)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(city) ^
      const DeepCollectionEquality().hash(region) ^
      const DeepCollectionEquality().hash(street) ^
      const DeepCollectionEquality().hash(postalCode) ^
      const DeepCollectionEquality().hash(country) ^
      runtimeType.hashCode;
}

extension $DepositSwitchAddressDataExtension on DepositSwitchAddressData {
  DepositSwitchAddressData copyWith(
      {String? city,
      String? region,
      String? street,
      String? postalCode,
      String? country}) {
    return DepositSwitchAddressData(
        city: city ?? this.city,
        region: region ?? this.region,
        street: street ?? this.street,
        postalCode: postalCode ?? this.postalCode,
        country: country ?? this.country);
  }
}

@JsonSerializable(explicitToJson: true)
class SandboxBankTransferFireWebhookRequest {
  SandboxBankTransferFireWebhookRequest({
    this.clientId,
    this.secret,
    this.webhook,
  });

  factory SandboxBankTransferFireWebhookRequest.fromJson(
          Map<String, dynamic> json) =>
      _$SandboxBankTransferFireWebhookRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'webhook')
  final String? webhook;
  static const fromJsonFactory =
      _$SandboxBankTransferFireWebhookRequestFromJson;
  static const toJsonFactory = _$SandboxBankTransferFireWebhookRequestToJson;
  Map<String, dynamic> toJson() =>
      _$SandboxBankTransferFireWebhookRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SandboxBankTransferFireWebhookRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.webhook, webhook) ||
                const DeepCollectionEquality().equals(other.webhook, webhook)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(webhook) ^
      runtimeType.hashCode;
}

extension $SandboxBankTransferFireWebhookRequestExtension
    on SandboxBankTransferFireWebhookRequest {
  SandboxBankTransferFireWebhookRequest copyWith(
      {String? clientId, String? secret, String? webhook}) {
    return SandboxBankTransferFireWebhookRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        webhook: webhook ?? this.webhook);
  }
}

@JsonSerializable(explicitToJson: true)
class SandboxBankTransferFireWebhookResponse {
  SandboxBankTransferFireWebhookResponse({
    this.requestId,
  });

  factory SandboxBankTransferFireWebhookResponse.fromJson(
          Map<String, dynamic> json) =>
      _$SandboxBankTransferFireWebhookResponseFromJson(json);

  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory =
      _$SandboxBankTransferFireWebhookResponseFromJson;
  static const toJsonFactory = _$SandboxBankTransferFireWebhookResponseToJson;
  Map<String, dynamic> toJson() =>
      _$SandboxBankTransferFireWebhookResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SandboxBankTransferFireWebhookResponse &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(requestId) ^ runtimeType.hashCode;
}

extension $SandboxBankTransferFireWebhookResponseExtension
    on SandboxBankTransferFireWebhookResponse {
  SandboxBankTransferFireWebhookResponse copyWith({String? requestId}) {
    return SandboxBankTransferFireWebhookResponse(
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class Application {
  Application({
    this.applicationId,
    this.name,
    this.createdAt,
    this.logoUrl,
    this.applicationUrl,
    this.reasonForAccess,
  });

  factory Application.fromJson(Map<String, dynamic> json) =>
      _$ApplicationFromJson(json);

  @JsonKey(name: 'application_id')
  final String? applicationId;
  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'created_at', toJson: _dateToJson)
  final DateTime? createdAt;
  @JsonKey(name: 'logo_url')
  final String? logoUrl;
  @JsonKey(name: 'application_url')
  final String? applicationUrl;
  @JsonKey(name: 'reason_for_access')
  final String? reasonForAccess;
  static const fromJsonFactory = _$ApplicationFromJson;
  static const toJsonFactory = _$ApplicationToJson;
  Map<String, dynamic> toJson() => _$ApplicationToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Application &&
            (identical(other.applicationId, applicationId) ||
                const DeepCollectionEquality()
                    .equals(other.applicationId, applicationId)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.createdAt, createdAt) ||
                const DeepCollectionEquality()
                    .equals(other.createdAt, createdAt)) &&
            (identical(other.logoUrl, logoUrl) ||
                const DeepCollectionEquality()
                    .equals(other.logoUrl, logoUrl)) &&
            (identical(other.applicationUrl, applicationUrl) ||
                const DeepCollectionEquality()
                    .equals(other.applicationUrl, applicationUrl)) &&
            (identical(other.reasonForAccess, reasonForAccess) ||
                const DeepCollectionEquality()
                    .equals(other.reasonForAccess, reasonForAccess)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(applicationId) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(createdAt) ^
      const DeepCollectionEquality().hash(logoUrl) ^
      const DeepCollectionEquality().hash(applicationUrl) ^
      const DeepCollectionEquality().hash(reasonForAccess) ^
      runtimeType.hashCode;
}

extension $ApplicationExtension on Application {
  Application copyWith(
      {String? applicationId,
      String? name,
      DateTime? createdAt,
      String? logoUrl,
      String? applicationUrl,
      String? reasonForAccess}) {
    return Application(
        applicationId: applicationId ?? this.applicationId,
        name: name ?? this.name,
        createdAt: createdAt ?? this.createdAt,
        logoUrl: logoUrl ?? this.logoUrl,
        applicationUrl: applicationUrl ?? this.applicationUrl,
        reasonForAccess: reasonForAccess ?? this.reasonForAccess);
  }
}

@JsonSerializable(explicitToJson: true)
class ApplicationGetRequest {
  ApplicationGetRequest({
    this.clientId,
    this.secret,
    this.applicationId,
  });

  factory ApplicationGetRequest.fromJson(Map<String, dynamic> json) =>
      _$ApplicationGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'application_id')
  final String? applicationId;
  static const fromJsonFactory = _$ApplicationGetRequestFromJson;
  static const toJsonFactory = _$ApplicationGetRequestToJson;
  Map<String, dynamic> toJson() => _$ApplicationGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ApplicationGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.applicationId, applicationId) ||
                const DeepCollectionEquality()
                    .equals(other.applicationId, applicationId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(applicationId) ^
      runtimeType.hashCode;
}

extension $ApplicationGetRequestExtension on ApplicationGetRequest {
  ApplicationGetRequest copyWith(
      {String? clientId, String? secret, String? applicationId}) {
    return ApplicationGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        applicationId: applicationId ?? this.applicationId);
  }
}

@JsonSerializable(explicitToJson: true)
class ApplicationGetResponse {
  ApplicationGetResponse({
    this.requestId,
    this.application,
  });

  factory ApplicationGetResponse.fromJson(Map<String, dynamic> json) =>
      _$ApplicationGetResponseFromJson(json);

  @JsonKey(name: 'request_id')
  final String? requestId;
  @JsonKey(name: 'application')
  final Application? application;
  static const fromJsonFactory = _$ApplicationGetResponseFromJson;
  static const toJsonFactory = _$ApplicationGetResponseToJson;
  Map<String, dynamic> toJson() => _$ApplicationGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ApplicationGetResponse &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)) &&
            (identical(other.application, application) ||
                const DeepCollectionEquality()
                    .equals(other.application, application)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(requestId) ^
      const DeepCollectionEquality().hash(application) ^
      runtimeType.hashCode;
}

extension $ApplicationGetResponseExtension on ApplicationGetResponse {
  ApplicationGetResponse copyWith(
      {String? requestId, Application? application}) {
    return ApplicationGetResponse(
        requestId: requestId ?? this.requestId,
        application: application ?? this.application);
  }
}

@JsonSerializable(explicitToJson: true)
class ProductAccess {
  ProductAccess({
    this.statements,
    this.identity,
    this.auth,
    this.transactions,
  });

  factory ProductAccess.fromJson(Map<String, dynamic> json) =>
      _$ProductAccessFromJson(json);

  @JsonKey(name: 'statements', defaultValue: true)
  final bool? statements;
  @JsonKey(name: 'identity', defaultValue: true)
  final bool? identity;
  @JsonKey(name: 'auth', defaultValue: true)
  final bool? auth;
  @JsonKey(name: 'transactions', defaultValue: true)
  final bool? transactions;
  static const fromJsonFactory = _$ProductAccessFromJson;
  static const toJsonFactory = _$ProductAccessToJson;
  Map<String, dynamic> toJson() => _$ProductAccessToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ProductAccess &&
            (identical(other.statements, statements) ||
                const DeepCollectionEquality()
                    .equals(other.statements, statements)) &&
            (identical(other.identity, identity) ||
                const DeepCollectionEquality()
                    .equals(other.identity, identity)) &&
            (identical(other.auth, auth) ||
                const DeepCollectionEquality().equals(other.auth, auth)) &&
            (identical(other.transactions, transactions) ||
                const DeepCollectionEquality()
                    .equals(other.transactions, transactions)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(statements) ^
      const DeepCollectionEquality().hash(identity) ^
      const DeepCollectionEquality().hash(auth) ^
      const DeepCollectionEquality().hash(transactions) ^
      runtimeType.hashCode;
}

extension $ProductAccessExtension on ProductAccess {
  ProductAccess copyWith(
      {bool? statements, bool? identity, bool? auth, bool? transactions}) {
    return ProductAccess(
        statements: statements ?? this.statements,
        identity: identity ?? this.identity,
        auth: auth ?? this.auth,
        transactions: transactions ?? this.transactions);
  }
}

@JsonSerializable(explicitToJson: true)
class AccountAccess {
  AccountAccess({
    this.uniqueId,
    this.authorized,
    this.accountProductAccess,
  });

  factory AccountAccess.fromJson(Map<String, dynamic> json) =>
      _$AccountAccessFromJson(json);

  @JsonKey(name: 'unique_id')
  final String? uniqueId;
  @JsonKey(name: 'authorized', defaultValue: true)
  final bool? authorized;
  @JsonKey(name: 'account_product_access')
  final AccountProductAccessNullable? accountProductAccess;
  static const fromJsonFactory = _$AccountAccessFromJson;
  static const toJsonFactory = _$AccountAccessToJson;
  Map<String, dynamic> toJson() => _$AccountAccessToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AccountAccess &&
            (identical(other.uniqueId, uniqueId) ||
                const DeepCollectionEquality()
                    .equals(other.uniqueId, uniqueId)) &&
            (identical(other.authorized, authorized) ||
                const DeepCollectionEquality()
                    .equals(other.authorized, authorized)) &&
            (identical(other.accountProductAccess, accountProductAccess) ||
                const DeepCollectionEquality()
                    .equals(other.accountProductAccess, accountProductAccess)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(uniqueId) ^
      const DeepCollectionEquality().hash(authorized) ^
      const DeepCollectionEquality().hash(accountProductAccess) ^
      runtimeType.hashCode;
}

extension $AccountAccessExtension on AccountAccess {
  AccountAccess copyWith(
      {String? uniqueId,
      bool? authorized,
      AccountProductAccessNullable? accountProductAccess}) {
    return AccountAccess(
        uniqueId: uniqueId ?? this.uniqueId,
        authorized: authorized ?? this.authorized,
        accountProductAccess:
            accountProductAccess ?? this.accountProductAccess);
  }
}

@JsonSerializable(explicitToJson: true)
class AccountProductAccessNullable {
  AccountProductAccessNullable();

  factory AccountProductAccessNullable.fromJson(Map<String, dynamic> json) =>
      _$AccountProductAccessNullableFromJson(json);

  static const fromJsonFactory = _$AccountProductAccessNullableFromJson;
  static const toJsonFactory = _$AccountProductAccessNullableToJson;
  Map<String, dynamic> toJson() => _$AccountProductAccessNullableToJson(this);

  @override
  int get hashCode => runtimeType.hashCode;
}

@JsonSerializable(explicitToJson: true)
class AccountProductAccess {
  AccountProductAccess({
    this.accountData,
    this.statements,
    this.taxDocuments,
  });

  factory AccountProductAccess.fromJson(Map<String, dynamic> json) =>
      _$AccountProductAccessFromJson(json);

  @JsonKey(name: 'account_data', defaultValue: true)
  final bool? accountData;
  @JsonKey(name: 'statements', defaultValue: true)
  final bool? statements;
  @JsonKey(name: 'tax_documents', defaultValue: true)
  final bool? taxDocuments;
  static const fromJsonFactory = _$AccountProductAccessFromJson;
  static const toJsonFactory = _$AccountProductAccessToJson;
  Map<String, dynamic> toJson() => _$AccountProductAccessToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AccountProductAccess &&
            (identical(other.accountData, accountData) ||
                const DeepCollectionEquality()
                    .equals(other.accountData, accountData)) &&
            (identical(other.statements, statements) ||
                const DeepCollectionEquality()
                    .equals(other.statements, statements)) &&
            (identical(other.taxDocuments, taxDocuments) ||
                const DeepCollectionEquality()
                    .equals(other.taxDocuments, taxDocuments)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountData) ^
      const DeepCollectionEquality().hash(statements) ^
      const DeepCollectionEquality().hash(taxDocuments) ^
      runtimeType.hashCode;
}

extension $AccountProductAccessExtension on AccountProductAccess {
  AccountProductAccess copyWith(
      {bool? accountData, bool? statements, bool? taxDocuments}) {
    return AccountProductAccess(
        accountData: accountData ?? this.accountData,
        statements: statements ?? this.statements,
        taxDocuments: taxDocuments ?? this.taxDocuments);
  }
}

@JsonSerializable(explicitToJson: true)
class ScopesNullable {
  ScopesNullable();

  factory ScopesNullable.fromJson(Map<String, dynamic> json) =>
      _$ScopesNullableFromJson(json);

  static const fromJsonFactory = _$ScopesNullableFromJson;
  static const toJsonFactory = _$ScopesNullableToJson;
  Map<String, dynamic> toJson() => _$ScopesNullableToJson(this);

  @override
  int get hashCode => runtimeType.hashCode;
}

@JsonSerializable(explicitToJson: true)
class Scopes {
  Scopes({
    this.productAccess,
    this.accounts,
    this.newAccounts,
  });

  factory Scopes.fromJson(Map<String, dynamic> json) => _$ScopesFromJson(json);

  @JsonKey(name: 'product_access')
  final ProductAccess? productAccess;
  @JsonKey(name: 'accounts', defaultValue: <AccountAccess>[])
  final List<AccountAccess>? accounts;
  @JsonKey(name: 'new_accounts', defaultValue: true)
  final bool? newAccounts;
  static const fromJsonFactory = _$ScopesFromJson;
  static const toJsonFactory = _$ScopesToJson;
  Map<String, dynamic> toJson() => _$ScopesToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is Scopes &&
            (identical(other.productAccess, productAccess) ||
                const DeepCollectionEquality()
                    .equals(other.productAccess, productAccess)) &&
            (identical(other.accounts, accounts) ||
                const DeepCollectionEquality()
                    .equals(other.accounts, accounts)) &&
            (identical(other.newAccounts, newAccounts) ||
                const DeepCollectionEquality()
                    .equals(other.newAccounts, newAccounts)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(productAccess) ^
      const DeepCollectionEquality().hash(accounts) ^
      const DeepCollectionEquality().hash(newAccounts) ^
      runtimeType.hashCode;
}

extension $ScopesExtension on Scopes {
  Scopes copyWith(
      {ProductAccess? productAccess,
      List<AccountAccess>? accounts,
      bool? newAccounts}) {
    return Scopes(
        productAccess: productAccess ?? this.productAccess,
        accounts: accounts ?? this.accounts,
        newAccounts: newAccounts ?? this.newAccounts);
  }
}

@JsonSerializable(explicitToJson: true)
class RequestedScopes {
  RequestedScopes({
    this.requiredProductAccess,
    this.optionalProductAccess,
    this.accountFilters,
    this.accountSelectionCardinality,
  });

  factory RequestedScopes.fromJson(Map<String, dynamic> json) =>
      _$RequestedScopesFromJson(json);

  @JsonKey(name: 'required_product_access')
  final ProductAccess? requiredProductAccess;
  @JsonKey(name: 'optional_product_access')
  final ProductAccess? optionalProductAccess;
  @JsonKey(name: 'account_filters')
  final AccountFilter? accountFilters;
  @JsonKey(
      name: 'account_selection_cardinality',
      toJson: accountSelectionCardinalityToJson,
      fromJson: accountSelectionCardinalityFromJson)
  final enums.AccountSelectionCardinality? accountSelectionCardinality;
  static const fromJsonFactory = _$RequestedScopesFromJson;
  static const toJsonFactory = _$RequestedScopesToJson;
  Map<String, dynamic> toJson() => _$RequestedScopesToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is RequestedScopes &&
            (identical(other.requiredProductAccess, requiredProductAccess) ||
                const DeepCollectionEquality().equals(
                    other.requiredProductAccess, requiredProductAccess)) &&
            (identical(other.optionalProductAccess, optionalProductAccess) ||
                const DeepCollectionEquality().equals(
                    other.optionalProductAccess, optionalProductAccess)) &&
            (identical(other.accountFilters, accountFilters) ||
                const DeepCollectionEquality()
                    .equals(other.accountFilters, accountFilters)) &&
            (identical(other.accountSelectionCardinality,
                    accountSelectionCardinality) ||
                const DeepCollectionEquality().equals(
                    other.accountSelectionCardinality,
                    accountSelectionCardinality)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(requiredProductAccess) ^
      const DeepCollectionEquality().hash(optionalProductAccess) ^
      const DeepCollectionEquality().hash(accountFilters) ^
      const DeepCollectionEquality().hash(accountSelectionCardinality) ^
      runtimeType.hashCode;
}

extension $RequestedScopesExtension on RequestedScopes {
  RequestedScopes copyWith(
      {ProductAccess? requiredProductAccess,
      ProductAccess? optionalProductAccess,
      AccountFilter? accountFilters,
      enums.AccountSelectionCardinality? accountSelectionCardinality}) {
    return RequestedScopes(
        requiredProductAccess:
            requiredProductAccess ?? this.requiredProductAccess,
        optionalProductAccess:
            optionalProductAccess ?? this.optionalProductAccess,
        accountFilters: accountFilters ?? this.accountFilters,
        accountSelectionCardinality:
            accountSelectionCardinality ?? this.accountSelectionCardinality);
  }
}

@JsonSerializable(explicitToJson: true)
class ItemApplicationScopesUpdateRequest {
  ItemApplicationScopesUpdateRequest({
    this.clientId,
    this.secret,
    this.accessToken,
    this.applicationId,
    this.scopes,
    this.state,
    this.context,
  });

  factory ItemApplicationScopesUpdateRequest.fromJson(
          Map<String, dynamic> json) =>
      _$ItemApplicationScopesUpdateRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'access_token')
  final String? accessToken;
  @JsonKey(name: 'application_id')
  final String? applicationId;
  @JsonKey(name: 'scopes')
  final Scopes? scopes;
  @JsonKey(name: 'state')
  final String? state;
  @JsonKey(
      name: 'context',
      toJson: scopesContextToJson,
      fromJson: scopesContextFromJson)
  final enums.ScopesContext? context;
  static const fromJsonFactory = _$ItemApplicationScopesUpdateRequestFromJson;
  static const toJsonFactory = _$ItemApplicationScopesUpdateRequestToJson;
  Map<String, dynamic> toJson() =>
      _$ItemApplicationScopesUpdateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ItemApplicationScopesUpdateRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)) &&
            (identical(other.applicationId, applicationId) ||
                const DeepCollectionEquality()
                    .equals(other.applicationId, applicationId)) &&
            (identical(other.scopes, scopes) ||
                const DeepCollectionEquality().equals(other.scopes, scopes)) &&
            (identical(other.state, state) ||
                const DeepCollectionEquality().equals(other.state, state)) &&
            (identical(other.context, context) ||
                const DeepCollectionEquality().equals(other.context, context)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(accessToken) ^
      const DeepCollectionEquality().hash(applicationId) ^
      const DeepCollectionEquality().hash(scopes) ^
      const DeepCollectionEquality().hash(state) ^
      const DeepCollectionEquality().hash(context) ^
      runtimeType.hashCode;
}

extension $ItemApplicationScopesUpdateRequestExtension
    on ItemApplicationScopesUpdateRequest {
  ItemApplicationScopesUpdateRequest copyWith(
      {String? clientId,
      String? secret,
      String? accessToken,
      String? applicationId,
      Scopes? scopes,
      String? state,
      enums.ScopesContext? context}) {
    return ItemApplicationScopesUpdateRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        accessToken: accessToken ?? this.accessToken,
        applicationId: applicationId ?? this.applicationId,
        scopes: scopes ?? this.scopes,
        state: state ?? this.state,
        context: context ?? this.context);
  }
}

@JsonSerializable(explicitToJson: true)
class ItemApplicationScopesUpdateResponse {
  ItemApplicationScopesUpdateResponse({
    this.requestId,
  });

  factory ItemApplicationScopesUpdateResponse.fromJson(
          Map<String, dynamic> json) =>
      _$ItemApplicationScopesUpdateResponseFromJson(json);

  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$ItemApplicationScopesUpdateResponseFromJson;
  static const toJsonFactory = _$ItemApplicationScopesUpdateResponseToJson;
  Map<String, dynamic> toJson() =>
      _$ItemApplicationScopesUpdateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ItemApplicationScopesUpdateResponse &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(requestId) ^ runtimeType.hashCode;
}

extension $ItemApplicationScopesUpdateResponseExtension
    on ItemApplicationScopesUpdateResponse {
  ItemApplicationScopesUpdateResponse copyWith({String? requestId}) {
    return ItemApplicationScopesUpdateResponse(
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class ItemApplicationListRequest {
  ItemApplicationListRequest({
    this.clientId,
    this.secret,
    this.accessToken,
  });

  factory ItemApplicationListRequest.fromJson(Map<String, dynamic> json) =>
      _$ItemApplicationListRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'access_token')
  final String? accessToken;
  static const fromJsonFactory = _$ItemApplicationListRequestFromJson;
  static const toJsonFactory = _$ItemApplicationListRequestToJson;
  Map<String, dynamic> toJson() => _$ItemApplicationListRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ItemApplicationListRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(accessToken) ^
      runtimeType.hashCode;
}

extension $ItemApplicationListRequestExtension on ItemApplicationListRequest {
  ItemApplicationListRequest copyWith(
      {String? clientId, String? secret, String? accessToken}) {
    return ItemApplicationListRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        accessToken: accessToken ?? this.accessToken);
  }
}

@JsonSerializable(explicitToJson: true)
class ItemApplicationListResponse {
  ItemApplicationListResponse({
    this.requestId,
    this.applications,
  });

  factory ItemApplicationListResponse.fromJson(Map<String, dynamic> json) =>
      _$ItemApplicationListResponseFromJson(json);

  @JsonKey(name: 'request_id')
  final String? requestId;
  @JsonKey(name: 'applications', defaultValue: <ConnectedApplication>[])
  final List<ConnectedApplication>? applications;
  static const fromJsonFactory = _$ItemApplicationListResponseFromJson;
  static const toJsonFactory = _$ItemApplicationListResponseToJson;
  Map<String, dynamic> toJson() => _$ItemApplicationListResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ItemApplicationListResponse &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)) &&
            (identical(other.applications, applications) ||
                const DeepCollectionEquality()
                    .equals(other.applications, applications)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(requestId) ^
      const DeepCollectionEquality().hash(applications) ^
      runtimeType.hashCode;
}

extension $ItemApplicationListResponseExtension on ItemApplicationListResponse {
  ItemApplicationListResponse copyWith(
      {String? requestId, List<ConnectedApplication>? applications}) {
    return ItemApplicationListResponse(
        requestId: requestId ?? this.requestId,
        applications: applications ?? this.applications);
  }
}

@JsonSerializable(explicitToJson: true)
class ConnectedApplication {
  ConnectedApplication({
    this.applicationId,
    this.name,
    this.logo,
    this.logoUrl,
    this.applicationUrl,
    this.reasonForAccess,
    this.createdAt,
    this.productDataTypes,
    this.scopes,
    this.requestedScopes,
  });

  factory ConnectedApplication.fromJson(Map<String, dynamic> json) =>
      _$ConnectedApplicationFromJson(json);

  @JsonKey(name: 'application_id')
  final String? applicationId;
  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'logo')
  final String? logo;
  @JsonKey(name: 'logo_url')
  final String? logoUrl;
  @JsonKey(name: 'application_url')
  final String? applicationUrl;
  @JsonKey(name: 'reason_for_access')
  final String? reasonForAccess;
  @JsonKey(name: 'created_at', toJson: _dateToJson)
  final DateTime? createdAt;
  @JsonKey(
      name: 'product_data_types',
      toJson: connectedApplicationProductDataTypesListToJson,
      fromJson: connectedApplicationProductDataTypesListFromJson)
  final List<enums.ConnectedApplicationProductDataTypes>? productDataTypes;
  @JsonKey(name: 'scopes')
  final ScopesNullable? scopes;
  @JsonKey(name: 'requested_scopes')
  final RequestedScopes? requestedScopes;
  static const fromJsonFactory = _$ConnectedApplicationFromJson;
  static const toJsonFactory = _$ConnectedApplicationToJson;
  Map<String, dynamic> toJson() => _$ConnectedApplicationToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ConnectedApplication &&
            (identical(other.applicationId, applicationId) ||
                const DeepCollectionEquality()
                    .equals(other.applicationId, applicationId)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.logo, logo) ||
                const DeepCollectionEquality().equals(other.logo, logo)) &&
            (identical(other.logoUrl, logoUrl) ||
                const DeepCollectionEquality()
                    .equals(other.logoUrl, logoUrl)) &&
            (identical(other.applicationUrl, applicationUrl) ||
                const DeepCollectionEquality()
                    .equals(other.applicationUrl, applicationUrl)) &&
            (identical(other.reasonForAccess, reasonForAccess) ||
                const DeepCollectionEquality()
                    .equals(other.reasonForAccess, reasonForAccess)) &&
            (identical(other.createdAt, createdAt) ||
                const DeepCollectionEquality()
                    .equals(other.createdAt, createdAt)) &&
            (identical(other.productDataTypes, productDataTypes) ||
                const DeepCollectionEquality()
                    .equals(other.productDataTypes, productDataTypes)) &&
            (identical(other.scopes, scopes) ||
                const DeepCollectionEquality().equals(other.scopes, scopes)) &&
            (identical(other.requestedScopes, requestedScopes) ||
                const DeepCollectionEquality()
                    .equals(other.requestedScopes, requestedScopes)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(applicationId) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(logo) ^
      const DeepCollectionEquality().hash(logoUrl) ^
      const DeepCollectionEquality().hash(applicationUrl) ^
      const DeepCollectionEquality().hash(reasonForAccess) ^
      const DeepCollectionEquality().hash(createdAt) ^
      const DeepCollectionEquality().hash(productDataTypes) ^
      const DeepCollectionEquality().hash(scopes) ^
      const DeepCollectionEquality().hash(requestedScopes) ^
      runtimeType.hashCode;
}

extension $ConnectedApplicationExtension on ConnectedApplication {
  ConnectedApplication copyWith(
      {String? applicationId,
      String? name,
      String? logo,
      String? logoUrl,
      String? applicationUrl,
      String? reasonForAccess,
      DateTime? createdAt,
      List<enums.ConnectedApplicationProductDataTypes>? productDataTypes,
      ScopesNullable? scopes,
      RequestedScopes? requestedScopes}) {
    return ConnectedApplication(
        applicationId: applicationId ?? this.applicationId,
        name: name ?? this.name,
        logo: logo ?? this.logo,
        logoUrl: logoUrl ?? this.logoUrl,
        applicationUrl: applicationUrl ?? this.applicationUrl,
        reasonForAccess: reasonForAccess ?? this.reasonForAccess,
        createdAt: createdAt ?? this.createdAt,
        productDataTypes: productDataTypes ?? this.productDataTypes,
        scopes: scopes ?? this.scopes,
        requestedScopes: requestedScopes ?? this.requestedScopes);
  }
}

@JsonSerializable(explicitToJson: true)
class AccountFilter {
  AccountFilter({
    this.depository,
    this.credit,
    this.loan,
    this.investment,
  });

  factory AccountFilter.fromJson(Map<String, dynamic> json) =>
      _$AccountFilterFromJson(json);

  @JsonKey(name: 'depository')
  final AccountFilterSubtypes? depository;
  @JsonKey(name: 'credit')
  final AccountFilterSubtypes? credit;
  @JsonKey(name: 'loan')
  final AccountFilterSubtypes? loan;
  @JsonKey(name: 'investment')
  final AccountFilterSubtypes? investment;
  static const fromJsonFactory = _$AccountFilterFromJson;
  static const toJsonFactory = _$AccountFilterToJson;
  Map<String, dynamic> toJson() => _$AccountFilterToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AccountFilter &&
            (identical(other.depository, depository) ||
                const DeepCollectionEquality()
                    .equals(other.depository, depository)) &&
            (identical(other.credit, credit) ||
                const DeepCollectionEquality().equals(other.credit, credit)) &&
            (identical(other.loan, loan) ||
                const DeepCollectionEquality().equals(other.loan, loan)) &&
            (identical(other.investment, investment) ||
                const DeepCollectionEquality()
                    .equals(other.investment, investment)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(depository) ^
      const DeepCollectionEquality().hash(credit) ^
      const DeepCollectionEquality().hash(loan) ^
      const DeepCollectionEquality().hash(investment) ^
      runtimeType.hashCode;
}

extension $AccountFilterExtension on AccountFilter {
  AccountFilter copyWith(
      {AccountFilterSubtypes? depository,
      AccountFilterSubtypes? credit,
      AccountFilterSubtypes? loan,
      AccountFilterSubtypes? investment}) {
    return AccountFilter(
        depository: depository ?? this.depository,
        credit: credit ?? this.credit,
        loan: loan ?? this.loan,
        investment: investment ?? this.investment);
  }
}

@JsonSerializable(explicitToJson: true)
class AccountFilterSubtypes {
  AccountFilterSubtypes();

  factory AccountFilterSubtypes.fromJson(Map<String, dynamic> json) =>
      _$AccountFilterSubtypesFromJson(json);

  static const fromJsonFactory = _$AccountFilterSubtypesFromJson;
  static const toJsonFactory = _$AccountFilterSubtypesToJson;
  Map<String, dynamic> toJson() => _$AccountFilterSubtypesToJson(this);

  @override
  int get hashCode => runtimeType.hashCode;
}

@JsonSerializable(explicitToJson: true)
class SandboxIncomeFireWebhookRequest {
  SandboxIncomeFireWebhookRequest({
    this.clientId,
    this.secret,
    this.incomeVerificationId,
    this.itemId,
    this.webhook,
    this.verificationStatus,
  });

  factory SandboxIncomeFireWebhookRequest.fromJson(Map<String, dynamic> json) =>
      _$SandboxIncomeFireWebhookRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'income_verification_id')
  final String? incomeVerificationId;
  @JsonKey(name: 'item_id')
  final String? itemId;
  @JsonKey(name: 'webhook')
  final String? webhook;
  @JsonKey(
      name: 'verification_status',
      toJson: sandboxIncomeFireWebhookRequestVerificationStatusToJson,
      fromJson: sandboxIncomeFireWebhookRequestVerificationStatusFromJson)
  final enums.SandboxIncomeFireWebhookRequestVerificationStatus?
      verificationStatus;
  static const fromJsonFactory = _$SandboxIncomeFireWebhookRequestFromJson;
  static const toJsonFactory = _$SandboxIncomeFireWebhookRequestToJson;
  Map<String, dynamic> toJson() =>
      _$SandboxIncomeFireWebhookRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SandboxIncomeFireWebhookRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.incomeVerificationId, incomeVerificationId) ||
                const DeepCollectionEquality().equals(
                    other.incomeVerificationId, incomeVerificationId)) &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)) &&
            (identical(other.webhook, webhook) ||
                const DeepCollectionEquality()
                    .equals(other.webhook, webhook)) &&
            (identical(other.verificationStatus, verificationStatus) ||
                const DeepCollectionEquality()
                    .equals(other.verificationStatus, verificationStatus)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(incomeVerificationId) ^
      const DeepCollectionEquality().hash(itemId) ^
      const DeepCollectionEquality().hash(webhook) ^
      const DeepCollectionEquality().hash(verificationStatus) ^
      runtimeType.hashCode;
}

extension $SandboxIncomeFireWebhookRequestExtension
    on SandboxIncomeFireWebhookRequest {
  SandboxIncomeFireWebhookRequest copyWith(
      {String? clientId,
      String? secret,
      String? incomeVerificationId,
      String? itemId,
      String? webhook,
      enums.SandboxIncomeFireWebhookRequestVerificationStatus?
          verificationStatus}) {
    return SandboxIncomeFireWebhookRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        incomeVerificationId: incomeVerificationId ?? this.incomeVerificationId,
        itemId: itemId ?? this.itemId,
        webhook: webhook ?? this.webhook,
        verificationStatus: verificationStatus ?? this.verificationStatus);
  }
}

@JsonSerializable(explicitToJson: true)
class SandboxIncomeFireWebhookResponse {
  SandboxIncomeFireWebhookResponse({
    this.requestId,
  });

  factory SandboxIncomeFireWebhookResponse.fromJson(
          Map<String, dynamic> json) =>
      _$SandboxIncomeFireWebhookResponseFromJson(json);

  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$SandboxIncomeFireWebhookResponseFromJson;
  static const toJsonFactory = _$SandboxIncomeFireWebhookResponseToJson;
  Map<String, dynamic> toJson() =>
      _$SandboxIncomeFireWebhookResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SandboxIncomeFireWebhookResponse &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(requestId) ^ runtimeType.hashCode;
}

extension $SandboxIncomeFireWebhookResponseExtension
    on SandboxIncomeFireWebhookResponse {
  SandboxIncomeFireWebhookResponse copyWith({String? requestId}) {
    return SandboxIncomeFireWebhookResponse(
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class ItemApplicationListUserAuth {
  ItemApplicationListUserAuth({
    this.userId,
    this.fiUsernameHash,
  });

  factory ItemApplicationListUserAuth.fromJson(Map<String, dynamic> json) =>
      _$ItemApplicationListUserAuthFromJson(json);

  @JsonKey(name: 'user_id')
  final String? userId;
  @JsonKey(name: 'fi_username_hash')
  final String? fiUsernameHash;
  static const fromJsonFactory = _$ItemApplicationListUserAuthFromJson;
  static const toJsonFactory = _$ItemApplicationListUserAuthToJson;
  Map<String, dynamic> toJson() => _$ItemApplicationListUserAuthToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is ItemApplicationListUserAuth &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)) &&
            (identical(other.fiUsernameHash, fiUsernameHash) ||
                const DeepCollectionEquality()
                    .equals(other.fiUsernameHash, fiUsernameHash)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(userId) ^
      const DeepCollectionEquality().hash(fiUsernameHash) ^
      runtimeType.hashCode;
}

extension $ItemApplicationListUserAuthExtension on ItemApplicationListUserAuth {
  ItemApplicationListUserAuth copyWith(
      {String? userId, String? fiUsernameHash}) {
    return ItemApplicationListUserAuth(
        userId: userId ?? this.userId,
        fiUsernameHash: fiUsernameHash ?? this.fiUsernameHash);
  }
}

@JsonSerializable(explicitToJson: true)
class SignalEvaluateRequest {
  SignalEvaluateRequest({
    this.clientId,
    this.secret,
    this.accessToken,
    this.accountId,
    this.clientTransactionId,
    this.amount,
    this.userPresent,
    this.clientUserId,
    this.user,
    this.device,
  });

  factory SignalEvaluateRequest.fromJson(Map<String, dynamic> json) =>
      _$SignalEvaluateRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'access_token')
  final String? accessToken;
  @JsonKey(name: 'account_id')
  final String? accountId;
  @JsonKey(name: 'client_transaction_id')
  final String? clientTransactionId;
  @JsonKey(name: 'amount')
  final double? amount;
  @JsonKey(name: 'user_present')
  final bool? userPresent;
  @JsonKey(name: 'client_user_id')
  final String? clientUserId;
  @JsonKey(name: 'user')
  final SignalUser? user;
  @JsonKey(name: 'device')
  final SignalDevice? device;
  static const fromJsonFactory = _$SignalEvaluateRequestFromJson;
  static const toJsonFactory = _$SignalEvaluateRequestToJson;
  Map<String, dynamic> toJson() => _$SignalEvaluateRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SignalEvaluateRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)) &&
            (identical(other.accountId, accountId) ||
                const DeepCollectionEquality()
                    .equals(other.accountId, accountId)) &&
            (identical(other.clientTransactionId, clientTransactionId) ||
                const DeepCollectionEquality()
                    .equals(other.clientTransactionId, clientTransactionId)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.userPresent, userPresent) ||
                const DeepCollectionEquality()
                    .equals(other.userPresent, userPresent)) &&
            (identical(other.clientUserId, clientUserId) ||
                const DeepCollectionEquality()
                    .equals(other.clientUserId, clientUserId)) &&
            (identical(other.user, user) ||
                const DeepCollectionEquality().equals(other.user, user)) &&
            (identical(other.device, device) ||
                const DeepCollectionEquality().equals(other.device, device)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(accessToken) ^
      const DeepCollectionEquality().hash(accountId) ^
      const DeepCollectionEquality().hash(clientTransactionId) ^
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(userPresent) ^
      const DeepCollectionEquality().hash(clientUserId) ^
      const DeepCollectionEquality().hash(user) ^
      const DeepCollectionEquality().hash(device) ^
      runtimeType.hashCode;
}

extension $SignalEvaluateRequestExtension on SignalEvaluateRequest {
  SignalEvaluateRequest copyWith(
      {String? clientId,
      String? secret,
      String? accessToken,
      String? accountId,
      String? clientTransactionId,
      double? amount,
      bool? userPresent,
      String? clientUserId,
      SignalUser? user,
      SignalDevice? device}) {
    return SignalEvaluateRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        accessToken: accessToken ?? this.accessToken,
        accountId: accountId ?? this.accountId,
        clientTransactionId: clientTransactionId ?? this.clientTransactionId,
        amount: amount ?? this.amount,
        userPresent: userPresent ?? this.userPresent,
        clientUserId: clientUserId ?? this.clientUserId,
        user: user ?? this.user,
        device: device ?? this.device);
  }
}

@JsonSerializable(explicitToJson: true)
class SignalUser {
  SignalUser({
    this.name,
    this.phoneNumber,
    this.emailAddress,
    this.address,
  });

  factory SignalUser.fromJson(Map<String, dynamic> json) =>
      _$SignalUserFromJson(json);

  @JsonKey(name: 'name')
  final SignalPersonName? name;
  @JsonKey(name: 'phone_number')
  final String? phoneNumber;
  @JsonKey(name: 'email_address')
  final String? emailAddress;
  @JsonKey(name: 'address')
  final SignalAddressData? address;
  static const fromJsonFactory = _$SignalUserFromJson;
  static const toJsonFactory = _$SignalUserToJson;
  Map<String, dynamic> toJson() => _$SignalUserToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SignalUser &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.phoneNumber, phoneNumber) ||
                const DeepCollectionEquality()
                    .equals(other.phoneNumber, phoneNumber)) &&
            (identical(other.emailAddress, emailAddress) ||
                const DeepCollectionEquality()
                    .equals(other.emailAddress, emailAddress)) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality().equals(other.address, address)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(phoneNumber) ^
      const DeepCollectionEquality().hash(emailAddress) ^
      const DeepCollectionEquality().hash(address) ^
      runtimeType.hashCode;
}

extension $SignalUserExtension on SignalUser {
  SignalUser copyWith(
      {SignalPersonName? name,
      String? phoneNumber,
      String? emailAddress,
      SignalAddressData? address}) {
    return SignalUser(
        name: name ?? this.name,
        phoneNumber: phoneNumber ?? this.phoneNumber,
        emailAddress: emailAddress ?? this.emailAddress,
        address: address ?? this.address);
  }
}

@JsonSerializable(explicitToJson: true)
class SignalPersonName {
  SignalPersonName({
    this.prefix,
    this.givenName,
    this.middleName,
    this.familyName,
    this.suffix,
  });

  factory SignalPersonName.fromJson(Map<String, dynamic> json) =>
      _$SignalPersonNameFromJson(json);

  @JsonKey(name: 'prefix')
  final String? prefix;
  @JsonKey(name: 'given_name')
  final String? givenName;
  @JsonKey(name: 'middle_name')
  final String? middleName;
  @JsonKey(name: 'family_name')
  final String? familyName;
  @JsonKey(name: 'suffix')
  final String? suffix;
  static const fromJsonFactory = _$SignalPersonNameFromJson;
  static const toJsonFactory = _$SignalPersonNameToJson;
  Map<String, dynamic> toJson() => _$SignalPersonNameToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SignalPersonName &&
            (identical(other.prefix, prefix) ||
                const DeepCollectionEquality().equals(other.prefix, prefix)) &&
            (identical(other.givenName, givenName) ||
                const DeepCollectionEquality()
                    .equals(other.givenName, givenName)) &&
            (identical(other.middleName, middleName) ||
                const DeepCollectionEquality()
                    .equals(other.middleName, middleName)) &&
            (identical(other.familyName, familyName) ||
                const DeepCollectionEquality()
                    .equals(other.familyName, familyName)) &&
            (identical(other.suffix, suffix) ||
                const DeepCollectionEquality().equals(other.suffix, suffix)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(prefix) ^
      const DeepCollectionEquality().hash(givenName) ^
      const DeepCollectionEquality().hash(middleName) ^
      const DeepCollectionEquality().hash(familyName) ^
      const DeepCollectionEquality().hash(suffix) ^
      runtimeType.hashCode;
}

extension $SignalPersonNameExtension on SignalPersonName {
  SignalPersonName copyWith(
      {String? prefix,
      String? givenName,
      String? middleName,
      String? familyName,
      String? suffix}) {
    return SignalPersonName(
        prefix: prefix ?? this.prefix,
        givenName: givenName ?? this.givenName,
        middleName: middleName ?? this.middleName,
        familyName: familyName ?? this.familyName,
        suffix: suffix ?? this.suffix);
  }
}

@JsonSerializable(explicitToJson: true)
class SignalAddressData {
  SignalAddressData({
    this.city,
    this.region,
    this.street,
    this.postalCode,
    this.country,
  });

  factory SignalAddressData.fromJson(Map<String, dynamic> json) =>
      _$SignalAddressDataFromJson(json);

  @JsonKey(name: 'city')
  final String? city;
  @JsonKey(name: 'region')
  final String? region;
  @JsonKey(name: 'street')
  final String? street;
  @JsonKey(name: 'postal_code')
  final String? postalCode;
  @JsonKey(name: 'country')
  final String? country;
  static const fromJsonFactory = _$SignalAddressDataFromJson;
  static const toJsonFactory = _$SignalAddressDataToJson;
  Map<String, dynamic> toJson() => _$SignalAddressDataToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SignalAddressData &&
            (identical(other.city, city) ||
                const DeepCollectionEquality().equals(other.city, city)) &&
            (identical(other.region, region) ||
                const DeepCollectionEquality().equals(other.region, region)) &&
            (identical(other.street, street) ||
                const DeepCollectionEquality().equals(other.street, street)) &&
            (identical(other.postalCode, postalCode) ||
                const DeepCollectionEquality()
                    .equals(other.postalCode, postalCode)) &&
            (identical(other.country, country) ||
                const DeepCollectionEquality().equals(other.country, country)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(city) ^
      const DeepCollectionEquality().hash(region) ^
      const DeepCollectionEquality().hash(street) ^
      const DeepCollectionEquality().hash(postalCode) ^
      const DeepCollectionEquality().hash(country) ^
      runtimeType.hashCode;
}

extension $SignalAddressDataExtension on SignalAddressData {
  SignalAddressData copyWith(
      {String? city,
      String? region,
      String? street,
      String? postalCode,
      String? country}) {
    return SignalAddressData(
        city: city ?? this.city,
        region: region ?? this.region,
        street: street ?? this.street,
        postalCode: postalCode ?? this.postalCode,
        country: country ?? this.country);
  }
}

@JsonSerializable(explicitToJson: true)
class SignalDevice {
  SignalDevice({
    this.ipAddress,
    this.userAgent,
  });

  factory SignalDevice.fromJson(Map<String, dynamic> json) =>
      _$SignalDeviceFromJson(json);

  @JsonKey(name: 'ip_address')
  final String? ipAddress;
  @JsonKey(name: 'user_agent')
  final String? userAgent;
  static const fromJsonFactory = _$SignalDeviceFromJson;
  static const toJsonFactory = _$SignalDeviceToJson;
  Map<String, dynamic> toJson() => _$SignalDeviceToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SignalDevice &&
            (identical(other.ipAddress, ipAddress) ||
                const DeepCollectionEquality()
                    .equals(other.ipAddress, ipAddress)) &&
            (identical(other.userAgent, userAgent) ||
                const DeepCollectionEquality()
                    .equals(other.userAgent, userAgent)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ipAddress) ^
      const DeepCollectionEquality().hash(userAgent) ^
      runtimeType.hashCode;
}

extension $SignalDeviceExtension on SignalDevice {
  SignalDevice copyWith({String? ipAddress, String? userAgent}) {
    return SignalDevice(
        ipAddress: ipAddress ?? this.ipAddress,
        userAgent: userAgent ?? this.userAgent);
  }
}

@JsonSerializable(explicitToJson: true)
class SignalEvaluateResponse {
  SignalEvaluateResponse({
    this.requestId,
    this.scores,
    this.coreAttributes,
  });

  factory SignalEvaluateResponse.fromJson(Map<String, dynamic> json) =>
      _$SignalEvaluateResponseFromJson(json);

  @JsonKey(name: 'request_id')
  final String? requestId;
  @JsonKey(name: 'scores')
  final SignalScores? scores;
  @JsonKey(name: 'core_attributes')
  final SignalEvaluateCoreAttributes? coreAttributes;
  static const fromJsonFactory = _$SignalEvaluateResponseFromJson;
  static const toJsonFactory = _$SignalEvaluateResponseToJson;
  Map<String, dynamic> toJson() => _$SignalEvaluateResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SignalEvaluateResponse &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)) &&
            (identical(other.scores, scores) ||
                const DeepCollectionEquality().equals(other.scores, scores)) &&
            (identical(other.coreAttributes, coreAttributes) ||
                const DeepCollectionEquality()
                    .equals(other.coreAttributes, coreAttributes)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(requestId) ^
      const DeepCollectionEquality().hash(scores) ^
      const DeepCollectionEquality().hash(coreAttributes) ^
      runtimeType.hashCode;
}

extension $SignalEvaluateResponseExtension on SignalEvaluateResponse {
  SignalEvaluateResponse copyWith(
      {String? requestId,
      SignalScores? scores,
      SignalEvaluateCoreAttributes? coreAttributes}) {
    return SignalEvaluateResponse(
        requestId: requestId ?? this.requestId,
        scores: scores ?? this.scores,
        coreAttributes: coreAttributes ?? this.coreAttributes);
  }
}

@JsonSerializable(explicitToJson: true)
class SignalScores {
  SignalScores({
    this.customerInitiatedReturnRisk,
    this.bankInitiatedReturnRisk,
  });

  factory SignalScores.fromJson(Map<String, dynamic> json) =>
      _$SignalScoresFromJson(json);

  @JsonKey(name: 'customer_initiated_return_risk')
  final CustomerInitiatedReturnRisk? customerInitiatedReturnRisk;
  @JsonKey(name: 'bank_initiated_return_risk')
  final BankInitiatedReturnRisk? bankInitiatedReturnRisk;
  static const fromJsonFactory = _$SignalScoresFromJson;
  static const toJsonFactory = _$SignalScoresToJson;
  Map<String, dynamic> toJson() => _$SignalScoresToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SignalScores &&
            (identical(other.customerInitiatedReturnRisk,
                    customerInitiatedReturnRisk) ||
                const DeepCollectionEquality().equals(
                    other.customerInitiatedReturnRisk,
                    customerInitiatedReturnRisk)) &&
            (identical(
                    other.bankInitiatedReturnRisk, bankInitiatedReturnRisk) ||
                const DeepCollectionEquality().equals(
                    other.bankInitiatedReturnRisk, bankInitiatedReturnRisk)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(customerInitiatedReturnRisk) ^
      const DeepCollectionEquality().hash(bankInitiatedReturnRisk) ^
      runtimeType.hashCode;
}

extension $SignalScoresExtension on SignalScores {
  SignalScores copyWith(
      {CustomerInitiatedReturnRisk? customerInitiatedReturnRisk,
      BankInitiatedReturnRisk? bankInitiatedReturnRisk}) {
    return SignalScores(
        customerInitiatedReturnRisk:
            customerInitiatedReturnRisk ?? this.customerInitiatedReturnRisk,
        bankInitiatedReturnRisk:
            bankInitiatedReturnRisk ?? this.bankInitiatedReturnRisk);
  }
}

@JsonSerializable(explicitToJson: true)
class CustomerInitiatedReturnRisk {
  CustomerInitiatedReturnRisk({
    this.score,
    this.riskTier,
  });

  factory CustomerInitiatedReturnRisk.fromJson(Map<String, dynamic> json) =>
      _$CustomerInitiatedReturnRiskFromJson(json);

  @JsonKey(name: 'score')
  final int? score;
  @JsonKey(name: 'risk_tier')
  final int? riskTier;
  static const fromJsonFactory = _$CustomerInitiatedReturnRiskFromJson;
  static const toJsonFactory = _$CustomerInitiatedReturnRiskToJson;
  Map<String, dynamic> toJson() => _$CustomerInitiatedReturnRiskToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is CustomerInitiatedReturnRisk &&
            (identical(other.score, score) ||
                const DeepCollectionEquality().equals(other.score, score)) &&
            (identical(other.riskTier, riskTier) ||
                const DeepCollectionEquality()
                    .equals(other.riskTier, riskTier)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(score) ^
      const DeepCollectionEquality().hash(riskTier) ^
      runtimeType.hashCode;
}

extension $CustomerInitiatedReturnRiskExtension on CustomerInitiatedReturnRisk {
  CustomerInitiatedReturnRisk copyWith({int? score, int? riskTier}) {
    return CustomerInitiatedReturnRisk(
        score: score ?? this.score, riskTier: riskTier ?? this.riskTier);
  }
}

@JsonSerializable(explicitToJson: true)
class BankInitiatedReturnRisk {
  BankInitiatedReturnRisk({
    this.score,
    this.riskTier,
  });

  factory BankInitiatedReturnRisk.fromJson(Map<String, dynamic> json) =>
      _$BankInitiatedReturnRiskFromJson(json);

  @JsonKey(name: 'score')
  final int? score;
  @JsonKey(name: 'risk_tier')
  final int? riskTier;
  static const fromJsonFactory = _$BankInitiatedReturnRiskFromJson;
  static const toJsonFactory = _$BankInitiatedReturnRiskToJson;
  Map<String, dynamic> toJson() => _$BankInitiatedReturnRiskToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is BankInitiatedReturnRisk &&
            (identical(other.score, score) ||
                const DeepCollectionEquality().equals(other.score, score)) &&
            (identical(other.riskTier, riskTier) ||
                const DeepCollectionEquality()
                    .equals(other.riskTier, riskTier)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(score) ^
      const DeepCollectionEquality().hash(riskTier) ^
      runtimeType.hashCode;
}

extension $BankInitiatedReturnRiskExtension on BankInitiatedReturnRisk {
  BankInitiatedReturnRisk copyWith({int? score, int? riskTier}) {
    return BankInitiatedReturnRisk(
        score: score ?? this.score, riskTier: riskTier ?? this.riskTier);
  }
}

@JsonSerializable(explicitToJson: true)
class SignalEvaluateCoreAttributes {
  SignalEvaluateCoreAttributes({
    this.unauthorizedTransactionsCount7d,
    this.unauthorizedTransactionsCount30d,
    this.unauthorizedTransactionsCount60d,
    this.unauthorizedTransactionsCount90d,
    this.nsfOverdraftTransactionsCount7d,
    this.nsfOverdraftTransactionsCount30d,
    this.nsfOverdraftTransactionsCount60d,
    this.nsfOverdraftTransactionsCount90d,
    this.daysSinceFirstPlaidConnection,
    this.plaidConnectionsCount7d,
    this.plaidConnectionsCount30d,
    this.totalPlaidConnectionsCount,
    this.isSavingsOrMoneyMarketAccount,
    this.totalCreditTransactionsAmount10d,
    this.totalDebitTransactionsAmount10d,
    this.p50CreditTransactionsAmount28d,
    this.p50DebitTransactionsAmount28d,
    this.p95CreditTransactionsAmount28d,
    this.p95DebitTransactionsAmount28d,
    this.daysWithNegativeBalanceCount90d,
    this.p90EodBalance30d,
    this.p90EodBalance60d,
    this.p90EodBalance90d,
    this.p10EodBalance30d,
    this.p10EodBalance60d,
    this.p10EodBalance90d,
    this.availableBalance,
    this.currentBalance,
    this.balanceLastUpdated,
    this.phoneChangeCount28d,
    this.phoneChangeCount90d,
    this.emailChangeCount28d,
    this.emailChangeCount90d,
    this.addressChangeCount28d,
    this.addressChangeCount90d,
  });

  factory SignalEvaluateCoreAttributes.fromJson(Map<String, dynamic> json) =>
      _$SignalEvaluateCoreAttributesFromJson(json);

  @JsonKey(name: 'unauthorized_transactions_count_7d')
  final int? unauthorizedTransactionsCount7d;
  @JsonKey(name: 'unauthorized_transactions_count_30d')
  final int? unauthorizedTransactionsCount30d;
  @JsonKey(name: 'unauthorized_transactions_count_60d')
  final int? unauthorizedTransactionsCount60d;
  @JsonKey(name: 'unauthorized_transactions_count_90d')
  final int? unauthorizedTransactionsCount90d;
  @JsonKey(name: 'nsf_overdraft_transactions_count_7d')
  final int? nsfOverdraftTransactionsCount7d;
  @JsonKey(name: 'nsf_overdraft_transactions_count_30d')
  final int? nsfOverdraftTransactionsCount30d;
  @JsonKey(name: 'nsf_overdraft_transactions_count_60d')
  final int? nsfOverdraftTransactionsCount60d;
  @JsonKey(name: 'nsf_overdraft_transactions_count_90d')
  final int? nsfOverdraftTransactionsCount90d;
  @JsonKey(name: 'days_since_first_plaid_connection')
  final int? daysSinceFirstPlaidConnection;
  @JsonKey(name: 'plaid_connections_count_7d')
  final int? plaidConnectionsCount7d;
  @JsonKey(name: 'plaid_connections_count_30d')
  final int? plaidConnectionsCount30d;
  @JsonKey(name: 'total_plaid_connections_count')
  final int? totalPlaidConnectionsCount;
  @JsonKey(name: 'is_savings_or_money_market_account')
  final bool? isSavingsOrMoneyMarketAccount;
  @JsonKey(name: 'total_credit_transactions_amount_10d')
  final double? totalCreditTransactionsAmount10d;
  @JsonKey(name: 'total_debit_transactions_amount_10d')
  final double? totalDebitTransactionsAmount10d;
  @JsonKey(name: 'p50_credit_transactions_amount_28d')
  final double? p50CreditTransactionsAmount28d;
  @JsonKey(name: 'p50_debit_transactions_amount_28d')
  final double? p50DebitTransactionsAmount28d;
  @JsonKey(name: 'p95_credit_transactions_amount_28d')
  final double? p95CreditTransactionsAmount28d;
  @JsonKey(name: 'p95_debit_transactions_amount_28d')
  final double? p95DebitTransactionsAmount28d;
  @JsonKey(name: 'days_with_negative_balance_count_90d')
  final int? daysWithNegativeBalanceCount90d;
  @JsonKey(name: 'p90_eod_balance_30d')
  final double? p90EodBalance30d;
  @JsonKey(name: 'p90_eod_balance_60d')
  final double? p90EodBalance60d;
  @JsonKey(name: 'p90_eod_balance_90d')
  final double? p90EodBalance90d;
  @JsonKey(name: 'p10_eod_balance_30d')
  final double? p10EodBalance30d;
  @JsonKey(name: 'p10_eod_balance_60d')
  final double? p10EodBalance60d;
  @JsonKey(name: 'p10_eod_balance_90d')
  final double? p10EodBalance90d;
  @JsonKey(name: 'available_balance')
  final double? availableBalance;
  @JsonKey(name: 'current_balance')
  final double? currentBalance;
  @JsonKey(name: 'balance_last_updated')
  final DateTime? balanceLastUpdated;
  @JsonKey(name: 'phone_change_count_28d')
  final int? phoneChangeCount28d;
  @JsonKey(name: 'phone_change_count_90d')
  final int? phoneChangeCount90d;
  @JsonKey(name: 'email_change_count_28d')
  final int? emailChangeCount28d;
  @JsonKey(name: 'email_change_count_90d')
  final int? emailChangeCount90d;
  @JsonKey(name: 'address_change_count_28d')
  final int? addressChangeCount28d;
  @JsonKey(name: 'address_change_count_90d')
  final int? addressChangeCount90d;
  static const fromJsonFactory = _$SignalEvaluateCoreAttributesFromJson;
  static const toJsonFactory = _$SignalEvaluateCoreAttributesToJson;
  Map<String, dynamic> toJson() => _$SignalEvaluateCoreAttributesToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SignalEvaluateCoreAttributes &&
            (identical(other.unauthorizedTransactionsCount7d, unauthorizedTransactionsCount7d) ||
                const DeepCollectionEquality().equals(
                    other.unauthorizedTransactionsCount7d,
                    unauthorizedTransactionsCount7d)) &&
            (identical(other.unauthorizedTransactionsCount30d, unauthorizedTransactionsCount30d) ||
                const DeepCollectionEquality().equals(
                    other.unauthorizedTransactionsCount30d,
                    unauthorizedTransactionsCount30d)) &&
            (identical(other.unauthorizedTransactionsCount60d, unauthorizedTransactionsCount60d) ||
                const DeepCollectionEquality().equals(
                    other.unauthorizedTransactionsCount60d,
                    unauthorizedTransactionsCount60d)) &&
            (identical(other.unauthorizedTransactionsCount90d, unauthorizedTransactionsCount90d) ||
                const DeepCollectionEquality().equals(
                    other.unauthorizedTransactionsCount90d,
                    unauthorizedTransactionsCount90d)) &&
            (identical(other.nsfOverdraftTransactionsCount7d, nsfOverdraftTransactionsCount7d) ||
                const DeepCollectionEquality().equals(
                    other.nsfOverdraftTransactionsCount7d,
                    nsfOverdraftTransactionsCount7d)) &&
            (identical(other.nsfOverdraftTransactionsCount30d, nsfOverdraftTransactionsCount30d) ||
                const DeepCollectionEquality().equals(
                    other.nsfOverdraftTransactionsCount30d,
                    nsfOverdraftTransactionsCount30d)) &&
            (identical(other.nsfOverdraftTransactionsCount60d, nsfOverdraftTransactionsCount60d) ||
                const DeepCollectionEquality().equals(
                    other.nsfOverdraftTransactionsCount60d,
                    nsfOverdraftTransactionsCount60d)) &&
            (identical(other.nsfOverdraftTransactionsCount90d, nsfOverdraftTransactionsCount90d) ||
                const DeepCollectionEquality().equals(
                    other.nsfOverdraftTransactionsCount90d,
                    nsfOverdraftTransactionsCount90d)) &&
            (identical(other.daysSinceFirstPlaidConnection, daysSinceFirstPlaidConnection) ||
                const DeepCollectionEquality().equals(
                    other.daysSinceFirstPlaidConnection,
                    daysSinceFirstPlaidConnection)) &&
            (identical(other.plaidConnectionsCount7d, plaidConnectionsCount7d) ||
                const DeepCollectionEquality().equals(other.plaidConnectionsCount7d, plaidConnectionsCount7d)) &&
            (identical(other.plaidConnectionsCount30d, plaidConnectionsCount30d) || const DeepCollectionEquality().equals(other.plaidConnectionsCount30d, plaidConnectionsCount30d)) &&
            (identical(other.totalPlaidConnectionsCount, totalPlaidConnectionsCount) || const DeepCollectionEquality().equals(other.totalPlaidConnectionsCount, totalPlaidConnectionsCount)) &&
            (identical(other.isSavingsOrMoneyMarketAccount, isSavingsOrMoneyMarketAccount) || const DeepCollectionEquality().equals(other.isSavingsOrMoneyMarketAccount, isSavingsOrMoneyMarketAccount)) &&
            (identical(other.totalCreditTransactionsAmount10d, totalCreditTransactionsAmount10d) || const DeepCollectionEquality().equals(other.totalCreditTransactionsAmount10d, totalCreditTransactionsAmount10d)) &&
            (identical(other.totalDebitTransactionsAmount10d, totalDebitTransactionsAmount10d) || const DeepCollectionEquality().equals(other.totalDebitTransactionsAmount10d, totalDebitTransactionsAmount10d)) &&
            (identical(other.p50CreditTransactionsAmount28d, p50CreditTransactionsAmount28d) || const DeepCollectionEquality().equals(other.p50CreditTransactionsAmount28d, p50CreditTransactionsAmount28d)) &&
            (identical(other.p50DebitTransactionsAmount28d, p50DebitTransactionsAmount28d) || const DeepCollectionEquality().equals(other.p50DebitTransactionsAmount28d, p50DebitTransactionsAmount28d)) &&
            (identical(other.p95CreditTransactionsAmount28d, p95CreditTransactionsAmount28d) || const DeepCollectionEquality().equals(other.p95CreditTransactionsAmount28d, p95CreditTransactionsAmount28d)) &&
            (identical(other.p95DebitTransactionsAmount28d, p95DebitTransactionsAmount28d) || const DeepCollectionEquality().equals(other.p95DebitTransactionsAmount28d, p95DebitTransactionsAmount28d)) &&
            (identical(other.daysWithNegativeBalanceCount90d, daysWithNegativeBalanceCount90d) || const DeepCollectionEquality().equals(other.daysWithNegativeBalanceCount90d, daysWithNegativeBalanceCount90d)) &&
            (identical(other.p90EodBalance30d, p90EodBalance30d) || const DeepCollectionEquality().equals(other.p90EodBalance30d, p90EodBalance30d)) &&
            (identical(other.p90EodBalance60d, p90EodBalance60d) || const DeepCollectionEquality().equals(other.p90EodBalance60d, p90EodBalance60d)) &&
            (identical(other.p90EodBalance90d, p90EodBalance90d) || const DeepCollectionEquality().equals(other.p90EodBalance90d, p90EodBalance90d)) &&
            (identical(other.p10EodBalance30d, p10EodBalance30d) || const DeepCollectionEquality().equals(other.p10EodBalance30d, p10EodBalance30d)) &&
            (identical(other.p10EodBalance60d, p10EodBalance60d) || const DeepCollectionEquality().equals(other.p10EodBalance60d, p10EodBalance60d)) &&
            (identical(other.p10EodBalance90d, p10EodBalance90d) || const DeepCollectionEquality().equals(other.p10EodBalance90d, p10EodBalance90d)) &&
            (identical(other.availableBalance, availableBalance) || const DeepCollectionEquality().equals(other.availableBalance, availableBalance)) &&
            (identical(other.currentBalance, currentBalance) || const DeepCollectionEquality().equals(other.currentBalance, currentBalance)) &&
            (identical(other.balanceLastUpdated, balanceLastUpdated) || const DeepCollectionEquality().equals(other.balanceLastUpdated, balanceLastUpdated)) &&
            (identical(other.phoneChangeCount28d, phoneChangeCount28d) || const DeepCollectionEquality().equals(other.phoneChangeCount28d, phoneChangeCount28d)) &&
            (identical(other.phoneChangeCount90d, phoneChangeCount90d) || const DeepCollectionEquality().equals(other.phoneChangeCount90d, phoneChangeCount90d)) &&
            (identical(other.emailChangeCount28d, emailChangeCount28d) || const DeepCollectionEquality().equals(other.emailChangeCount28d, emailChangeCount28d)) &&
            (identical(other.emailChangeCount90d, emailChangeCount90d) || const DeepCollectionEquality().equals(other.emailChangeCount90d, emailChangeCount90d)) &&
            (identical(other.addressChangeCount28d, addressChangeCount28d) || const DeepCollectionEquality().equals(other.addressChangeCount28d, addressChangeCount28d)) &&
            (identical(other.addressChangeCount90d, addressChangeCount90d) || const DeepCollectionEquality().equals(other.addressChangeCount90d, addressChangeCount90d)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(unauthorizedTransactionsCount7d) ^
      const DeepCollectionEquality().hash(unauthorizedTransactionsCount30d) ^
      const DeepCollectionEquality().hash(unauthorizedTransactionsCount60d) ^
      const DeepCollectionEquality().hash(unauthorizedTransactionsCount90d) ^
      const DeepCollectionEquality().hash(nsfOverdraftTransactionsCount7d) ^
      const DeepCollectionEquality().hash(nsfOverdraftTransactionsCount30d) ^
      const DeepCollectionEquality().hash(nsfOverdraftTransactionsCount60d) ^
      const DeepCollectionEquality().hash(nsfOverdraftTransactionsCount90d) ^
      const DeepCollectionEquality().hash(daysSinceFirstPlaidConnection) ^
      const DeepCollectionEquality().hash(plaidConnectionsCount7d) ^
      const DeepCollectionEquality().hash(plaidConnectionsCount30d) ^
      const DeepCollectionEquality().hash(totalPlaidConnectionsCount) ^
      const DeepCollectionEquality().hash(isSavingsOrMoneyMarketAccount) ^
      const DeepCollectionEquality().hash(totalCreditTransactionsAmount10d) ^
      const DeepCollectionEquality().hash(totalDebitTransactionsAmount10d) ^
      const DeepCollectionEquality().hash(p50CreditTransactionsAmount28d) ^
      const DeepCollectionEquality().hash(p50DebitTransactionsAmount28d) ^
      const DeepCollectionEquality().hash(p95CreditTransactionsAmount28d) ^
      const DeepCollectionEquality().hash(p95DebitTransactionsAmount28d) ^
      const DeepCollectionEquality().hash(daysWithNegativeBalanceCount90d) ^
      const DeepCollectionEquality().hash(p90EodBalance30d) ^
      const DeepCollectionEquality().hash(p90EodBalance60d) ^
      const DeepCollectionEquality().hash(p90EodBalance90d) ^
      const DeepCollectionEquality().hash(p10EodBalance30d) ^
      const DeepCollectionEquality().hash(p10EodBalance60d) ^
      const DeepCollectionEquality().hash(p10EodBalance90d) ^
      const DeepCollectionEquality().hash(availableBalance) ^
      const DeepCollectionEquality().hash(currentBalance) ^
      const DeepCollectionEquality().hash(balanceLastUpdated) ^
      const DeepCollectionEquality().hash(phoneChangeCount28d) ^
      const DeepCollectionEquality().hash(phoneChangeCount90d) ^
      const DeepCollectionEquality().hash(emailChangeCount28d) ^
      const DeepCollectionEquality().hash(emailChangeCount90d) ^
      const DeepCollectionEquality().hash(addressChangeCount28d) ^
      const DeepCollectionEquality().hash(addressChangeCount90d) ^
      runtimeType.hashCode;
}

extension $SignalEvaluateCoreAttributesExtension
    on SignalEvaluateCoreAttributes {
  SignalEvaluateCoreAttributes copyWith(
      {int? unauthorizedTransactionsCount7d,
      int? unauthorizedTransactionsCount30d,
      int? unauthorizedTransactionsCount60d,
      int? unauthorizedTransactionsCount90d,
      int? nsfOverdraftTransactionsCount7d,
      int? nsfOverdraftTransactionsCount30d,
      int? nsfOverdraftTransactionsCount60d,
      int? nsfOverdraftTransactionsCount90d,
      int? daysSinceFirstPlaidConnection,
      int? plaidConnectionsCount7d,
      int? plaidConnectionsCount30d,
      int? totalPlaidConnectionsCount,
      bool? isSavingsOrMoneyMarketAccount,
      double? totalCreditTransactionsAmount10d,
      double? totalDebitTransactionsAmount10d,
      double? p50CreditTransactionsAmount28d,
      double? p50DebitTransactionsAmount28d,
      double? p95CreditTransactionsAmount28d,
      double? p95DebitTransactionsAmount28d,
      int? daysWithNegativeBalanceCount90d,
      double? p90EodBalance30d,
      double? p90EodBalance60d,
      double? p90EodBalance90d,
      double? p10EodBalance30d,
      double? p10EodBalance60d,
      double? p10EodBalance90d,
      double? availableBalance,
      double? currentBalance,
      DateTime? balanceLastUpdated,
      int? phoneChangeCount28d,
      int? phoneChangeCount90d,
      int? emailChangeCount28d,
      int? emailChangeCount90d,
      int? addressChangeCount28d,
      int? addressChangeCount90d}) {
    return SignalEvaluateCoreAttributes(
        unauthorizedTransactionsCount7d: unauthorizedTransactionsCount7d ??
            this.unauthorizedTransactionsCount7d,
        unauthorizedTransactionsCount30d: unauthorizedTransactionsCount30d ??
            this.unauthorizedTransactionsCount30d,
        unauthorizedTransactionsCount60d: unauthorizedTransactionsCount60d ??
            this.unauthorizedTransactionsCount60d,
        unauthorizedTransactionsCount90d: unauthorizedTransactionsCount90d ??
            this.unauthorizedTransactionsCount90d,
        nsfOverdraftTransactionsCount7d: nsfOverdraftTransactionsCount7d ??
            this.nsfOverdraftTransactionsCount7d,
        nsfOverdraftTransactionsCount30d: nsfOverdraftTransactionsCount30d ??
            this.nsfOverdraftTransactionsCount30d,
        nsfOverdraftTransactionsCount60d: nsfOverdraftTransactionsCount60d ??
            this.nsfOverdraftTransactionsCount60d,
        nsfOverdraftTransactionsCount90d: nsfOverdraftTransactionsCount90d ??
            this.nsfOverdraftTransactionsCount90d,
        daysSinceFirstPlaidConnection:
            daysSinceFirstPlaidConnection ?? this.daysSinceFirstPlaidConnection,
        plaidConnectionsCount7d:
            plaidConnectionsCount7d ?? this.plaidConnectionsCount7d,
        plaidConnectionsCount30d:
            plaidConnectionsCount30d ?? this.plaidConnectionsCount30d,
        totalPlaidConnectionsCount:
            totalPlaidConnectionsCount ?? this.totalPlaidConnectionsCount,
        isSavingsOrMoneyMarketAccount:
            isSavingsOrMoneyMarketAccount ?? this.isSavingsOrMoneyMarketAccount,
        totalCreditTransactionsAmount10d: totalCreditTransactionsAmount10d ??
            this.totalCreditTransactionsAmount10d,
        totalDebitTransactionsAmount10d: totalDebitTransactionsAmount10d ??
            this.totalDebitTransactionsAmount10d,
        p50CreditTransactionsAmount28d: p50CreditTransactionsAmount28d ??
            this.p50CreditTransactionsAmount28d,
        p50DebitTransactionsAmount28d:
            p50DebitTransactionsAmount28d ?? this.p50DebitTransactionsAmount28d,
        p95CreditTransactionsAmount28d: p95CreditTransactionsAmount28d ??
            this.p95CreditTransactionsAmount28d,
        p95DebitTransactionsAmount28d:
            p95DebitTransactionsAmount28d ?? this.p95DebitTransactionsAmount28d,
        daysWithNegativeBalanceCount90d: daysWithNegativeBalanceCount90d ??
            this.daysWithNegativeBalanceCount90d,
        p90EodBalance30d: p90EodBalance30d ?? this.p90EodBalance30d,
        p90EodBalance60d: p90EodBalance60d ?? this.p90EodBalance60d,
        p90EodBalance90d: p90EodBalance90d ?? this.p90EodBalance90d,
        p10EodBalance30d: p10EodBalance30d ?? this.p10EodBalance30d,
        p10EodBalance60d: p10EodBalance60d ?? this.p10EodBalance60d,
        p10EodBalance90d: p10EodBalance90d ?? this.p10EodBalance90d,
        availableBalance: availableBalance ?? this.availableBalance,
        currentBalance: currentBalance ?? this.currentBalance,
        balanceLastUpdated: balanceLastUpdated ?? this.balanceLastUpdated,
        phoneChangeCount28d: phoneChangeCount28d ?? this.phoneChangeCount28d,
        phoneChangeCount90d: phoneChangeCount90d ?? this.phoneChangeCount90d,
        emailChangeCount28d: emailChangeCount28d ?? this.emailChangeCount28d,
        emailChangeCount90d: emailChangeCount90d ?? this.emailChangeCount90d,
        addressChangeCount28d:
            addressChangeCount28d ?? this.addressChangeCount28d,
        addressChangeCount90d:
            addressChangeCount90d ?? this.addressChangeCount90d);
  }
}

@JsonSerializable(explicitToJson: true)
class SignalDecisionReportRequest {
  SignalDecisionReportRequest({
    this.clientId,
    this.secret,
    this.clientTransactionId,
    this.initiated,
    this.daysFundsOnHold,
  });

  factory SignalDecisionReportRequest.fromJson(Map<String, dynamic> json) =>
      _$SignalDecisionReportRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'client_transaction_id')
  final String? clientTransactionId;
  @JsonKey(name: 'initiated')
  final bool? initiated;
  @JsonKey(name: 'days_funds_on_hold')
  final int? daysFundsOnHold;
  static const fromJsonFactory = _$SignalDecisionReportRequestFromJson;
  static const toJsonFactory = _$SignalDecisionReportRequestToJson;
  Map<String, dynamic> toJson() => _$SignalDecisionReportRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SignalDecisionReportRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.clientTransactionId, clientTransactionId) ||
                const DeepCollectionEquality()
                    .equals(other.clientTransactionId, clientTransactionId)) &&
            (identical(other.initiated, initiated) ||
                const DeepCollectionEquality()
                    .equals(other.initiated, initiated)) &&
            (identical(other.daysFundsOnHold, daysFundsOnHold) ||
                const DeepCollectionEquality()
                    .equals(other.daysFundsOnHold, daysFundsOnHold)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(clientTransactionId) ^
      const DeepCollectionEquality().hash(initiated) ^
      const DeepCollectionEquality().hash(daysFundsOnHold) ^
      runtimeType.hashCode;
}

extension $SignalDecisionReportRequestExtension on SignalDecisionReportRequest {
  SignalDecisionReportRequest copyWith(
      {String? clientId,
      String? secret,
      String? clientTransactionId,
      bool? initiated,
      int? daysFundsOnHold}) {
    return SignalDecisionReportRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        clientTransactionId: clientTransactionId ?? this.clientTransactionId,
        initiated: initiated ?? this.initiated,
        daysFundsOnHold: daysFundsOnHold ?? this.daysFundsOnHold);
  }
}

@JsonSerializable(explicitToJson: true)
class SignalDecisionReportResponse {
  SignalDecisionReportResponse({
    this.requestId,
  });

  factory SignalDecisionReportResponse.fromJson(Map<String, dynamic> json) =>
      _$SignalDecisionReportResponseFromJson(json);

  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$SignalDecisionReportResponseFromJson;
  static const toJsonFactory = _$SignalDecisionReportResponseToJson;
  Map<String, dynamic> toJson() => _$SignalDecisionReportResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SignalDecisionReportResponse &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(requestId) ^ runtimeType.hashCode;
}

extension $SignalDecisionReportResponseExtension
    on SignalDecisionReportResponse {
  SignalDecisionReportResponse copyWith({String? requestId}) {
    return SignalDecisionReportResponse(requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class SignalReturnReportRequest {
  SignalReturnReportRequest({
    this.clientId,
    this.secret,
    this.clientTransactionId,
    this.returnCode,
  });

  factory SignalReturnReportRequest.fromJson(Map<String, dynamic> json) =>
      _$SignalReturnReportRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'client_transaction_id')
  final String? clientTransactionId;
  @JsonKey(name: 'return_code')
  final String? returnCode;
  static const fromJsonFactory = _$SignalReturnReportRequestFromJson;
  static const toJsonFactory = _$SignalReturnReportRequestToJson;
  Map<String, dynamic> toJson() => _$SignalReturnReportRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SignalReturnReportRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.clientTransactionId, clientTransactionId) ||
                const DeepCollectionEquality()
                    .equals(other.clientTransactionId, clientTransactionId)) &&
            (identical(other.returnCode, returnCode) ||
                const DeepCollectionEquality()
                    .equals(other.returnCode, returnCode)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(clientTransactionId) ^
      const DeepCollectionEquality().hash(returnCode) ^
      runtimeType.hashCode;
}

extension $SignalReturnReportRequestExtension on SignalReturnReportRequest {
  SignalReturnReportRequest copyWith(
      {String? clientId,
      String? secret,
      String? clientTransactionId,
      String? returnCode}) {
    return SignalReturnReportRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        clientTransactionId: clientTransactionId ?? this.clientTransactionId,
        returnCode: returnCode ?? this.returnCode);
  }
}

@JsonSerializable(explicitToJson: true)
class SignalReturnReportResponse {
  SignalReturnReportResponse({
    this.requestId,
  });

  factory SignalReturnReportResponse.fromJson(Map<String, dynamic> json) =>
      _$SignalReturnReportResponseFromJson(json);

  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$SignalReturnReportResponseFromJson;
  static const toJsonFactory = _$SignalReturnReportResponseToJson;
  Map<String, dynamic> toJson() => _$SignalReturnReportResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SignalReturnReportResponse &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(requestId) ^ runtimeType.hashCode;
}

extension $SignalReturnReportResponseExtension on SignalReturnReportResponse {
  SignalReturnReportResponse copyWith({String? requestId}) {
    return SignalReturnReportResponse(requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class SandboxOauthSelectAccountsRequest {
  SandboxOauthSelectAccountsRequest({
    this.oauthStateId,
    this.accounts,
  });

  factory SandboxOauthSelectAccountsRequest.fromJson(
          Map<String, dynamic> json) =>
      _$SandboxOauthSelectAccountsRequestFromJson(json);

  @JsonKey(name: 'oauth_state_id')
  final String? oauthStateId;
  @JsonKey(name: 'accounts', defaultValue: <String>[])
  final List<String>? accounts;
  static const fromJsonFactory = _$SandboxOauthSelectAccountsRequestFromJson;
  static const toJsonFactory = _$SandboxOauthSelectAccountsRequestToJson;
  Map<String, dynamic> toJson() =>
      _$SandboxOauthSelectAccountsRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SandboxOauthSelectAccountsRequest &&
            (identical(other.oauthStateId, oauthStateId) ||
                const DeepCollectionEquality()
                    .equals(other.oauthStateId, oauthStateId)) &&
            (identical(other.accounts, accounts) ||
                const DeepCollectionEquality()
                    .equals(other.accounts, accounts)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(oauthStateId) ^
      const DeepCollectionEquality().hash(accounts) ^
      runtimeType.hashCode;
}

extension $SandboxOauthSelectAccountsRequestExtension
    on SandboxOauthSelectAccountsRequest {
  SandboxOauthSelectAccountsRequest copyWith(
      {String? oauthStateId, List<String>? accounts}) {
    return SandboxOauthSelectAccountsRequest(
        oauthStateId: oauthStateId ?? this.oauthStateId,
        accounts: accounts ?? this.accounts);
  }
}

@JsonSerializable(explicitToJson: true)
class SandboxOauthSelectAccountsResponse {
  SandboxOauthSelectAccountsResponse();

  factory SandboxOauthSelectAccountsResponse.fromJson(
          Map<String, dynamic> json) =>
      _$SandboxOauthSelectAccountsResponseFromJson(json);

  static const fromJsonFactory = _$SandboxOauthSelectAccountsResponseFromJson;
  static const toJsonFactory = _$SandboxOauthSelectAccountsResponseToJson;
  Map<String, dynamic> toJson() =>
      _$SandboxOauthSelectAccountsResponseToJson(this);

  @override
  int get hashCode => runtimeType.hashCode;
}

@JsonSerializable(explicitToJson: true)
class NewAccountsAvailableWebhook {
  NewAccountsAvailableWebhook({
    this.webhookType,
    this.webhookCode,
    this.itemId,
    this.error,
  });

  factory NewAccountsAvailableWebhook.fromJson(Map<String, dynamic> json) =>
      _$NewAccountsAvailableWebhookFromJson(json);

  @JsonKey(name: 'webhook_type')
  final String? webhookType;
  @JsonKey(name: 'webhook_code')
  final String? webhookCode;
  @JsonKey(name: 'item_id')
  final String? itemId;
  @JsonKey(name: 'error')
  final Error? error;
  static const fromJsonFactory = _$NewAccountsAvailableWebhookFromJson;
  static const toJsonFactory = _$NewAccountsAvailableWebhookToJson;
  Map<String, dynamic> toJson() => _$NewAccountsAvailableWebhookToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is NewAccountsAvailableWebhook &&
            (identical(other.webhookType, webhookType) ||
                const DeepCollectionEquality()
                    .equals(other.webhookType, webhookType)) &&
            (identical(other.webhookCode, webhookCode) ||
                const DeepCollectionEquality()
                    .equals(other.webhookCode, webhookCode)) &&
            (identical(other.itemId, itemId) ||
                const DeepCollectionEquality().equals(other.itemId, itemId)) &&
            (identical(other.error, error) ||
                const DeepCollectionEquality().equals(other.error, error)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(webhookType) ^
      const DeepCollectionEquality().hash(webhookCode) ^
      const DeepCollectionEquality().hash(itemId) ^
      const DeepCollectionEquality().hash(error) ^
      runtimeType.hashCode;
}

extension $NewAccountsAvailableWebhookExtension on NewAccountsAvailableWebhook {
  NewAccountsAvailableWebhook copyWith(
      {String? webhookType,
      String? webhookCode,
      String? itemId,
      Error? error}) {
    return NewAccountsAvailableWebhook(
        webhookType: webhookType ?? this.webhookType,
        webhookCode: webhookCode ?? this.webhookCode,
        itemId: itemId ?? this.itemId,
        error: error ?? this.error);
  }
}

@JsonSerializable(explicitToJson: true)
class WalletGetRequest {
  WalletGetRequest({
    this.clientId,
    this.secret,
    this.walletId,
  });

  factory WalletGetRequest.fromJson(Map<String, dynamic> json) =>
      _$WalletGetRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'wallet_id')
  final String? walletId;
  static const fromJsonFactory = _$WalletGetRequestFromJson;
  static const toJsonFactory = _$WalletGetRequestToJson;
  Map<String, dynamic> toJson() => _$WalletGetRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WalletGetRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.walletId, walletId) ||
                const DeepCollectionEquality()
                    .equals(other.walletId, walletId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(walletId) ^
      runtimeType.hashCode;
}

extension $WalletGetRequestExtension on WalletGetRequest {
  WalletGetRequest copyWith(
      {String? clientId, String? secret, String? walletId}) {
    return WalletGetRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        walletId: walletId ?? this.walletId);
  }
}

@JsonSerializable(explicitToJson: true)
class WalletGetResponse {
  WalletGetResponse({
    this.walletId,
    this.balance,
    this.requestId,
  });

  factory WalletGetResponse.fromJson(Map<String, dynamic> json) =>
      _$WalletGetResponseFromJson(json);

  @JsonKey(name: 'wallet_id')
  final String? walletId;
  @JsonKey(name: 'balance')
  final WalletBalance? balance;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$WalletGetResponseFromJson;
  static const toJsonFactory = _$WalletGetResponseToJson;
  Map<String, dynamic> toJson() => _$WalletGetResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WalletGetResponse &&
            (identical(other.walletId, walletId) ||
                const DeepCollectionEquality()
                    .equals(other.walletId, walletId)) &&
            (identical(other.balance, balance) ||
                const DeepCollectionEquality()
                    .equals(other.balance, balance)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(walletId) ^
      const DeepCollectionEquality().hash(balance) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $WalletGetResponseExtension on WalletGetResponse {
  WalletGetResponse copyWith(
      {String? walletId, WalletBalance? balance, String? requestId}) {
    return WalletGetResponse(
        walletId: walletId ?? this.walletId,
        balance: balance ?? this.balance,
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class WalletBalance {
  WalletBalance({
    this.isoCurrencyCode,
    this.current,
  });

  factory WalletBalance.fromJson(Map<String, dynamic> json) =>
      _$WalletBalanceFromJson(json);

  @JsonKey(name: 'iso_currency_code')
  final String? isoCurrencyCode;
  @JsonKey(name: 'current')
  final double? current;
  static const fromJsonFactory = _$WalletBalanceFromJson;
  static const toJsonFactory = _$WalletBalanceToJson;
  Map<String, dynamic> toJson() => _$WalletBalanceToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WalletBalance &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)) &&
            (identical(other.current, current) ||
                const DeepCollectionEquality().equals(other.current, current)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      const DeepCollectionEquality().hash(current) ^
      runtimeType.hashCode;
}

extension $WalletBalanceExtension on WalletBalance {
  WalletBalance copyWith({String? isoCurrencyCode, double? current}) {
    return WalletBalance(
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode,
        current: current ?? this.current);
  }
}

@JsonSerializable(explicitToJson: true)
class WalletTransactionExecuteRequest {
  WalletTransactionExecuteRequest({
    this.clientId,
    this.secret,
    this.idempotencyKey,
    this.walletId,
    this.counterparty,
    this.amount,
    this.reference,
  });

  factory WalletTransactionExecuteRequest.fromJson(Map<String, dynamic> json) =>
      _$WalletTransactionExecuteRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'idempotency_key')
  final String? idempotencyKey;
  @JsonKey(name: 'wallet_id')
  final String? walletId;
  @JsonKey(name: 'counterparty')
  final WalletTransactionCounterparty? counterparty;
  @JsonKey(name: 'amount')
  final WalletTransactionAmount? amount;
  @JsonKey(name: 'reference')
  final String? reference;
  static const fromJsonFactory = _$WalletTransactionExecuteRequestFromJson;
  static const toJsonFactory = _$WalletTransactionExecuteRequestToJson;
  Map<String, dynamic> toJson() =>
      _$WalletTransactionExecuteRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WalletTransactionExecuteRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.idempotencyKey, idempotencyKey) ||
                const DeepCollectionEquality()
                    .equals(other.idempotencyKey, idempotencyKey)) &&
            (identical(other.walletId, walletId) ||
                const DeepCollectionEquality()
                    .equals(other.walletId, walletId)) &&
            (identical(other.counterparty, counterparty) ||
                const DeepCollectionEquality()
                    .equals(other.counterparty, counterparty)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.reference, reference) ||
                const DeepCollectionEquality()
                    .equals(other.reference, reference)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(idempotencyKey) ^
      const DeepCollectionEquality().hash(walletId) ^
      const DeepCollectionEquality().hash(counterparty) ^
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(reference) ^
      runtimeType.hashCode;
}

extension $WalletTransactionExecuteRequestExtension
    on WalletTransactionExecuteRequest {
  WalletTransactionExecuteRequest copyWith(
      {String? clientId,
      String? secret,
      String? idempotencyKey,
      String? walletId,
      WalletTransactionCounterparty? counterparty,
      WalletTransactionAmount? amount,
      String? reference}) {
    return WalletTransactionExecuteRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        idempotencyKey: idempotencyKey ?? this.idempotencyKey,
        walletId: walletId ?? this.walletId,
        counterparty: counterparty ?? this.counterparty,
        amount: amount ?? this.amount,
        reference: reference ?? this.reference);
  }
}

@JsonSerializable(explicitToJson: true)
class WalletTransactionCounterparty {
  WalletTransactionCounterparty({
    this.name,
    this.numbers,
  });

  factory WalletTransactionCounterparty.fromJson(Map<String, dynamic> json) =>
      _$WalletTransactionCounterpartyFromJson(json);

  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'numbers')
  final WalletTransactionCounterpartyNumbers? numbers;
  static const fromJsonFactory = _$WalletTransactionCounterpartyFromJson;
  static const toJsonFactory = _$WalletTransactionCounterpartyToJson;
  Map<String, dynamic> toJson() => _$WalletTransactionCounterpartyToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WalletTransactionCounterparty &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.numbers, numbers) ||
                const DeepCollectionEquality().equals(other.numbers, numbers)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(numbers) ^
      runtimeType.hashCode;
}

extension $WalletTransactionCounterpartyExtension
    on WalletTransactionCounterparty {
  WalletTransactionCounterparty copyWith(
      {String? name, WalletTransactionCounterpartyNumbers? numbers}) {
    return WalletTransactionCounterparty(
        name: name ?? this.name, numbers: numbers ?? this.numbers);
  }
}

@JsonSerializable(explicitToJson: true)
class WalletTransactionCounterpartyNumbers {
  WalletTransactionCounterpartyNumbers({
    this.bacs,
  });

  factory WalletTransactionCounterpartyNumbers.fromJson(
          Map<String, dynamic> json) =>
      _$WalletTransactionCounterpartyNumbersFromJson(json);

  @JsonKey(name: 'bacs')
  final WalletTransactionCounterpartyBACS? bacs;
  static const fromJsonFactory = _$WalletTransactionCounterpartyNumbersFromJson;
  static const toJsonFactory = _$WalletTransactionCounterpartyNumbersToJson;
  Map<String, dynamic> toJson() =>
      _$WalletTransactionCounterpartyNumbersToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WalletTransactionCounterpartyNumbers &&
            (identical(other.bacs, bacs) ||
                const DeepCollectionEquality().equals(other.bacs, bacs)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(bacs) ^ runtimeType.hashCode;
}

extension $WalletTransactionCounterpartyNumbersExtension
    on WalletTransactionCounterpartyNumbers {
  WalletTransactionCounterpartyNumbers copyWith(
      {WalletTransactionCounterpartyBACS? bacs}) {
    return WalletTransactionCounterpartyNumbers(bacs: bacs ?? this.bacs);
  }
}

@JsonSerializable(explicitToJson: true)
class WalletTransactionCounterpartyBACS {
  WalletTransactionCounterpartyBACS();

  factory WalletTransactionCounterpartyBACS.fromJson(
          Map<String, dynamic> json) =>
      _$WalletTransactionCounterpartyBACSFromJson(json);

  static const fromJsonFactory = _$WalletTransactionCounterpartyBACSFromJson;
  static const toJsonFactory = _$WalletTransactionCounterpartyBACSToJson;
  Map<String, dynamic> toJson() =>
      _$WalletTransactionCounterpartyBACSToJson(this);

  @override
  int get hashCode => runtimeType.hashCode;
}

@JsonSerializable(explicitToJson: true)
class WalletTransactionAmount {
  WalletTransactionAmount({
    this.isoCurrencyCode,
    this.value,
  });

  factory WalletTransactionAmount.fromJson(Map<String, dynamic> json) =>
      _$WalletTransactionAmountFromJson(json);

  @JsonKey(
      name: 'iso_currency_code',
      toJson: walletTransactionAmountIsoCurrencyCodeToJson,
      fromJson: walletTransactionAmountIsoCurrencyCodeFromJson)
  final enums.WalletTransactionAmountIsoCurrencyCode? isoCurrencyCode;
  @JsonKey(name: 'value')
  final double? value;
  static const fromJsonFactory = _$WalletTransactionAmountFromJson;
  static const toJsonFactory = _$WalletTransactionAmountToJson;
  Map<String, dynamic> toJson() => _$WalletTransactionAmountToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WalletTransactionAmount &&
            (identical(other.isoCurrencyCode, isoCurrencyCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCurrencyCode, isoCurrencyCode)) &&
            (identical(other.value, value) ||
                const DeepCollectionEquality().equals(other.value, value)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(isoCurrencyCode) ^
      const DeepCollectionEquality().hash(value) ^
      runtimeType.hashCode;
}

extension $WalletTransactionAmountExtension on WalletTransactionAmount {
  WalletTransactionAmount copyWith(
      {enums.WalletTransactionAmountIsoCurrencyCode? isoCurrencyCode,
      double? value}) {
    return WalletTransactionAmount(
        isoCurrencyCode: isoCurrencyCode ?? this.isoCurrencyCode,
        value: value ?? this.value);
  }
}

@JsonSerializable(explicitToJson: true)
class WalletTransactionExecuteResponse {
  WalletTransactionExecuteResponse({
    this.transactionId,
    this.status,
    this.requestId,
  });

  factory WalletTransactionExecuteResponse.fromJson(
          Map<String, dynamic> json) =>
      _$WalletTransactionExecuteResponseFromJson(json);

  @JsonKey(name: 'transaction_id')
  final String? transactionId;
  @JsonKey(
      name: 'status',
      toJson: walletTransactionStatusToJson,
      fromJson: walletTransactionStatusFromJson)
  final enums.WalletTransactionStatus? status;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$WalletTransactionExecuteResponseFromJson;
  static const toJsonFactory = _$WalletTransactionExecuteResponseToJson;
  Map<String, dynamic> toJson() =>
      _$WalletTransactionExecuteResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WalletTransactionExecuteResponse &&
            (identical(other.transactionId, transactionId) ||
                const DeepCollectionEquality()
                    .equals(other.transactionId, transactionId)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(transactionId) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $WalletTransactionExecuteResponseExtension
    on WalletTransactionExecuteResponse {
  WalletTransactionExecuteResponse copyWith(
      {String? transactionId,
      enums.WalletTransactionStatus? status,
      String? requestId}) {
    return WalletTransactionExecuteResponse(
        transactionId: transactionId ?? this.transactionId,
        status: status ?? this.status,
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class WalletTransactionsListRequest {
  WalletTransactionsListRequest({
    this.clientId,
    this.secret,
    this.walletId,
    this.cursor,
    this.count,
  });

  factory WalletTransactionsListRequest.fromJson(Map<String, dynamic> json) =>
      _$WalletTransactionsListRequestFromJson(json);

  @JsonKey(name: 'client_id')
  final String? clientId;
  @JsonKey(name: 'secret')
  final String? secret;
  @JsonKey(name: 'wallet_id')
  final String? walletId;
  @JsonKey(name: 'cursor')
  final String? cursor;
  @JsonKey(name: 'count')
  final int? count;
  static const fromJsonFactory = _$WalletTransactionsListRequestFromJson;
  static const toJsonFactory = _$WalletTransactionsListRequestToJson;
  Map<String, dynamic> toJson() => _$WalletTransactionsListRequestToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WalletTransactionsListRequest &&
            (identical(other.clientId, clientId) ||
                const DeepCollectionEquality()
                    .equals(other.clientId, clientId)) &&
            (identical(other.secret, secret) ||
                const DeepCollectionEquality().equals(other.secret, secret)) &&
            (identical(other.walletId, walletId) ||
                const DeepCollectionEquality()
                    .equals(other.walletId, walletId)) &&
            (identical(other.cursor, cursor) ||
                const DeepCollectionEquality().equals(other.cursor, cursor)) &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(clientId) ^
      const DeepCollectionEquality().hash(secret) ^
      const DeepCollectionEquality().hash(walletId) ^
      const DeepCollectionEquality().hash(cursor) ^
      const DeepCollectionEquality().hash(count) ^
      runtimeType.hashCode;
}

extension $WalletTransactionsListRequestExtension
    on WalletTransactionsListRequest {
  WalletTransactionsListRequest copyWith(
      {String? clientId,
      String? secret,
      String? walletId,
      String? cursor,
      int? count}) {
    return WalletTransactionsListRequest(
        clientId: clientId ?? this.clientId,
        secret: secret ?? this.secret,
        walletId: walletId ?? this.walletId,
        cursor: cursor ?? this.cursor,
        count: count ?? this.count);
  }
}

@JsonSerializable(explicitToJson: true)
class WalletTransactionsListResponse {
  WalletTransactionsListResponse({
    this.transactions,
    this.nextCursor,
    this.requestId,
  });

  factory WalletTransactionsListResponse.fromJson(Map<String, dynamic> json) =>
      _$WalletTransactionsListResponseFromJson(json);

  @JsonKey(name: 'transactions', defaultValue: <WalletTransaction>[])
  final List<WalletTransaction>? transactions;
  @JsonKey(name: 'next_cursor')
  final String? nextCursor;
  @JsonKey(name: 'request_id')
  final String? requestId;
  static const fromJsonFactory = _$WalletTransactionsListResponseFromJson;
  static const toJsonFactory = _$WalletTransactionsListResponseToJson;
  Map<String, dynamic> toJson() => _$WalletTransactionsListResponseToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WalletTransactionsListResponse &&
            (identical(other.transactions, transactions) ||
                const DeepCollectionEquality()
                    .equals(other.transactions, transactions)) &&
            (identical(other.nextCursor, nextCursor) ||
                const DeepCollectionEquality()
                    .equals(other.nextCursor, nextCursor)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(transactions) ^
      const DeepCollectionEquality().hash(nextCursor) ^
      const DeepCollectionEquality().hash(requestId) ^
      runtimeType.hashCode;
}

extension $WalletTransactionsListResponseExtension
    on WalletTransactionsListResponse {
  WalletTransactionsListResponse copyWith(
      {List<WalletTransaction>? transactions,
      String? nextCursor,
      String? requestId}) {
    return WalletTransactionsListResponse(
        transactions: transactions ?? this.transactions,
        nextCursor: nextCursor ?? this.nextCursor,
        requestId: requestId ?? this.requestId);
  }
}

@JsonSerializable(explicitToJson: true)
class WalletTransaction {
  WalletTransaction({
    this.transactionId,
    this.reference,
    this.type,
    this.amount,
    this.counterparty,
    this.status,
    this.createdAt,
  });

  factory WalletTransaction.fromJson(Map<String, dynamic> json) =>
      _$WalletTransactionFromJson(json);

  @JsonKey(name: 'transaction_id')
  final String? transactionId;
  @JsonKey(name: 'reference')
  final String? reference;
  @JsonKey(
      name: 'type',
      toJson: walletTransactionType$ToJson,
      fromJson: walletTransactionType$FromJson)
  final enums.WalletTransactionType$? type;
  @JsonKey(name: 'amount')
  final WalletTransactionAmount? amount;
  @JsonKey(name: 'counterparty')
  final WalletTransactionCounterparty? counterparty;
  @JsonKey(
      name: 'status',
      toJson: walletTransactionStatusToJson,
      fromJson: walletTransactionStatusFromJson)
  final enums.WalletTransactionStatus? status;
  @JsonKey(name: 'created_at')
  final DateTime? createdAt;
  static const fromJsonFactory = _$WalletTransactionFromJson;
  static const toJsonFactory = _$WalletTransactionToJson;
  Map<String, dynamic> toJson() => _$WalletTransactionToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is WalletTransaction &&
            (identical(other.transactionId, transactionId) ||
                const DeepCollectionEquality()
                    .equals(other.transactionId, transactionId)) &&
            (identical(other.reference, reference) ||
                const DeepCollectionEquality()
                    .equals(other.reference, reference)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.amount, amount) ||
                const DeepCollectionEquality().equals(other.amount, amount)) &&
            (identical(other.counterparty, counterparty) ||
                const DeepCollectionEquality()
                    .equals(other.counterparty, counterparty)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.createdAt, createdAt) ||
                const DeepCollectionEquality()
                    .equals(other.createdAt, createdAt)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(transactionId) ^
      const DeepCollectionEquality().hash(reference) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(amount) ^
      const DeepCollectionEquality().hash(counterparty) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(createdAt) ^
      runtimeType.hashCode;
}

extension $WalletTransactionExtension on WalletTransaction {
  WalletTransaction copyWith(
      {String? transactionId,
      String? reference,
      enums.WalletTransactionType$? type,
      WalletTransactionAmount? amount,
      WalletTransactionCounterparty? counterparty,
      enums.WalletTransactionStatus? status,
      DateTime? createdAt}) {
    return WalletTransaction(
        transactionId: transactionId ?? this.transactionId,
        reference: reference ?? this.reference,
        type: type ?? this.type,
        amount: amount ?? this.amount,
        counterparty: counterparty ?? this.counterparty,
        status: status ?? this.status,
        createdAt: createdAt ?? this.createdAt);
  }
}

@JsonSerializable(explicitToJson: true)
class LinkTokenCreateRequestAccountSubtypes$Depository {
  LinkTokenCreateRequestAccountSubtypes$Depository({
    this.accountSubtypes,
  });

  factory LinkTokenCreateRequestAccountSubtypes$Depository.fromJson(
          Map<String, dynamic> json) =>
      _$LinkTokenCreateRequestAccountSubtypes$DepositoryFromJson(json);

  @JsonKey(name: 'account_subtypes')
  final List<AccountSubtype>? accountSubtypes;
  static const fromJsonFactory =
      _$LinkTokenCreateRequestAccountSubtypes$DepositoryFromJson;
  static const toJsonFactory =
      _$LinkTokenCreateRequestAccountSubtypes$DepositoryToJson;
  Map<String, dynamic> toJson() =>
      _$LinkTokenCreateRequestAccountSubtypes$DepositoryToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LinkTokenCreateRequestAccountSubtypes$Depository &&
            (identical(other.accountSubtypes, accountSubtypes) ||
                const DeepCollectionEquality()
                    .equals(other.accountSubtypes, accountSubtypes)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountSubtypes) ^
      runtimeType.hashCode;
}

extension $LinkTokenCreateRequestAccountSubtypes$DepositoryExtension
    on LinkTokenCreateRequestAccountSubtypes$Depository {
  LinkTokenCreateRequestAccountSubtypes$Depository copyWith(
      {List<AccountSubtype>? accountSubtypes}) {
    return LinkTokenCreateRequestAccountSubtypes$Depository(
        accountSubtypes: accountSubtypes ?? this.accountSubtypes);
  }
}

@JsonSerializable(explicitToJson: true)
class LinkTokenCreateRequestAccountSubtypes$Credit {
  LinkTokenCreateRequestAccountSubtypes$Credit({
    this.accountSubtypes,
  });

  factory LinkTokenCreateRequestAccountSubtypes$Credit.fromJson(
          Map<String, dynamic> json) =>
      _$LinkTokenCreateRequestAccountSubtypes$CreditFromJson(json);

  @JsonKey(name: 'account_subtypes')
  final List<AccountSubtype>? accountSubtypes;
  static const fromJsonFactory =
      _$LinkTokenCreateRequestAccountSubtypes$CreditFromJson;
  static const toJsonFactory =
      _$LinkTokenCreateRequestAccountSubtypes$CreditToJson;
  Map<String, dynamic> toJson() =>
      _$LinkTokenCreateRequestAccountSubtypes$CreditToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LinkTokenCreateRequestAccountSubtypes$Credit &&
            (identical(other.accountSubtypes, accountSubtypes) ||
                const DeepCollectionEquality()
                    .equals(other.accountSubtypes, accountSubtypes)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountSubtypes) ^
      runtimeType.hashCode;
}

extension $LinkTokenCreateRequestAccountSubtypes$CreditExtension
    on LinkTokenCreateRequestAccountSubtypes$Credit {
  LinkTokenCreateRequestAccountSubtypes$Credit copyWith(
      {List<AccountSubtype>? accountSubtypes}) {
    return LinkTokenCreateRequestAccountSubtypes$Credit(
        accountSubtypes: accountSubtypes ?? this.accountSubtypes);
  }
}

@JsonSerializable(explicitToJson: true)
class LinkTokenCreateRequestAccountSubtypes$Loan {
  LinkTokenCreateRequestAccountSubtypes$Loan({
    this.accountSubtypes,
  });

  factory LinkTokenCreateRequestAccountSubtypes$Loan.fromJson(
          Map<String, dynamic> json) =>
      _$LinkTokenCreateRequestAccountSubtypes$LoanFromJson(json);

  @JsonKey(name: 'account_subtypes')
  final List<AccountSubtype>? accountSubtypes;
  static const fromJsonFactory =
      _$LinkTokenCreateRequestAccountSubtypes$LoanFromJson;
  static const toJsonFactory =
      _$LinkTokenCreateRequestAccountSubtypes$LoanToJson;
  Map<String, dynamic> toJson() =>
      _$LinkTokenCreateRequestAccountSubtypes$LoanToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LinkTokenCreateRequestAccountSubtypes$Loan &&
            (identical(other.accountSubtypes, accountSubtypes) ||
                const DeepCollectionEquality()
                    .equals(other.accountSubtypes, accountSubtypes)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountSubtypes) ^
      runtimeType.hashCode;
}

extension $LinkTokenCreateRequestAccountSubtypes$LoanExtension
    on LinkTokenCreateRequestAccountSubtypes$Loan {
  LinkTokenCreateRequestAccountSubtypes$Loan copyWith(
      {List<AccountSubtype>? accountSubtypes}) {
    return LinkTokenCreateRequestAccountSubtypes$Loan(
        accountSubtypes: accountSubtypes ?? this.accountSubtypes);
  }
}

@JsonSerializable(explicitToJson: true)
class LinkTokenCreateRequestAccountSubtypes$Investment {
  LinkTokenCreateRequestAccountSubtypes$Investment({
    this.accountSubtypes,
  });

  factory LinkTokenCreateRequestAccountSubtypes$Investment.fromJson(
          Map<String, dynamic> json) =>
      _$LinkTokenCreateRequestAccountSubtypes$InvestmentFromJson(json);

  @JsonKey(name: 'account_subtypes')
  final List<AccountSubtype>? accountSubtypes;
  static const fromJsonFactory =
      _$LinkTokenCreateRequestAccountSubtypes$InvestmentFromJson;
  static const toJsonFactory =
      _$LinkTokenCreateRequestAccountSubtypes$InvestmentToJson;
  Map<String, dynamic> toJson() =>
      _$LinkTokenCreateRequestAccountSubtypes$InvestmentToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is LinkTokenCreateRequestAccountSubtypes$Investment &&
            (identical(other.accountSubtypes, accountSubtypes) ||
                const DeepCollectionEquality()
                    .equals(other.accountSubtypes, accountSubtypes)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(accountSubtypes) ^
      runtimeType.hashCode;
}

extension $LinkTokenCreateRequestAccountSubtypes$InvestmentExtension
    on LinkTokenCreateRequestAccountSubtypes$Investment {
  LinkTokenCreateRequestAccountSubtypes$Investment copyWith(
      {List<AccountSubtype>? accountSubtypes}) {
    return LinkTokenCreateRequestAccountSubtypes$Investment(
        accountSubtypes: accountSubtypes ?? this.accountSubtypes);
  }
}

@JsonSerializable(explicitToJson: true)
class PaystubOverride$Employer {
  PaystubOverride$Employer({
    this.name,
  });

  factory PaystubOverride$Employer.fromJson(Map<String, dynamic> json) =>
      _$PaystubOverride$EmployerFromJson(json);

  @JsonKey(name: 'name')
  final String? name;
  static const fromJsonFactory = _$PaystubOverride$EmployerFromJson;
  static const toJsonFactory = _$PaystubOverride$EmployerToJson;
  Map<String, dynamic> toJson() => _$PaystubOverride$EmployerToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaystubOverride$Employer &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^ runtimeType.hashCode;
}

extension $PaystubOverride$EmployerExtension on PaystubOverride$Employer {
  PaystubOverride$Employer copyWith({String? name}) {
    return PaystubOverride$Employer(name: name ?? this.name);
  }
}

@JsonSerializable(explicitToJson: true)
class PaystubOverride$Employee {
  PaystubOverride$Employee({
    this.name,
    this.address,
  });

  factory PaystubOverride$Employee.fromJson(Map<String, dynamic> json) =>
      _$PaystubOverride$EmployeeFromJson(json);

  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'address')
  final PaystubOverride$Employee$Address? address;
  static const fromJsonFactory = _$PaystubOverride$EmployeeFromJson;
  static const toJsonFactory = _$PaystubOverride$EmployeeToJson;
  Map<String, dynamic> toJson() => _$PaystubOverride$EmployeeToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaystubOverride$Employee &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality().equals(other.address, address)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(address) ^
      runtimeType.hashCode;
}

extension $PaystubOverride$EmployeeExtension on PaystubOverride$Employee {
  PaystubOverride$Employee copyWith(
      {String? name, PaystubOverride$Employee$Address? address}) {
    return PaystubOverride$Employee(
        name: name ?? this.name, address: address ?? this.address);
  }
}

@JsonSerializable(explicitToJson: true)
class PaystubOverride$Employee$Address {
  PaystubOverride$Employee$Address({
    this.city,
    this.region,
    this.street,
    this.postalCode,
    this.country,
  });

  factory PaystubOverride$Employee$Address.fromJson(
          Map<String, dynamic> json) =>
      _$PaystubOverride$Employee$AddressFromJson(json);

  @JsonKey(name: 'city')
  final String? city;
  @JsonKey(name: 'region')
  final String? region;
  @JsonKey(name: 'street')
  final String? street;
  @JsonKey(name: 'postal_code')
  final String? postalCode;
  @JsonKey(name: 'country')
  final String? country;
  static const fromJsonFactory = _$PaystubOverride$Employee$AddressFromJson;
  static const toJsonFactory = _$PaystubOverride$Employee$AddressToJson;
  Map<String, dynamic> toJson() =>
      _$PaystubOverride$Employee$AddressToJson(this);

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PaystubOverride$Employee$Address &&
            (identical(other.city, city) ||
                const DeepCollectionEquality().equals(other.city, city)) &&
            (identical(other.region, region) ||
                const DeepCollectionEquality().equals(other.region, region)) &&
            (identical(other.street, street) ||
                const DeepCollectionEquality().equals(other.street, street)) &&
            (identical(other.postalCode, postalCode) ||
                const DeepCollectionEquality()
                    .equals(other.postalCode, postalCode)) &&
            (identical(other.country, country) ||
                const DeepCollectionEquality().equals(other.country, country)));
  }

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(city) ^
      const DeepCollectionEquality().hash(region) ^
      const DeepCollectionEquality().hash(street) ^
      const DeepCollectionEquality().hash(postalCode) ^
      const DeepCollectionEquality().hash(country) ^
      runtimeType.hashCode;
}

extension $PaystubOverride$Employee$AddressExtension
    on PaystubOverride$Employee$Address {
  PaystubOverride$Employee$Address copyWith(
      {String? city,
      String? region,
      String? street,
      String? postalCode,
      String? country}) {
    return PaystubOverride$Employee$Address(
        city: city ?? this.city,
        region: region ?? this.region,
        street: street ?? this.street,
        postalCode: postalCode ?? this.postalCode,
        country: country ?? this.country);
  }
}

String? sandboxItemFireWebhookRequestWebhookCodeToJson(
    enums.SandboxItemFireWebhookRequestWebhookCode?
        sandboxItemFireWebhookRequestWebhookCode) {
  return enums.$SandboxItemFireWebhookRequestWebhookCodeMap[
      sandboxItemFireWebhookRequestWebhookCode];
}

enums.SandboxItemFireWebhookRequestWebhookCode
    sandboxItemFireWebhookRequestWebhookCodeFromJson(
        Object? sandboxItemFireWebhookRequestWebhookCode) {
  if (sandboxItemFireWebhookRequestWebhookCode is int) {
    return enums.$SandboxItemFireWebhookRequestWebhookCodeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                sandboxItemFireWebhookRequestWebhookCode.toString(),
            orElse: () => const MapEntry(
                enums.SandboxItemFireWebhookRequestWebhookCode
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  if (sandboxItemFireWebhookRequestWebhookCode is String) {
    return enums.$SandboxItemFireWebhookRequestWebhookCodeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                sandboxItemFireWebhookRequestWebhookCode.toLowerCase(),
            orElse: () => const MapEntry(
                enums.SandboxItemFireWebhookRequestWebhookCode
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  return enums.SandboxItemFireWebhookRequestWebhookCode.swaggerGeneratedUnknown;
}

List<String> sandboxItemFireWebhookRequestWebhookCodeListToJson(
    List<enums.SandboxItemFireWebhookRequestWebhookCode>?
        sandboxItemFireWebhookRequestWebhookCode) {
  if (sandboxItemFireWebhookRequestWebhookCode == null) {
    return [];
  }

  return sandboxItemFireWebhookRequestWebhookCode
      .map((e) => enums.$SandboxItemFireWebhookRequestWebhookCodeMap[e]!)
      .toList();
}

List<enums.SandboxItemFireWebhookRequestWebhookCode>
    sandboxItemFireWebhookRequestWebhookCodeListFromJson(
        List? sandboxItemFireWebhookRequestWebhookCode) {
  if (sandboxItemFireWebhookRequestWebhookCode == null) {
    return [];
  }

  return sandboxItemFireWebhookRequestWebhookCode
      .map(
          (e) => sandboxItemFireWebhookRequestWebhookCodeFromJson(e.toString()))
      .toList();
}

String? paymentInitiationPaymentReverseResponseStatusToJson(
    enums.PaymentInitiationPaymentReverseResponseStatus?
        paymentInitiationPaymentReverseResponseStatus) {
  return enums.$PaymentInitiationPaymentReverseResponseStatusMap[
      paymentInitiationPaymentReverseResponseStatus];
}

enums.PaymentInitiationPaymentReverseResponseStatus
    paymentInitiationPaymentReverseResponseStatusFromJson(
        Object? paymentInitiationPaymentReverseResponseStatus) {
  if (paymentInitiationPaymentReverseResponseStatus is int) {
    return enums.$PaymentInitiationPaymentReverseResponseStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                paymentInitiationPaymentReverseResponseStatus.toString(),
            orElse: () => const MapEntry(
                enums.PaymentInitiationPaymentReverseResponseStatus
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  if (paymentInitiationPaymentReverseResponseStatus is String) {
    return enums.$PaymentInitiationPaymentReverseResponseStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                paymentInitiationPaymentReverseResponseStatus.toLowerCase(),
            orElse: () => const MapEntry(
                enums.PaymentInitiationPaymentReverseResponseStatus
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  return enums
      .PaymentInitiationPaymentReverseResponseStatus.swaggerGeneratedUnknown;
}

List<String> paymentInitiationPaymentReverseResponseStatusListToJson(
    List<enums.PaymentInitiationPaymentReverseResponseStatus>?
        paymentInitiationPaymentReverseResponseStatus) {
  if (paymentInitiationPaymentReverseResponseStatus == null) {
    return [];
  }

  return paymentInitiationPaymentReverseResponseStatus
      .map((e) => enums.$PaymentInitiationPaymentReverseResponseStatusMap[e]!)
      .toList();
}

List<enums.PaymentInitiationPaymentReverseResponseStatus>
    paymentInitiationPaymentReverseResponseStatusListFromJson(
        List? paymentInitiationPaymentReverseResponseStatus) {
  if (paymentInitiationPaymentReverseResponseStatus == null) {
    return [];
  }

  return paymentInitiationPaymentReverseResponseStatus
      .map((e) =>
          paymentInitiationPaymentReverseResponseStatusFromJson(e.toString()))
      .toList();
}

String? paymentInitiationPaymentCreateResponseStatusToJson(
    enums.PaymentInitiationPaymentCreateResponseStatus?
        paymentInitiationPaymentCreateResponseStatus) {
  return enums.$PaymentInitiationPaymentCreateResponseStatusMap[
      paymentInitiationPaymentCreateResponseStatus];
}

enums.PaymentInitiationPaymentCreateResponseStatus
    paymentInitiationPaymentCreateResponseStatusFromJson(
        Object? paymentInitiationPaymentCreateResponseStatus) {
  if (paymentInitiationPaymentCreateResponseStatus is int) {
    return enums.$PaymentInitiationPaymentCreateResponseStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                paymentInitiationPaymentCreateResponseStatus.toString(),
            orElse: () => const MapEntry(
                enums.PaymentInitiationPaymentCreateResponseStatus
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  if (paymentInitiationPaymentCreateResponseStatus is String) {
    return enums.$PaymentInitiationPaymentCreateResponseStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                paymentInitiationPaymentCreateResponseStatus.toLowerCase(),
            orElse: () => const MapEntry(
                enums.PaymentInitiationPaymentCreateResponseStatus
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  return enums
      .PaymentInitiationPaymentCreateResponseStatus.swaggerGeneratedUnknown;
}

List<String> paymentInitiationPaymentCreateResponseStatusListToJson(
    List<enums.PaymentInitiationPaymentCreateResponseStatus>?
        paymentInitiationPaymentCreateResponseStatus) {
  if (paymentInitiationPaymentCreateResponseStatus == null) {
    return [];
  }

  return paymentInitiationPaymentCreateResponseStatus
      .map((e) => enums.$PaymentInitiationPaymentCreateResponseStatusMap[e]!)
      .toList();
}

List<enums.PaymentInitiationPaymentCreateResponseStatus>
    paymentInitiationPaymentCreateResponseStatusListFromJson(
        List? paymentInitiationPaymentCreateResponseStatus) {
  if (paymentInitiationPaymentCreateResponseStatus == null) {
    return [];
  }

  return paymentInitiationPaymentCreateResponseStatus
      .map((e) =>
          paymentInitiationPaymentCreateResponseStatusFromJson(e.toString()))
      .toList();
}

String? sandboxItemSetVerificationStatusRequestVerificationStatusToJson(
    enums.SandboxItemSetVerificationStatusRequestVerificationStatus?
        sandboxItemSetVerificationStatusRequestVerificationStatus) {
  return enums.$SandboxItemSetVerificationStatusRequestVerificationStatusMap[
      sandboxItemSetVerificationStatusRequestVerificationStatus];
}

enums.SandboxItemSetVerificationStatusRequestVerificationStatus
    sandboxItemSetVerificationStatusRequestVerificationStatusFromJson(
        Object? sandboxItemSetVerificationStatusRequestVerificationStatus) {
  if (sandboxItemSetVerificationStatusRequestVerificationStatus is int) {
    return enums
        .$SandboxItemSetVerificationStatusRequestVerificationStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                sandboxItemSetVerificationStatusRequestVerificationStatus
                    .toString(),
            orElse: () => const MapEntry(
                enums.SandboxItemSetVerificationStatusRequestVerificationStatus
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  if (sandboxItemSetVerificationStatusRequestVerificationStatus is String) {
    return enums
        .$SandboxItemSetVerificationStatusRequestVerificationStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                sandboxItemSetVerificationStatusRequestVerificationStatus
                    .toLowerCase(),
            orElse: () => const MapEntry(
                enums.SandboxItemSetVerificationStatusRequestVerificationStatus
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  return enums.SandboxItemSetVerificationStatusRequestVerificationStatus
      .swaggerGeneratedUnknown;
}

List<String>
    sandboxItemSetVerificationStatusRequestVerificationStatusListToJson(
        List<enums.SandboxItemSetVerificationStatusRequestVerificationStatus>?
            sandboxItemSetVerificationStatusRequestVerificationStatus) {
  if (sandboxItemSetVerificationStatusRequestVerificationStatus == null) {
    return [];
  }

  return sandboxItemSetVerificationStatusRequestVerificationStatus
      .map((e) => enums
          .$SandboxItemSetVerificationStatusRequestVerificationStatusMap[e]!)
      .toList();
}

List<enums.SandboxItemSetVerificationStatusRequestVerificationStatus>
    sandboxItemSetVerificationStatusRequestVerificationStatusListFromJson(
        List? sandboxItemSetVerificationStatusRequestVerificationStatus) {
  if (sandboxItemSetVerificationStatusRequestVerificationStatus == null) {
    return [];
  }

  return sandboxItemSetVerificationStatusRequestVerificationStatus
      .map((e) =>
          sandboxItemSetVerificationStatusRequestVerificationStatusFromJson(
              e.toString()))
      .toList();
}

String? paymentInitiationPaymentStatusToJson(
    enums.PaymentInitiationPaymentStatus? paymentInitiationPaymentStatus) {
  return enums
      .$PaymentInitiationPaymentStatusMap[paymentInitiationPaymentStatus];
}

enums.PaymentInitiationPaymentStatus paymentInitiationPaymentStatusFromJson(
    Object? paymentInitiationPaymentStatus) {
  if (paymentInitiationPaymentStatus is int) {
    return enums.$PaymentInitiationPaymentStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                paymentInitiationPaymentStatus.toString(),
            orElse: () => const MapEntry(
                enums.PaymentInitiationPaymentStatus.swaggerGeneratedUnknown,
                ''))
        .key;
  }

  if (paymentInitiationPaymentStatus is String) {
    return enums.$PaymentInitiationPaymentStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                paymentInitiationPaymentStatus.toLowerCase(),
            orElse: () => const MapEntry(
                enums.PaymentInitiationPaymentStatus.swaggerGeneratedUnknown,
                ''))
        .key;
  }

  return enums.PaymentInitiationPaymentStatus.swaggerGeneratedUnknown;
}

List<String> paymentInitiationPaymentStatusListToJson(
    List<enums.PaymentInitiationPaymentStatus>?
        paymentInitiationPaymentStatus) {
  if (paymentInitiationPaymentStatus == null) {
    return [];
  }

  return paymentInitiationPaymentStatus
      .map((e) => enums.$PaymentInitiationPaymentStatusMap[e]!)
      .toList();
}

List<enums.PaymentInitiationPaymentStatus>
    paymentInitiationPaymentStatusListFromJson(
        List? paymentInitiationPaymentStatus) {
  if (paymentInitiationPaymentStatus == null) {
    return [];
  }

  return paymentInitiationPaymentStatus
      .map((e) => paymentInitiationPaymentStatusFromJson(e.toString()))
      .toList();
}

String? paymentInitiationRefundStatusToJson(
    enums.PaymentInitiationRefundStatus? paymentInitiationRefundStatus) {
  return enums.$PaymentInitiationRefundStatusMap[paymentInitiationRefundStatus];
}

enums.PaymentInitiationRefundStatus paymentInitiationRefundStatusFromJson(
    Object? paymentInitiationRefundStatus) {
  if (paymentInitiationRefundStatus is int) {
    return enums.$PaymentInitiationRefundStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                paymentInitiationRefundStatus.toString(),
            orElse: () => const MapEntry(
                enums.PaymentInitiationRefundStatus.swaggerGeneratedUnknown,
                ''))
        .key;
  }

  if (paymentInitiationRefundStatus is String) {
    return enums.$PaymentInitiationRefundStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                paymentInitiationRefundStatus.toLowerCase(),
            orElse: () => const MapEntry(
                enums.PaymentInitiationRefundStatus.swaggerGeneratedUnknown,
                ''))
        .key;
  }

  return enums.PaymentInitiationRefundStatus.swaggerGeneratedUnknown;
}

List<String> paymentInitiationRefundStatusListToJson(
    List<enums.PaymentInitiationRefundStatus>? paymentInitiationRefundStatus) {
  if (paymentInitiationRefundStatus == null) {
    return [];
  }

  return paymentInitiationRefundStatus
      .map((e) => enums.$PaymentInitiationRefundStatusMap[e]!)
      .toList();
}

List<enums.PaymentInitiationRefundStatus>
    paymentInitiationRefundStatusListFromJson(
        List? paymentInitiationRefundStatus) {
  if (paymentInitiationRefundStatus == null) {
    return [];
  }

  return paymentInitiationRefundStatus
      .map((e) => paymentInitiationRefundStatusFromJson(e.toString()))
      .toList();
}

String? processorTokenCreateRequestProcessorToJson(
    enums.ProcessorTokenCreateRequestProcessor?
        processorTokenCreateRequestProcessor) {
  return enums.$ProcessorTokenCreateRequestProcessorMap[
      processorTokenCreateRequestProcessor];
}

enums.ProcessorTokenCreateRequestProcessor
    processorTokenCreateRequestProcessorFromJson(
        Object? processorTokenCreateRequestProcessor) {
  if (processorTokenCreateRequestProcessor is int) {
    return enums.$ProcessorTokenCreateRequestProcessorMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                processorTokenCreateRequestProcessor.toString(),
            orElse: () => const MapEntry(
                enums.ProcessorTokenCreateRequestProcessor
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  if (processorTokenCreateRequestProcessor is String) {
    return enums.$ProcessorTokenCreateRequestProcessorMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                processorTokenCreateRequestProcessor.toLowerCase(),
            orElse: () => const MapEntry(
                enums.ProcessorTokenCreateRequestProcessor
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  return enums.ProcessorTokenCreateRequestProcessor.swaggerGeneratedUnknown;
}

List<String> processorTokenCreateRequestProcessorListToJson(
    List<enums.ProcessorTokenCreateRequestProcessor>?
        processorTokenCreateRequestProcessor) {
  if (processorTokenCreateRequestProcessor == null) {
    return [];
  }

  return processorTokenCreateRequestProcessor
      .map((e) => enums.$ProcessorTokenCreateRequestProcessorMap[e]!)
      .toList();
}

List<enums.ProcessorTokenCreateRequestProcessor>
    processorTokenCreateRequestProcessorListFromJson(
        List? processorTokenCreateRequestProcessor) {
  if (processorTokenCreateRequestProcessor == null) {
    return [];
  }

  return processorTokenCreateRequestProcessor
      .map((e) => processorTokenCreateRequestProcessorFromJson(e.toString()))
      .toList();
}

String? depositSwitchCreateRequestCountryCodeToJson(
    enums.DepositSwitchCreateRequestCountryCode?
        depositSwitchCreateRequestCountryCode) {
  return enums.$DepositSwitchCreateRequestCountryCodeMap[
      depositSwitchCreateRequestCountryCode];
}

enums.DepositSwitchCreateRequestCountryCode
    depositSwitchCreateRequestCountryCodeFromJson(
        Object? depositSwitchCreateRequestCountryCode) {
  if (depositSwitchCreateRequestCountryCode is int) {
    return enums.$DepositSwitchCreateRequestCountryCodeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                depositSwitchCreateRequestCountryCode.toString(),
            orElse: () => const MapEntry(
                enums.DepositSwitchCreateRequestCountryCode
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  if (depositSwitchCreateRequestCountryCode is String) {
    return enums.$DepositSwitchCreateRequestCountryCodeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                depositSwitchCreateRequestCountryCode.toLowerCase(),
            orElse: () => const MapEntry(
                enums.DepositSwitchCreateRequestCountryCode
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  return enums.DepositSwitchCreateRequestCountryCode.swaggerGeneratedUnknown;
}

List<String> depositSwitchCreateRequestCountryCodeListToJson(
    List<enums.DepositSwitchCreateRequestCountryCode>?
        depositSwitchCreateRequestCountryCode) {
  if (depositSwitchCreateRequestCountryCode == null) {
    return [];
  }

  return depositSwitchCreateRequestCountryCode
      .map((e) => enums.$DepositSwitchCreateRequestCountryCodeMap[e]!)
      .toList();
}

List<enums.DepositSwitchCreateRequestCountryCode>
    depositSwitchCreateRequestCountryCodeListFromJson(
        List? depositSwitchCreateRequestCountryCode) {
  if (depositSwitchCreateRequestCountryCode == null) {
    return [];
  }

  return depositSwitchCreateRequestCountryCode
      .map((e) => depositSwitchCreateRequestCountryCodeFromJson(e.toString()))
      .toList();
}

String? linkTokenCreateRequestAuthFlowTypeToJson(
    enums.LinkTokenCreateRequestAuthFlowType?
        linkTokenCreateRequestAuthFlowType) {
  return enums.$LinkTokenCreateRequestAuthFlowTypeMap[
      linkTokenCreateRequestAuthFlowType];
}

enums.LinkTokenCreateRequestAuthFlowType
    linkTokenCreateRequestAuthFlowTypeFromJson(
        Object? linkTokenCreateRequestAuthFlowType) {
  if (linkTokenCreateRequestAuthFlowType is int) {
    return enums.$LinkTokenCreateRequestAuthFlowTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                linkTokenCreateRequestAuthFlowType.toString(),
            orElse: () => const MapEntry(
                enums
                    .LinkTokenCreateRequestAuthFlowType.swaggerGeneratedUnknown,
                ''))
        .key;
  }

  if (linkTokenCreateRequestAuthFlowType is String) {
    return enums.$LinkTokenCreateRequestAuthFlowTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                linkTokenCreateRequestAuthFlowType.toLowerCase(),
            orElse: () => const MapEntry(
                enums
                    .LinkTokenCreateRequestAuthFlowType.swaggerGeneratedUnknown,
                ''))
        .key;
  }

  return enums.LinkTokenCreateRequestAuthFlowType.swaggerGeneratedUnknown;
}

List<String> linkTokenCreateRequestAuthFlowTypeListToJson(
    List<enums.LinkTokenCreateRequestAuthFlowType>?
        linkTokenCreateRequestAuthFlowType) {
  if (linkTokenCreateRequestAuthFlowType == null) {
    return [];
  }

  return linkTokenCreateRequestAuthFlowType
      .map((e) => enums.$LinkTokenCreateRequestAuthFlowTypeMap[e]!)
      .toList();
}

List<enums.LinkTokenCreateRequestAuthFlowType>
    linkTokenCreateRequestAuthFlowTypeListFromJson(
        List? linkTokenCreateRequestAuthFlowType) {
  if (linkTokenCreateRequestAuthFlowType == null) {
    return [];
  }

  return linkTokenCreateRequestAuthFlowType
      .map((e) => linkTokenCreateRequestAuthFlowTypeFromJson(e.toString()))
      .toList();
}

String? itemUpdateTypeToJson(enums.ItemUpdateType? itemUpdateType) {
  return enums.$ItemUpdateTypeMap[itemUpdateType];
}

enums.ItemUpdateType itemUpdateTypeFromJson(Object? itemUpdateType) {
  if (itemUpdateType is int) {
    return enums.$ItemUpdateTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == itemUpdateType.toString(),
            orElse: () => const MapEntry(
                enums.ItemUpdateType.swaggerGeneratedUnknown, ''))
        .key;
  }

  if (itemUpdateType is String) {
    return enums.$ItemUpdateTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == itemUpdateType.toLowerCase(),
            orElse: () => const MapEntry(
                enums.ItemUpdateType.swaggerGeneratedUnknown, ''))
        .key;
  }

  return enums.ItemUpdateType.swaggerGeneratedUnknown;
}

List<String> itemUpdateTypeListToJson(
    List<enums.ItemUpdateType>? itemUpdateType) {
  if (itemUpdateType == null) {
    return [];
  }

  return itemUpdateType.map((e) => enums.$ItemUpdateTypeMap[e]!).toList();
}

List<enums.ItemUpdateType> itemUpdateTypeListFromJson(List? itemUpdateType) {
  if (itemUpdateType == null) {
    return [];
  }

  return itemUpdateType
      .map((e) => itemUpdateTypeFromJson(e.toString()))
      .toList();
}

String? errorErrorTypeToJson(enums.ErrorErrorType? errorErrorType) {
  return enums.$ErrorErrorTypeMap[errorErrorType];
}

enums.ErrorErrorType errorErrorTypeFromJson(Object? errorErrorType) {
  if (errorErrorType is int) {
    return enums.$ErrorErrorTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == errorErrorType.toString(),
            orElse: () => const MapEntry(
                enums.ErrorErrorType.swaggerGeneratedUnknown, ''))
        .key;
  }

  if (errorErrorType is String) {
    return enums.$ErrorErrorTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == errorErrorType.toLowerCase(),
            orElse: () => const MapEntry(
                enums.ErrorErrorType.swaggerGeneratedUnknown, ''))
        .key;
  }

  return enums.ErrorErrorType.swaggerGeneratedUnknown;
}

List<String> errorErrorTypeListToJson(
    List<enums.ErrorErrorType>? errorErrorType) {
  if (errorErrorType == null) {
    return [];
  }

  return errorErrorType.map((e) => enums.$ErrorErrorTypeMap[e]!).toList();
}

List<enums.ErrorErrorType> errorErrorTypeListFromJson(List? errorErrorType) {
  if (errorErrorType == null) {
    return [];
  }

  return errorErrorType
      .map((e) => errorErrorTypeFromJson(e.toString()))
      .toList();
}

String? accountTypeToJson(enums.AccountType? accountType) {
  return enums.$AccountTypeMap[accountType];
}

enums.AccountType accountTypeFromJson(Object? accountType) {
  if (accountType is int) {
    return enums.$AccountTypeMap.entries
        .firstWhere(
            (element) => element.value.toLowerCase() == accountType.toString(),
            orElse: () =>
                const MapEntry(enums.AccountType.swaggerGeneratedUnknown, ''))
        .key;
  }

  if (accountType is String) {
    return enums.$AccountTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == accountType.toLowerCase(),
            orElse: () =>
                const MapEntry(enums.AccountType.swaggerGeneratedUnknown, ''))
        .key;
  }

  return enums.AccountType.swaggerGeneratedUnknown;
}

List<String> accountTypeListToJson(List<enums.AccountType>? accountType) {
  if (accountType == null) {
    return [];
  }

  return accountType.map((e) => enums.$AccountTypeMap[e]!).toList();
}

List<enums.AccountType> accountTypeListFromJson(List? accountType) {
  if (accountType == null) {
    return [];
  }

  return accountType.map((e) => accountTypeFromJson(e.toString())).toList();
}

String? overrideAccountTypeToJson(
    enums.OverrideAccountType? overrideAccountType) {
  return enums.$OverrideAccountTypeMap[overrideAccountType];
}

enums.OverrideAccountType overrideAccountTypeFromJson(
    Object? overrideAccountType) {
  if (overrideAccountType is int) {
    return enums.$OverrideAccountTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == overrideAccountType.toString(),
            orElse: () => const MapEntry(
                enums.OverrideAccountType.swaggerGeneratedUnknown, ''))
        .key;
  }

  if (overrideAccountType is String) {
    return enums.$OverrideAccountTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                overrideAccountType.toLowerCase(),
            orElse: () => const MapEntry(
                enums.OverrideAccountType.swaggerGeneratedUnknown, ''))
        .key;
  }

  return enums.OverrideAccountType.swaggerGeneratedUnknown;
}

List<String> overrideAccountTypeListToJson(
    List<enums.OverrideAccountType>? overrideAccountType) {
  if (overrideAccountType == null) {
    return [];
  }

  return overrideAccountType
      .map((e) => enums.$OverrideAccountTypeMap[e]!)
      .toList();
}

List<enums.OverrideAccountType> overrideAccountTypeListFromJson(
    List? overrideAccountType) {
  if (overrideAccountType == null) {
    return [];
  }

  return overrideAccountType
      .map((e) => overrideAccountTypeFromJson(e.toString()))
      .toList();
}

String? accountBaseVerificationStatusToJson(
    enums.AccountBaseVerificationStatus? accountBaseVerificationStatus) {
  return enums.$AccountBaseVerificationStatusMap[accountBaseVerificationStatus];
}

enums.AccountBaseVerificationStatus accountBaseVerificationStatusFromJson(
    Object? accountBaseVerificationStatus) {
  if (accountBaseVerificationStatus is int) {
    return enums.$AccountBaseVerificationStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                accountBaseVerificationStatus.toString(),
            orElse: () => const MapEntry(
                enums.AccountBaseVerificationStatus.swaggerGeneratedUnknown,
                ''))
        .key;
  }

  if (accountBaseVerificationStatus is String) {
    return enums.$AccountBaseVerificationStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                accountBaseVerificationStatus.toLowerCase(),
            orElse: () => const MapEntry(
                enums.AccountBaseVerificationStatus.swaggerGeneratedUnknown,
                ''))
        .key;
  }

  return enums.AccountBaseVerificationStatus.swaggerGeneratedUnknown;
}

List<String> accountBaseVerificationStatusListToJson(
    List<enums.AccountBaseVerificationStatus>? accountBaseVerificationStatus) {
  if (accountBaseVerificationStatus == null) {
    return [];
  }

  return accountBaseVerificationStatus
      .map((e) => enums.$AccountBaseVerificationStatusMap[e]!)
      .toList();
}

List<enums.AccountBaseVerificationStatus>
    accountBaseVerificationStatusListFromJson(
        List? accountBaseVerificationStatus) {
  if (accountBaseVerificationStatus == null) {
    return [];
  }

  return accountBaseVerificationStatus
      .map((e) => accountBaseVerificationStatusFromJson(e.toString()))
      .toList();
}

String? accountSubtypeToJson(enums.AccountSubtype? accountSubtype) {
  return enums.$AccountSubtypeMap[accountSubtype];
}

enums.AccountSubtype accountSubtypeFromJson(Object? accountSubtype) {
  if (accountSubtype is int) {
    return enums.$AccountSubtypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == accountSubtype.toString(),
            orElse: () => const MapEntry(
                enums.AccountSubtype.swaggerGeneratedUnknown, ''))
        .key;
  }

  if (accountSubtype is String) {
    return enums.$AccountSubtypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == accountSubtype.toLowerCase(),
            orElse: () => const MapEntry(
                enums.AccountSubtype.swaggerGeneratedUnknown, ''))
        .key;
  }

  return enums.AccountSubtype.swaggerGeneratedUnknown;
}

List<String> accountSubtypeListToJson(
    List<enums.AccountSubtype>? accountSubtype) {
  if (accountSubtype == null) {
    return [];
  }

  return accountSubtype.map((e) => enums.$AccountSubtypeMap[e]!).toList();
}

List<enums.AccountSubtype> accountSubtypeListFromJson(List? accountSubtype) {
  if (accountSubtype == null) {
    return [];
  }

  return accountSubtype
      .map((e) => accountSubtypeFromJson(e.toString()))
      .toList();
}

String? transactionBaseTransactionTypeToJson(
    enums.TransactionBaseTransactionType? transactionBaseTransactionType) {
  return enums
      .$TransactionBaseTransactionTypeMap[transactionBaseTransactionType];
}

enums.TransactionBaseTransactionType transactionBaseTransactionTypeFromJson(
    Object? transactionBaseTransactionType) {
  if (transactionBaseTransactionType is int) {
    return enums.$TransactionBaseTransactionTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                transactionBaseTransactionType.toString(),
            orElse: () => const MapEntry(
                enums.TransactionBaseTransactionType.swaggerGeneratedUnknown,
                ''))
        .key;
  }

  if (transactionBaseTransactionType is String) {
    return enums.$TransactionBaseTransactionTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                transactionBaseTransactionType.toLowerCase(),
            orElse: () => const MapEntry(
                enums.TransactionBaseTransactionType.swaggerGeneratedUnknown,
                ''))
        .key;
  }

  return enums.TransactionBaseTransactionType.swaggerGeneratedUnknown;
}

List<String> transactionBaseTransactionTypeListToJson(
    List<enums.TransactionBaseTransactionType>?
        transactionBaseTransactionType) {
  if (transactionBaseTransactionType == null) {
    return [];
  }

  return transactionBaseTransactionType
      .map((e) => enums.$TransactionBaseTransactionTypeMap[e]!)
      .toList();
}

List<enums.TransactionBaseTransactionType>
    transactionBaseTransactionTypeListFromJson(
        List? transactionBaseTransactionType) {
  if (transactionBaseTransactionType == null) {
    return [];
  }

  return transactionBaseTransactionType
      .map((e) => transactionBaseTransactionTypeFromJson(e.toString()))
      .toList();
}

String? transactionPaymentChannelToJson(
    enums.TransactionPaymentChannel? transactionPaymentChannel) {
  return enums.$TransactionPaymentChannelMap[transactionPaymentChannel];
}

enums.TransactionPaymentChannel transactionPaymentChannelFromJson(
    Object? transactionPaymentChannel) {
  if (transactionPaymentChannel is int) {
    return enums.$TransactionPaymentChannelMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                transactionPaymentChannel.toString(),
            orElse: () => const MapEntry(
                enums.TransactionPaymentChannel.swaggerGeneratedUnknown, ''))
        .key;
  }

  if (transactionPaymentChannel is String) {
    return enums.$TransactionPaymentChannelMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                transactionPaymentChannel.toLowerCase(),
            orElse: () => const MapEntry(
                enums.TransactionPaymentChannel.swaggerGeneratedUnknown, ''))
        .key;
  }

  return enums.TransactionPaymentChannel.swaggerGeneratedUnknown;
}

List<String> transactionPaymentChannelListToJson(
    List<enums.TransactionPaymentChannel>? transactionPaymentChannel) {
  if (transactionPaymentChannel == null) {
    return [];
  }

  return transactionPaymentChannel
      .map((e) => enums.$TransactionPaymentChannelMap[e]!)
      .toList();
}

List<enums.TransactionPaymentChannel> transactionPaymentChannelListFromJson(
    List? transactionPaymentChannel) {
  if (transactionPaymentChannel == null) {
    return [];
  }

  return transactionPaymentChannel
      .map((e) => transactionPaymentChannelFromJson(e.toString()))
      .toList();
}

String? transactionTransactionTypeToJson(
    enums.TransactionTransactionType? transactionTransactionType) {
  return enums.$TransactionTransactionTypeMap[transactionTransactionType];
}

enums.TransactionTransactionType transactionTransactionTypeFromJson(
    Object? transactionTransactionType) {
  if (transactionTransactionType is int) {
    return enums.$TransactionTransactionTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                transactionTransactionType.toString(),
            orElse: () => const MapEntry(
                enums.TransactionTransactionType.swaggerGeneratedUnknown, ''))
        .key;
  }

  if (transactionTransactionType is String) {
    return enums.$TransactionTransactionTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                transactionTransactionType.toLowerCase(),
            orElse: () => const MapEntry(
                enums.TransactionTransactionType.swaggerGeneratedUnknown, ''))
        .key;
  }

  return enums.TransactionTransactionType.swaggerGeneratedUnknown;
}

List<String> transactionTransactionTypeListToJson(
    List<enums.TransactionTransactionType>? transactionTransactionType) {
  if (transactionTransactionType == null) {
    return [];
  }

  return transactionTransactionType
      .map((e) => enums.$TransactionTransactionTypeMap[e]!)
      .toList();
}

List<enums.TransactionTransactionType> transactionTransactionTypeListFromJson(
    List? transactionTransactionType) {
  if (transactionTransactionType == null) {
    return [];
  }

  return transactionTransactionType
      .map((e) => transactionTransactionTypeFromJson(e.toString()))
      .toList();
}

String? recurringTransactionFrequencyToJson(
    enums.RecurringTransactionFrequency? recurringTransactionFrequency) {
  return enums.$RecurringTransactionFrequencyMap[recurringTransactionFrequency];
}

enums.RecurringTransactionFrequency recurringTransactionFrequencyFromJson(
    Object? recurringTransactionFrequency) {
  if (recurringTransactionFrequency is int) {
    return enums.$RecurringTransactionFrequencyMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                recurringTransactionFrequency.toString(),
            orElse: () => const MapEntry(
                enums.RecurringTransactionFrequency.swaggerGeneratedUnknown,
                ''))
        .key;
  }

  if (recurringTransactionFrequency is String) {
    return enums.$RecurringTransactionFrequencyMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                recurringTransactionFrequency.toLowerCase(),
            orElse: () => const MapEntry(
                enums.RecurringTransactionFrequency.swaggerGeneratedUnknown,
                ''))
        .key;
  }

  return enums.RecurringTransactionFrequency.swaggerGeneratedUnknown;
}

List<String> recurringTransactionFrequencyListToJson(
    List<enums.RecurringTransactionFrequency>? recurringTransactionFrequency) {
  if (recurringTransactionFrequency == null) {
    return [];
  }

  return recurringTransactionFrequency
      .map((e) => enums.$RecurringTransactionFrequencyMap[e]!)
      .toList();
}

List<enums.RecurringTransactionFrequency>
    recurringTransactionFrequencyListFromJson(
        List? recurringTransactionFrequency) {
  if (recurringTransactionFrequency == null) {
    return [];
  }

  return recurringTransactionFrequency
      .map((e) => recurringTransactionFrequencyFromJson(e.toString()))
      .toList();
}

String? countryCodeToJson(enums.CountryCode? countryCode) {
  return enums.$CountryCodeMap[countryCode];
}

enums.CountryCode countryCodeFromJson(Object? countryCode) {
  if (countryCode is int) {
    return enums.$CountryCodeMap.entries
        .firstWhere(
            (element) => element.value.toLowerCase() == countryCode.toString(),
            orElse: () =>
                const MapEntry(enums.CountryCode.swaggerGeneratedUnknown, ''))
        .key;
  }

  if (countryCode is String) {
    return enums.$CountryCodeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == countryCode.toLowerCase(),
            orElse: () =>
                const MapEntry(enums.CountryCode.swaggerGeneratedUnknown, ''))
        .key;
  }

  return enums.CountryCode.swaggerGeneratedUnknown;
}

List<String> countryCodeListToJson(List<enums.CountryCode>? countryCode) {
  if (countryCode == null) {
    return [];
  }

  return countryCode.map((e) => enums.$CountryCodeMap[e]!).toList();
}

List<enums.CountryCode> countryCodeListFromJson(List? countryCode) {
  if (countryCode == null) {
    return [];
  }

  return countryCode.map((e) => countryCodeFromJson(e.toString())).toList();
}

String? transactionCodeToJson(enums.TransactionCode? transactionCode) {
  return enums.$TransactionCodeMap[transactionCode];
}

enums.TransactionCode transactionCodeFromJson(Object? transactionCode) {
  if (transactionCode is int) {
    return enums.$TransactionCodeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == transactionCode.toString(),
            orElse: () => const MapEntry(
                enums.TransactionCode.swaggerGeneratedUnknown, ''))
        .key;
  }

  if (transactionCode is String) {
    return enums.$TransactionCodeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == transactionCode.toLowerCase(),
            orElse: () => const MapEntry(
                enums.TransactionCode.swaggerGeneratedUnknown, ''))
        .key;
  }

  return enums.TransactionCode.swaggerGeneratedUnknown;
}

List<String> transactionCodeListToJson(
    List<enums.TransactionCode>? transactionCode) {
  if (transactionCode == null) {
    return [];
  }

  return transactionCode.map((e) => enums.$TransactionCodeMap[e]!).toList();
}

List<enums.TransactionCode> transactionCodeListFromJson(List? transactionCode) {
  if (transactionCode == null) {
    return [];
  }

  return transactionCode
      .map((e) => transactionCodeFromJson(e.toString()))
      .toList();
}

String? phoneNumberType$ToJson(enums.PhoneNumberType$? phoneNumberType$) {
  return enums.$PhoneNumberType$Map[phoneNumberType$];
}

enums.PhoneNumberType$ phoneNumberType$FromJson(Object? phoneNumberType$) {
  if (phoneNumberType$ is int) {
    return enums.$PhoneNumberType$Map.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == phoneNumberType$.toString(),
            orElse: () => const MapEntry(
                enums.PhoneNumberType$.swaggerGeneratedUnknown, ''))
        .key;
  }

  if (phoneNumberType$ is String) {
    return enums.$PhoneNumberType$Map.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == phoneNumberType$.toLowerCase(),
            orElse: () => const MapEntry(
                enums.PhoneNumberType$.swaggerGeneratedUnknown, ''))
        .key;
  }

  return enums.PhoneNumberType$.swaggerGeneratedUnknown;
}

List<String> phoneNumberType$ListToJson(
    List<enums.PhoneNumberType$>? phoneNumberType$) {
  if (phoneNumberType$ == null) {
    return [];
  }

  return phoneNumberType$.map((e) => enums.$PhoneNumberType$Map[e]!).toList();
}

List<enums.PhoneNumberType$> phoneNumberType$ListFromJson(
    List? phoneNumberType$) {
  if (phoneNumberType$ == null) {
    return [];
  }

  return phoneNumberType$
      .map((e) => phoneNumberType$FromJson(e.toString()))
      .toList();
}

String? emailType$ToJson(enums.EmailType$? emailType$) {
  return enums.$EmailType$Map[emailType$];
}

enums.EmailType$ emailType$FromJson(Object? emailType$) {
  if (emailType$ is int) {
    return enums.$EmailType$Map.entries
        .firstWhere(
            (element) => element.value.toLowerCase() == emailType$.toString(),
            orElse: () =>
                const MapEntry(enums.EmailType$.swaggerGeneratedUnknown, ''))
        .key;
  }

  if (emailType$ is String) {
    return enums.$EmailType$Map.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == emailType$.toLowerCase(),
            orElse: () =>
                const MapEntry(enums.EmailType$.swaggerGeneratedUnknown, ''))
        .key;
  }

  return enums.EmailType$.swaggerGeneratedUnknown;
}

List<String> emailType$ListToJson(List<enums.EmailType$>? emailType$) {
  if (emailType$ == null) {
    return [];
  }

  return emailType$.map((e) => enums.$EmailType$Map[e]!).toList();
}

List<enums.EmailType$> emailType$ListFromJson(List? emailType$) {
  if (emailType$ == null) {
    return [];
  }

  return emailType$.map((e) => emailType$FromJson(e.toString())).toList();
}

String? studentLoanStatusType$ToJson(
    enums.StudentLoanStatusType$? studentLoanStatusType$) {
  return enums.$StudentLoanStatusType$Map[studentLoanStatusType$];
}

enums.StudentLoanStatusType$ studentLoanStatusType$FromJson(
    Object? studentLoanStatusType$) {
  if (studentLoanStatusType$ is int) {
    return enums.$StudentLoanStatusType$Map.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                studentLoanStatusType$.toString(),
            orElse: () => const MapEntry(
                enums.StudentLoanStatusType$.swaggerGeneratedUnknown, ''))
        .key;
  }

  if (studentLoanStatusType$ is String) {
    return enums.$StudentLoanStatusType$Map.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                studentLoanStatusType$.toLowerCase(),
            orElse: () => const MapEntry(
                enums.StudentLoanStatusType$.swaggerGeneratedUnknown, ''))
        .key;
  }

  return enums.StudentLoanStatusType$.swaggerGeneratedUnknown;
}

List<String> studentLoanStatusType$ListToJson(
    List<enums.StudentLoanStatusType$>? studentLoanStatusType$) {
  if (studentLoanStatusType$ == null) {
    return [];
  }

  return studentLoanStatusType$
      .map((e) => enums.$StudentLoanStatusType$Map[e]!)
      .toList();
}

List<enums.StudentLoanStatusType$> studentLoanStatusType$ListFromJson(
    List? studentLoanStatusType$) {
  if (studentLoanStatusType$ == null) {
    return [];
  }

  return studentLoanStatusType$
      .map((e) => studentLoanStatusType$FromJson(e.toString()))
      .toList();
}

String? studentRepaymentPlanType$ToJson(
    enums.StudentRepaymentPlanType$? studentRepaymentPlanType$) {
  return enums.$StudentRepaymentPlanType$Map[studentRepaymentPlanType$];
}

enums.StudentRepaymentPlanType$ studentRepaymentPlanType$FromJson(
    Object? studentRepaymentPlanType$) {
  if (studentRepaymentPlanType$ is int) {
    return enums.$StudentRepaymentPlanType$Map.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                studentRepaymentPlanType$.toString(),
            orElse: () => const MapEntry(
                enums.StudentRepaymentPlanType$.swaggerGeneratedUnknown, ''))
        .key;
  }

  if (studentRepaymentPlanType$ is String) {
    return enums.$StudentRepaymentPlanType$Map.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                studentRepaymentPlanType$.toLowerCase(),
            orElse: () => const MapEntry(
                enums.StudentRepaymentPlanType$.swaggerGeneratedUnknown, ''))
        .key;
  }

  return enums.StudentRepaymentPlanType$.swaggerGeneratedUnknown;
}

List<String> studentRepaymentPlanType$ListToJson(
    List<enums.StudentRepaymentPlanType$>? studentRepaymentPlanType$) {
  if (studentRepaymentPlanType$ == null) {
    return [];
  }

  return studentRepaymentPlanType$
      .map((e) => enums.$StudentRepaymentPlanType$Map[e]!)
      .toList();
}

List<enums.StudentRepaymentPlanType$> studentRepaymentPlanType$ListFromJson(
    List? studentRepaymentPlanType$) {
  if (studentRepaymentPlanType$ == null) {
    return [];
  }

  return studentRepaymentPlanType$
      .map((e) => studentRepaymentPlanType$FromJson(e.toString()))
      .toList();
}

String? aprAprTypeToJson(enums.AprAprType? aprAprType) {
  return enums.$AprAprTypeMap[aprAprType];
}

enums.AprAprType aprAprTypeFromJson(Object? aprAprType) {
  if (aprAprType is int) {
    return enums.$AprAprTypeMap.entries
        .firstWhere(
            (element) => element.value.toLowerCase() == aprAprType.toString(),
            orElse: () =>
                const MapEntry(enums.AprAprType.swaggerGeneratedUnknown, ''))
        .key;
  }

  if (aprAprType is String) {
    return enums.$AprAprTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == aprAprType.toLowerCase(),
            orElse: () =>
                const MapEntry(enums.AprAprType.swaggerGeneratedUnknown, ''))
        .key;
  }

  return enums.AprAprType.swaggerGeneratedUnknown;
}

List<String> aprAprTypeListToJson(List<enums.AprAprType>? aprAprType) {
  if (aprAprType == null) {
    return [];
  }

  return aprAprType.map((e) => enums.$AprAprTypeMap[e]!).toList();
}

List<enums.AprAprType> aprAprTypeListFromJson(List? aprAprType) {
  if (aprAprType == null) {
    return [];
  }

  return aprAprType.map((e) => aprAprTypeFromJson(e.toString())).toList();
}

String? paymentScheduleIntervalToJson(
    enums.PaymentScheduleInterval? paymentScheduleInterval) {
  return enums.$PaymentScheduleIntervalMap[paymentScheduleInterval];
}

enums.PaymentScheduleInterval paymentScheduleIntervalFromJson(
    Object? paymentScheduleInterval) {
  if (paymentScheduleInterval is int) {
    return enums.$PaymentScheduleIntervalMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                paymentScheduleInterval.toString(),
            orElse: () => const MapEntry(
                enums.PaymentScheduleInterval.swaggerGeneratedUnknown, ''))
        .key;
  }

  if (paymentScheduleInterval is String) {
    return enums.$PaymentScheduleIntervalMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                paymentScheduleInterval.toLowerCase(),
            orElse: () => const MapEntry(
                enums.PaymentScheduleInterval.swaggerGeneratedUnknown, ''))
        .key;
  }

  return enums.PaymentScheduleInterval.swaggerGeneratedUnknown;
}

List<String> paymentScheduleIntervalListToJson(
    List<enums.PaymentScheduleInterval>? paymentScheduleInterval) {
  if (paymentScheduleInterval == null) {
    return [];
  }

  return paymentScheduleInterval
      .map((e) => enums.$PaymentScheduleIntervalMap[e]!)
      .toList();
}

List<enums.PaymentScheduleInterval> paymentScheduleIntervalListFromJson(
    List? paymentScheduleInterval) {
  if (paymentScheduleInterval == null) {
    return [];
  }

  return paymentScheduleInterval
      .map((e) => paymentScheduleIntervalFromJson(e.toString()))
      .toList();
}

String? productsToJson(enums.Products? products) {
  return enums.$ProductsMap[products];
}

enums.Products productsFromJson(Object? products) {
  if (products is int) {
    return enums.$ProductsMap.entries
        .firstWhere(
            (element) => element.value.toLowerCase() == products.toString(),
            orElse: () =>
                const MapEntry(enums.Products.swaggerGeneratedUnknown, ''))
        .key;
  }

  if (products is String) {
    return enums.$ProductsMap.entries
        .firstWhere(
            (element) => element.value.toLowerCase() == products.toLowerCase(),
            orElse: () =>
                const MapEntry(enums.Products.swaggerGeneratedUnknown, ''))
        .key;
  }

  return enums.Products.swaggerGeneratedUnknown;
}

List<String> productsListToJson(List<enums.Products>? products) {
  if (products == null) {
    return [];
  }

  return products.map((e) => enums.$ProductsMap[e]!).toList();
}

List<enums.Products> productsListFromJson(List? products) {
  if (products == null) {
    return [];
  }

  return products.map((e) => productsFromJson(e.toString())).toList();
}

String? productStatusStatusToJson(
    enums.ProductStatusStatus? productStatusStatus) {
  return enums.$ProductStatusStatusMap[productStatusStatus];
}

enums.ProductStatusStatus productStatusStatusFromJson(
    Object? productStatusStatus) {
  if (productStatusStatus is int) {
    return enums.$ProductStatusStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == productStatusStatus.toString(),
            orElse: () => const MapEntry(
                enums.ProductStatusStatus.swaggerGeneratedUnknown, ''))
        .key;
  }

  if (productStatusStatus is String) {
    return enums.$ProductStatusStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                productStatusStatus.toLowerCase(),
            orElse: () => const MapEntry(
                enums.ProductStatusStatus.swaggerGeneratedUnknown, ''))
        .key;
  }

  return enums.ProductStatusStatus.swaggerGeneratedUnknown;
}

List<String> productStatusStatusListToJson(
    List<enums.ProductStatusStatus>? productStatusStatus) {
  if (productStatusStatus == null) {
    return [];
  }

  return productStatusStatus
      .map((e) => enums.$ProductStatusStatusMap[e]!)
      .toList();
}

List<enums.ProductStatusStatus> productStatusStatusListFromJson(
    List? productStatusStatus) {
  if (productStatusStatus == null) {
    return [];
  }

  return productStatusStatus
      .map((e) => productStatusStatusFromJson(e.toString()))
      .toList();
}

String? productStatusBreakdownRefreshIntervalToJson(
    enums.ProductStatusBreakdownRefreshInterval?
        productStatusBreakdownRefreshInterval) {
  return enums.$ProductStatusBreakdownRefreshIntervalMap[
      productStatusBreakdownRefreshInterval];
}

enums.ProductStatusBreakdownRefreshInterval
    productStatusBreakdownRefreshIntervalFromJson(
        Object? productStatusBreakdownRefreshInterval) {
  if (productStatusBreakdownRefreshInterval is int) {
    return enums.$ProductStatusBreakdownRefreshIntervalMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                productStatusBreakdownRefreshInterval.toString(),
            orElse: () => const MapEntry(
                enums.ProductStatusBreakdownRefreshInterval
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  if (productStatusBreakdownRefreshInterval is String) {
    return enums.$ProductStatusBreakdownRefreshIntervalMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                productStatusBreakdownRefreshInterval.toLowerCase(),
            orElse: () => const MapEntry(
                enums.ProductStatusBreakdownRefreshInterval
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  return enums.ProductStatusBreakdownRefreshInterval.swaggerGeneratedUnknown;
}

List<String> productStatusBreakdownRefreshIntervalListToJson(
    List<enums.ProductStatusBreakdownRefreshInterval>?
        productStatusBreakdownRefreshInterval) {
  if (productStatusBreakdownRefreshInterval == null) {
    return [];
  }

  return productStatusBreakdownRefreshInterval
      .map((e) => enums.$ProductStatusBreakdownRefreshIntervalMap[e]!)
      .toList();
}

List<enums.ProductStatusBreakdownRefreshInterval>
    productStatusBreakdownRefreshIntervalListFromJson(
        List? productStatusBreakdownRefreshInterval) {
  if (productStatusBreakdownRefreshInterval == null) {
    return [];
  }

  return productStatusBreakdownRefreshInterval
      .map((e) => productStatusBreakdownRefreshIntervalFromJson(e.toString()))
      .toList();
}

String? warningWarningCodeToJson(enums.WarningWarningCode? warningWarningCode) {
  return enums.$WarningWarningCodeMap[warningWarningCode];
}

enums.WarningWarningCode warningWarningCodeFromJson(
    Object? warningWarningCode) {
  if (warningWarningCode is int) {
    return enums.$WarningWarningCodeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == warningWarningCode.toString(),
            orElse: () => const MapEntry(
                enums.WarningWarningCode.swaggerGeneratedUnknown, ''))
        .key;
  }

  if (warningWarningCode is String) {
    return enums.$WarningWarningCodeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == warningWarningCode.toLowerCase(),
            orElse: () => const MapEntry(
                enums.WarningWarningCode.swaggerGeneratedUnknown, ''))
        .key;
  }

  return enums.WarningWarningCode.swaggerGeneratedUnknown;
}

List<String> warningWarningCodeListToJson(
    List<enums.WarningWarningCode>? warningWarningCode) {
  if (warningWarningCode == null) {
    return [];
  }

  return warningWarningCode
      .map((e) => enums.$WarningWarningCodeMap[e]!)
      .toList();
}

List<enums.WarningWarningCode> warningWarningCodeListFromJson(
    List? warningWarningCode) {
  if (warningWarningCode == null) {
    return [];
  }

  return warningWarningCode
      .map((e) => warningWarningCodeFromJson(e.toString()))
      .toList();
}

String? paymentAmountCurrencyToJson(
    enums.PaymentAmountCurrency? paymentAmountCurrency) {
  return enums.$PaymentAmountCurrencyMap[paymentAmountCurrency];
}

enums.PaymentAmountCurrency paymentAmountCurrencyFromJson(
    Object? paymentAmountCurrency) {
  if (paymentAmountCurrency is int) {
    return enums.$PaymentAmountCurrencyMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == paymentAmountCurrency.toString(),
            orElse: () => const MapEntry(
                enums.PaymentAmountCurrency.swaggerGeneratedUnknown, ''))
        .key;
  }

  if (paymentAmountCurrency is String) {
    return enums.$PaymentAmountCurrencyMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                paymentAmountCurrency.toLowerCase(),
            orElse: () => const MapEntry(
                enums.PaymentAmountCurrency.swaggerGeneratedUnknown, ''))
        .key;
  }

  return enums.PaymentAmountCurrency.swaggerGeneratedUnknown;
}

List<String> paymentAmountCurrencyListToJson(
    List<enums.PaymentAmountCurrency>? paymentAmountCurrency) {
  if (paymentAmountCurrency == null) {
    return [];
  }

  return paymentAmountCurrency
      .map((e) => enums.$PaymentAmountCurrencyMap[e]!)
      .toList();
}

List<enums.PaymentAmountCurrency> paymentAmountCurrencyListFromJson(
    List? paymentAmountCurrency) {
  if (paymentAmountCurrency == null) {
    return [];
  }

  return paymentAmountCurrency
      .map((e) => paymentAmountCurrencyFromJson(e.toString()))
      .toList();
}

String? paymentStatusUpdateWebhookNewPaymentStatusToJson(
    enums.PaymentStatusUpdateWebhookNewPaymentStatus?
        paymentStatusUpdateWebhookNewPaymentStatus) {
  return enums.$PaymentStatusUpdateWebhookNewPaymentStatusMap[
      paymentStatusUpdateWebhookNewPaymentStatus];
}

enums.PaymentStatusUpdateWebhookNewPaymentStatus
    paymentStatusUpdateWebhookNewPaymentStatusFromJson(
        Object? paymentStatusUpdateWebhookNewPaymentStatus) {
  if (paymentStatusUpdateWebhookNewPaymentStatus is int) {
    return enums.$PaymentStatusUpdateWebhookNewPaymentStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                paymentStatusUpdateWebhookNewPaymentStatus.toString(),
            orElse: () => const MapEntry(
                enums.PaymentStatusUpdateWebhookNewPaymentStatus
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  if (paymentStatusUpdateWebhookNewPaymentStatus is String) {
    return enums.$PaymentStatusUpdateWebhookNewPaymentStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                paymentStatusUpdateWebhookNewPaymentStatus.toLowerCase(),
            orElse: () => const MapEntry(
                enums.PaymentStatusUpdateWebhookNewPaymentStatus
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  return enums
      .PaymentStatusUpdateWebhookNewPaymentStatus.swaggerGeneratedUnknown;
}

List<String> paymentStatusUpdateWebhookNewPaymentStatusListToJson(
    List<enums.PaymentStatusUpdateWebhookNewPaymentStatus>?
        paymentStatusUpdateWebhookNewPaymentStatus) {
  if (paymentStatusUpdateWebhookNewPaymentStatus == null) {
    return [];
  }

  return paymentStatusUpdateWebhookNewPaymentStatus
      .map((e) => enums.$PaymentStatusUpdateWebhookNewPaymentStatusMap[e]!)
      .toList();
}

List<enums.PaymentStatusUpdateWebhookNewPaymentStatus>
    paymentStatusUpdateWebhookNewPaymentStatusListFromJson(
        List? paymentStatusUpdateWebhookNewPaymentStatus) {
  if (paymentStatusUpdateWebhookNewPaymentStatus == null) {
    return [];
  }

  return paymentStatusUpdateWebhookNewPaymentStatus
      .map((e) =>
          paymentStatusUpdateWebhookNewPaymentStatusFromJson(e.toString()))
      .toList();
}

String? paymentStatusUpdateWebhookOldPaymentStatusToJson(
    enums.PaymentStatusUpdateWebhookOldPaymentStatus?
        paymentStatusUpdateWebhookOldPaymentStatus) {
  return enums.$PaymentStatusUpdateWebhookOldPaymentStatusMap[
      paymentStatusUpdateWebhookOldPaymentStatus];
}

enums.PaymentStatusUpdateWebhookOldPaymentStatus
    paymentStatusUpdateWebhookOldPaymentStatusFromJson(
        Object? paymentStatusUpdateWebhookOldPaymentStatus) {
  if (paymentStatusUpdateWebhookOldPaymentStatus is int) {
    return enums.$PaymentStatusUpdateWebhookOldPaymentStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                paymentStatusUpdateWebhookOldPaymentStatus.toString(),
            orElse: () => const MapEntry(
                enums.PaymentStatusUpdateWebhookOldPaymentStatus
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  if (paymentStatusUpdateWebhookOldPaymentStatus is String) {
    return enums.$PaymentStatusUpdateWebhookOldPaymentStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                paymentStatusUpdateWebhookOldPaymentStatus.toLowerCase(),
            orElse: () => const MapEntry(
                enums.PaymentStatusUpdateWebhookOldPaymentStatus
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  return enums
      .PaymentStatusUpdateWebhookOldPaymentStatus.swaggerGeneratedUnknown;
}

List<String> paymentStatusUpdateWebhookOldPaymentStatusListToJson(
    List<enums.PaymentStatusUpdateWebhookOldPaymentStatus>?
        paymentStatusUpdateWebhookOldPaymentStatus) {
  if (paymentStatusUpdateWebhookOldPaymentStatus == null) {
    return [];
  }

  return paymentStatusUpdateWebhookOldPaymentStatus
      .map((e) => enums.$PaymentStatusUpdateWebhookOldPaymentStatusMap[e]!)
      .toList();
}

List<enums.PaymentStatusUpdateWebhookOldPaymentStatus>
    paymentStatusUpdateWebhookOldPaymentStatusListFromJson(
        List? paymentStatusUpdateWebhookOldPaymentStatus) {
  if (paymentStatusUpdateWebhookOldPaymentStatus == null) {
    return [];
  }

  return paymentStatusUpdateWebhookOldPaymentStatus
      .map((e) =>
          paymentStatusUpdateWebhookOldPaymentStatusFromJson(e.toString()))
      .toList();
}

String? investmentTransactionType$ToJson(
    enums.InvestmentTransactionType$? investmentTransactionType$) {
  return enums.$InvestmentTransactionType$Map[investmentTransactionType$];
}

enums.InvestmentTransactionType$ investmentTransactionType$FromJson(
    Object? investmentTransactionType$) {
  if (investmentTransactionType$ is int) {
    return enums.$InvestmentTransactionType$Map.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                investmentTransactionType$.toString(),
            orElse: () => const MapEntry(
                enums.InvestmentTransactionType$.swaggerGeneratedUnknown, ''))
        .key;
  }

  if (investmentTransactionType$ is String) {
    return enums.$InvestmentTransactionType$Map.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                investmentTransactionType$.toLowerCase(),
            orElse: () => const MapEntry(
                enums.InvestmentTransactionType$.swaggerGeneratedUnknown, ''))
        .key;
  }

  return enums.InvestmentTransactionType$.swaggerGeneratedUnknown;
}

List<String> investmentTransactionType$ListToJson(
    List<enums.InvestmentTransactionType$>? investmentTransactionType$) {
  if (investmentTransactionType$ == null) {
    return [];
  }

  return investmentTransactionType$
      .map((e) => enums.$InvestmentTransactionType$Map[e]!)
      .toList();
}

List<enums.InvestmentTransactionType$> investmentTransactionType$ListFromJson(
    List? investmentTransactionType$) {
  if (investmentTransactionType$ == null) {
    return [];
  }

  return investmentTransactionType$
      .map((e) => investmentTransactionType$FromJson(e.toString()))
      .toList();
}

String? investmentTransactionSubtypeToJson(
    enums.InvestmentTransactionSubtype? investmentTransactionSubtype) {
  return enums.$InvestmentTransactionSubtypeMap[investmentTransactionSubtype];
}

enums.InvestmentTransactionSubtype investmentTransactionSubtypeFromJson(
    Object? investmentTransactionSubtype) {
  if (investmentTransactionSubtype is int) {
    return enums.$InvestmentTransactionSubtypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                investmentTransactionSubtype.toString(),
            orElse: () => const MapEntry(
                enums.InvestmentTransactionSubtype.swaggerGeneratedUnknown, ''))
        .key;
  }

  if (investmentTransactionSubtype is String) {
    return enums.$InvestmentTransactionSubtypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                investmentTransactionSubtype.toLowerCase(),
            orElse: () => const MapEntry(
                enums.InvestmentTransactionSubtype.swaggerGeneratedUnknown, ''))
        .key;
  }

  return enums.InvestmentTransactionSubtype.swaggerGeneratedUnknown;
}

List<String> investmentTransactionSubtypeListToJson(
    List<enums.InvestmentTransactionSubtype>? investmentTransactionSubtype) {
  if (investmentTransactionSubtype == null) {
    return [];
  }

  return investmentTransactionSubtype
      .map((e) => enums.$InvestmentTransactionSubtypeMap[e]!)
      .toList();
}

List<enums.InvestmentTransactionSubtype>
    investmentTransactionSubtypeListFromJson(
        List? investmentTransactionSubtype) {
  if (investmentTransactionSubtype == null) {
    return [];
  }

  return investmentTransactionSubtype
      .map((e) => investmentTransactionSubtypeFromJson(e.toString()))
      .toList();
}

String? depositSwitchGetResponseStateToJson(
    enums.DepositSwitchGetResponseState? depositSwitchGetResponseState) {
  return enums.$DepositSwitchGetResponseStateMap[depositSwitchGetResponseState];
}

enums.DepositSwitchGetResponseState depositSwitchGetResponseStateFromJson(
    Object? depositSwitchGetResponseState) {
  if (depositSwitchGetResponseState is int) {
    return enums.$DepositSwitchGetResponseStateMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                depositSwitchGetResponseState.toString(),
            orElse: () => const MapEntry(
                enums.DepositSwitchGetResponseState.swaggerGeneratedUnknown,
                ''))
        .key;
  }

  if (depositSwitchGetResponseState is String) {
    return enums.$DepositSwitchGetResponseStateMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                depositSwitchGetResponseState.toLowerCase(),
            orElse: () => const MapEntry(
                enums.DepositSwitchGetResponseState.swaggerGeneratedUnknown,
                ''))
        .key;
  }

  return enums.DepositSwitchGetResponseState.swaggerGeneratedUnknown;
}

List<String> depositSwitchGetResponseStateListToJson(
    List<enums.DepositSwitchGetResponseState>? depositSwitchGetResponseState) {
  if (depositSwitchGetResponseState == null) {
    return [];
  }

  return depositSwitchGetResponseState
      .map((e) => enums.$DepositSwitchGetResponseStateMap[e]!)
      .toList();
}

List<enums.DepositSwitchGetResponseState>
    depositSwitchGetResponseStateListFromJson(
        List? depositSwitchGetResponseState) {
  if (depositSwitchGetResponseState == null) {
    return [];
  }

  return depositSwitchGetResponseState
      .map((e) => depositSwitchGetResponseStateFromJson(e.toString()))
      .toList();
}

String? depositSwitchGetResponseSwitchMethodToJson(
    enums.DepositSwitchGetResponseSwitchMethod?
        depositSwitchGetResponseSwitchMethod) {
  return enums.$DepositSwitchGetResponseSwitchMethodMap[
      depositSwitchGetResponseSwitchMethod];
}

enums.DepositSwitchGetResponseSwitchMethod
    depositSwitchGetResponseSwitchMethodFromJson(
        Object? depositSwitchGetResponseSwitchMethod) {
  if (depositSwitchGetResponseSwitchMethod is int) {
    return enums.$DepositSwitchGetResponseSwitchMethodMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                depositSwitchGetResponseSwitchMethod.toString(),
            orElse: () => const MapEntry(
                enums.DepositSwitchGetResponseSwitchMethod
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  if (depositSwitchGetResponseSwitchMethod is String) {
    return enums.$DepositSwitchGetResponseSwitchMethodMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                depositSwitchGetResponseSwitchMethod.toLowerCase(),
            orElse: () => const MapEntry(
                enums.DepositSwitchGetResponseSwitchMethod
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  return enums.DepositSwitchGetResponseSwitchMethod.swaggerGeneratedUnknown;
}

List<String> depositSwitchGetResponseSwitchMethodListToJson(
    List<enums.DepositSwitchGetResponseSwitchMethod>?
        depositSwitchGetResponseSwitchMethod) {
  if (depositSwitchGetResponseSwitchMethod == null) {
    return [];
  }

  return depositSwitchGetResponseSwitchMethod
      .map((e) => enums.$DepositSwitchGetResponseSwitchMethodMap[e]!)
      .toList();
}

List<enums.DepositSwitchGetResponseSwitchMethod>
    depositSwitchGetResponseSwitchMethodListFromJson(
        List? depositSwitchGetResponseSwitchMethod) {
  if (depositSwitchGetResponseSwitchMethod == null) {
    return [];
  }

  return depositSwitchGetResponseSwitchMethod
      .map((e) => depositSwitchGetResponseSwitchMethodFromJson(e.toString()))
      .toList();
}

String? aCHClassToJson(enums.ACHClass? aCHClass) {
  return enums.$ACHClassMap[aCHClass];
}

enums.ACHClass aCHClassFromJson(Object? aCHClass) {
  if (aCHClass is int) {
    return enums.$ACHClassMap.entries
        .firstWhere(
            (element) => element.value.toLowerCase() == aCHClass.toString(),
            orElse: () =>
                const MapEntry(enums.ACHClass.swaggerGeneratedUnknown, ''))
        .key;
  }

  if (aCHClass is String) {
    return enums.$ACHClassMap.entries
        .firstWhere(
            (element) => element.value.toLowerCase() == aCHClass.toLowerCase(),
            orElse: () =>
                const MapEntry(enums.ACHClass.swaggerGeneratedUnknown, ''))
        .key;
  }

  return enums.ACHClass.swaggerGeneratedUnknown;
}

List<String> aCHClassListToJson(List<enums.ACHClass>? aCHClass) {
  if (aCHClass == null) {
    return [];
  }

  return aCHClass.map((e) => enums.$ACHClassMap[e]!).toList();
}

List<enums.ACHClass> aCHClassListFromJson(List? aCHClass) {
  if (aCHClass == null) {
    return [];
  }

  return aCHClass.map((e) => aCHClassFromJson(e.toString())).toList();
}

String? transferIntentCreateModeToJson(
    enums.TransferIntentCreateMode? transferIntentCreateMode) {
  return enums.$TransferIntentCreateModeMap[transferIntentCreateMode];
}

enums.TransferIntentCreateMode transferIntentCreateModeFromJson(
    Object? transferIntentCreateMode) {
  if (transferIntentCreateMode is int) {
    return enums.$TransferIntentCreateModeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                transferIntentCreateMode.toString(),
            orElse: () => const MapEntry(
                enums.TransferIntentCreateMode.swaggerGeneratedUnknown, ''))
        .key;
  }

  if (transferIntentCreateMode is String) {
    return enums.$TransferIntentCreateModeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                transferIntentCreateMode.toLowerCase(),
            orElse: () => const MapEntry(
                enums.TransferIntentCreateMode.swaggerGeneratedUnknown, ''))
        .key;
  }

  return enums.TransferIntentCreateMode.swaggerGeneratedUnknown;
}

List<String> transferIntentCreateModeListToJson(
    List<enums.TransferIntentCreateMode>? transferIntentCreateMode) {
  if (transferIntentCreateMode == null) {
    return [];
  }

  return transferIntentCreateMode
      .map((e) => enums.$TransferIntentCreateModeMap[e]!)
      .toList();
}

List<enums.TransferIntentCreateMode> transferIntentCreateModeListFromJson(
    List? transferIntentCreateMode) {
  if (transferIntentCreateMode == null) {
    return [];
  }

  return transferIntentCreateMode
      .map((e) => transferIntentCreateModeFromJson(e.toString()))
      .toList();
}

String? transferAuthorizationDecisionRationaleCodeToJson(
    enums.TransferAuthorizationDecisionRationaleCode?
        transferAuthorizationDecisionRationaleCode) {
  return enums.$TransferAuthorizationDecisionRationaleCodeMap[
      transferAuthorizationDecisionRationaleCode];
}

enums.TransferAuthorizationDecisionRationaleCode
    transferAuthorizationDecisionRationaleCodeFromJson(
        Object? transferAuthorizationDecisionRationaleCode) {
  if (transferAuthorizationDecisionRationaleCode is int) {
    return enums.$TransferAuthorizationDecisionRationaleCodeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                transferAuthorizationDecisionRationaleCode.toString(),
            orElse: () => const MapEntry(
                enums.TransferAuthorizationDecisionRationaleCode
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  if (transferAuthorizationDecisionRationaleCode is String) {
    return enums.$TransferAuthorizationDecisionRationaleCodeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                transferAuthorizationDecisionRationaleCode.toLowerCase(),
            orElse: () => const MapEntry(
                enums.TransferAuthorizationDecisionRationaleCode
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  return enums
      .TransferAuthorizationDecisionRationaleCode.swaggerGeneratedUnknown;
}

List<String> transferAuthorizationDecisionRationaleCodeListToJson(
    List<enums.TransferAuthorizationDecisionRationaleCode>?
        transferAuthorizationDecisionRationaleCode) {
  if (transferAuthorizationDecisionRationaleCode == null) {
    return [];
  }

  return transferAuthorizationDecisionRationaleCode
      .map((e) => enums.$TransferAuthorizationDecisionRationaleCodeMap[e]!)
      .toList();
}

List<enums.TransferAuthorizationDecisionRationaleCode>
    transferAuthorizationDecisionRationaleCodeListFromJson(
        List? transferAuthorizationDecisionRationaleCode) {
  if (transferAuthorizationDecisionRationaleCode == null) {
    return [];
  }

  return transferAuthorizationDecisionRationaleCode
      .map((e) =>
          transferAuthorizationDecisionRationaleCodeFromJson(e.toString()))
      .toList();
}

String? transferTypeToJson(enums.TransferType? transferType) {
  return enums.$TransferTypeMap[transferType];
}

enums.TransferType transferTypeFromJson(Object? transferType) {
  if (transferType is int) {
    return enums.$TransferTypeMap.entries
        .firstWhere(
            (element) => element.value.toLowerCase() == transferType.toString(),
            orElse: () =>
                const MapEntry(enums.TransferType.swaggerGeneratedUnknown, ''))
        .key;
  }

  if (transferType is String) {
    return enums.$TransferTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == transferType.toLowerCase(),
            orElse: () =>
                const MapEntry(enums.TransferType.swaggerGeneratedUnknown, ''))
        .key;
  }

  return enums.TransferType.swaggerGeneratedUnknown;
}

List<String> transferTypeListToJson(List<enums.TransferType>? transferType) {
  if (transferType == null) {
    return [];
  }

  return transferType.map((e) => enums.$TransferTypeMap[e]!).toList();
}

List<enums.TransferType> transferTypeListFromJson(List? transferType) {
  if (transferType == null) {
    return [];
  }

  return transferType.map((e) => transferTypeFromJson(e.toString())).toList();
}

String? bankTransferTypeToJson(enums.BankTransferType? bankTransferType) {
  return enums.$BankTransferTypeMap[bankTransferType];
}

enums.BankTransferType bankTransferTypeFromJson(Object? bankTransferType) {
  if (bankTransferType is int) {
    return enums.$BankTransferTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == bankTransferType.toString(),
            orElse: () => const MapEntry(
                enums.BankTransferType.swaggerGeneratedUnknown, ''))
        .key;
  }

  if (bankTransferType is String) {
    return enums.$BankTransferTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == bankTransferType.toLowerCase(),
            orElse: () => const MapEntry(
                enums.BankTransferType.swaggerGeneratedUnknown, ''))
        .key;
  }

  return enums.BankTransferType.swaggerGeneratedUnknown;
}

List<String> bankTransferTypeListToJson(
    List<enums.BankTransferType>? bankTransferType) {
  if (bankTransferType == null) {
    return [];
  }

  return bankTransferType.map((e) => enums.$BankTransferTypeMap[e]!).toList();
}

List<enums.BankTransferType> bankTransferTypeListFromJson(
    List? bankTransferType) {
  if (bankTransferType == null) {
    return [];
  }

  return bankTransferType
      .map((e) => bankTransferTypeFromJson(e.toString()))
      .toList();
}

String? transferStatusToJson(enums.TransferStatus? transferStatus) {
  return enums.$TransferStatusMap[transferStatus];
}

enums.TransferStatus transferStatusFromJson(Object? transferStatus) {
  if (transferStatus is int) {
    return enums.$TransferStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == transferStatus.toString(),
            orElse: () => const MapEntry(
                enums.TransferStatus.swaggerGeneratedUnknown, ''))
        .key;
  }

  if (transferStatus is String) {
    return enums.$TransferStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == transferStatus.toLowerCase(),
            orElse: () => const MapEntry(
                enums.TransferStatus.swaggerGeneratedUnknown, ''))
        .key;
  }

  return enums.TransferStatus.swaggerGeneratedUnknown;
}

List<String> transferStatusListToJson(
    List<enums.TransferStatus>? transferStatus) {
  if (transferStatus == null) {
    return [];
  }

  return transferStatus.map((e) => enums.$TransferStatusMap[e]!).toList();
}

List<enums.TransferStatus> transferStatusListFromJson(List? transferStatus) {
  if (transferStatus == null) {
    return [];
  }

  return transferStatus
      .map((e) => transferStatusFromJson(e.toString()))
      .toList();
}

String? transferSweepStatusToJson(
    enums.TransferSweepStatus? transferSweepStatus) {
  return enums.$TransferSweepStatusMap[transferSweepStatus];
}

enums.TransferSweepStatus transferSweepStatusFromJson(
    Object? transferSweepStatus) {
  if (transferSweepStatus is int) {
    return enums.$TransferSweepStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == transferSweepStatus.toString(),
            orElse: () => const MapEntry(
                enums.TransferSweepStatus.swaggerGeneratedUnknown, ''))
        .key;
  }

  if (transferSweepStatus is String) {
    return enums.$TransferSweepStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                transferSweepStatus.toLowerCase(),
            orElse: () => const MapEntry(
                enums.TransferSweepStatus.swaggerGeneratedUnknown, ''))
        .key;
  }

  return enums.TransferSweepStatus.swaggerGeneratedUnknown;
}

List<String> transferSweepStatusListToJson(
    List<enums.TransferSweepStatus>? transferSweepStatus) {
  if (transferSweepStatus == null) {
    return [];
  }

  return transferSweepStatus
      .map((e) => enums.$TransferSweepStatusMap[e]!)
      .toList();
}

List<enums.TransferSweepStatus> transferSweepStatusListFromJson(
    List? transferSweepStatus) {
  if (transferSweepStatus == null) {
    return [];
  }

  return transferSweepStatus
      .map((e) => transferSweepStatusFromJson(e.toString()))
      .toList();
}

String? bankTransferStatusToJson(enums.BankTransferStatus? bankTransferStatus) {
  return enums.$BankTransferStatusMap[bankTransferStatus];
}

enums.BankTransferStatus bankTransferStatusFromJson(
    Object? bankTransferStatus) {
  if (bankTransferStatus is int) {
    return enums.$BankTransferStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == bankTransferStatus.toString(),
            orElse: () => const MapEntry(
                enums.BankTransferStatus.swaggerGeneratedUnknown, ''))
        .key;
  }

  if (bankTransferStatus is String) {
    return enums.$BankTransferStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == bankTransferStatus.toLowerCase(),
            orElse: () => const MapEntry(
                enums.BankTransferStatus.swaggerGeneratedUnknown, ''))
        .key;
  }

  return enums.BankTransferStatus.swaggerGeneratedUnknown;
}

List<String> bankTransferStatusListToJson(
    List<enums.BankTransferStatus>? bankTransferStatus) {
  if (bankTransferStatus == null) {
    return [];
  }

  return bankTransferStatus
      .map((e) => enums.$BankTransferStatusMap[e]!)
      .toList();
}

List<enums.BankTransferStatus> bankTransferStatusListFromJson(
    List? bankTransferStatus) {
  if (bankTransferStatus == null) {
    return [];
  }

  return bankTransferStatus
      .map((e) => bankTransferStatusFromJson(e.toString()))
      .toList();
}

String? transferNetworkToJson(enums.TransferNetwork? transferNetwork) {
  return enums.$TransferNetworkMap[transferNetwork];
}

enums.TransferNetwork transferNetworkFromJson(Object? transferNetwork) {
  if (transferNetwork is int) {
    return enums.$TransferNetworkMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == transferNetwork.toString(),
            orElse: () => const MapEntry(
                enums.TransferNetwork.swaggerGeneratedUnknown, ''))
        .key;
  }

  if (transferNetwork is String) {
    return enums.$TransferNetworkMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == transferNetwork.toLowerCase(),
            orElse: () => const MapEntry(
                enums.TransferNetwork.swaggerGeneratedUnknown, ''))
        .key;
  }

  return enums.TransferNetwork.swaggerGeneratedUnknown;
}

List<String> transferNetworkListToJson(
    List<enums.TransferNetwork>? transferNetwork) {
  if (transferNetwork == null) {
    return [];
  }

  return transferNetwork.map((e) => enums.$TransferNetworkMap[e]!).toList();
}

List<enums.TransferNetwork> transferNetworkListFromJson(List? transferNetwork) {
  if (transferNetwork == null) {
    return [];
  }

  return transferNetwork
      .map((e) => transferNetworkFromJson(e.toString()))
      .toList();
}

String? bankTransferNetworkToJson(
    enums.BankTransferNetwork? bankTransferNetwork) {
  return enums.$BankTransferNetworkMap[bankTransferNetwork];
}

enums.BankTransferNetwork bankTransferNetworkFromJson(
    Object? bankTransferNetwork) {
  if (bankTransferNetwork is int) {
    return enums.$BankTransferNetworkMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == bankTransferNetwork.toString(),
            orElse: () => const MapEntry(
                enums.BankTransferNetwork.swaggerGeneratedUnknown, ''))
        .key;
  }

  if (bankTransferNetwork is String) {
    return enums.$BankTransferNetworkMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                bankTransferNetwork.toLowerCase(),
            orElse: () => const MapEntry(
                enums.BankTransferNetwork.swaggerGeneratedUnknown, ''))
        .key;
  }

  return enums.BankTransferNetwork.swaggerGeneratedUnknown;
}

List<String> bankTransferNetworkListToJson(
    List<enums.BankTransferNetwork>? bankTransferNetwork) {
  if (bankTransferNetwork == null) {
    return [];
  }

  return bankTransferNetwork
      .map((e) => enums.$BankTransferNetworkMap[e]!)
      .toList();
}

List<enums.BankTransferNetwork> bankTransferNetworkListFromJson(
    List? bankTransferNetwork) {
  if (bankTransferNetwork == null) {
    return [];
  }

  return bankTransferNetwork
      .map((e) => bankTransferNetworkFromJson(e.toString()))
      .toList();
}

String? transferAuthorizationDecisionToJson(
    enums.TransferAuthorizationDecision? transferAuthorizationDecision) {
  return enums.$TransferAuthorizationDecisionMap[transferAuthorizationDecision];
}

enums.TransferAuthorizationDecision transferAuthorizationDecisionFromJson(
    Object? transferAuthorizationDecision) {
  if (transferAuthorizationDecision is int) {
    return enums.$TransferAuthorizationDecisionMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                transferAuthorizationDecision.toString(),
            orElse: () => const MapEntry(
                enums.TransferAuthorizationDecision.swaggerGeneratedUnknown,
                ''))
        .key;
  }

  if (transferAuthorizationDecision is String) {
    return enums.$TransferAuthorizationDecisionMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                transferAuthorizationDecision.toLowerCase(),
            orElse: () => const MapEntry(
                enums.TransferAuthorizationDecision.swaggerGeneratedUnknown,
                ''))
        .key;
  }

  return enums.TransferAuthorizationDecision.swaggerGeneratedUnknown;
}

List<String> transferAuthorizationDecisionListToJson(
    List<enums.TransferAuthorizationDecision>? transferAuthorizationDecision) {
  if (transferAuthorizationDecision == null) {
    return [];
  }

  return transferAuthorizationDecision
      .map((e) => enums.$TransferAuthorizationDecisionMap[e]!)
      .toList();
}

List<enums.TransferAuthorizationDecision>
    transferAuthorizationDecisionListFromJson(
        List? transferAuthorizationDecision) {
  if (transferAuthorizationDecision == null) {
    return [];
  }

  return transferAuthorizationDecision
      .map((e) => transferAuthorizationDecisionFromJson(e.toString()))
      .toList();
}

String? bankTransferDirectionToJson(
    enums.BankTransferDirection? bankTransferDirection) {
  return enums.$BankTransferDirectionMap[bankTransferDirection];
}

enums.BankTransferDirection bankTransferDirectionFromJson(
    Object? bankTransferDirection) {
  if (bankTransferDirection is int) {
    return enums.$BankTransferDirectionMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == bankTransferDirection.toString(),
            orElse: () => const MapEntry(
                enums.BankTransferDirection.swaggerGeneratedUnknown, ''))
        .key;
  }

  if (bankTransferDirection is String) {
    return enums.$BankTransferDirectionMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                bankTransferDirection.toLowerCase(),
            orElse: () => const MapEntry(
                enums.BankTransferDirection.swaggerGeneratedUnknown, ''))
        .key;
  }

  return enums.BankTransferDirection.swaggerGeneratedUnknown;
}

List<String> bankTransferDirectionListToJson(
    List<enums.BankTransferDirection>? bankTransferDirection) {
  if (bankTransferDirection == null) {
    return [];
  }

  return bankTransferDirection
      .map((e) => enums.$BankTransferDirectionMap[e]!)
      .toList();
}

List<enums.BankTransferDirection> bankTransferDirectionListFromJson(
    List? bankTransferDirection) {
  if (bankTransferDirection == null) {
    return [];
  }

  return bankTransferDirection
      .map((e) => bankTransferDirectionFromJson(e.toString()))
      .toList();
}

String? transferEventListRequestTransferTypeToJson(
    enums.TransferEventListRequestTransferType?
        transferEventListRequestTransferType) {
  return enums.$TransferEventListRequestTransferTypeMap[
      transferEventListRequestTransferType];
}

enums.TransferEventListRequestTransferType
    transferEventListRequestTransferTypeFromJson(
        Object? transferEventListRequestTransferType) {
  if (transferEventListRequestTransferType is int) {
    return enums.$TransferEventListRequestTransferTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                transferEventListRequestTransferType.toString(),
            orElse: () => const MapEntry(
                enums.TransferEventListRequestTransferType
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  if (transferEventListRequestTransferType is String) {
    return enums.$TransferEventListRequestTransferTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                transferEventListRequestTransferType.toLowerCase(),
            orElse: () => const MapEntry(
                enums.TransferEventListRequestTransferType
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  return enums.TransferEventListRequestTransferType.swaggerGeneratedUnknown;
}

List<String> transferEventListRequestTransferTypeListToJson(
    List<enums.TransferEventListRequestTransferType>?
        transferEventListRequestTransferType) {
  if (transferEventListRequestTransferType == null) {
    return [];
  }

  return transferEventListRequestTransferType
      .map((e) => enums.$TransferEventListRequestTransferTypeMap[e]!)
      .toList();
}

List<enums.TransferEventListRequestTransferType>
    transferEventListRequestTransferTypeListFromJson(
        List? transferEventListRequestTransferType) {
  if (transferEventListRequestTransferType == null) {
    return [];
  }

  return transferEventListRequestTransferType
      .map((e) => transferEventListRequestTransferTypeFromJson(e.toString()))
      .toList();
}

String? bankTransferEventListRequestBankTransferTypeToJson(
    enums.BankTransferEventListRequestBankTransferType?
        bankTransferEventListRequestBankTransferType) {
  return enums.$BankTransferEventListRequestBankTransferTypeMap[
      bankTransferEventListRequestBankTransferType];
}

enums.BankTransferEventListRequestBankTransferType
    bankTransferEventListRequestBankTransferTypeFromJson(
        Object? bankTransferEventListRequestBankTransferType) {
  if (bankTransferEventListRequestBankTransferType is int) {
    return enums.$BankTransferEventListRequestBankTransferTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                bankTransferEventListRequestBankTransferType.toString(),
            orElse: () => const MapEntry(
                enums.BankTransferEventListRequestBankTransferType
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  if (bankTransferEventListRequestBankTransferType is String) {
    return enums.$BankTransferEventListRequestBankTransferTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                bankTransferEventListRequestBankTransferType.toLowerCase(),
            orElse: () => const MapEntry(
                enums.BankTransferEventListRequestBankTransferType
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  return enums
      .BankTransferEventListRequestBankTransferType.swaggerGeneratedUnknown;
}

List<String> bankTransferEventListRequestBankTransferTypeListToJson(
    List<enums.BankTransferEventListRequestBankTransferType>?
        bankTransferEventListRequestBankTransferType) {
  if (bankTransferEventListRequestBankTransferType == null) {
    return [];
  }

  return bankTransferEventListRequestBankTransferType
      .map((e) => enums.$BankTransferEventListRequestBankTransferTypeMap[e]!)
      .toList();
}

List<enums.BankTransferEventListRequestBankTransferType>
    bankTransferEventListRequestBankTransferTypeListFromJson(
        List? bankTransferEventListRequestBankTransferType) {
  if (bankTransferEventListRequestBankTransferType == null) {
    return [];
  }

  return bankTransferEventListRequestBankTransferType
      .map((e) =>
          bankTransferEventListRequestBankTransferTypeFromJson(e.toString()))
      .toList();
}

String? bankTransferEventListRequestDirectionToJson(
    enums.BankTransferEventListRequestDirection?
        bankTransferEventListRequestDirection) {
  return enums.$BankTransferEventListRequestDirectionMap[
      bankTransferEventListRequestDirection];
}

enums.BankTransferEventListRequestDirection
    bankTransferEventListRequestDirectionFromJson(
        Object? bankTransferEventListRequestDirection) {
  if (bankTransferEventListRequestDirection is int) {
    return enums.$BankTransferEventListRequestDirectionMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                bankTransferEventListRequestDirection.toString(),
            orElse: () => const MapEntry(
                enums.BankTransferEventListRequestDirection
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  if (bankTransferEventListRequestDirection is String) {
    return enums.$BankTransferEventListRequestDirectionMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                bankTransferEventListRequestDirection.toLowerCase(),
            orElse: () => const MapEntry(
                enums.BankTransferEventListRequestDirection
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  return enums.BankTransferEventListRequestDirection.swaggerGeneratedUnknown;
}

List<String> bankTransferEventListRequestDirectionListToJson(
    List<enums.BankTransferEventListRequestDirection>?
        bankTransferEventListRequestDirection) {
  if (bankTransferEventListRequestDirection == null) {
    return [];
  }

  return bankTransferEventListRequestDirection
      .map((e) => enums.$BankTransferEventListRequestDirectionMap[e]!)
      .toList();
}

List<enums.BankTransferEventListRequestDirection>
    bankTransferEventListRequestDirectionListFromJson(
        List? bankTransferEventListRequestDirection) {
  if (bankTransferEventListRequestDirection == null) {
    return [];
  }

  return bankTransferEventListRequestDirection
      .map((e) => bankTransferEventListRequestDirectionFromJson(e.toString()))
      .toList();
}

String? transferEventTypeToJson(enums.TransferEventType? transferEventType) {
  return enums.$TransferEventTypeMap[transferEventType];
}

enums.TransferEventType transferEventTypeFromJson(Object? transferEventType) {
  if (transferEventType is int) {
    return enums.$TransferEventTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == transferEventType.toString(),
            orElse: () => const MapEntry(
                enums.TransferEventType.swaggerGeneratedUnknown, ''))
        .key;
  }

  if (transferEventType is String) {
    return enums.$TransferEventTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == transferEventType.toLowerCase(),
            orElse: () => const MapEntry(
                enums.TransferEventType.swaggerGeneratedUnknown, ''))
        .key;
  }

  return enums.TransferEventType.swaggerGeneratedUnknown;
}

List<String> transferEventTypeListToJson(
    List<enums.TransferEventType>? transferEventType) {
  if (transferEventType == null) {
    return [];
  }

  return transferEventType.map((e) => enums.$TransferEventTypeMap[e]!).toList();
}

List<enums.TransferEventType> transferEventTypeListFromJson(
    List? transferEventType) {
  if (transferEventType == null) {
    return [];
  }

  return transferEventType
      .map((e) => transferEventTypeFromJson(e.toString()))
      .toList();
}

String? bankTransferEventTypeToJson(
    enums.BankTransferEventType? bankTransferEventType) {
  return enums.$BankTransferEventTypeMap[bankTransferEventType];
}

enums.BankTransferEventType bankTransferEventTypeFromJson(
    Object? bankTransferEventType) {
  if (bankTransferEventType is int) {
    return enums.$BankTransferEventTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == bankTransferEventType.toString(),
            orElse: () => const MapEntry(
                enums.BankTransferEventType.swaggerGeneratedUnknown, ''))
        .key;
  }

  if (bankTransferEventType is String) {
    return enums.$BankTransferEventTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                bankTransferEventType.toLowerCase(),
            orElse: () => const MapEntry(
                enums.BankTransferEventType.swaggerGeneratedUnknown, ''))
        .key;
  }

  return enums.BankTransferEventType.swaggerGeneratedUnknown;
}

List<String> bankTransferEventTypeListToJson(
    List<enums.BankTransferEventType>? bankTransferEventType) {
  if (bankTransferEventType == null) {
    return [];
  }

  return bankTransferEventType
      .map((e) => enums.$BankTransferEventTypeMap[e]!)
      .toList();
}

List<enums.BankTransferEventType> bankTransferEventTypeListFromJson(
    List? bankTransferEventType) {
  if (bankTransferEventType == null) {
    return [];
  }

  return bankTransferEventType
      .map((e) => bankTransferEventTypeFromJson(e.toString()))
      .toList();
}

String? transferIntentCreateStatusToJson(
    enums.TransferIntentCreateStatus? transferIntentCreateStatus) {
  return enums.$TransferIntentCreateStatusMap[transferIntentCreateStatus];
}

enums.TransferIntentCreateStatus transferIntentCreateStatusFromJson(
    Object? transferIntentCreateStatus) {
  if (transferIntentCreateStatus is int) {
    return enums.$TransferIntentCreateStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                transferIntentCreateStatus.toString(),
            orElse: () => const MapEntry(
                enums.TransferIntentCreateStatus.swaggerGeneratedUnknown, ''))
        .key;
  }

  if (transferIntentCreateStatus is String) {
    return enums.$TransferIntentCreateStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                transferIntentCreateStatus.toLowerCase(),
            orElse: () => const MapEntry(
                enums.TransferIntentCreateStatus.swaggerGeneratedUnknown, ''))
        .key;
  }

  return enums.TransferIntentCreateStatus.swaggerGeneratedUnknown;
}

List<String> transferIntentCreateStatusListToJson(
    List<enums.TransferIntentCreateStatus>? transferIntentCreateStatus) {
  if (transferIntentCreateStatus == null) {
    return [];
  }

  return transferIntentCreateStatus
      .map((e) => enums.$TransferIntentCreateStatusMap[e]!)
      .toList();
}

List<enums.TransferIntentCreateStatus> transferIntentCreateStatusListFromJson(
    List? transferIntentCreateStatus) {
  if (transferIntentCreateStatus == null) {
    return [];
  }

  return transferIntentCreateStatus
      .map((e) => transferIntentCreateStatusFromJson(e.toString()))
      .toList();
}

String? transferIntentGetStatusToJson(
    enums.TransferIntentGetStatus? transferIntentGetStatus) {
  return enums.$TransferIntentGetStatusMap[transferIntentGetStatus];
}

enums.TransferIntentGetStatus transferIntentGetStatusFromJson(
    Object? transferIntentGetStatus) {
  if (transferIntentGetStatus is int) {
    return enums.$TransferIntentGetStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                transferIntentGetStatus.toString(),
            orElse: () => const MapEntry(
                enums.TransferIntentGetStatus.swaggerGeneratedUnknown, ''))
        .key;
  }

  if (transferIntentGetStatus is String) {
    return enums.$TransferIntentGetStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                transferIntentGetStatus.toLowerCase(),
            orElse: () => const MapEntry(
                enums.TransferIntentGetStatus.swaggerGeneratedUnknown, ''))
        .key;
  }

  return enums.TransferIntentGetStatus.swaggerGeneratedUnknown;
}

List<String> transferIntentGetStatusListToJson(
    List<enums.TransferIntentGetStatus>? transferIntentGetStatus) {
  if (transferIntentGetStatus == null) {
    return [];
  }

  return transferIntentGetStatus
      .map((e) => enums.$TransferIntentGetStatusMap[e]!)
      .toList();
}

List<enums.TransferIntentGetStatus> transferIntentGetStatusListFromJson(
    List? transferIntentGetStatus) {
  if (transferIntentGetStatus == null) {
    return [];
  }

  return transferIntentGetStatus
      .map((e) => transferIntentGetStatusFromJson(e.toString()))
      .toList();
}

String? transferIntentGetAuthorizationDecisionToJson(
    enums.TransferIntentGetAuthorizationDecision?
        transferIntentGetAuthorizationDecision) {
  return enums.$TransferIntentGetAuthorizationDecisionMap[
      transferIntentGetAuthorizationDecision];
}

enums.TransferIntentGetAuthorizationDecision
    transferIntentGetAuthorizationDecisionFromJson(
        Object? transferIntentGetAuthorizationDecision) {
  if (transferIntentGetAuthorizationDecision is int) {
    return enums.$TransferIntentGetAuthorizationDecisionMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                transferIntentGetAuthorizationDecision.toString(),
            orElse: () => const MapEntry(
                enums.TransferIntentGetAuthorizationDecision
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  if (transferIntentGetAuthorizationDecision is String) {
    return enums.$TransferIntentGetAuthorizationDecisionMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                transferIntentGetAuthorizationDecision.toLowerCase(),
            orElse: () => const MapEntry(
                enums.TransferIntentGetAuthorizationDecision
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  return enums.TransferIntentGetAuthorizationDecision.swaggerGeneratedUnknown;
}

List<String> transferIntentGetAuthorizationDecisionListToJson(
    List<enums.TransferIntentGetAuthorizationDecision>?
        transferIntentGetAuthorizationDecision) {
  if (transferIntentGetAuthorizationDecision == null) {
    return [];
  }

  return transferIntentGetAuthorizationDecision
      .map((e) => enums.$TransferIntentGetAuthorizationDecisionMap[e]!)
      .toList();
}

List<enums.TransferIntentGetAuthorizationDecision>
    transferIntentGetAuthorizationDecisionListFromJson(
        List? transferIntentGetAuthorizationDecision) {
  if (transferIntentGetAuthorizationDecision == null) {
    return [];
  }

  return transferIntentGetAuthorizationDecision
      .map((e) => transferIntentGetAuthorizationDecisionFromJson(e.toString()))
      .toList();
}

String? bankTransferReceiverDetailsAvailableBalanceToJson(
    enums.BankTransferReceiverDetailsAvailableBalance?
        bankTransferReceiverDetailsAvailableBalance) {
  return enums.$BankTransferReceiverDetailsAvailableBalanceMap[
      bankTransferReceiverDetailsAvailableBalance];
}

enums.BankTransferReceiverDetailsAvailableBalance
    bankTransferReceiverDetailsAvailableBalanceFromJson(
        Object? bankTransferReceiverDetailsAvailableBalance) {
  if (bankTransferReceiverDetailsAvailableBalance is int) {
    return enums.$BankTransferReceiverDetailsAvailableBalanceMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                bankTransferReceiverDetailsAvailableBalance.toString(),
            orElse: () => const MapEntry(
                enums.BankTransferReceiverDetailsAvailableBalance
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  if (bankTransferReceiverDetailsAvailableBalance is String) {
    return enums.$BankTransferReceiverDetailsAvailableBalanceMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                bankTransferReceiverDetailsAvailableBalance.toLowerCase(),
            orElse: () => const MapEntry(
                enums.BankTransferReceiverDetailsAvailableBalance
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  return enums
      .BankTransferReceiverDetailsAvailableBalance.swaggerGeneratedUnknown;
}

List<String> bankTransferReceiverDetailsAvailableBalanceListToJson(
    List<enums.BankTransferReceiverDetailsAvailableBalance>?
        bankTransferReceiverDetailsAvailableBalance) {
  if (bankTransferReceiverDetailsAvailableBalance == null) {
    return [];
  }

  return bankTransferReceiverDetailsAvailableBalance
      .map((e) => enums.$BankTransferReceiverDetailsAvailableBalanceMap[e]!)
      .toList();
}

List<enums.BankTransferReceiverDetailsAvailableBalance>
    bankTransferReceiverDetailsAvailableBalanceListFromJson(
        List? bankTransferReceiverDetailsAvailableBalance) {
  if (bankTransferReceiverDetailsAvailableBalance == null) {
    return [];
  }

  return bankTransferReceiverDetailsAvailableBalance
      .map((e) =>
          bankTransferReceiverDetailsAvailableBalanceFromJson(e.toString()))
      .toList();
}

String? accountIdentityVerificationStatusToJson(
    enums.AccountIdentityVerificationStatus?
        accountIdentityVerificationStatus) {
  return enums
      .$AccountIdentityVerificationStatusMap[accountIdentityVerificationStatus];
}

enums.AccountIdentityVerificationStatus
    accountIdentityVerificationStatusFromJson(
        Object? accountIdentityVerificationStatus) {
  if (accountIdentityVerificationStatus is int) {
    return enums.$AccountIdentityVerificationStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                accountIdentityVerificationStatus.toString(),
            orElse: () => const MapEntry(
                enums.AccountIdentityVerificationStatus.swaggerGeneratedUnknown,
                ''))
        .key;
  }

  if (accountIdentityVerificationStatus is String) {
    return enums.$AccountIdentityVerificationStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                accountIdentityVerificationStatus.toLowerCase(),
            orElse: () => const MapEntry(
                enums.AccountIdentityVerificationStatus.swaggerGeneratedUnknown,
                ''))
        .key;
  }

  return enums.AccountIdentityVerificationStatus.swaggerGeneratedUnknown;
}

List<String> accountIdentityVerificationStatusListToJson(
    List<enums.AccountIdentityVerificationStatus>?
        accountIdentityVerificationStatus) {
  if (accountIdentityVerificationStatus == null) {
    return [];
  }

  return accountIdentityVerificationStatus
      .map((e) => enums.$AccountIdentityVerificationStatusMap[e]!)
      .toList();
}

List<enums.AccountIdentityVerificationStatus>
    accountIdentityVerificationStatusListFromJson(
        List? accountIdentityVerificationStatus) {
  if (accountIdentityVerificationStatus == null) {
    return [];
  }

  return accountIdentityVerificationStatus
      .map((e) => accountIdentityVerificationStatusFromJson(e.toString()))
      .toList();
}

String? accountAssetsVerificationStatusToJson(
    enums.AccountAssetsVerificationStatus? accountAssetsVerificationStatus) {
  return enums
      .$AccountAssetsVerificationStatusMap[accountAssetsVerificationStatus];
}

enums.AccountAssetsVerificationStatus accountAssetsVerificationStatusFromJson(
    Object? accountAssetsVerificationStatus) {
  if (accountAssetsVerificationStatus is int) {
    return enums.$AccountAssetsVerificationStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                accountAssetsVerificationStatus.toString(),
            orElse: () => const MapEntry(
                enums.AccountAssetsVerificationStatus.swaggerGeneratedUnknown,
                ''))
        .key;
  }

  if (accountAssetsVerificationStatus is String) {
    return enums.$AccountAssetsVerificationStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                accountAssetsVerificationStatus.toLowerCase(),
            orElse: () => const MapEntry(
                enums.AccountAssetsVerificationStatus.swaggerGeneratedUnknown,
                ''))
        .key;
  }

  return enums.AccountAssetsVerificationStatus.swaggerGeneratedUnknown;
}

List<String> accountAssetsVerificationStatusListToJson(
    List<enums.AccountAssetsVerificationStatus>?
        accountAssetsVerificationStatus) {
  if (accountAssetsVerificationStatus == null) {
    return [];
  }

  return accountAssetsVerificationStatus
      .map((e) => enums.$AccountAssetsVerificationStatusMap[e]!)
      .toList();
}

List<enums.AccountAssetsVerificationStatus>
    accountAssetsVerificationStatusListFromJson(
        List? accountAssetsVerificationStatus) {
  if (accountAssetsVerificationStatus == null) {
    return [];
  }

  return accountAssetsVerificationStatus
      .map((e) => accountAssetsVerificationStatusFromJson(e.toString()))
      .toList();
}

String? incomeVerificationPrecheckMilitaryInfoBranchToJson(
    enums.IncomeVerificationPrecheckMilitaryInfoBranch?
        incomeVerificationPrecheckMilitaryInfoBranch) {
  return enums.$IncomeVerificationPrecheckMilitaryInfoBranchMap[
      incomeVerificationPrecheckMilitaryInfoBranch];
}

enums.IncomeVerificationPrecheckMilitaryInfoBranch
    incomeVerificationPrecheckMilitaryInfoBranchFromJson(
        Object? incomeVerificationPrecheckMilitaryInfoBranch) {
  if (incomeVerificationPrecheckMilitaryInfoBranch is int) {
    return enums.$IncomeVerificationPrecheckMilitaryInfoBranchMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                incomeVerificationPrecheckMilitaryInfoBranch.toString(),
            orElse: () => const MapEntry(
                enums.IncomeVerificationPrecheckMilitaryInfoBranch
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  if (incomeVerificationPrecheckMilitaryInfoBranch is String) {
    return enums.$IncomeVerificationPrecheckMilitaryInfoBranchMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                incomeVerificationPrecheckMilitaryInfoBranch.toLowerCase(),
            orElse: () => const MapEntry(
                enums.IncomeVerificationPrecheckMilitaryInfoBranch
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  return enums
      .IncomeVerificationPrecheckMilitaryInfoBranch.swaggerGeneratedUnknown;
}

List<String> incomeVerificationPrecheckMilitaryInfoBranchListToJson(
    List<enums.IncomeVerificationPrecheckMilitaryInfoBranch>?
        incomeVerificationPrecheckMilitaryInfoBranch) {
  if (incomeVerificationPrecheckMilitaryInfoBranch == null) {
    return [];
  }

  return incomeVerificationPrecheckMilitaryInfoBranch
      .map((e) => enums.$IncomeVerificationPrecheckMilitaryInfoBranchMap[e]!)
      .toList();
}

List<enums.IncomeVerificationPrecheckMilitaryInfoBranch>
    incomeVerificationPrecheckMilitaryInfoBranchListFromJson(
        List? incomeVerificationPrecheckMilitaryInfoBranch) {
  if (incomeVerificationPrecheckMilitaryInfoBranch == null) {
    return [];
  }

  return incomeVerificationPrecheckMilitaryInfoBranch
      .map((e) =>
          incomeVerificationPrecheckMilitaryInfoBranchFromJson(e.toString()))
      .toList();
}

String? incomeVerificationPrecheckConfidenceToJson(
    enums.IncomeVerificationPrecheckConfidence?
        incomeVerificationPrecheckConfidence) {
  return enums.$IncomeVerificationPrecheckConfidenceMap[
      incomeVerificationPrecheckConfidence];
}

enums.IncomeVerificationPrecheckConfidence
    incomeVerificationPrecheckConfidenceFromJson(
        Object? incomeVerificationPrecheckConfidence) {
  if (incomeVerificationPrecheckConfidence is int) {
    return enums.$IncomeVerificationPrecheckConfidenceMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                incomeVerificationPrecheckConfidence.toString(),
            orElse: () => const MapEntry(
                enums.IncomeVerificationPrecheckConfidence
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  if (incomeVerificationPrecheckConfidence is String) {
    return enums.$IncomeVerificationPrecheckConfidenceMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                incomeVerificationPrecheckConfidence.toLowerCase(),
            orElse: () => const MapEntry(
                enums.IncomeVerificationPrecheckConfidence
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  return enums.IncomeVerificationPrecheckConfidence.swaggerGeneratedUnknown;
}

List<String> incomeVerificationPrecheckConfidenceListToJson(
    List<enums.IncomeVerificationPrecheckConfidence>?
        incomeVerificationPrecheckConfidence) {
  if (incomeVerificationPrecheckConfidence == null) {
    return [];
  }

  return incomeVerificationPrecheckConfidence
      .map((e) => enums.$IncomeVerificationPrecheckConfidenceMap[e]!)
      .toList();
}

List<enums.IncomeVerificationPrecheckConfidence>
    incomeVerificationPrecheckConfidenceListFromJson(
        List? incomeVerificationPrecheckConfidence) {
  if (incomeVerificationPrecheckConfidence == null) {
    return [];
  }

  return incomeVerificationPrecheckConfidence
      .map((e) => incomeVerificationPrecheckConfidenceFromJson(e.toString()))
      .toList();
}

String? payFrequencyValueToJson(enums.PayFrequencyValue? payFrequencyValue) {
  return enums.$PayFrequencyValueMap[payFrequencyValue];
}

enums.PayFrequencyValue payFrequencyValueFromJson(Object? payFrequencyValue) {
  if (payFrequencyValue is int) {
    return enums.$PayFrequencyValueMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == payFrequencyValue.toString(),
            orElse: () => const MapEntry(
                enums.PayFrequencyValue.swaggerGeneratedUnknown, ''))
        .key;
  }

  if (payFrequencyValue is String) {
    return enums.$PayFrequencyValueMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == payFrequencyValue.toLowerCase(),
            orElse: () => const MapEntry(
                enums.PayFrequencyValue.swaggerGeneratedUnknown, ''))
        .key;
  }

  return enums.PayFrequencyValue.swaggerGeneratedUnknown;
}

List<String> payFrequencyValueListToJson(
    List<enums.PayFrequencyValue>? payFrequencyValue) {
  if (payFrequencyValue == null) {
    return [];
  }

  return payFrequencyValue.map((e) => enums.$PayFrequencyValueMap[e]!).toList();
}

List<enums.PayFrequencyValue> payFrequencyValueListFromJson(
    List? payFrequencyValue) {
  if (payFrequencyValue == null) {
    return [];
  }

  return payFrequencyValue
      .map((e) => payFrequencyValueFromJson(e.toString()))
      .toList();
}

String? verificationStatusToJson(enums.VerificationStatus? verificationStatus) {
  return enums.$VerificationStatusMap[verificationStatus];
}

enums.VerificationStatus verificationStatusFromJson(
    Object? verificationStatus) {
  if (verificationStatus is int) {
    return enums.$VerificationStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == verificationStatus.toString(),
            orElse: () => const MapEntry(
                enums.VerificationStatus.swaggerGeneratedUnknown, ''))
        .key;
  }

  if (verificationStatus is String) {
    return enums.$VerificationStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == verificationStatus.toLowerCase(),
            orElse: () => const MapEntry(
                enums.VerificationStatus.swaggerGeneratedUnknown, ''))
        .key;
  }

  return enums.VerificationStatus.swaggerGeneratedUnknown;
}

List<String> verificationStatusListToJson(
    List<enums.VerificationStatus>? verificationStatus) {
  if (verificationStatus == null) {
    return [];
  }

  return verificationStatus
      .map((e) => enums.$VerificationStatusMap[e]!)
      .toList();
}

List<enums.VerificationStatus> verificationStatusListFromJson(
    List? verificationStatus) {
  if (verificationStatus == null) {
    return [];
  }

  return verificationStatus
      .map((e) => verificationStatusFromJson(e.toString()))
      .toList();
}

String? verificationRefreshStatusToJson(
    enums.VerificationRefreshStatus? verificationRefreshStatus) {
  return enums.$VerificationRefreshStatusMap[verificationRefreshStatus];
}

enums.VerificationRefreshStatus verificationRefreshStatusFromJson(
    Object? verificationRefreshStatus) {
  if (verificationRefreshStatus is int) {
    return enums.$VerificationRefreshStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                verificationRefreshStatus.toString(),
            orElse: () => const MapEntry(
                enums.VerificationRefreshStatus.swaggerGeneratedUnknown, ''))
        .key;
  }

  if (verificationRefreshStatus is String) {
    return enums.$VerificationRefreshStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                verificationRefreshStatus.toLowerCase(),
            orElse: () => const MapEntry(
                enums.VerificationRefreshStatus.swaggerGeneratedUnknown, ''))
        .key;
  }

  return enums.VerificationRefreshStatus.swaggerGeneratedUnknown;
}

List<String> verificationRefreshStatusListToJson(
    List<enums.VerificationRefreshStatus>? verificationRefreshStatus) {
  if (verificationRefreshStatus == null) {
    return [];
  }

  return verificationRefreshStatus
      .map((e) => enums.$VerificationRefreshStatusMap[e]!)
      .toList();
}

List<enums.VerificationRefreshStatus> verificationRefreshStatusListFromJson(
    List? verificationRefreshStatus) {
  if (verificationRefreshStatus == null) {
    return [];
  }

  return verificationRefreshStatus
      .map((e) => verificationRefreshStatusFromJson(e.toString()))
      .toList();
}

String? docTypeToJson(enums.DocType? docType) {
  return enums.$DocTypeMap[docType];
}

enums.DocType docTypeFromJson(Object? docType) {
  if (docType is int) {
    return enums.$DocTypeMap.entries
        .firstWhere(
            (element) => element.value.toLowerCase() == docType.toString(),
            orElse: () =>
                const MapEntry(enums.DocType.swaggerGeneratedUnknown, ''))
        .key;
  }

  if (docType is String) {
    return enums.$DocTypeMap.entries
        .firstWhere(
            (element) => element.value.toLowerCase() == docType.toLowerCase(),
            orElse: () =>
                const MapEntry(enums.DocType.swaggerGeneratedUnknown, ''))
        .key;
  }

  return enums.DocType.swaggerGeneratedUnknown;
}

List<String> docTypeListToJson(List<enums.DocType>? docType) {
  if (docType == null) {
    return [];
  }

  return docType.map((e) => enums.$DocTypeMap[e]!).toList();
}

List<enums.DocType> docTypeListFromJson(List? docType) {
  if (docType == null) {
    return [];
  }

  return docType.map((e) => docTypeFromJson(e.toString())).toList();
}

String? totalCanonicalDescriptionToJson(
    enums.TotalCanonicalDescription? totalCanonicalDescription) {
  return enums.$TotalCanonicalDescriptionMap[totalCanonicalDescription];
}

enums.TotalCanonicalDescription totalCanonicalDescriptionFromJson(
    Object? totalCanonicalDescription) {
  if (totalCanonicalDescription is int) {
    return enums.$TotalCanonicalDescriptionMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                totalCanonicalDescription.toString(),
            orElse: () => const MapEntry(
                enums.TotalCanonicalDescription.swaggerGeneratedUnknown, ''))
        .key;
  }

  if (totalCanonicalDescription is String) {
    return enums.$TotalCanonicalDescriptionMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                totalCanonicalDescription.toLowerCase(),
            orElse: () => const MapEntry(
                enums.TotalCanonicalDescription.swaggerGeneratedUnknown, ''))
        .key;
  }

  return enums.TotalCanonicalDescription.swaggerGeneratedUnknown;
}

List<String> totalCanonicalDescriptionListToJson(
    List<enums.TotalCanonicalDescription>? totalCanonicalDescription) {
  if (totalCanonicalDescription == null) {
    return [];
  }

  return totalCanonicalDescription
      .map((e) => enums.$TotalCanonicalDescriptionMap[e]!)
      .toList();
}

List<enums.TotalCanonicalDescription> totalCanonicalDescriptionListFromJson(
    List? totalCanonicalDescription) {
  if (totalCanonicalDescription == null) {
    return [];
  }

  return totalCanonicalDescription
      .map((e) => totalCanonicalDescriptionFromJson(e.toString()))
      .toList();
}

String? earningsBreakdownCanonicalDescriptionToJson(
    enums.EarningsBreakdownCanonicalDescription?
        earningsBreakdownCanonicalDescription) {
  return enums.$EarningsBreakdownCanonicalDescriptionMap[
      earningsBreakdownCanonicalDescription];
}

enums.EarningsBreakdownCanonicalDescription
    earningsBreakdownCanonicalDescriptionFromJson(
        Object? earningsBreakdownCanonicalDescription) {
  if (earningsBreakdownCanonicalDescription is int) {
    return enums.$EarningsBreakdownCanonicalDescriptionMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                earningsBreakdownCanonicalDescription.toString(),
            orElse: () => const MapEntry(
                enums.EarningsBreakdownCanonicalDescription
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  if (earningsBreakdownCanonicalDescription is String) {
    return enums.$EarningsBreakdownCanonicalDescriptionMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                earningsBreakdownCanonicalDescription.toLowerCase(),
            orElse: () => const MapEntry(
                enums.EarningsBreakdownCanonicalDescription
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  return enums.EarningsBreakdownCanonicalDescription.swaggerGeneratedUnknown;
}

List<String> earningsBreakdownCanonicalDescriptionListToJson(
    List<enums.EarningsBreakdownCanonicalDescription>?
        earningsBreakdownCanonicalDescription) {
  if (earningsBreakdownCanonicalDescription == null) {
    return [];
  }

  return earningsBreakdownCanonicalDescription
      .map((e) => enums.$EarningsBreakdownCanonicalDescriptionMap[e]!)
      .toList();
}

List<enums.EarningsBreakdownCanonicalDescription>
    earningsBreakdownCanonicalDescriptionListFromJson(
        List? earningsBreakdownCanonicalDescription) {
  if (earningsBreakdownCanonicalDescription == null) {
    return [];
  }

  return earningsBreakdownCanonicalDescription
      .map((e) => earningsBreakdownCanonicalDescriptionFromJson(e.toString()))
      .toList();
}

String? paystubPayFrequencyToJson(
    enums.PaystubPayFrequency? paystubPayFrequency) {
  return enums.$PaystubPayFrequencyMap[paystubPayFrequency];
}

enums.PaystubPayFrequency paystubPayFrequencyFromJson(
    Object? paystubPayFrequency) {
  if (paystubPayFrequency is int) {
    return enums.$PaystubPayFrequencyMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == paystubPayFrequency.toString(),
            orElse: () => const MapEntry(
                enums.PaystubPayFrequency.swaggerGeneratedUnknown, ''))
        .key;
  }

  if (paystubPayFrequency is String) {
    return enums.$PaystubPayFrequencyMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                paystubPayFrequency.toLowerCase(),
            orElse: () => const MapEntry(
                enums.PaystubPayFrequency.swaggerGeneratedUnknown, ''))
        .key;
  }

  return enums.PaystubPayFrequency.swaggerGeneratedUnknown;
}

List<String> paystubPayFrequencyListToJson(
    List<enums.PaystubPayFrequency>? paystubPayFrequency) {
  if (paystubPayFrequency == null) {
    return [];
  }

  return paystubPayFrequency
      .map((e) => enums.$PaystubPayFrequencyMap[e]!)
      .toList();
}

List<enums.PaystubPayFrequency> paystubPayFrequencyListFromJson(
    List? paystubPayFrequency) {
  if (paystubPayFrequency == null) {
    return [];
  }

  return paystubPayFrequency
      .map((e) => paystubPayFrequencyFromJson(e.toString()))
      .toList();
}

String? incomeBreakdownTypeToJson(
    enums.IncomeBreakdownType? incomeBreakdownType) {
  return enums.$IncomeBreakdownTypeMap[incomeBreakdownType];
}

enums.IncomeBreakdownType incomeBreakdownTypeFromJson(
    Object? incomeBreakdownType) {
  if (incomeBreakdownType is int) {
    return enums.$IncomeBreakdownTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == incomeBreakdownType.toString(),
            orElse: () => const MapEntry(
                enums.IncomeBreakdownType.swaggerGeneratedUnknown, ''))
        .key;
  }

  if (incomeBreakdownType is String) {
    return enums.$IncomeBreakdownTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                incomeBreakdownType.toLowerCase(),
            orElse: () => const MapEntry(
                enums.IncomeBreakdownType.swaggerGeneratedUnknown, ''))
        .key;
  }

  return enums.IncomeBreakdownType.swaggerGeneratedUnknown;
}

List<String> incomeBreakdownTypeListToJson(
    List<enums.IncomeBreakdownType>? incomeBreakdownType) {
  if (incomeBreakdownType == null) {
    return [];
  }

  return incomeBreakdownType
      .map((e) => enums.$IncomeBreakdownTypeMap[e]!)
      .toList();
}

List<enums.IncomeBreakdownType> incomeBreakdownTypeListFromJson(
    List? incomeBreakdownType) {
  if (incomeBreakdownType == null) {
    return [];
  }

  return incomeBreakdownType
      .map((e) => incomeBreakdownTypeFromJson(e.toString()))
      .toList();
}

String? payPeriodDetailsPayFrequencyToJson(
    enums.PayPeriodDetailsPayFrequency? payPeriodDetailsPayFrequency) {
  return enums.$PayPeriodDetailsPayFrequencyMap[payPeriodDetailsPayFrequency];
}

enums.PayPeriodDetailsPayFrequency payPeriodDetailsPayFrequencyFromJson(
    Object? payPeriodDetailsPayFrequency) {
  if (payPeriodDetailsPayFrequency is int) {
    return enums.$PayPeriodDetailsPayFrequencyMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                payPeriodDetailsPayFrequency.toString(),
            orElse: () => const MapEntry(
                enums.PayPeriodDetailsPayFrequency.swaggerGeneratedUnknown, ''))
        .key;
  }

  if (payPeriodDetailsPayFrequency is String) {
    return enums.$PayPeriodDetailsPayFrequencyMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                payPeriodDetailsPayFrequency.toLowerCase(),
            orElse: () => const MapEntry(
                enums.PayPeriodDetailsPayFrequency.swaggerGeneratedUnknown, ''))
        .key;
  }

  return enums.PayPeriodDetailsPayFrequency.swaggerGeneratedUnknown;
}

List<String> payPeriodDetailsPayFrequencyListToJson(
    List<enums.PayPeriodDetailsPayFrequency>? payPeriodDetailsPayFrequency) {
  if (payPeriodDetailsPayFrequency == null) {
    return [];
  }

  return payPeriodDetailsPayFrequency
      .map((e) => enums.$PayPeriodDetailsPayFrequencyMap[e]!)
      .toList();
}

List<enums.PayPeriodDetailsPayFrequency>
    payPeriodDetailsPayFrequencyListFromJson(
        List? payPeriodDetailsPayFrequency) {
  if (payPeriodDetailsPayFrequency == null) {
    return [];
  }

  return payPeriodDetailsPayFrequency
      .map((e) => payPeriodDetailsPayFrequencyFromJson(e.toString()))
      .toList();
}

String? paystubVerificationStatusToJson(
    enums.PaystubVerificationStatus? paystubVerificationStatus) {
  return enums.$PaystubVerificationStatusMap[paystubVerificationStatus];
}

enums.PaystubVerificationStatus paystubVerificationStatusFromJson(
    Object? paystubVerificationStatus) {
  if (paystubVerificationStatus is int) {
    return enums.$PaystubVerificationStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                paystubVerificationStatus.toString(),
            orElse: () => const MapEntry(
                enums.PaystubVerificationStatus.swaggerGeneratedUnknown, ''))
        .key;
  }

  if (paystubVerificationStatus is String) {
    return enums.$PaystubVerificationStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                paystubVerificationStatus.toLowerCase(),
            orElse: () => const MapEntry(
                enums.PaystubVerificationStatus.swaggerGeneratedUnknown, ''))
        .key;
  }

  return enums.PaystubVerificationStatus.swaggerGeneratedUnknown;
}

List<String> paystubVerificationStatusListToJson(
    List<enums.PaystubVerificationStatus>? paystubVerificationStatus) {
  if (paystubVerificationStatus == null) {
    return [];
  }

  return paystubVerificationStatus
      .map((e) => enums.$PaystubVerificationStatusMap[e]!)
      .toList();
}

List<enums.PaystubVerificationStatus> paystubVerificationStatusListFromJson(
    List? paystubVerificationStatus) {
  if (paystubVerificationStatus == null) {
    return [];
  }

  return paystubVerificationStatus
      .map((e) => paystubVerificationStatusFromJson(e.toString()))
      .toList();
}

String? verificationAttributeType$ToJson(
    enums.VerificationAttributeType$? verificationAttributeType$) {
  return enums.$VerificationAttributeType$Map[verificationAttributeType$];
}

enums.VerificationAttributeType$ verificationAttributeType$FromJson(
    Object? verificationAttributeType$) {
  if (verificationAttributeType$ is int) {
    return enums.$VerificationAttributeType$Map.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                verificationAttributeType$.toString(),
            orElse: () => const MapEntry(
                enums.VerificationAttributeType$.swaggerGeneratedUnknown, ''))
        .key;
  }

  if (verificationAttributeType$ is String) {
    return enums.$VerificationAttributeType$Map.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                verificationAttributeType$.toLowerCase(),
            orElse: () => const MapEntry(
                enums.VerificationAttributeType$.swaggerGeneratedUnknown, ''))
        .key;
  }

  return enums.VerificationAttributeType$.swaggerGeneratedUnknown;
}

List<String> verificationAttributeType$ListToJson(
    List<enums.VerificationAttributeType$>? verificationAttributeType$) {
  if (verificationAttributeType$ == null) {
    return [];
  }

  return verificationAttributeType$
      .map((e) => enums.$VerificationAttributeType$Map[e]!)
      .toList();
}

List<enums.VerificationAttributeType$> verificationAttributeType$ListFromJson(
    List? verificationAttributeType$) {
  if (verificationAttributeType$ == null) {
    return [];
  }

  return verificationAttributeType$
      .map((e) => verificationAttributeType$FromJson(e.toString()))
      .toList();
}

String? employmentVerificationStatusToJson(
    enums.EmploymentVerificationStatus? employmentVerificationStatus) {
  return enums.$EmploymentVerificationStatusMap[employmentVerificationStatus];
}

enums.EmploymentVerificationStatus employmentVerificationStatusFromJson(
    Object? employmentVerificationStatus) {
  if (employmentVerificationStatus is int) {
    return enums.$EmploymentVerificationStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                employmentVerificationStatus.toString(),
            orElse: () => const MapEntry(
                enums.EmploymentVerificationStatus.swaggerGeneratedUnknown, ''))
        .key;
  }

  if (employmentVerificationStatus is String) {
    return enums.$EmploymentVerificationStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                employmentVerificationStatus.toLowerCase(),
            orElse: () => const MapEntry(
                enums.EmploymentVerificationStatus.swaggerGeneratedUnknown, ''))
        .key;
  }

  return enums.EmploymentVerificationStatus.swaggerGeneratedUnknown;
}

List<String> employmentVerificationStatusListToJson(
    List<enums.EmploymentVerificationStatus>? employmentVerificationStatus) {
  if (employmentVerificationStatus == null) {
    return [];
  }

  return employmentVerificationStatus
      .map((e) => enums.$EmploymentVerificationStatusMap[e]!)
      .toList();
}

List<enums.EmploymentVerificationStatus>
    employmentVerificationStatusListFromJson(
        List? employmentVerificationStatus) {
  if (employmentVerificationStatus == null) {
    return [];
  }

  return employmentVerificationStatus
      .map((e) => employmentVerificationStatusFromJson(e.toString()))
      .toList();
}

String? assetReportTransactionTransactionTypeToJson(
    enums.AssetReportTransactionTransactionType?
        assetReportTransactionTransactionType) {
  return enums.$AssetReportTransactionTransactionTypeMap[
      assetReportTransactionTransactionType];
}

enums.AssetReportTransactionTransactionType
    assetReportTransactionTransactionTypeFromJson(
        Object? assetReportTransactionTransactionType) {
  if (assetReportTransactionTransactionType is int) {
    return enums.$AssetReportTransactionTransactionTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                assetReportTransactionTransactionType.toString(),
            orElse: () => const MapEntry(
                enums.AssetReportTransactionTransactionType
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  if (assetReportTransactionTransactionType is String) {
    return enums.$AssetReportTransactionTransactionTypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                assetReportTransactionTransactionType.toLowerCase(),
            orElse: () => const MapEntry(
                enums.AssetReportTransactionTransactionType
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  return enums.AssetReportTransactionTransactionType.swaggerGeneratedUnknown;
}

List<String> assetReportTransactionTransactionTypeListToJson(
    List<enums.AssetReportTransactionTransactionType>?
        assetReportTransactionTransactionType) {
  if (assetReportTransactionTransactionType == null) {
    return [];
  }

  return assetReportTransactionTransactionType
      .map((e) => enums.$AssetReportTransactionTransactionTypeMap[e]!)
      .toList();
}

List<enums.AssetReportTransactionTransactionType>
    assetReportTransactionTransactionTypeListFromJson(
        List? assetReportTransactionTransactionType) {
  if (assetReportTransactionTransactionType == null) {
    return [];
  }

  return assetReportTransactionTransactionType
      .map((e) => assetReportTransactionTransactionTypeFromJson(e.toString()))
      .toList();
}

String? incidentUpdateStatusToJson(
    enums.IncidentUpdateStatus? incidentUpdateStatus) {
  return enums.$IncidentUpdateStatusMap[incidentUpdateStatus];
}

enums.IncidentUpdateStatus incidentUpdateStatusFromJson(
    Object? incidentUpdateStatus) {
  if (incidentUpdateStatus is int) {
    return enums.$IncidentUpdateStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == incidentUpdateStatus.toString(),
            orElse: () => const MapEntry(
                enums.IncidentUpdateStatus.swaggerGeneratedUnknown, ''))
        .key;
  }

  if (incidentUpdateStatus is String) {
    return enums.$IncidentUpdateStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                incidentUpdateStatus.toLowerCase(),
            orElse: () => const MapEntry(
                enums.IncidentUpdateStatus.swaggerGeneratedUnknown, ''))
        .key;
  }

  return enums.IncidentUpdateStatus.swaggerGeneratedUnknown;
}

List<String> incidentUpdateStatusListToJson(
    List<enums.IncidentUpdateStatus>? incidentUpdateStatus) {
  if (incidentUpdateStatus == null) {
    return [];
  }

  return incidentUpdateStatus
      .map((e) => enums.$IncidentUpdateStatusMap[e]!)
      .toList();
}

List<enums.IncidentUpdateStatus> incidentUpdateStatusListFromJson(
    List? incidentUpdateStatus) {
  if (incidentUpdateStatus == null) {
    return [];
  }

  return incidentUpdateStatus
      .map((e) => incidentUpdateStatusFromJson(e.toString()))
      .toList();
}

String? depositSwitchAltCreateRequestCountryCodeToJson(
    enums.DepositSwitchAltCreateRequestCountryCode?
        depositSwitchAltCreateRequestCountryCode) {
  return enums.$DepositSwitchAltCreateRequestCountryCodeMap[
      depositSwitchAltCreateRequestCountryCode];
}

enums.DepositSwitchAltCreateRequestCountryCode
    depositSwitchAltCreateRequestCountryCodeFromJson(
        Object? depositSwitchAltCreateRequestCountryCode) {
  if (depositSwitchAltCreateRequestCountryCode is int) {
    return enums.$DepositSwitchAltCreateRequestCountryCodeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                depositSwitchAltCreateRequestCountryCode.toString(),
            orElse: () => const MapEntry(
                enums.DepositSwitchAltCreateRequestCountryCode
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  if (depositSwitchAltCreateRequestCountryCode is String) {
    return enums.$DepositSwitchAltCreateRequestCountryCodeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                depositSwitchAltCreateRequestCountryCode.toLowerCase(),
            orElse: () => const MapEntry(
                enums.DepositSwitchAltCreateRequestCountryCode
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  return enums.DepositSwitchAltCreateRequestCountryCode.swaggerGeneratedUnknown;
}

List<String> depositSwitchAltCreateRequestCountryCodeListToJson(
    List<enums.DepositSwitchAltCreateRequestCountryCode>?
        depositSwitchAltCreateRequestCountryCode) {
  if (depositSwitchAltCreateRequestCountryCode == null) {
    return [];
  }

  return depositSwitchAltCreateRequestCountryCode
      .map((e) => enums.$DepositSwitchAltCreateRequestCountryCodeMap[e]!)
      .toList();
}

List<enums.DepositSwitchAltCreateRequestCountryCode>
    depositSwitchAltCreateRequestCountryCodeListFromJson(
        List? depositSwitchAltCreateRequestCountryCode) {
  if (depositSwitchAltCreateRequestCountryCode == null) {
    return [];
  }

  return depositSwitchAltCreateRequestCountryCode
      .map(
          (e) => depositSwitchAltCreateRequestCountryCodeFromJson(e.toString()))
      .toList();
}

String? depositSwitchTargetAccountAccountSubtypeToJson(
    enums.DepositSwitchTargetAccountAccountSubtype?
        depositSwitchTargetAccountAccountSubtype) {
  return enums.$DepositSwitchTargetAccountAccountSubtypeMap[
      depositSwitchTargetAccountAccountSubtype];
}

enums.DepositSwitchTargetAccountAccountSubtype
    depositSwitchTargetAccountAccountSubtypeFromJson(
        Object? depositSwitchTargetAccountAccountSubtype) {
  if (depositSwitchTargetAccountAccountSubtype is int) {
    return enums.$DepositSwitchTargetAccountAccountSubtypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                depositSwitchTargetAccountAccountSubtype.toString(),
            orElse: () => const MapEntry(
                enums.DepositSwitchTargetAccountAccountSubtype
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  if (depositSwitchTargetAccountAccountSubtype is String) {
    return enums.$DepositSwitchTargetAccountAccountSubtypeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                depositSwitchTargetAccountAccountSubtype.toLowerCase(),
            orElse: () => const MapEntry(
                enums.DepositSwitchTargetAccountAccountSubtype
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  return enums.DepositSwitchTargetAccountAccountSubtype.swaggerGeneratedUnknown;
}

List<String> depositSwitchTargetAccountAccountSubtypeListToJson(
    List<enums.DepositSwitchTargetAccountAccountSubtype>?
        depositSwitchTargetAccountAccountSubtype) {
  if (depositSwitchTargetAccountAccountSubtype == null) {
    return [];
  }

  return depositSwitchTargetAccountAccountSubtype
      .map((e) => enums.$DepositSwitchTargetAccountAccountSubtypeMap[e]!)
      .toList();
}

List<enums.DepositSwitchTargetAccountAccountSubtype>
    depositSwitchTargetAccountAccountSubtypeListFromJson(
        List? depositSwitchTargetAccountAccountSubtype) {
  if (depositSwitchTargetAccountAccountSubtype == null) {
    return [];
  }

  return depositSwitchTargetAccountAccountSubtype
      .map(
          (e) => depositSwitchTargetAccountAccountSubtypeFromJson(e.toString()))
      .toList();
}

String? scopesContextToJson(enums.ScopesContext? scopesContext) {
  return enums.$ScopesContextMap[scopesContext];
}

enums.ScopesContext scopesContextFromJson(Object? scopesContext) {
  if (scopesContext is int) {
    return enums.$ScopesContextMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == scopesContext.toString(),
            orElse: () =>
                const MapEntry(enums.ScopesContext.swaggerGeneratedUnknown, ''))
        .key;
  }

  if (scopesContext is String) {
    return enums.$ScopesContextMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() == scopesContext.toLowerCase(),
            orElse: () =>
                const MapEntry(enums.ScopesContext.swaggerGeneratedUnknown, ''))
        .key;
  }

  return enums.ScopesContext.swaggerGeneratedUnknown;
}

List<String> scopesContextListToJson(List<enums.ScopesContext>? scopesContext) {
  if (scopesContext == null) {
    return [];
  }

  return scopesContext.map((e) => enums.$ScopesContextMap[e]!).toList();
}

List<enums.ScopesContext> scopesContextListFromJson(List? scopesContext) {
  if (scopesContext == null) {
    return [];
  }

  return scopesContext.map((e) => scopesContextFromJson(e.toString())).toList();
}

String? connectedApplicationProductDataTypesToJson(
    enums.ConnectedApplicationProductDataTypes?
        connectedApplicationProductDataTypes) {
  return enums.$ConnectedApplicationProductDataTypesMap[
      connectedApplicationProductDataTypes];
}

enums.ConnectedApplicationProductDataTypes
    connectedApplicationProductDataTypesFromJson(
        Object? connectedApplicationProductDataTypes) {
  if (connectedApplicationProductDataTypes is int) {
    return enums.$ConnectedApplicationProductDataTypesMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                connectedApplicationProductDataTypes.toString(),
            orElse: () => const MapEntry(
                enums.ConnectedApplicationProductDataTypes
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  if (connectedApplicationProductDataTypes is String) {
    return enums.$ConnectedApplicationProductDataTypesMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                connectedApplicationProductDataTypes.toLowerCase(),
            orElse: () => const MapEntry(
                enums.ConnectedApplicationProductDataTypes
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  return enums.ConnectedApplicationProductDataTypes.swaggerGeneratedUnknown;
}

List<String> connectedApplicationProductDataTypesListToJson(
    List<enums.ConnectedApplicationProductDataTypes>?
        connectedApplicationProductDataTypes) {
  if (connectedApplicationProductDataTypes == null) {
    return [];
  }

  return connectedApplicationProductDataTypes
      .map((e) => enums.$ConnectedApplicationProductDataTypesMap[e]!)
      .toList();
}

List<enums.ConnectedApplicationProductDataTypes>
    connectedApplicationProductDataTypesListFromJson(
        List? connectedApplicationProductDataTypes) {
  if (connectedApplicationProductDataTypes == null) {
    return [];
  }

  return connectedApplicationProductDataTypes
      .map((e) => connectedApplicationProductDataTypesFromJson(e.toString()))
      .toList();
}

String? accountSelectionCardinalityToJson(
    enums.AccountSelectionCardinality? accountSelectionCardinality) {
  return enums.$AccountSelectionCardinalityMap[accountSelectionCardinality];
}

enums.AccountSelectionCardinality accountSelectionCardinalityFromJson(
    Object? accountSelectionCardinality) {
  if (accountSelectionCardinality is int) {
    return enums.$AccountSelectionCardinalityMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                accountSelectionCardinality.toString(),
            orElse: () => const MapEntry(
                enums.AccountSelectionCardinality.swaggerGeneratedUnknown, ''))
        .key;
  }

  if (accountSelectionCardinality is String) {
    return enums.$AccountSelectionCardinalityMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                accountSelectionCardinality.toLowerCase(),
            orElse: () => const MapEntry(
                enums.AccountSelectionCardinality.swaggerGeneratedUnknown, ''))
        .key;
  }

  return enums.AccountSelectionCardinality.swaggerGeneratedUnknown;
}

List<String> accountSelectionCardinalityListToJson(
    List<enums.AccountSelectionCardinality>? accountSelectionCardinality) {
  if (accountSelectionCardinality == null) {
    return [];
  }

  return accountSelectionCardinality
      .map((e) => enums.$AccountSelectionCardinalityMap[e]!)
      .toList();
}

List<enums.AccountSelectionCardinality> accountSelectionCardinalityListFromJson(
    List? accountSelectionCardinality) {
  if (accountSelectionCardinality == null) {
    return [];
  }

  return accountSelectionCardinality
      .map((e) => accountSelectionCardinalityFromJson(e.toString()))
      .toList();
}

String? sandboxIncomeFireWebhookRequestVerificationStatusToJson(
    enums.SandboxIncomeFireWebhookRequestVerificationStatus?
        sandboxIncomeFireWebhookRequestVerificationStatus) {
  return enums.$SandboxIncomeFireWebhookRequestVerificationStatusMap[
      sandboxIncomeFireWebhookRequestVerificationStatus];
}

enums.SandboxIncomeFireWebhookRequestVerificationStatus
    sandboxIncomeFireWebhookRequestVerificationStatusFromJson(
        Object? sandboxIncomeFireWebhookRequestVerificationStatus) {
  if (sandboxIncomeFireWebhookRequestVerificationStatus is int) {
    return enums.$SandboxIncomeFireWebhookRequestVerificationStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                sandboxIncomeFireWebhookRequestVerificationStatus.toString(),
            orElse: () => const MapEntry(
                enums.SandboxIncomeFireWebhookRequestVerificationStatus
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  if (sandboxIncomeFireWebhookRequestVerificationStatus is String) {
    return enums.$SandboxIncomeFireWebhookRequestVerificationStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                sandboxIncomeFireWebhookRequestVerificationStatus.toLowerCase(),
            orElse: () => const MapEntry(
                enums.SandboxIncomeFireWebhookRequestVerificationStatus
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  return enums.SandboxIncomeFireWebhookRequestVerificationStatus
      .swaggerGeneratedUnknown;
}

List<String> sandboxIncomeFireWebhookRequestVerificationStatusListToJson(
    List<enums.SandboxIncomeFireWebhookRequestVerificationStatus>?
        sandboxIncomeFireWebhookRequestVerificationStatus) {
  if (sandboxIncomeFireWebhookRequestVerificationStatus == null) {
    return [];
  }

  return sandboxIncomeFireWebhookRequestVerificationStatus
      .map((e) =>
          enums.$SandboxIncomeFireWebhookRequestVerificationStatusMap[e]!)
      .toList();
}

List<enums.SandboxIncomeFireWebhookRequestVerificationStatus>
    sandboxIncomeFireWebhookRequestVerificationStatusListFromJson(
        List? sandboxIncomeFireWebhookRequestVerificationStatus) {
  if (sandboxIncomeFireWebhookRequestVerificationStatus == null) {
    return [];
  }

  return sandboxIncomeFireWebhookRequestVerificationStatus
      .map((e) => sandboxIncomeFireWebhookRequestVerificationStatusFromJson(
          e.toString()))
      .toList();
}

String? walletTransactionAmountIsoCurrencyCodeToJson(
    enums.WalletTransactionAmountIsoCurrencyCode?
        walletTransactionAmountIsoCurrencyCode) {
  return enums.$WalletTransactionAmountIsoCurrencyCodeMap[
      walletTransactionAmountIsoCurrencyCode];
}

enums.WalletTransactionAmountIsoCurrencyCode
    walletTransactionAmountIsoCurrencyCodeFromJson(
        Object? walletTransactionAmountIsoCurrencyCode) {
  if (walletTransactionAmountIsoCurrencyCode is int) {
    return enums.$WalletTransactionAmountIsoCurrencyCodeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                walletTransactionAmountIsoCurrencyCode.toString(),
            orElse: () => const MapEntry(
                enums.WalletTransactionAmountIsoCurrencyCode
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  if (walletTransactionAmountIsoCurrencyCode is String) {
    return enums.$WalletTransactionAmountIsoCurrencyCodeMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                walletTransactionAmountIsoCurrencyCode.toLowerCase(),
            orElse: () => const MapEntry(
                enums.WalletTransactionAmountIsoCurrencyCode
                    .swaggerGeneratedUnknown,
                ''))
        .key;
  }

  return enums.WalletTransactionAmountIsoCurrencyCode.swaggerGeneratedUnknown;
}

List<String> walletTransactionAmountIsoCurrencyCodeListToJson(
    List<enums.WalletTransactionAmountIsoCurrencyCode>?
        walletTransactionAmountIsoCurrencyCode) {
  if (walletTransactionAmountIsoCurrencyCode == null) {
    return [];
  }

  return walletTransactionAmountIsoCurrencyCode
      .map((e) => enums.$WalletTransactionAmountIsoCurrencyCodeMap[e]!)
      .toList();
}

List<enums.WalletTransactionAmountIsoCurrencyCode>
    walletTransactionAmountIsoCurrencyCodeListFromJson(
        List? walletTransactionAmountIsoCurrencyCode) {
  if (walletTransactionAmountIsoCurrencyCode == null) {
    return [];
  }

  return walletTransactionAmountIsoCurrencyCode
      .map((e) => walletTransactionAmountIsoCurrencyCodeFromJson(e.toString()))
      .toList();
}

String? walletTransactionStatusToJson(
    enums.WalletTransactionStatus? walletTransactionStatus) {
  return enums.$WalletTransactionStatusMap[walletTransactionStatus];
}

enums.WalletTransactionStatus walletTransactionStatusFromJson(
    Object? walletTransactionStatus) {
  if (walletTransactionStatus is int) {
    return enums.$WalletTransactionStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                walletTransactionStatus.toString(),
            orElse: () => const MapEntry(
                enums.WalletTransactionStatus.swaggerGeneratedUnknown, ''))
        .key;
  }

  if (walletTransactionStatus is String) {
    return enums.$WalletTransactionStatusMap.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                walletTransactionStatus.toLowerCase(),
            orElse: () => const MapEntry(
                enums.WalletTransactionStatus.swaggerGeneratedUnknown, ''))
        .key;
  }

  return enums.WalletTransactionStatus.swaggerGeneratedUnknown;
}

List<String> walletTransactionStatusListToJson(
    List<enums.WalletTransactionStatus>? walletTransactionStatus) {
  if (walletTransactionStatus == null) {
    return [];
  }

  return walletTransactionStatus
      .map((e) => enums.$WalletTransactionStatusMap[e]!)
      .toList();
}

List<enums.WalletTransactionStatus> walletTransactionStatusListFromJson(
    List? walletTransactionStatus) {
  if (walletTransactionStatus == null) {
    return [];
  }

  return walletTransactionStatus
      .map((e) => walletTransactionStatusFromJson(e.toString()))
      .toList();
}

String? walletTransactionType$ToJson(
    enums.WalletTransactionType$? walletTransactionType$) {
  return enums.$WalletTransactionType$Map[walletTransactionType$];
}

enums.WalletTransactionType$ walletTransactionType$FromJson(
    Object? walletTransactionType$) {
  if (walletTransactionType$ is int) {
    return enums.$WalletTransactionType$Map.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                walletTransactionType$.toString(),
            orElse: () => const MapEntry(
                enums.WalletTransactionType$.swaggerGeneratedUnknown, ''))
        .key;
  }

  if (walletTransactionType$ is String) {
    return enums.$WalletTransactionType$Map.entries
        .firstWhere(
            (element) =>
                element.value.toLowerCase() ==
                walletTransactionType$.toLowerCase(),
            orElse: () => const MapEntry(
                enums.WalletTransactionType$.swaggerGeneratedUnknown, ''))
        .key;
  }

  return enums.WalletTransactionType$.swaggerGeneratedUnknown;
}

List<String> walletTransactionType$ListToJson(
    List<enums.WalletTransactionType$>? walletTransactionType$) {
  if (walletTransactionType$ == null) {
    return [];
  }

  return walletTransactionType$
      .map((e) => enums.$WalletTransactionType$Map[e]!)
      .toList();
}

List<enums.WalletTransactionType$> walletTransactionType$ListFromJson(
    List? walletTransactionType$) {
  if (walletTransactionType$ == null) {
    return [];
  }

  return walletTransactionType$
      .map((e) => walletTransactionType$FromJson(e.toString()))
      .toList();
}

typedef $JsonFactory<T> = T Function(Map<String, dynamic> json);

class $CustomJsonDecoder {
  $CustomJsonDecoder(this.factories);

  final Map<Type, $JsonFactory> factories;

  dynamic decode<T>(dynamic entity) {
    if (entity is Iterable) {
      return _decodeList<T>(entity);
    }

    if (entity is T) {
      return entity;
    }

    if (entity is Map<String, dynamic>) {
      return _decodeMap<T>(entity);
    }

    return entity;
  }

  T _decodeMap<T>(Map<String, dynamic> values) {
    final jsonFactory = factories[T];
    if (jsonFactory == null || jsonFactory is! $JsonFactory<T>) {
      return throw "Could not find factory for type $T. Is '$T: $T.fromJsonFactory' included in the CustomJsonDecoder instance creation in bootstrapper.dart?";
    }

    return jsonFactory(values);
  }

  List<T> _decodeList<T>(Iterable values) =>
      values.where((v) => v != null).map<T>((v) => decode<T>(v) as T).toList();
}

class $JsonSerializableConverter extends chopper.JsonConverter {
  @override
  chopper.Response<ResultType> convertResponse<ResultType, Item>(
      chopper.Response response) {
    if (response.bodyString.isEmpty) {
      // In rare cases, when let's say 204 (no content) is returned -
      // we cannot decode the missing json with the result type specified
      return chopper.Response(response.base, null, error: response.error);
    }

    final jsonRes = super.convertResponse(response);
    return jsonRes.copyWith<ResultType>(
        body: $jsonDecoder.decode<Item>(jsonRes.body) as ResultType);
  }
}

final $jsonDecoder = $CustomJsonDecoder(generatedMapping);

// ignore: unused_element
String? _dateToJson(DateTime? date) {
  if (date == null) {
    return null;
  }

  final year = date.year.toString();
  final month = date.month < 10 ? '0${date.month}' : date.month.toString();
  final day = date.day < 10 ? '0${date.day}' : date.day.toString();

  return '$year-$month-$day';
}
